//
// Copyright Aliaksei Levin (levlam@telegram.org), Arseny Smirnov (arseny30@gmail.com) 2014-2021
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
#include "td/telegram/MessagesManager.h"

#include "td/telegram/AuthManager.h"
#include "td/telegram/ChatId.h"
#include "td/telegram/ConfigShared.h"
#include "td/telegram/ContactsManager.h"
#include "td/telegram/DialogDb.h"
#include "td/telegram/DialogFilter.h"
#include "td/telegram/DialogFilter.hpp"
#include "td/telegram/DialogInviteLink.h"
#include "td/telegram/DialogLocation.h"
#include "td/telegram/DraftMessage.h"
#include "td/telegram/DraftMessage.hpp"
#include "td/telegram/FileReferenceManager.h"
#include "td/telegram/files/FileId.hpp"
#include "td/telegram/files/FileLocation.h"
#include "td/telegram/files/FileManager.h"
#include "td/telegram/files/FileType.h"
#include "td/telegram/Global.h"
#include "td/telegram/GroupCallManager.h"
#include "td/telegram/GroupCallParticipant.h"
#include "td/telegram/InlineQueriesManager.h"
#include "td/telegram/InputMessageText.h"
#include "td/telegram/Location.h"
#include "td/telegram/logevent/LogEvent.h"
#include "td/telegram/MessageContent.h"
#include "td/telegram/MessageEntity.h"
#include "td/telegram/MessageEntity.hpp"
#include "td/telegram/MessagesDb.h"
#include "td/telegram/misc.h"
#include "td/telegram/net/DcId.h"
#include "td/telegram/net/NetActor.h"
#include "td/telegram/net/NetQuery.h"
#include "td/telegram/NotificationGroupType.h"
#include "td/telegram/NotificationManager.h"
#include "td/telegram/NotificationSettings.hpp"
#include "td/telegram/NotificationType.h"
#include "td/telegram/Payments.h"
#include "td/telegram/ReplyMarkup.h"
#include "td/telegram/ReplyMarkup.hpp"
#include "td/telegram/SecretChatActor.h"
#include "td/telegram/SecretChatsManager.h"
#include "td/telegram/SequenceDispatcher.h"
#include "td/telegram/Td.h"
#include "td/telegram/TdDb.h"
#include "td/telegram/TopDialogCategory.h"
#include "td/telegram/UpdatesManager.h"
#include "td/telegram/Version.h"
#include "td/telegram/WebPageId.h"

#include "td/actor/PromiseFuture.h"
#include "td/actor/SleepActor.h"

#include "td/db/binlog/BinlogEvent.h"
#include "td/db/binlog/BinlogHelper.h"
#include "td/db/SqliteKeyValue.h"
#include "td/db/SqliteKeyValueAsync.h"

#include "td/utils/algorithm.h"
#include "td/utils/format.h"
#include "td/utils/misc.h"
#include "td/utils/PathView.h"
#include "td/utils/Random.h"
#include "td/utils/Slice.h"
#include "td/utils/Time.h"
#include "td/utils/tl_helpers.h"
#include "td/utils/utf8.h"

#include <algorithm>
#include <cstring>
#include <limits>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#include <utility>

namespace td {

class GetDialogFiltersQuery : public Td::ResultHandler {
  Promise<vector<tl_object_ptr<telegram_api::dialogFilter>>> promise_;

 public:
  explicit GetDialogFiltersQuery(Promise<vector<tl_object_ptr<telegram_api::dialogFilter>>> &&promise)
      : promise_(std::move(promise)) {
  }

  void send() {
    send_query(G()->net_query_creator().create(telegram_api::messages_getDialogFilters()));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getDialogFilters>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    promise_.set_value(result_ptr.move_as_ok());
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class UpdateDialogFilterQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit UpdateDialogFilterQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogFilterId dialog_filter_id, tl_object_ptr<telegram_api::dialogFilter> filter) {
    int32 flags = 0;
    if (filter != nullptr) {
      flags |= telegram_api::messages_updateDialogFilter::FILTER_MASK;
    }
    send_query(G()->net_query_creator().create(
        telegram_api::messages_updateDialogFilter(flags, dialog_filter_id.get(), std::move(filter))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_updateDialogFilter>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    LOG(INFO) << "Receive result for UpdateDialogFilterQuery: " << result_ptr.ok();
    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(ERROR) << "Receive error for UpdateDialogFilterQuery: " << status;
    promise_.set_error(std::move(status));
  }
};

class UpdateDialogFiltersOrderQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit UpdateDialogFiltersOrderQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(vector<DialogFilterId> dialog_filter_ids) {
    send_query(G()->net_query_creator().create(telegram_api::messages_updateDialogFiltersOrder(
        transform(dialog_filter_ids, [](auto dialog_filter_id) { return dialog_filter_id.get(); }))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_updateDialogFiltersOrder>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    LOG(INFO) << "Receive result for UpdateDialogFiltersOrderQuery: " << result_ptr.ok();
    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class GetSuggestedDialogFiltersQuery : public Td::ResultHandler {
  Promise<vector<tl_object_ptr<telegram_api::dialogFilterSuggested>>> promise_;

 public:
  explicit GetSuggestedDialogFiltersQuery(Promise<vector<tl_object_ptr<telegram_api::dialogFilterSuggested>>> &&promise)
      : promise_(std::move(promise)) {
  }

  void send() {
    send_query(G()->net_query_creator().create(telegram_api::messages_getSuggestedDialogFilters()));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getSuggestedDialogFilters>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    promise_.set_value(result_ptr.move_as_ok());
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class GetOnlinesQuery : public Td::ResultHandler {
  DialogId dialog_id_;

 public:
  void send(DialogId dialog_id) {
    dialog_id_ = dialog_id;
    CHECK(dialog_id.get_type() == DialogType::Channel);
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      return on_error(0, Status::Error(400, "Can't access the chat"));
    }

    send_query(G()->net_query_creator().create(telegram_api::messages_getOnlines(std::move(input_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getOnlines>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto result = result_ptr.move_as_ok();
    td->messages_manager_->on_update_dialog_online_member_count(dialog_id_, result->onlines_, true);
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetOnlinesQuery");
    td->messages_manager_->on_update_dialog_online_member_count(dialog_id_, 0, true);
  }
};

class GetAllDraftsQuery : public Td::ResultHandler {
 public:
  void send() {
    send_query(G()->net_query_creator().create(telegram_api::messages_getAllDrafts()));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getAllDrafts>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for GetAllDraftsQuery: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), Promise<Unit>());
  }

  void on_error(uint64 id, Status status) override {
    if (!G()->is_expected_error(status)) {
      LOG(ERROR) << "Receive error for GetAllDraftsQuery: " << status;
    }
    status.ignore();
  }
};

class GetDialogQuery : public Td::ResultHandler {
  DialogId dialog_id_;

 public:
  void send(DialogId dialog_id) {
    dialog_id_ = dialog_id;
    send_query(G()->net_query_creator().create(telegram_api::messages_getPeerDialogs(
        td->messages_manager_->get_input_dialog_peers({dialog_id}, AccessRights::Read))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getPeerDialogs>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto result = result_ptr.move_as_ok();
    LOG(INFO) << "Receive chat: " << to_string(result);

    td->contacts_manager_->on_get_users(std::move(result->users_), "GetDialogQuery");
    td->contacts_manager_->on_get_chats(std::move(result->chats_), "GetDialogQuery");
    td->messages_manager_->on_get_dialogs(
        FolderId(), std::move(result->dialogs_), -1, std::move(result->messages_),
        PromiseCreator::lambda([td = td, dialog_id = dialog_id_](Result<> result) {
          if (result.is_ok()) {
            td->messages_manager_->on_get_dialog_query_finished(dialog_id, Status::OK());
          } else {
            if (G()->close_flag()) {
              return;
            }
            td->messages_manager_->on_get_dialog_error(dialog_id, result.error(), "OnGetDialogs");
            td->messages_manager_->on_get_dialog_query_finished(dialog_id, result.move_as_error());
          }
        }));
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetDialogQuery");
    td->messages_manager_->on_get_dialog_query_finished(dialog_id_, std::move(status));
  }
};

class GetDialogsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit GetDialogsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(vector<InputDialogId> input_dialog_ids) {
    LOG(INFO) << "Send GetDialogsQuery to get " << input_dialog_ids;
    CHECK(!input_dialog_ids.empty());
    CHECK(input_dialog_ids.size() <= 100);
    auto input_dialog_peers = InputDialogId::get_input_dialog_peers(input_dialog_ids);
    CHECK(input_dialog_peers.size() == input_dialog_ids.size());
    send_query(G()->net_query_creator().create(telegram_api::messages_getPeerDialogs(std::move(input_dialog_peers))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getPeerDialogs>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto result = result_ptr.move_as_ok();
    LOG(INFO) << "Receive chats: " << to_string(result);

    td->contacts_manager_->on_get_users(std::move(result->users_), "GetDialogsQuery");
    td->contacts_manager_->on_get_chats(std::move(result->chats_), "GetDialogsQuery");
    td->messages_manager_->on_get_dialogs(FolderId(), std::move(result->dialogs_), -1, std::move(result->messages_),
                                          std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class GetPinnedDialogsActor : public NetActorOnce {
  FolderId folder_id_;
  Promise<Unit> promise_;

 public:
  explicit GetPinnedDialogsActor(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  NetQueryRef send(FolderId folder_id, uint64 sequence_id) {
    folder_id_ = folder_id;
    auto query = G()->net_query_creator().create(telegram_api::messages_getPinnedDialogs(folder_id.get()));
    auto result = query.get_weak();
    send_closure(td->messages_manager_->sequence_dispatcher_, &MultiSequenceDispatcher::send_with_callback,
                 std::move(query), actor_shared(this), sequence_id);
    return result;
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getPinnedDialogs>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto result = result_ptr.move_as_ok();
    LOG(INFO) << "Receive pinned chats in " << folder_id_ << ": " << to_string(result);

    td->contacts_manager_->on_get_users(std::move(result->users_), "GetPinnedDialogsActor");
    td->contacts_manager_->on_get_chats(std::move(result->chats_), "GetPinnedDialogsActor");
    td->messages_manager_->on_get_dialogs(folder_id_, std::move(result->dialogs_), -2, std::move(result->messages_),
                                          std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class GetDialogUnreadMarksQuery : public Td::ResultHandler {
 public:
  void send() {
    send_query(G()->net_query_creator().create(telegram_api::messages_getDialogUnreadMarks()));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getDialogUnreadMarks>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto results = result_ptr.move_as_ok();
    for (auto &result : results) {
      td->messages_manager_->on_update_dialog_is_marked_as_unread(DialogId(result), true);
    }

    G()->td_db()->get_binlog_pmc()->set("fetched_marks_as_unread", "1");
  }

  void on_error(uint64 id, Status status) override {
    if (!G()->is_expected_error(status)) {
      LOG(ERROR) << "Receive error for GetDialogUnreadMarksQuery: " << status;
    }
    status.ignore();
  }
};

class GetDiscussionMessageQuery : public Td::ResultHandler {
  Promise<vector<FullMessageId>> promise_;
  DialogId dialog_id_;
  MessageId message_id_;
  DialogId expected_dialog_id_;
  MessageId expected_message_id_;

 public:
  explicit GetDiscussionMessageQuery(Promise<vector<FullMessageId>> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, MessageId message_id, DialogId expected_dialog_id, MessageId expected_message_id) {
    dialog_id_ = dialog_id;
    message_id_ = message_id;
    expected_dialog_id_ = expected_dialog_id;
    expected_message_id_ = expected_message_id;
    CHECK(expected_dialog_id_.is_valid());
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);
    send_query(G()->net_query_creator().create(
        telegram_api::messages_getDiscussionMessage(std::move(input_peer), message_id.get_server_message_id().get())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getDiscussionMessage>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->messages_manager_->process_discussion_message(result_ptr.move_as_ok(), dialog_id_, message_id_,
                                                      expected_dialog_id_, expected_message_id_, std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    if (expected_dialog_id_ == dialog_id_) {
      td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetDiscussionMessageQuery");
    }
    promise_.set_error(std::move(status));
  }
};

class GetMessagesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit GetMessagesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(vector<tl_object_ptr<telegram_api::InputMessage>> &&message_ids) {
    send_query(G()->net_query_creator().create(telegram_api::messages_getMessages(std::move(message_ids))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getMessages>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "GetMessagesQuery");
    LOG_IF(ERROR, info.is_channel_messages) << "Receive channel messages in GetMessagesQuery";
    td->messages_manager_->on_get_messages(std::move(info.messages), info.is_channel_messages, false,
                                           "GetMessagesQuery");

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (status.message() == "MESSAGE_IDS_EMPTY") {
      promise_.set_value(Unit());
      return;
    }
    promise_.set_error(std::move(status));
  }
};

class GetChannelMessagesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  ChannelId channel_id_;

 public:
  explicit GetChannelMessagesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(ChannelId channel_id, tl_object_ptr<telegram_api::InputChannel> &&input_channel,
            vector<tl_object_ptr<telegram_api::InputMessage>> &&message_ids) {
    channel_id_ = channel_id;
    CHECK(input_channel != nullptr);
    send_query(G()->net_query_creator().create(
        telegram_api::channels_getMessages(std::move(input_channel), std::move(message_ids))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::channels_getMessages>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "GetChannelMessagesQuery");
    LOG_IF(ERROR, !info.is_channel_messages) << "Receive ordinary messages in GetChannelMessagesQuery";
    if (!td->auth_manager_->is_bot()) {  // bots can receive messageEmpty because of their privacy mode
      vector<MessageId> empty_message_ids;
      for (auto &message : info.messages) {
        if (message->get_id() == telegram_api::messageEmpty::ID) {
          auto message_id = MessagesManager::get_message_id(message, false);
          if (message_id.is_valid()) {
            empty_message_ids.push_back(message_id);
          }
        }
      }
      td->messages_manager_->on_get_empty_messages(DialogId(channel_id_), std::move(empty_message_ids));
    }
    td->messages_manager_->get_channel_difference_if_needed(
        DialogId(channel_id_), std::move(info),
        PromiseCreator::lambda(
            [td = td, promise = std::move(promise_)](Result<MessagesManager::MessagesInfo> &&result) mutable {
              if (result.is_error()) {
                promise.set_error(result.move_as_error());
              } else {
                auto info = result.move_as_ok();
                td->messages_manager_->on_get_messages(std::move(info.messages), info.is_channel_messages, false,
                                                       "GetChannelMessagesQuery");
                promise.set_value(Unit());
              }
            }));
  }

  void on_error(uint64 id, Status status) override {
    if (status.message() == "MESSAGE_IDS_EMPTY") {
      promise_.set_value(Unit());
      return;
    }
    td->contacts_manager_->on_get_channel_error(channel_id_, status, "GetChannelMessagesQuery");
    promise_.set_error(std::move(status));
  }
};

class GetScheduledMessagesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit GetScheduledMessagesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, tl_object_ptr<telegram_api::InputPeer> &&input_peer, vector<int32> &&message_ids) {
    dialog_id_ = dialog_id;
    CHECK(input_peer != nullptr);
    send_query(G()->net_query_creator().create(
        telegram_api::messages_getScheduledMessages(std::move(input_peer), std::move(message_ids))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getScheduledMessages>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "GetScheduledMessagesQuery");
    LOG_IF(ERROR, info.is_channel_messages != (dialog_id_.get_type() == DialogType::Channel))
        << "Receive wrong messages constructor in GetScheduledMessagesQuery";
    td->messages_manager_->on_get_messages(std::move(info.messages), info.is_channel_messages, true,
                                           "GetScheduledMessagesQuery");

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (status.message() == "MESSAGE_IDS_EMPTY") {
      promise_.set_value(Unit());
      return;
    }
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetScheduledMessagesQuery");
    promise_.set_error(std::move(status));
  }
};

class UpdateDialogPinnedMessageQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit UpdateDialogPinnedMessageQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, MessageId message_id, bool is_unpin, bool disable_notification, bool only_for_self) {
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    if (input_peer == nullptr) {
      LOG(INFO) << "Can't update pinned message in " << dialog_id;
      return on_error(0, Status::Error(500, "Can't update pinned message"));
    }

    int32 flags = 0;
    if (disable_notification) {
      flags |= telegram_api::messages_updatePinnedMessage::SILENT_MASK;
    }
    if (is_unpin) {
      flags |= telegram_api::messages_updatePinnedMessage::UNPIN_MASK;
    }
    if (only_for_self) {
      flags |= telegram_api::messages_updatePinnedMessage::PM_ONESIDE_MASK;
    }
    send_query(G()->net_query_creator().create(
        telegram_api::messages_updatePinnedMessage(flags, false /*ignored*/, false /*ignored*/, false /*ignored*/,
                                                   std::move(input_peer), message_id.get_server_message_id().get())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_updatePinnedMessage>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for UpdateDialogPinnedMessageQuery: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "UpdateDialogPinnedMessageQuery");
    promise_.set_error(std::move(status));
  }
};

class UnpinAllMessagesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

  void send_request() {
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id_, AccessRights::Write);
    if (input_peer == nullptr) {
      LOG(INFO) << "Can't unpin all messages in " << dialog_id_;
      return on_error(0, Status::Error(500, "Can't unpin all messages"));
    }

    send_query(G()->net_query_creator().create(telegram_api::messages_unpinAllMessages(std::move(input_peer))));
  }

 public:
  explicit UnpinAllMessagesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id) {
    dialog_id_ = dialog_id;

    send_request();
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_unpinAllMessages>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto affected_history = result_ptr.move_as_ok();
    CHECK(affected_history->get_id() == telegram_api::messages_affectedHistory::ID);

    if (affected_history->pts_count_ > 0) {
      affected_history->pts_count_ = 0;  // force receiving real updates from the server
      auto promise = affected_history->offset_ > 0 ? Promise<Unit>() : std::move(promise_);
      if (dialog_id_.get_type() == DialogType::Channel) {
        td->messages_manager_->add_pending_channel_update(dialog_id_, make_tl_object<dummyUpdate>(),
                                                          affected_history->pts_, affected_history->pts_count_,
                                                          std::move(promise), "unpin all messages");
      } else {
        td->updates_manager_->add_pending_pts_update(make_tl_object<dummyUpdate>(), affected_history->pts_,
                                                     affected_history->pts_count_, std::move(promise),
                                                     "unpin all messages");
      }
    } else if (affected_history->offset_ <= 0) {
      promise_.set_value(Unit());
    }

    if (affected_history->offset_ > 0) {
      send_request();
      return;
    }
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "UnpinAllMessagesQuery");
    promise_.set_error(std::move(status));
  }
};

class ExportChannelMessageLinkQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  ChannelId channel_id_;
  MessageId message_id_;
  bool for_group_ = false;
  bool ignore_result_ = false;

 public:
  explicit ExportChannelMessageLinkQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(ChannelId channel_id, MessageId message_id, bool for_group, bool ignore_result) {
    channel_id_ = channel_id;
    message_id_ = message_id;
    for_group_ = for_group;
    ignore_result_ = ignore_result;
    auto input_channel = td->contacts_manager_->get_input_channel(channel_id);
    CHECK(input_channel != nullptr);
    int32 flags = 0;
    if (for_group) {
      flags |= telegram_api::channels_exportMessageLink::GROUPED_MASK;
    }
    send_query(G()->net_query_creator().create(
        telegram_api::channels_exportMessageLink(flags, false /*ignored*/, false /*ignored*/, std::move(input_channel),
                                                 message_id.get_server_message_id().get())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::channels_exportMessageLink>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(DEBUG) << "Receive result for ExportChannelMessageLinkQuery: " << to_string(ptr);
    if (!ignore_result_) {
      td->messages_manager_->on_get_public_message_link({DialogId(channel_id_), message_id_}, for_group_,
                                                        std::move(ptr->link_), std::move(ptr->html_));
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!ignore_result_) {
      td->contacts_manager_->on_get_channel_error(channel_id_, status, "ExportChannelMessageLinkQuery");
    }
    promise_.set_error(std::move(status));
  }
};

class GetDialogListActor : public NetActorOnce {
  FolderId folder_id_;
  Promise<Unit> promise_;

 public:
  explicit GetDialogListActor(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(FolderId folder_id, int32 offset_date, ServerMessageId offset_message_id, DialogId offset_dialog_id,
            int32 limit, uint64 sequence_id) {
    folder_id_ = folder_id;
    auto input_peer = MessagesManager::get_input_peer_force(offset_dialog_id);
    CHECK(input_peer != nullptr);

    int32 flags =
        telegram_api::messages_getDialogs::EXCLUDE_PINNED_MASK | telegram_api::messages_getDialogs::FOLDER_ID_MASK;
    auto query = G()->net_query_creator().create(
        telegram_api::messages_getDialogs(flags, false /*ignored*/, folder_id.get(), offset_date,
                                          offset_message_id.get(), std::move(input_peer), limit, 0));
    send_closure(td->messages_manager_->sequence_dispatcher_, &MultiSequenceDispatcher::send_with_callback,
                 std::move(query), actor_shared(this), sequence_id);
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getDialogs>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive chats from chat list of " << folder_id_ << ": " << to_string(ptr);
    switch (ptr->get_id()) {
      case telegram_api::messages_dialogs::ID: {
        auto dialogs = move_tl_object_as<telegram_api::messages_dialogs>(ptr);
        td->contacts_manager_->on_get_users(std::move(dialogs->users_), "GetDialogListActor");
        td->contacts_manager_->on_get_chats(std::move(dialogs->chats_), "GetDialogListActor");
        td->messages_manager_->on_get_dialogs(folder_id_, std::move(dialogs->dialogs_),
                                              narrow_cast<int32>(dialogs->dialogs_.size()),
                                              std::move(dialogs->messages_), std::move(promise_));
        break;
      }
      case telegram_api::messages_dialogsSlice::ID: {
        auto dialogs = move_tl_object_as<telegram_api::messages_dialogsSlice>(ptr);
        td->contacts_manager_->on_get_users(std::move(dialogs->users_), "GetDialogListActor");
        td->contacts_manager_->on_get_chats(std::move(dialogs->chats_), "GetDialogListActor");
        td->messages_manager_->on_get_dialogs(folder_id_, std::move(dialogs->dialogs_), max(dialogs->count_, 0),
                                              std::move(dialogs->messages_), std::move(promise_));
        break;
      }
      case telegram_api::messages_dialogsNotModified::ID:
        LOG(ERROR) << "Receive " << to_string(ptr);
        return on_error(id, Status::Error(500, "Receive wrong server response messages.dialogsNotModified"));
      default:
        UNREACHABLE();
    }
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class SearchPublicDialogsQuery : public Td::ResultHandler {
  string query_;

 public:
  void send(const string &query) {
    query_ = query;
    send_query(G()->net_query_creator().create(telegram_api::contacts_search(query, 3 /* ignored server-side */)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::contacts_search>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto dialogs = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for SearchPublicDialogsQuery: " << to_string(dialogs);
    td->contacts_manager_->on_get_users(std::move(dialogs->users_), "SearchPublicDialogsQuery");
    td->contacts_manager_->on_get_chats(std::move(dialogs->chats_), "SearchPublicDialogsQuery");
    td->messages_manager_->on_get_public_dialogs_search_result(query_, std::move(dialogs->my_results_),
                                                               std::move(dialogs->results_));
  }

  void on_error(uint64 id, Status status) override {
    if (!G()->is_expected_error(status)) {
      LOG(ERROR) << "Receive error for SearchPublicDialogsQuery: " << status;
    }
    td->messages_manager_->on_failed_public_dialogs_search(query_, std::move(status));
  }
};

class GetCommonDialogsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  UserId user_id_;
  int32 offset_chat_id_ = 0;

 public:
  explicit GetCommonDialogsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(UserId user_id, int32 offset_chat_id, int32 limit) {
    user_id_ = user_id;
    offset_chat_id_ = offset_chat_id;
    LOG(INFO) << "Get common dialogs with " << user_id << " from " << offset_chat_id << " with limit " << limit;

    auto input_user = td->contacts_manager_->get_input_user(user_id);
    CHECK(input_user != nullptr);

    send_query(G()->net_query_creator().create(
        telegram_api::messages_getCommonChats(std::move(input_user), offset_chat_id, limit)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getCommonChats>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto chats_ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for GetCommonDialogsQuery: " << to_string(chats_ptr);
    switch (chats_ptr->get_id()) {
      case telegram_api::messages_chats::ID: {
        auto chats = move_tl_object_as<telegram_api::messages_chats>(chats_ptr);
        td->messages_manager_->on_get_common_dialogs(user_id_, offset_chat_id_, std::move(chats->chats_),
                                                     narrow_cast<int32>(chats->chats_.size()));
        break;
      }
      case telegram_api::messages_chatsSlice::ID: {
        auto chats = move_tl_object_as<telegram_api::messages_chatsSlice>(chats_ptr);
        td->messages_manager_->on_get_common_dialogs(user_id_, offset_chat_id_, std::move(chats->chats_),
                                                     chats->count_);
        break;
      }
      default:
        UNREACHABLE();
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class GetBlockedDialogsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  int32 offset_;
  int32 limit_;
  int64 random_id_;

 public:
  explicit GetBlockedDialogsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(int32 offset, int32 limit, int64 random_id) {
    offset_ = offset;
    limit_ = limit;
    random_id_ = random_id;

    send_query(G()->net_query_creator().create(telegram_api::contacts_getBlocked(offset, limit)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::contacts_getBlocked>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for GetBlockedDialogsQuery: " << to_string(ptr);

    switch (ptr->get_id()) {
      case telegram_api::contacts_blocked::ID: {
        auto blocked_peers = move_tl_object_as<telegram_api::contacts_blocked>(ptr);

        td->contacts_manager_->on_get_users(std::move(blocked_peers->users_), "GetBlockedDialogsQuery");
        td->contacts_manager_->on_get_chats(std::move(blocked_peers->chats_), "GetBlockedDialogsQuery");
        td->messages_manager_->on_get_blocked_dialogs(offset_, limit_, random_id_,
                                                      narrow_cast<int32>(blocked_peers->blocked_.size()),
                                                      std::move(blocked_peers->blocked_));
        break;
      }
      case telegram_api::contacts_blockedSlice::ID: {
        auto blocked_peers = move_tl_object_as<telegram_api::contacts_blockedSlice>(ptr);

        td->contacts_manager_->on_get_users(std::move(blocked_peers->users_), "GetBlockedDialogsQuery");
        td->contacts_manager_->on_get_chats(std::move(blocked_peers->chats_), "GetBlockedDialogsQuery");
        td->messages_manager_->on_get_blocked_dialogs(offset_, limit_, random_id_, blocked_peers->count_,
                                                      std::move(blocked_peers->blocked_));
        break;
      }
      default:
        UNREACHABLE();
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_failed_get_blocked_dialogs(random_id_);
    promise_.set_error(std::move(status));
  }
};

class CreateChatQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  int64 random_id_;

 public:
  explicit CreateChatQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(vector<tl_object_ptr<telegram_api::InputUser>> &&input_users, const string &title, int64 random_id) {
    random_id_ = random_id;
    send_query(G()->net_query_creator().create(telegram_api::messages_createChat(std::move(input_users), title)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_createChat>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for CreateChatQuery: " << to_string(ptr);
    td->messages_manager_->on_create_new_dialog_success(random_id_, std::move(ptr), DialogType::Chat,
                                                        std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_create_new_dialog_fail(random_id_, std::move(status), std::move(promise_));
  }
};

class CreateChannelQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  int64 random_id_;

 public:
  explicit CreateChannelQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(const string &title, bool is_megagroup, const string &about, const DialogLocation &location,
            bool for_import, int64 random_id) {
    int32 flags = 0;
    if (is_megagroup) {
      flags |= telegram_api::channels_createChannel::MEGAGROUP_MASK;
    } else {
      flags |= telegram_api::channels_createChannel::BROADCAST_MASK;
    }
    if (!location.empty()) {
      flags |= telegram_api::channels_createChannel::GEO_POINT_MASK;
    }
    if (for_import) {
      flags |= telegram_api::channels_createChannel::FOR_IMPORT_MASK;
    }

    random_id_ = random_id;
    send_query(G()->net_query_creator().create(
        telegram_api::channels_createChannel(flags, false /*ignored*/, false /*ignored*/, false /*ignored*/, title,
                                             about, location.get_input_geo_point(), location.get_address())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::channels_createChannel>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for CreateChannelQuery: " << to_string(ptr);
    td->messages_manager_->on_create_new_dialog_success(random_id_, std::move(ptr), DialogType::Channel,
                                                        std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_create_new_dialog_fail(random_id_, std::move(status), std::move(promise_));
  }
};

class CheckHistoryImportQuery : public Td::ResultHandler {
  Promise<tl_object_ptr<td_api::MessageFileType>> promise_;

 public:
  explicit CheckHistoryImportQuery(Promise<tl_object_ptr<td_api::MessageFileType>> &&promise)
      : promise_(std::move(promise)) {
  }

  void send(const string &message_file_head) {
    send_query(G()->net_query_creator().create(telegram_api::messages_checkHistoryImport(message_file_head)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_checkHistoryImport>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for CheckHistoryImportQuery: " << to_string(ptr);
    auto file_type = [&]() -> td_api::object_ptr<td_api::MessageFileType> {
      if (ptr->pm_) {
        return td_api::make_object<td_api::messageFileTypePrivate>(ptr->title_);
      } else if (ptr->group_) {
        return td_api::make_object<td_api::messageFileTypeGroup>(ptr->title_);
      } else {
        return td_api::make_object<td_api::messageFileTypeUnknown>();
      }
    }();
    promise_.set_value(std::move(file_type));
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class CheckHistoryImportPeerQuery : public Td::ResultHandler {
  Promise<string> promise_;
  DialogId dialog_id_;

 public:
  explicit CheckHistoryImportPeerQuery(Promise<string> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id) {
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    CHECK(input_peer != nullptr);
    send_query(G()->net_query_creator().create(telegram_api::messages_checkHistoryImportPeer(std::move(input_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_checkHistoryImportPeer>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for CheckHistoryImportPeerQuery: " << to_string(ptr);
    promise_.set_value(std::move(ptr->confirm_text_));
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "CheckHistoryImportPeerQuery");
    promise_.set_error(std::move(status));
  }
};

class InitHistoryImportQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  FileId file_id_;
  DialogId dialog_id_;
  vector<FileId> attached_file_ids_;

 public:
  explicit InitHistoryImportQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, FileId file_id, tl_object_ptr<telegram_api::InputFile> &&input_file,
            vector<FileId> attached_file_ids) {
    CHECK(input_file != nullptr);
    file_id_ = file_id;
    dialog_id_ = dialog_id;
    attached_file_ids_ = std::move(attached_file_ids);

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    CHECK(input_peer != nullptr);
    send_query(G()->net_query_creator().create(telegram_api::messages_initHistoryImport(
        std::move(input_peer), std::move(input_file), narrow_cast<int32>(attached_file_ids_.size()))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_initHistoryImport>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->file_manager_->delete_partial_remote_location(file_id_);

    auto ptr = result_ptr.move_as_ok();
    td->messages_manager_->start_import_messages(dialog_id_, ptr->id_, std::move(attached_file_ids_),
                                                 std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    if (FileReferenceManager::is_file_reference_error(status)) {
      LOG(ERROR) << "Receive file reference error " << status;
    }
    if (begins_with(status.message(), "FILE_PART_") && ends_with(status.message(), "_MISSING")) {
      // TODO support FILE_PART_*_MISSING
    }

    td->file_manager_->delete_partial_remote_location(file_id_);

    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "InitHistoryImportQuery");
    promise_.set_error(std::move(status));
  }
};

class UploadImportedMediaQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  int64 import_id_;
  FileId file_id_;

 public:
  explicit UploadImportedMediaQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, int64 import_id, const string &file_name, FileId file_id,
            tl_object_ptr<telegram_api::InputMedia> &&input_media) {
    CHECK(input_media != nullptr);
    dialog_id_ = dialog_id;
    import_id_ = import_id;
    file_id_ = file_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    if (input_peer == nullptr) {
      return on_error(0, Status::Error(400, "Have no write access to the chat"));
    }

    send_query(G()->net_query_creator().create(telegram_api::messages_uploadImportedMedia(
        std::move(input_peer), import_id, file_name, std::move(input_media))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_uploadImportedMedia>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->file_manager_->delete_partial_remote_location(file_id_);

    // ignore response

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (FileReferenceManager::is_file_reference_error(status)) {
      LOG(ERROR) << "Receive file reference error " << status;
    }
    if (begins_with(status.message(), "FILE_PART_") && ends_with(status.message(), "_MISSING")) {
      // TODO support FILE_PART_*_MISSING
    }

    td->file_manager_->delete_partial_remote_location(file_id_);
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "UploadImportedMediaQuery");
    promise_.set_error(std::move(status));
  }
};

class StartImportHistoryQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit StartImportHistoryQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, int64 import_id) {
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    CHECK(input_peer != nullptr);

    send_query(
        G()->net_query_creator().create(telegram_api::messages_startHistoryImport(std::move(input_peer), import_id)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_startHistoryImport>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    if (!result_ptr.ok()) {
      return on_error(id, Status::Error(500, "Import history returned false"));
    }
    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "StartImportHistoryQuery");
    promise_.set_error(std::move(status));
  }
};

class EditDialogPhotoQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  FileId file_id_;
  bool was_uploaded_ = false;
  string file_reference_;
  DialogId dialog_id_;

 public:
  explicit EditDialogPhotoQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, FileId file_id, tl_object_ptr<telegram_api::InputChatPhoto> &&input_chat_photo) {
    CHECK(input_chat_photo != nullptr);
    file_id_ = file_id;
    was_uploaded_ = FileManager::extract_was_uploaded(input_chat_photo);
    file_reference_ = FileManager::extract_file_reference(input_chat_photo);
    dialog_id_ = dialog_id;

    switch (dialog_id.get_type()) {
      case DialogType::Chat:
        send_query(G()->net_query_creator().create(
            telegram_api::messages_editChatPhoto(dialog_id.get_chat_id().get(), std::move(input_chat_photo))));
        break;
      case DialogType::Channel: {
        auto channel_id = dialog_id.get_channel_id();
        auto input_channel = td->contacts_manager_->get_input_channel(channel_id);
        CHECK(input_channel != nullptr);
        send_query(G()->net_query_creator().create(
            telegram_api::channels_editPhoto(std::move(input_channel), std::move(input_chat_photo))));
        break;
      }
      default:
        UNREACHABLE();
    }
  }

  void on_result(uint64 id, BufferSlice packet) override {
    static_assert(std::is_same<telegram_api::messages_editChatPhoto::ReturnType,
                               telegram_api::channels_editPhoto::ReturnType>::value,
                  "");
    auto result_ptr = fetch_result<telegram_api::messages_editChatPhoto>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for EditDialogPhotoQuery: " << to_string(ptr);

    if (file_id_.is_valid() && was_uploaded_) {
      td->file_manager_->delete_partial_remote_location(file_id_);
    }

    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    if (file_id_.is_valid() && was_uploaded_) {
      td->file_manager_->delete_partial_remote_location(file_id_);
    }
    if (!td->auth_manager_->is_bot() && FileReferenceManager::is_file_reference_error(status)) {
      if (file_id_.is_valid() && !was_uploaded_) {
        VLOG(file_references) << "Receive " << status << " for " << file_id_;
        td->file_manager_->delete_file_reference(file_id_, file_reference_);
        td->messages_manager_->upload_dialog_photo(dialog_id_, file_id_, false, 0.0, false, std::move(promise_), {-1});
        return;
      } else {
        LOG(ERROR) << "Receive file reference error, but file_id = " << file_id_
                   << ", was_uploaded = " << was_uploaded_;
      }
    }

    if (status.message() == "CHAT_NOT_MODIFIED") {
      if (!td->auth_manager_->is_bot()) {
        promise_.set_value(Unit());
        return;
      }
    } else {
      td->messages_manager_->on_get_dialog_error(dialog_id_, status, "EditDialogPhotoQuery");
    }
    td->updates_manager_->get_difference("EditDialogPhotoQuery");
    promise_.set_error(std::move(status));
  }
};

class EditDialogTitleQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit EditDialogTitleQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, const string &title) {
    dialog_id_ = dialog_id;
    switch (dialog_id.get_type()) {
      case DialogType::Chat:
        send_query(G()->net_query_creator().create(
            telegram_api::messages_editChatTitle(dialog_id.get_chat_id().get(), title)));
        break;
      case DialogType::Channel: {
        auto channel_id = dialog_id.get_channel_id();
        auto input_channel = td->contacts_manager_->get_input_channel(channel_id);
        CHECK(input_channel != nullptr);
        send_query(G()->net_query_creator().create(telegram_api::channels_editTitle(std::move(input_channel), title)));
        break;
      }
      default:
        UNREACHABLE();
    }
  }

  void on_result(uint64 id, BufferSlice packet) override {
    static_assert(std::is_same<telegram_api::messages_editChatTitle::ReturnType,
                               telegram_api::channels_editTitle::ReturnType>::value,
                  "");
    auto result_ptr = fetch_result<telegram_api::messages_editChatTitle>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for EditDialogTitleQuery: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    td->updates_manager_->get_difference("EditDialogTitleQuery");

    if (status.message() == "CHAT_NOT_MODIFIED") {
      if (!td->auth_manager_->is_bot()) {
        promise_.set_value(Unit());
        return;
      }
    } else {
      td->messages_manager_->on_get_dialog_error(dialog_id_, status, "EditDialogTitleQuery");
    }
    promise_.set_error(std::move(status));
  }
};

class SetHistoryTtlQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit SetHistoryTtlQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, int32 period) {
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    CHECK(input_peer != nullptr);

    send_query(G()->net_query_creator().create(telegram_api::messages_setHistoryTTL(std::move(input_peer), period)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_setHistoryTTL>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for SetHistoryTtlQuery: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    if (status.message() == "CHAT_NOT_MODIFIED") {
      if (!td->auth_manager_->is_bot()) {
        promise_.set_value(Unit());
        return;
      }
    } else {
      td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SetHistoryTtlQuery");
    }
    promise_.set_error(std::move(status));
  }
};

class EditChatDefaultBannedRightsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit EditChatDefaultBannedRightsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, RestrictedRights permissions) {
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    CHECK(input_peer != nullptr);
    send_query(G()->net_query_creator().create(telegram_api::messages_editChatDefaultBannedRights(
        std::move(input_peer), permissions.get_chat_banned_rights())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_editChatDefaultBannedRights>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for EditChatDefaultBannedRightsQuery: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    if (status.message() == "CHAT_NOT_MODIFIED") {
      if (!td->auth_manager_->is_bot()) {
        promise_.set_value(Unit());
        return;
      }
    } else {
      td->messages_manager_->on_get_dialog_error(dialog_id_, status, "EditChatDefaultBannedRightsQuery");
    }
    promise_.set_error(std::move(status));
  }
};

class SaveDraftMessageQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit SaveDraftMessageQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, const unique_ptr<DraftMessage> &draft_message) {
    LOG(INFO) << "Save draft in " << dialog_id;
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    if (input_peer == nullptr) {
      LOG(INFO) << "Can't update draft message because have no write access to " << dialog_id;
      return on_error(0, Status::Error(500, "Can't save draft message"));
    }

    int32 flags = 0;
    ServerMessageId reply_to_message_id;
    if (draft_message != nullptr) {
      if (draft_message->reply_to_message_id.is_valid() && draft_message->reply_to_message_id.is_server()) {
        reply_to_message_id = draft_message->reply_to_message_id.get_server_message_id();
        flags |= MessagesManager::SEND_MESSAGE_FLAG_IS_REPLY;
      }
      if (draft_message->input_message_text.disable_web_page_preview) {
        flags |= MessagesManager::SEND_MESSAGE_FLAG_DISABLE_WEB_PAGE_PREVIEW;
      }
      if (draft_message->input_message_text.text.entities.size()) {
        flags |= MessagesManager::SEND_MESSAGE_FLAG_HAS_ENTITIES;
      }
    }

    send_query(G()->net_query_creator().create(telegram_api::messages_saveDraft(
        flags, false /*ignored*/, reply_to_message_id.get(), std::move(input_peer),
        draft_message == nullptr ? "" : draft_message->input_message_text.text.text,
        draft_message == nullptr
            ? vector<tl_object_ptr<telegram_api::MessageEntity>>()
            : get_input_message_entities(td->contacts_manager_.get(), draft_message->input_message_text.text.entities,
                                         "SaveDraftMessageQuery"))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_saveDraft>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    if (!result) {
      on_error(id, Status::Error(400, "Save draft failed"));
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SaveDraftMessageQuery")) {
      LOG(ERROR) << "Receive error for SaveDraftMessageQuery: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class ClearAllDraftsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit ClearAllDraftsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send() {
    send_query(G()->net_query_creator().create(telegram_api::messages_clearAllDrafts()));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_clearAllDrafts>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.move_as_ok();
    if (!result) {
      LOG(INFO) << "Receive false for ClearAllDraftsQuery";
    } else {
      LOG(INFO) << "All draft messages has been cleared";
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!G()->is_expected_error(status)) {
      LOG(ERROR) << "Receive error for ClearAllDraftsQuery: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class ToggleDialogPinQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  bool is_pinned_;

 public:
  explicit ToggleDialogPinQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, bool is_pinned) {
    dialog_id_ = dialog_id;
    is_pinned_ = is_pinned;

    auto input_peer = td->messages_manager_->get_input_dialog_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      return on_error(0, Status::Error(500, "Can't update dialog is_pinned"));
    }

    int32 flags = 0;
    if (is_pinned) {
      flags |= telegram_api::messages_toggleDialogPin::PINNED_MASK;
    }
    send_query(G()->net_query_creator().create(
        telegram_api::messages_toggleDialogPin(flags, false /*ignored*/, std::move(input_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_toggleDialogPin>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    if (!result) {
      on_error(id, Status::Error(400, "Toggle dialog pin failed"));
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "ToggleDialogPinQuery")) {
      LOG(ERROR) << "Receive error for ToggleDialogPinQuery: " << status;
    }
    td->messages_manager_->on_update_pinned_dialogs(FolderId::main());
    td->messages_manager_->on_update_pinned_dialogs(FolderId::archive());
    promise_.set_error(std::move(status));
  }
};

class ReorderPinnedDialogsQuery : public Td::ResultHandler {
  FolderId folder_id_;
  Promise<Unit> promise_;

 public:
  explicit ReorderPinnedDialogsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(FolderId folder_id, const vector<DialogId> &dialog_ids) {
    folder_id_ = folder_id;
    int32 flags = telegram_api::messages_reorderPinnedDialogs::FORCE_MASK;
    send_query(G()->net_query_creator().create(telegram_api::messages_reorderPinnedDialogs(
        flags, true /*ignored*/, folder_id.get(),
        td->messages_manager_->get_input_dialog_peers(dialog_ids, AccessRights::Read))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_reorderPinnedDialogs>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.move_as_ok();
    if (!result) {
      return on_error(id, Status::Error(400, "Result is false"));
    }
    LOG(INFO) << "Pinned chats reordered in " << folder_id_;

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!G()->is_expected_error(status)) {
      LOG(ERROR) << "Receive error for ReorderPinnedDialogsQuery: " << status;
    }
    td->messages_manager_->on_update_pinned_dialogs(folder_id_);
    promise_.set_error(std::move(status));
  }
};

class ToggleDialogUnreadMarkQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  bool is_marked_as_unread_;

 public:
  explicit ToggleDialogUnreadMarkQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, bool is_marked_as_unread) {
    dialog_id_ = dialog_id;
    is_marked_as_unread_ = is_marked_as_unread;

    auto input_peer = td->messages_manager_->get_input_dialog_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      return on_error(0, Status::Error(500, "Can't update dialog is_marked_as_unread"));
    }

    int32 flags = 0;
    if (is_marked_as_unread) {
      flags |= telegram_api::messages_markDialogUnread::UNREAD_MASK;
    }
    send_query(G()->net_query_creator().create(
        telegram_api::messages_markDialogUnread(flags, false /*ignored*/, std::move(input_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_markDialogUnread>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    if (!result) {
      on_error(id, Status::Error(400, "Toggle dialog mark failed"));
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "ToggleDialogUnreadMarkQuery")) {
      LOG(ERROR) << "Receive error for ToggleDialogUnreadMarkQuery: " << status;
    }
    if (!G()->close_flag()) {
      td->messages_manager_->on_update_dialog_is_marked_as_unread(dialog_id_, !is_marked_as_unread_);
    }
    promise_.set_error(std::move(status));
  }
};

class ToggleDialogIsBlockedQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  bool is_blocked_;

 public:
  explicit ToggleDialogIsBlockedQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, bool is_blocked) {
    dialog_id_ = dialog_id;
    is_blocked_ = is_blocked;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Know);
    CHECK(input_peer != nullptr && input_peer->get_id() != telegram_api::inputPeerEmpty::ID);
    if (is_blocked) {
      send_query(G()->net_query_creator().create(telegram_api::contacts_block(std::move(input_peer))));
    } else {
      send_query(G()->net_query_creator().create(telegram_api::contacts_unblock(std::move(input_peer))));
    }
  }

  void on_result(uint64 id, BufferSlice packet) override {
    static_assert(
        std::is_same<telegram_api::contacts_block::ReturnType, telegram_api::contacts_unblock::ReturnType>::value, "");
    auto result_ptr = fetch_result<telegram_api::contacts_block>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    LOG_IF(WARNING, !result) << "Block/Unblock " << dialog_id_ << " has failed";

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "ToggleDialogIsBlockedQuery")) {
      LOG(ERROR) << "Receive error for ToggleDialogIsBlockedQuery: " << status;
    }
    if (!G()->close_flag()) {
      td->messages_manager_->on_update_dialog_is_blocked(dialog_id_, !is_blocked_);
      td->messages_manager_->get_dialog_info_full(dialog_id_, Auto());
      td->messages_manager_->reget_dialog_action_bar(dialog_id_, "ToggleDialogIsBlockedQuery");
    }
    promise_.set_error(std::move(status));
  }
};

class GetMessagesViewsQuery : public Td::ResultHandler {
  DialogId dialog_id_;
  vector<MessageId> message_ids_;

 public:
  void send(DialogId dialog_id, vector<MessageId> &&message_ids, bool increment_view_counter) {
    dialog_id_ = dialog_id;
    message_ids_ = std::move(message_ids);

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      LOG(ERROR) << "Can't update message view count because doesn't have info about the " << dialog_id;
      return on_error(0, Status::Error(500, "Can't update message view count"));
    }

    LOG(INFO) << "View " << message_ids_.size() << " messages in " << dialog_id
              << ", increment = " << increment_view_counter;
    send_query(G()->net_query_creator().create(telegram_api::messages_getMessagesViews(
        std::move(input_peer), MessagesManager::get_server_message_ids(message_ids_), increment_view_counter)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getMessagesViews>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto result = result_ptr.move_as_ok();
    auto interaction_infos = std::move(result->views_);
    if (message_ids_.size() != interaction_infos.size()) {
      return on_error(id, Status::Error(500, "Wrong number of message views returned"));
    }
    td->contacts_manager_->on_get_users(std::move(result->users_), "GetMessagesViewsQuery");
    td->contacts_manager_->on_get_chats(std::move(result->chats_), "GetMessagesViewsQuery");
    for (size_t i = 0; i < message_ids_.size(); i++) {
      FullMessageId full_message_id{dialog_id_, message_ids_[i]};

      auto *info = interaction_infos[i].get();
      auto flags = info->flags_;
      auto view_count = (flags & telegram_api::messageViews::VIEWS_MASK) != 0 ? info->views_ : 0;
      auto forward_count = (flags & telegram_api::messageViews::FORWARDS_MASK) != 0 ? info->forwards_ : 0;
      td->messages_manager_->on_update_message_interaction_info(full_message_id, view_count, forward_count, true,
                                                                std::move(info->replies_));
    }
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetMessagesViewsQuery")) {
      LOG(ERROR) << "Receive error for GetMessagesViewsQuery: " << status;
    }
  }
};

class ReadMessagesContentsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit ReadMessagesContentsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(vector<MessageId> &&message_ids) {
    LOG(INFO) << "Receive ReadMessagesContentsQuery for messages " << format::as_array(message_ids);

    send_query(G()->net_query_creator().create(
        telegram_api::messages_readMessageContents(MessagesManager::get_server_message_ids(message_ids))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_readMessageContents>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto affected_messages = result_ptr.move_as_ok();
    CHECK(affected_messages->get_id() == telegram_api::messages_affectedMessages::ID);

    if (affected_messages->pts_count_ > 0) {
      td->updates_manager_->add_pending_pts_update(make_tl_object<dummyUpdate>(), affected_messages->pts_,
                                                   affected_messages->pts_count_, Promise<Unit>(),
                                                   "read messages content query");
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!G()->is_expected_error(status)) {
      LOG(ERROR) << "Receive error for read message contents: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class ReadChannelMessagesContentsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  ChannelId channel_id_;

 public:
  explicit ReadChannelMessagesContentsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(ChannelId channel_id, vector<MessageId> &&message_ids) {
    channel_id_ = channel_id;

    auto input_channel = td->contacts_manager_->get_input_channel(channel_id);
    if (input_channel == nullptr) {
      LOG(ERROR) << "Have no input channel for " << channel_id;
      return on_error(0, Status::Error(500, "Can't read channel message contents"));
    }

    LOG(INFO) << "Receive ReadChannelMessagesContentsQuery for messages " << format::as_array(message_ids) << " in "
              << channel_id;

    send_query(G()->net_query_creator().create(telegram_api::channels_readMessageContents(
        std::move(input_channel), MessagesManager::get_server_message_ids(message_ids))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::channels_readMessageContents>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    LOG_IF(ERROR, !result) << "Read channel messages contents failed";

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->contacts_manager_->on_get_channel_error(channel_id_, status, "ReadChannelMessagesContentsQuery")) {
      LOG(ERROR) << "Receive error for read messages contents in " << channel_id_ << ": " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class GetDialogMessageByDateQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  int32 date_;
  int64 random_id_;

 public:
  explicit GetDialogMessageByDateQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, int32 date, int64 random_id) {
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      return promise_.set_error(Status::Error(500, "Have no info about the chat"));
    }

    dialog_id_ = dialog_id;
    date_ = date;
    random_id_ = random_id;

    send_query(G()->net_query_creator().create(
        telegram_api::messages_getHistory(std::move(input_peer), 0, date, -3, 5, 0, 0, 0)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getHistory>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "GetDialogMessageByDateQuery");
    td->messages_manager_->get_channel_difference_if_needed(
        dialog_id_, std::move(info),
        PromiseCreator::lambda([td = td, dialog_id = dialog_id_, date = date_, random_id = random_id_,
                                promise = std::move(promise_)](Result<MessagesManager::MessagesInfo> &&result) mutable {
          if (result.is_error()) {
            promise.set_error(result.move_as_error());
          } else {
            auto info = result.move_as_ok();
            td->messages_manager_->on_get_dialog_message_by_date_success(dialog_id, date, random_id,
                                                                         std::move(info.messages));
            promise.set_value(Unit());
          }
        }));
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetDialogMessageByDateQuery")) {
      LOG(ERROR) << "Receive error for GetDialogMessageByDateQuery in " << dialog_id_ << ": " << status;
    }
    promise_.set_error(std::move(status));
    td->messages_manager_->on_get_dialog_message_by_date_fail(random_id_);
  }
};

class GetHistoryQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  MessageId from_message_id_;
  int32 offset_;
  int32 limit_;
  bool from_the_end_;

 public:
  explicit GetHistoryQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, MessageId from_message_id, int32 offset, int32 limit) {
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      LOG(ERROR) << "Can't get chat history in " << dialog_id << " because doesn't have info about the chat";
      return promise_.set_error(Status::Error(500, "Have no info about the chat"));
    }
    CHECK(offset < 0);

    dialog_id_ = dialog_id;
    from_message_id_ = from_message_id;
    offset_ = offset;
    limit_ = limit;
    from_the_end_ = false;
    send_query(G()->net_query_creator().create(telegram_api::messages_getHistory(
        std::move(input_peer), from_message_id.get_server_message_id().get(), 0, offset, limit, 0, 0, 0)));
  }

  void send_get_from_the_end(DialogId dialog_id, int32 limit) {
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      LOG(ERROR) << "Can't get chat history because doesn't have info about the chat";
      return promise_.set_error(Status::Error(500, "Have no info about the chat"));
    }

    dialog_id_ = dialog_id;
    offset_ = 0;
    limit_ = limit;
    from_the_end_ = true;
    send_query(G()->net_query_creator().create(
        telegram_api::messages_getHistory(std::move(input_peer), 0, 0, 0, limit, 0, 0, 0)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getHistory>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "GetHistoryQuery");
    td->messages_manager_->get_channel_difference_if_needed(
        dialog_id_, std::move(info),
        PromiseCreator::lambda([td = td, dialog_id = dialog_id_, from_message_id = from_message_id_, offset = offset_,
                                limit = limit_, from_the_end = from_the_end_,
                                promise = std::move(promise_)](Result<MessagesManager::MessagesInfo> &&result) mutable {
          if (result.is_error()) {
            promise.set_error(result.move_as_error());
          } else {
            auto info = result.move_as_ok();
            // TODO use info.total_count, info.pts
            td->messages_manager_->on_get_history(dialog_id, from_message_id, offset, limit, from_the_end,
                                                  std::move(info.messages));
            promise.set_value(Unit());
          }
        }));
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetHistoryQuery")) {
      LOG(ERROR) << "Receive error for GetHistoryQuery in " << dialog_id_ << ": " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class ReadHistoryQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit ReadHistoryQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, MessageId max_message_id) {
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);
    send_query(G()->net_query_creator().create(
        telegram_api::messages_readHistory(std::move(input_peer), max_message_id.get_server_message_id().get())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_readHistory>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto affected_messages = result_ptr.move_as_ok();
    CHECK(affected_messages->get_id() == telegram_api::messages_affectedMessages::ID);
    LOG(INFO) << "Receive result for ReadHistoryQuery: " << to_string(affected_messages);

    if (affected_messages->pts_count_ > 0) {
      td->updates_manager_->add_pending_pts_update(make_tl_object<dummyUpdate>(), affected_messages->pts_,
                                                   affected_messages->pts_count_, Promise<Unit>(),
                                                   "read history query");
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "ReadHistoryQuery")) {
      LOG(ERROR) << "Receive error for ReadHistoryQuery: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class ReadChannelHistoryQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  ChannelId channel_id_;

 public:
  explicit ReadChannelHistoryQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(ChannelId channel_id, MessageId max_message_id) {
    channel_id_ = channel_id;
    auto input_channel = td->contacts_manager_->get_input_channel(channel_id);
    CHECK(input_channel != nullptr);

    send_query(G()->net_query_creator().create(
        telegram_api::channels_readHistory(std::move(input_channel), max_message_id.get_server_message_id().get())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::channels_readHistory>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->contacts_manager_->on_get_channel_error(channel_id_, status, "ReadChannelHistoryQuery")) {
      LOG(ERROR) << "Receive error for ReadChannelHistoryQuery: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class ReadDiscussionQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit ReadDiscussionQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, MessageId top_thread_message_id, MessageId max_message_id) {
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);
    send_query(G()->net_query_creator().create(telegram_api::messages_readDiscussion(
        std::move(input_peer), top_thread_message_id.get_server_message_id().get(),
        max_message_id.get_server_message_id().get())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_readDiscussion>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "ReadDiscussionQuery");
    promise_.set_error(std::move(status));
  }
};

class SearchMessagesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  string query_;
  DialogId sender_dialog_id_;
  MessageId from_message_id_;
  int32 offset_;
  int32 limit_;
  MessageSearchFilter filter_;
  MessageId top_thread_message_id_;
  int64 random_id_;
  bool handle_errors_ = true;

 public:
  explicit SearchMessagesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, const string &query, DialogId sender_dialog_id, MessageId from_message_id, int32 offset,
            int32 limit, MessageSearchFilter filter, MessageId top_thread_message_id, int64 random_id) {
    auto input_peer = dialog_id.is_valid() ? td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read)
                                           : make_tl_object<telegram_api::inputPeerEmpty>();
    if (input_peer == nullptr) {
      LOG(ERROR) << "Can't search messages because doesn't have info about the chat";
      return promise_.set_error(Status::Error(500, "Have no info about the chat"));
    }

    dialog_id_ = dialog_id;
    query_ = query;
    sender_dialog_id_ = sender_dialog_id;
    from_message_id_ = from_message_id;
    offset_ = offset;
    limit_ = limit;
    filter_ = filter;
    top_thread_message_id_ = top_thread_message_id;
    random_id_ = random_id;

    if (filter == MessageSearchFilter::UnreadMention) {
      send_query(G()->net_query_creator().create(
          telegram_api::messages_getUnreadMentions(std::move(input_peer), from_message_id.get_server_message_id().get(),
                                                   offset, limit, std::numeric_limits<int32>::max(), 0)));
    } else if (top_thread_message_id.is_valid() && query.empty() && !sender_dialog_id.is_valid() &&
               filter == MessageSearchFilter::Empty) {
      handle_errors_ = dialog_id.get_type() != DialogType::Channel ||
                       td->contacts_manager_->get_channel_type(dialog_id.get_channel_id()) != ChannelType::Broadcast;
      send_query(G()->net_query_creator().create(telegram_api::messages_getReplies(
          std::move(input_peer), top_thread_message_id.get_server_message_id().get(),
          from_message_id.get_server_message_id().get(), 0, offset, limit, std::numeric_limits<int32>::max(), 0, 0)));
    } else {
      int32 flags = 0;
      tl_object_ptr<telegram_api::InputPeer> sender_input_peer;
      if (sender_dialog_id.is_valid()) {
        flags |= telegram_api::messages_search::FROM_ID_MASK;
        sender_input_peer = td->messages_manager_->get_input_peer(sender_dialog_id, AccessRights::Read);
        CHECK(sender_input_peer != nullptr);
      }
      if (top_thread_message_id.is_valid()) {
        flags |= telegram_api::messages_search::TOP_MSG_ID_MASK;
      }

      send_query(G()->net_query_creator().create(telegram_api::messages_search(
          flags, std::move(input_peer), query, std::move(sender_input_peer),
          top_thread_message_id.get_server_message_id().get(), get_input_messages_filter(filter), 0,
          std::numeric_limits<int32>::max(), from_message_id.get_server_message_id().get(), offset, limit,
          std::numeric_limits<int32>::max(), 0, 0)));
    }
  }

  void on_result(uint64 id, BufferSlice packet) override {
    static_assert(std::is_same<telegram_api::messages_getUnreadMentions::ReturnType,
                               telegram_api::messages_search::ReturnType>::value,
                  "");
    static_assert(
        std::is_same<telegram_api::messages_getReplies::ReturnType, telegram_api::messages_search::ReturnType>::value,
        "");
    auto result_ptr = fetch_result<telegram_api::messages_search>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "SearchMessagesQuery");
    td->messages_manager_->get_channel_difference_if_needed(
        dialog_id_, std::move(info),
        PromiseCreator::lambda([td = td, dialog_id = dialog_id_, query = std::move(query_),
                                sender_dialog_id = sender_dialog_id_, from_message_id = from_message_id_,
                                offset = offset_, limit = limit_, filter = filter_,
                                top_thread_message_id = top_thread_message_id_, random_id = random_id_,
                                promise = std::move(promise_)](Result<MessagesManager::MessagesInfo> &&result) mutable {
          if (result.is_error()) {
            promise.set_error(result.move_as_error());
          } else {
            auto info = result.move_as_ok();
            td->messages_manager_->on_get_dialog_messages_search_result(
                dialog_id, query, sender_dialog_id, from_message_id, offset, limit, filter, top_thread_message_id,
                random_id, info.total_count, std::move(info.messages));
            promise.set_value(Unit());
          }
        }));
  }

  void on_error(uint64 id, Status status) override {
    if (!handle_errors_) {
      td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SearchMessagesQuery");
    }
    td->messages_manager_->on_failed_dialog_messages_search(dialog_id_, random_id_);
    promise_.set_error(std::move(status));
  }
};

class SearchMessagesGlobalQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  string query_;
  int32 offset_date_;
  DialogId offset_dialog_id_;
  MessageId offset_message_id_;
  int32 limit_;
  MessageSearchFilter filter_;
  int32 min_date_;
  int32 max_date_;
  int64 random_id_;

 public:
  explicit SearchMessagesGlobalQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(FolderId folder_id, bool ignore_folder_id, const string &query, int32 offset_date,
            DialogId offset_dialog_id, MessageId offset_message_id, int32 limit, MessageSearchFilter filter,
            int32 min_date, int32 max_date, int64 random_id) {
    query_ = query;
    offset_date_ = offset_date;
    offset_dialog_id_ = offset_dialog_id;
    offset_message_id_ = offset_message_id;
    limit_ = limit;
    random_id_ = random_id;
    filter_ = filter;
    min_date_ = min_date;
    max_date_ = max_date;

    auto input_peer = MessagesManager::get_input_peer_force(offset_dialog_id);
    CHECK(input_peer != nullptr);

    int32 flags = 0;
    if (!ignore_folder_id) {
      flags |= telegram_api::messages_searchGlobal::FOLDER_ID_MASK;
    }
    send_query(G()->net_query_creator().create(telegram_api::messages_searchGlobal(
        flags, folder_id.get(), query, get_input_messages_filter(filter), min_date_, max_date_, offset_date_,
        std::move(input_peer), offset_message_id.get_server_message_id().get(), limit)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_searchGlobal>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "SearchMessagesGlobalQuery");
    td->messages_manager_->on_get_messages_search_result(query_, offset_date_, offset_dialog_id_, offset_message_id_,
                                                         limit_, filter_, min_date_, max_date_, random_id_,
                                                         info.total_count, std::move(info.messages));

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_failed_messages_search(random_id_);
    promise_.set_error(std::move(status));
  }
};

class GetAllScheduledMessagesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  uint32 generation_;

 public:
  explicit GetAllScheduledMessagesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, int32 hash, uint32 generation) {
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);

    dialog_id_ = dialog_id;
    generation_ = generation;

    send_query(
        G()->net_query_creator().create(telegram_api::messages_getScheduledHistory(std::move(input_peer), hash)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getScheduledHistory>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    if (result_ptr.ok()->get_id() == telegram_api::messages_messagesNotModified::ID) {
      td->messages_manager_->on_get_scheduled_server_messages(dialog_id_, generation_, Auto(), true);
    } else {
      auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "GetAllScheduledMessagesQuery");
      td->messages_manager_->on_get_scheduled_server_messages(dialog_id_, generation_, std::move(info.messages), false);
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetAllScheduledMessagesQuery");
    promise_.set_error(std::move(status));
  }
};

class GetRecentLocationsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  int32 limit_;
  int64 random_id_;

 public:
  explicit GetRecentLocationsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, int32 limit, int64 random_id) {
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      LOG(ERROR) << "Can't get recent locations because doesn't have info about the chat";
      return promise_.set_error(Status::Error(500, "Have no info about the chat"));
    }

    dialog_id_ = dialog_id;
    limit_ = limit;
    random_id_ = random_id;

    send_query(
        G()->net_query_creator().create(telegram_api::messages_getRecentLocations(std::move(input_peer), limit, 0)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getRecentLocations>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "GetRecentLocationsQuery");
    td->messages_manager_->get_channel_difference_if_needed(
        dialog_id_, std::move(info),
        PromiseCreator::lambda([td = td, dialog_id = dialog_id_, limit = limit_, random_id = random_id_,
                                promise = std::move(promise_)](Result<MessagesManager::MessagesInfo> &&result) mutable {
          if (result.is_error()) {
            promise.set_error(result.move_as_error());
          } else {
            auto info = result.move_as_ok();
            td->messages_manager_->on_get_recent_locations(dialog_id, limit, random_id, info.total_count,
                                                           std::move(info.messages));
            promise.set_value(Unit());
          }
        }));
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetRecentLocationsQuery");
    td->messages_manager_->on_get_recent_locations_failed(random_id_);
    promise_.set_error(std::move(status));
  }
};

class GetMessagePublicForwardsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  int32 limit_;
  int64 random_id_;

 public:
  explicit GetMessagePublicForwardsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(FullMessageId full_message_id, int32 offset_date, DialogId offset_dialog_id,
            ServerMessageId offset_message_id, int32 limit, int64 random_id) {
    dialog_id_ = full_message_id.get_dialog_id();
    limit_ = limit;
    random_id_ = random_id;

    auto input_peer = MessagesManager::get_input_peer_force(offset_dialog_id);
    CHECK(input_peer != nullptr);

    send_query(G()->net_query_creator().create(telegram_api::stats_getMessagePublicForwards(
        td->contacts_manager_->get_input_channel(dialog_id_.get_channel_id()),
        full_message_id.get_message_id().get_server_message_id().get(), offset_date, std::move(input_peer),
        offset_message_id.get(), limit)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::stats_getMessagePublicForwards>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto info = td->messages_manager_->on_get_messages(result_ptr.move_as_ok(), "GetMessagePublicForwardsQuery");
    td->messages_manager_->on_get_message_public_forwards_result(random_id_, info.total_count,
                                                                 std::move(info.messages));

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetMessagePublicForwardsQuery");
    td->messages_manager_->on_failed_get_message_public_forwards(random_id_);
    promise_.set_error(std::move(status));
  }
};

class HidePromoDataQuery : public Td::ResultHandler {
  DialogId dialog_id_;

 public:
  void send(DialogId dialog_id) {
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);
    send_query(G()->net_query_creator().create(telegram_api::help_hidePromoData(std::move(input_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::help_hidePromoData>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    // we are not interested in the result
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "HidePromoDataQuery")) {
      LOG(ERROR) << "Receive error for sponsored chat hiding: " << status;
    }
  }
};

class DeleteHistoryQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  MessageId max_message_id_;
  bool remove_from_dialog_list_;
  bool revoke_;

  void send_request() {
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id_, AccessRights::Read);
    if (input_peer == nullptr) {
      return promise_.set_error(Status::Error(3, "Chat is not accessible"));
    }

    int32 flags = 0;
    if (!remove_from_dialog_list_) {
      flags |= telegram_api::messages_deleteHistory::JUST_CLEAR_MASK;
    }
    if (revoke_) {
      flags |= telegram_api::messages_deleteHistory::REVOKE_MASK;
    }
    LOG(INFO) << "Delete " << dialog_id_ << " history up to " << max_message_id_ << " with flags " << flags;

    send_query(G()->net_query_creator().create(
        telegram_api::messages_deleteHistory(flags, false /*ignored*/, false /*ignored*/, std::move(input_peer),
                                             max_message_id_.get_server_message_id().get())));
  }

 public:
  explicit DeleteHistoryQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, MessageId max_message_id, bool remove_from_dialog_list, bool revoke) {
    dialog_id_ = dialog_id;
    max_message_id_ = max_message_id;
    remove_from_dialog_list_ = remove_from_dialog_list;
    revoke_ = revoke;

    send_request();
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_deleteHistory>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto affected_history = result_ptr.move_as_ok();
    CHECK(affected_history->get_id() == telegram_api::messages_affectedHistory::ID);

    if (affected_history->pts_count_ > 0) {
      td->updates_manager_->add_pending_pts_update(make_tl_object<dummyUpdate>(), affected_history->pts_,
                                                   affected_history->pts_count_, Promise<Unit>(),
                                                   "delete history query");
    }

    if (affected_history->offset_ > 0) {
      send_request();
      return;
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "DeleteHistoryQuery");
    promise_.set_error(std::move(status));
  }
};

class DeleteChannelHistoryQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  ChannelId channel_id_;
  MessageId max_message_id_;
  bool allow_error_;

 public:
  explicit DeleteChannelHistoryQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(ChannelId channel_id, MessageId max_message_id, bool allow_error) {
    channel_id_ = channel_id;
    max_message_id_ = max_message_id;
    allow_error_ = allow_error;
    auto input_channel = td->contacts_manager_->get_input_channel(channel_id);
    CHECK(input_channel != nullptr);

    send_query(G()->net_query_creator().create(
        telegram_api::channels_deleteHistory(std::move(input_channel), max_message_id.get_server_message_id().get())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::channels_deleteHistory>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    LOG_IF(ERROR, !allow_error_ && !result)
        << "Delete history in " << channel_id_ << " up to " << max_message_id_ << " failed";

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->contacts_manager_->on_get_channel_error(channel_id_, status, "DeleteChannelHistoryQuery")) {
      LOG(ERROR) << "Receive error for DeleteChannelHistoryQuery: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class DeletePhoneCallHistoryQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  bool revoke_;

  void send_request() {
    int32 flags = 0;
    if (revoke_) {
      flags |= telegram_api::messages_deletePhoneCallHistory::REVOKE_MASK;
    }
    send_query(
        G()->net_query_creator().create(telegram_api::messages_deletePhoneCallHistory(flags, false /*ignored*/)));
  }

 public:
  explicit DeletePhoneCallHistoryQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(bool revoke) {
    revoke_ = revoke;

    send_request();
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_deletePhoneCallHistory>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto affected_messages = result_ptr.move_as_ok();
    CHECK(affected_messages->get_id() == telegram_api::messages_affectedFoundMessages::ID);

    if (affected_messages->pts_count_ > 0) {
      auto promise = affected_messages->offset_ > 0 ? Promise<Unit>() : std::move(promise_);
      auto pts = affected_messages->pts_;
      auto pts_count = affected_messages->pts_count_;
      auto update =
          make_tl_object<telegram_api::updateDeleteMessages>(std::move(affected_messages->messages_), pts, pts_count);
      td->updates_manager_->add_pending_pts_update(std::move(update), pts, pts_count, std::move(promise),
                                                   "delete phone call history query");
    } else if (affected_messages->offset_ <= 0) {
      promise_.set_value(Unit());
    }

    if (affected_messages->offset_ > 0) {
      send_request();
      return;
    }
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class BlockFromRepliesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit BlockFromRepliesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(MessageId message_id, bool delete_message, bool delete_all_messages, bool report_spam) {
    int32 flags = 0;
    if (delete_message) {
      flags |= telegram_api::contacts_blockFromReplies::DELETE_MESSAGE_MASK;
    }
    if (delete_all_messages) {
      flags |= telegram_api::contacts_blockFromReplies::DELETE_HISTORY_MASK;
    }
    if (report_spam) {
      flags |= telegram_api::contacts_blockFromReplies::REPORT_SPAM_MASK;
    }
    send_query(G()->net_query_creator().create(telegram_api::contacts_blockFromReplies(
        flags, false /*ignored*/, false /*ignored*/, false /*ignored*/, message_id.get_server_message_id().get())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::contacts_blockFromReplies>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for BlockFromRepliesQuery: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class DeleteUserHistoryQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  ChannelId channel_id_;
  UserId user_id_;

  void send_request() {
    auto input_channel = td->contacts_manager_->get_input_channel(channel_id_);
    if (input_channel == nullptr) {
      return promise_.set_error(Status::Error(3, "Chat is not accessible"));
    }
    auto input_user = td->contacts_manager_->get_input_user(user_id_);
    if (input_user == nullptr) {
      return promise_.set_error(Status::Error(3, "Usat is not accessible"));
    }

    LOG(INFO) << "Delete all messages from " << user_id_ << " in " << channel_id_;

    send_query(G()->net_query_creator().create(
        telegram_api::channels_deleteUserHistory(std::move(input_channel), std::move(input_user))));
  }

 public:
  explicit DeleteUserHistoryQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(ChannelId channel_id, UserId user_id) {
    channel_id_ = channel_id;
    user_id_ = user_id;

    send_request();
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::channels_deleteUserHistory>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto affected_history = result_ptr.move_as_ok();
    CHECK(affected_history->get_id() == telegram_api::messages_affectedHistory::ID);

    if (affected_history->pts_count_ > 0) {
      td->messages_manager_->add_pending_channel_update(
          DialogId(channel_id_), make_tl_object<dummyUpdate>(), affected_history->pts_, affected_history->pts_count_,
          affected_history->offset_ > 0 ? Promise<Unit>() : std::move(promise_), "delete user history query");
    } else if (affected_history->offset_ <= 0) {
      promise_.set_value(Unit());
    }

    if (affected_history->offset_ > 0) {
      send_request();
      return;
    }
  }

  void on_error(uint64 id, Status status) override {
    td->contacts_manager_->on_get_channel_error(channel_id_, status, "DeleteUserHistoryQuery");
    promise_.set_error(std::move(status));
  }
};

class ReadMentionsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

  void send_request() {
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id_, AccessRights::Read);
    if (input_peer == nullptr) {
      return promise_.set_error(Status::Error(3, "Chat is not accessible"));
    }

    LOG(INFO) << "Read all mentions in " << dialog_id_;

    send_query(G()->net_query_creator().create(telegram_api::messages_readMentions(std::move(input_peer))));
  }

 public:
  explicit ReadMentionsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id) {
    dialog_id_ = dialog_id;

    send_request();
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_readMentions>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto affected_history = result_ptr.move_as_ok();
    CHECK(affected_history->get_id() == telegram_api::messages_affectedHistory::ID);

    if (affected_history->pts_count_ > 0) {
      if (dialog_id_.get_type() == DialogType::Channel) {
        LOG(ERROR) << "Receive pts_count " << affected_history->pts_count_ << " in result of ReadMentionsQuery in "
                   << dialog_id_;
        td->updates_manager_->get_difference("Wrong messages_readMentions result");
      } else {
        td->updates_manager_->add_pending_pts_update(make_tl_object<dummyUpdate>(), affected_history->pts_,
                                                     affected_history->pts_count_, Promise<Unit>(),
                                                     "read all mentions query");
      }
    }

    if (affected_history->offset_ > 0) {
      send_request();
      return;
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "ReadMentionsQuery");
    promise_.set_error(std::move(status));
  }
};

class SendSecretMessageActor : public NetActor {
  int64 random_id_;

 public:
  void send(DialogId dialog_id, int64 reply_to_random_id, int32 ttl, const string &text, SecretInputMedia media,
            vector<tl_object_ptr<secret_api::MessageEntity>> &&entities, UserId via_bot_user_id, int64 media_album_id,
            bool disable_notification, int64 random_id) {
    if (false && !media.empty()) {
      td->messages_manager_->on_send_secret_message_error(random_id, Status::Error(400, "FILE_PART_1_MISSING"), Auto());
      stop();
      return;
    }

    CHECK(dialog_id.get_type() == DialogType::SecretChat);
    random_id_ = random_id;

    int32 flags = 0;
    if (reply_to_random_id != 0) {
      flags |= secret_api::decryptedMessage::REPLY_TO_RANDOM_ID_MASK;
    }
    if (via_bot_user_id.is_valid()) {
      flags |= secret_api::decryptedMessage::VIA_BOT_NAME_MASK;
    }
    if (!media.empty()) {
      flags |= secret_api::decryptedMessage::MEDIA_MASK;
    }
    if (!entities.empty()) {
      flags |= secret_api::decryptedMessage::ENTITIES_MASK;
    }
    if (media_album_id != 0) {
      CHECK(media_album_id < 0);
      flags |= secret_api::decryptedMessage::GROUPED_ID_MASK;
    }
    if (disable_notification) {
      flags |= secret_api::decryptedMessage::SILENT_MASK;
    }

    send_closure(
        G()->secret_chats_manager(), &SecretChatsManager::send_message, dialog_id.get_secret_chat_id(),
        make_tl_object<secret_api::decryptedMessage>(
            flags, false /*ignored*/, random_id, ttl, text, std::move(media.decrypted_media_), std::move(entities),
            td->contacts_manager_->get_user_username(via_bot_user_id), reply_to_random_id, -media_album_id),
        std::move(media.input_file_), PromiseCreator::event(self_closure(this, &SendSecretMessageActor::done)));
  }

  void done() {
    stop();
  }
};

class SendMessageActor : public NetActorOnce {
  int64 random_id_;
  DialogId dialog_id_;

 public:
  void send(int32 flags, DialogId dialog_id, MessageId reply_to_message_id, int32 schedule_date,
            tl_object_ptr<telegram_api::ReplyMarkup> &&reply_markup,
            vector<tl_object_ptr<telegram_api::MessageEntity>> &&entities, const string &text, int64 random_id,
            NetQueryRef *send_query_ref, uint64 sequence_dispatcher_id) {
    random_id_ = random_id;
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    if (input_peer == nullptr) {
      on_error(0, Status::Error(400, "Have no write access to the chat"));
      stop();
      return;
    }

    if (!entities.empty()) {
      flags |= MessagesManager::SEND_MESSAGE_FLAG_HAS_ENTITIES;
    }

    auto query = G()->net_query_creator().create(telegram_api::messages_sendMessage(
        flags, false /*ignored*/, false /*ignored*/, false /*ignored*/, false /*ignored*/, std::move(input_peer),
        reply_to_message_id.get_server_message_id().get(), text, random_id, std::move(reply_markup),
        std::move(entities), schedule_date));
    if (G()->shared_config().get_option_boolean("use_quick_ack")) {
      query->quick_ack_promise_ = PromiseCreator::lambda(
          [random_id](Unit) {
            send_closure(G()->messages_manager(), &MessagesManager::on_send_message_get_quick_ack, random_id);
          },
          PromiseCreator::Ignore());
    }
    *send_query_ref = query.get_weak();
    query->debug("send to MessagesManager::MultiSequenceDispatcher");
    send_closure(td->messages_manager_->sequence_dispatcher_, &MultiSequenceDispatcher::send_with_callback,
                 std::move(query), actor_shared(this), sequence_dispatcher_id);
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_sendMessage>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for SendMessage for " << random_id_ << ": " << to_string(ptr);

    auto constructor_id = ptr->get_id();
    if (constructor_id != telegram_api::updateShortSentMessage::ID) {
      td->messages_manager_->check_send_message_result(random_id_, dialog_id_, ptr.get(), "SendMessage");
      return td->updates_manager_->on_get_updates(std::move(ptr), Promise<Unit>());
    }
    auto sent_message = move_tl_object_as<telegram_api::updateShortSentMessage>(ptr);
    td->messages_manager_->on_update_sent_text_message(random_id_, std::move(sent_message->media_),
                                                       std::move(sent_message->entities_));

    auto message_id = MessageId(ServerMessageId(sent_message->id_));
    auto ttl_period = (sent_message->flags_ & telegram_api::updateShortSentMessage::TTL_PERIOD_MASK) != 0
                          ? sent_message->ttl_period_
                          : 0;
    auto update = make_tl_object<updateSentMessage>(random_id_, message_id, sent_message->date_, ttl_period);
    if (dialog_id_.get_type() == DialogType::Channel) {
      td->messages_manager_->add_pending_channel_update(dialog_id_, std::move(update), sent_message->pts_,
                                                        sent_message->pts_count_, Promise<Unit>(),
                                                        "send message actor");
      return;
    }

    td->updates_manager_->add_pending_pts_update(std::move(update), sent_message->pts_, sent_message->pts_count_,
                                                 Promise<Unit>(), "send message actor");
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for SendMessage: " << status;
    if (G()->close_flag() && G()->parameters().use_message_db) {
      // do not send error, message will be re-sent
      return;
    }
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SendMessageActor");
    td->messages_manager_->on_send_message_fail(random_id_, std::move(status));
  }
};

class StartBotQuery : public Td::ResultHandler {
  int64 random_id_;
  DialogId dialog_id_;

 public:
  NetQueryRef send(tl_object_ptr<telegram_api::InputUser> bot_input_user, DialogId dialog_id,
                   tl_object_ptr<telegram_api::InputPeer> input_peer, const string &parameter, int64 random_id) {
    CHECK(bot_input_user != nullptr);
    CHECK(input_peer != nullptr);
    random_id_ = random_id;
    dialog_id_ = dialog_id;

    auto query = G()->net_query_creator().create(
        telegram_api::messages_startBot(std::move(bot_input_user), std::move(input_peer), random_id, parameter));
    if (G()->shared_config().get_option_boolean("use_quick_ack")) {
      query->quick_ack_promise_ = PromiseCreator::lambda(
          [random_id](Unit) {
            send_closure(G()->messages_manager(), &MessagesManager::on_send_message_get_quick_ack, random_id);
          },
          PromiseCreator::Ignore());
    }
    auto send_query_ref = query.get_weak();
    send_query(std::move(query));
    return send_query_ref;
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_startBot>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for StartBotQuery for " << random_id_ << ": " << to_string(ptr);
    // Result may contain messageActionChatAddUser
    // td->messages_manager_->check_send_message_result(random_id_, dialog_id_, ptr.get(), "StartBot");
    td->updates_manager_->on_get_updates(std::move(ptr), Promise<Unit>());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for StartBotQuery: " << status;
    if (G()->close_flag() && G()->parameters().use_message_db) {
      // do not send error, message should be re-sent
      return;
    }
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "StartBotQuery");
    td->messages_manager_->on_send_message_fail(random_id_, std::move(status));
  }
};

class SendInlineBotResultQuery : public Td::ResultHandler {
  int64 random_id_;
  DialogId dialog_id_;

 public:
  NetQueryRef send(int32 flags, DialogId dialog_id, MessageId reply_to_message_id, int32 schedule_date, int64 random_id,
                   int64 query_id, const string &result_id) {
    random_id_ = random_id;
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    CHECK(input_peer != nullptr);

    auto query = G()->net_query_creator().create(telegram_api::messages_sendInlineBotResult(
        flags, false /*ignored*/, false /*ignored*/, false /*ignored*/, false /*ignored*/, std::move(input_peer),
        reply_to_message_id.get_server_message_id().get(), random_id, query_id, result_id, schedule_date));
    auto send_query_ref = query.get_weak();
    send_query(std::move(query));
    return send_query_ref;
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_sendInlineBotResult>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for SendInlineBotResultQuery for " << random_id_ << ": " << to_string(ptr);
    td->messages_manager_->check_send_message_result(random_id_, dialog_id_, ptr.get(), "SendInlineBotResult");
    td->updates_manager_->on_get_updates(std::move(ptr), Promise<Unit>());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for SendInlineBotResultQuery: " << status;
    if (G()->close_flag() && G()->parameters().use_message_db) {
      // do not send error, message will be re-sent
      return;
    }
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SendInlineBotResultQuery");
    td->messages_manager_->on_send_message_fail(random_id_, std::move(status));
  }
};

class SendMultiMediaActor : public NetActorOnce {
  vector<FileId> file_ids_;
  vector<string> file_references_;
  vector<int64> random_ids_;
  DialogId dialog_id_;

 public:
  void send(int32 flags, DialogId dialog_id, MessageId reply_to_message_id, int32 schedule_date,
            vector<FileId> &&file_ids, vector<tl_object_ptr<telegram_api::inputSingleMedia>> &&input_single_media,
            uint64 sequence_dispatcher_id) {
    for (auto &single_media : input_single_media) {
      random_ids_.push_back(single_media->random_id_);
      CHECK(FileManager::extract_was_uploaded(single_media->media_) == false);
      file_references_.push_back(FileManager::extract_file_reference(single_media->media_));
    }
    dialog_id_ = dialog_id;
    file_ids_ = std::move(file_ids);
    CHECK(file_ids_.size() == random_ids_.size());

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    if (input_peer == nullptr) {
      on_error(0, Status::Error(400, "Have no write access to the chat"));
      stop();
      return;
    }

    auto query = G()->net_query_creator().create(telegram_api::messages_sendMultiMedia(
        flags, false /*ignored*/, false /*ignored*/, false /*ignored*/, std::move(input_peer),
        reply_to_message_id.get_server_message_id().get(), std::move(input_single_media), schedule_date));
    // no quick ack, because file reference errors are very likely to happen
    query->debug("send to MessagesManager::MultiSequenceDispatcher");
    send_closure(td->messages_manager_->sequence_dispatcher_, &MultiSequenceDispatcher::send_with_callback,
                 std::move(query), actor_shared(this), sequence_dispatcher_id);
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_sendMultiMedia>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for SendMultiMedia for " << format::as_array(random_ids_) << ": " << to_string(ptr);

    auto sent_random_ids = UpdatesManager::get_sent_messages_random_ids(ptr.get());
    bool is_result_wrong = false;
    auto sent_random_ids_size = sent_random_ids.size();
    for (auto &random_id : random_ids_) {
      auto it = sent_random_ids.find(random_id);
      if (it == sent_random_ids.end()) {
        if (random_ids_.size() == 1) {
          is_result_wrong = true;
        }
        td->messages_manager_->on_send_message_fail(random_id, Status::Error(400, "Message was not sent"));
      } else {
        sent_random_ids.erase(it);
      }
    }
    if (!sent_random_ids.empty()) {
      is_result_wrong = true;
    }
    if (!is_result_wrong) {
      auto sent_messages = UpdatesManager::get_new_messages(ptr.get());
      if (sent_random_ids_size != sent_messages.size()) {
        is_result_wrong = true;
      }
      for (auto &sent_message : sent_messages) {
        if (MessagesManager::get_message_dialog_id(*sent_message) != dialog_id_) {
          is_result_wrong = true;
        }
      }
    }
    if (is_result_wrong) {
      LOG(ERROR) << "Receive wrong result for SendMultiMedia with random_ids " << format::as_array(random_ids_)
                 << " to " << dialog_id_ << ": " << oneline(to_string(ptr));
      td->updates_manager_->schedule_get_difference("Wrong sendMultiMedia result");
    }

    td->updates_manager_->on_get_updates(std::move(ptr), Promise<Unit>());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for SendMultiMedia: " << status;
    if (G()->close_flag() && G()->parameters().use_message_db) {
      // do not send error, message will be re-sent
      return;
    }
    if (!td->auth_manager_->is_bot() && FileReferenceManager::is_file_reference_error(status)) {
      auto pos = FileReferenceManager::get_file_reference_error_pos(status);
      if (1 <= pos && pos <= file_ids_.size() && file_ids_[pos - 1].is_valid()) {
        VLOG(file_references) << "Receive " << status << " for " << file_ids_[pos - 1];
        td->file_manager_->delete_file_reference(file_ids_[pos - 1], file_references_[pos - 1]);
        td->messages_manager_->on_send_media_group_file_reference_error(dialog_id_, std::move(random_ids_));
        return;
      } else {
        LOG(ERROR) << "Receive file reference error " << status << ", but file_ids = " << file_ids_
                   << ", message_count = " << file_ids_.size();
      }
    }
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SendMultiMediaActor");
    for (auto &random_id : random_ids_) {
      td->messages_manager_->on_send_message_fail(random_id, status.clone());
    }
  }
};

class SendMediaActor : public NetActorOnce {
  int64 random_id_ = 0;
  FileId file_id_;
  FileId thumbnail_file_id_;
  DialogId dialog_id_;
  string file_reference_;
  bool was_uploaded_ = false;
  bool was_thumbnail_uploaded_ = false;

 public:
  void send(FileId file_id, FileId thumbnail_file_id, int32 flags, DialogId dialog_id, MessageId reply_to_message_id,
            int32 schedule_date, tl_object_ptr<telegram_api::ReplyMarkup> &&reply_markup,
            vector<tl_object_ptr<telegram_api::MessageEntity>> &&entities, const string &text,
            tl_object_ptr<telegram_api::InputMedia> &&input_media, int64 random_id, NetQueryRef *send_query_ref,
            uint64 sequence_dispatcher_id) {
    random_id_ = random_id;
    file_id_ = file_id;
    thumbnail_file_id_ = thumbnail_file_id;
    dialog_id_ = dialog_id;
    file_reference_ = FileManager::extract_file_reference(input_media);
    was_uploaded_ = FileManager::extract_was_uploaded(input_media);
    was_thumbnail_uploaded_ = FileManager::extract_was_thumbnail_uploaded(input_media);

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    if (input_peer == nullptr) {
      on_error(0, Status::Error(400, "Have no write access to the chat"));
      stop();
      return;
    }
    if (!entities.empty()) {
      flags |= telegram_api::messages_sendMedia::ENTITIES_MASK;
    }

    auto query = G()->net_query_creator().create(telegram_api::messages_sendMedia(
        flags, false /*ignored*/, false /*ignored*/, false /*ignored*/, std::move(input_peer),
        reply_to_message_id.get_server_message_id().get(), std::move(input_media), text, random_id,
        std::move(reply_markup), std::move(entities), schedule_date));
    if (G()->shared_config().get_option_boolean("use_quick_ack") && was_uploaded_) {
      query->quick_ack_promise_ = PromiseCreator::lambda(
          [random_id](Unit) {
            send_closure(G()->messages_manager(), &MessagesManager::on_send_message_get_quick_ack, random_id);
          },
          PromiseCreator::Ignore());
    }
    *send_query_ref = query.get_weak();
    query->debug("send to MessagesManager::MultiSequenceDispatcher");
    send_closure(td->messages_manager_->sequence_dispatcher_, &MultiSequenceDispatcher::send_with_callback,
                 std::move(query), actor_shared(this), sequence_dispatcher_id);
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_sendMedia>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    if (was_thumbnail_uploaded_) {
      CHECK(thumbnail_file_id_.is_valid());
      // always delete partial remote location for the thumbnail, because it can't be reused anyway
      // TODO delete it only in the case it can't be merged with file thumbnail
      td->file_manager_->delete_partial_remote_location(thumbnail_file_id_);
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for SendMedia for " << random_id_ << ": " << to_string(ptr);
    td->messages_manager_->check_send_message_result(random_id_, dialog_id_, ptr.get(), "SendMedia");
    td->updates_manager_->on_get_updates(std::move(ptr), Promise<Unit>());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for SendMedia: " << status;
    if (G()->close_flag() && G()->parameters().use_message_db) {
      // do not send error, message will be re-sent
      return;
    }
    if (was_uploaded_) {
      if (was_thumbnail_uploaded_) {
        CHECK(thumbnail_file_id_.is_valid());
        // always delete partial remote location for the thumbnail, because it can't be reused anyway
        td->file_manager_->delete_partial_remote_location(thumbnail_file_id_);
      }

      CHECK(file_id_.is_valid());
      if (begins_with(status.message(), "FILE_PART_") && ends_with(status.message(), "_MISSING")) {
        td->messages_manager_->on_send_message_file_part_missing(random_id_,
                                                                 to_integer<int32>(status.message().substr(10)));
        return;
      } else {
        if (status.code() != 429 && status.code() < 500 && !G()->close_flag()) {
          td->file_manager_->delete_partial_remote_location(file_id_);
        }
      }
    } else if (!td->auth_manager_->is_bot() && FileReferenceManager::is_file_reference_error(status)) {
      if (file_id_.is_valid() && !was_uploaded_) {
        VLOG(file_references) << "Receive " << status << " for " << file_id_;
        td->file_manager_->delete_file_reference(file_id_, file_reference_);
        td->messages_manager_->on_send_message_file_reference_error(random_id_);
        return;
      } else {
        LOG(ERROR) << "Receive file reference error, but file_id = " << file_id_
                   << ", was_uploaded = " << was_uploaded_;
      }
    }

    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SendMediaActor");
    td->messages_manager_->on_send_message_fail(random_id_, std::move(status));
  }
};

class UploadMediaQuery : public Td::ResultHandler {
  DialogId dialog_id_;
  MessageId message_id_;
  FileId file_id_;
  FileId thumbnail_file_id_;
  string file_reference_;
  bool was_uploaded_ = false;
  bool was_thumbnail_uploaded_ = false;

 public:
  void send(DialogId dialog_id, MessageId message_id, FileId file_id, FileId thumbnail_file_id,
            tl_object_ptr<telegram_api::InputMedia> &&input_media) {
    CHECK(input_media != nullptr);
    dialog_id_ = dialog_id;
    message_id_ = message_id;
    file_id_ = file_id;
    thumbnail_file_id_ = thumbnail_file_id;
    file_reference_ = FileManager::extract_file_reference(input_media);
    was_uploaded_ = FileManager::extract_was_uploaded(input_media);
    was_thumbnail_uploaded_ = FileManager::extract_was_thumbnail_uploaded(input_media);

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    if (input_peer == nullptr) {
      return on_error(0, Status::Error(400, "Have no write access to the chat"));
    }

    send_query(G()->net_query_creator().create(
        telegram_api::messages_uploadMedia(std::move(input_peer), std::move(input_media))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_uploadMedia>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    if (was_thumbnail_uploaded_) {
      CHECK(thumbnail_file_id_.is_valid());
      // always delete partial remote location for the thumbnail, because it can't be reused anyway
      td->file_manager_->delete_partial_remote_location(thumbnail_file_id_);
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for UploadMediaQuery for " << message_id_ << " in " << dialog_id_ << ": "
              << to_string(ptr);
    td->messages_manager_->on_upload_message_media_success(dialog_id_, message_id_, std::move(ptr));
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for UploadMediaQuery for " << message_id_ << " in " << dialog_id_ << ": " << status;
    if (G()->close_flag() && G()->parameters().use_message_db) {
      // do not send error, message will be re-sent
      return;
    }
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "UploadMediaQuery");
    if (was_uploaded_) {
      if (was_thumbnail_uploaded_) {
        CHECK(thumbnail_file_id_.is_valid());
        // always delete partial remote location for the thumbnail, because it can't be reused anyway
        td->file_manager_->delete_partial_remote_location(thumbnail_file_id_);
      }

      CHECK(file_id_.is_valid());
      if (begins_with(status.message(), "FILE_PART_") && ends_with(status.message(), "_MISSING")) {
        td->messages_manager_->on_upload_message_media_file_part_missing(
            dialog_id_, message_id_, to_integer<int32>(status.message().substr(10)));
        return;
      } else {
        if (status.code() != 429 && status.code() < 500 && !G()->close_flag()) {
          td->file_manager_->delete_partial_remote_location(file_id_);
        }
      }
    } else if (FileReferenceManager::is_file_reference_error(status)) {
      LOG(ERROR) << "Receive file reference error for UploadMediaQuery";
    }
    td->messages_manager_->on_upload_message_media_fail(dialog_id_, message_id_, std::move(status));
  }
};

class SendScheduledMessageActor : public NetActorOnce {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit SendScheduledMessageActor(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, MessageId message_id, uint64 sequence_dispatcher_id) {
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Edit);
    if (input_peer == nullptr) {
      on_error(0, Status::Error(400, "Can't access the chat"));
      stop();
      return;
    }

    LOG(DEBUG) << "Send " << FullMessageId{dialog_id, message_id};

    int32 server_message_id = message_id.get_scheduled_server_message_id().get();
    auto query = G()->net_query_creator().create(
        telegram_api::messages_sendScheduledMessages(std::move(input_peer), {server_message_id}));

    query->debug("send to MessagesManager::MultiSequenceDispatcher");
    send_closure(td->messages_manager_->sequence_dispatcher_, &MultiSequenceDispatcher::send_with_callback,
                 std::move(query), actor_shared(this), sequence_dispatcher_id);
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_sendScheduledMessages>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for SendScheduledMessageActor: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for SendScheduledMessageActor: " << status;
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SendScheduledMessageActor");
    promise_.set_error(std::move(status));
  }
};

class EditMessageActor : public NetActorOnce {
  Promise<int32> promise_;
  DialogId dialog_id_;

 public:
  explicit EditMessageActor(Promise<Unit> &&promise) {
    promise_ = PromiseCreator::lambda([promise = std::move(promise)](Result<int32> result) mutable {
      if (result.is_error()) {
        promise.set_error(result.move_as_error());
      } else {
        promise.set_value(Unit());
      }
    });
  }
  explicit EditMessageActor(Promise<int32> &&promise) : promise_(std::move(promise)) {
  }

  void send(int32 flags, DialogId dialog_id, MessageId message_id, const string &text,
            vector<tl_object_ptr<telegram_api::MessageEntity>> &&entities,
            tl_object_ptr<telegram_api::InputMedia> &&input_media,
            tl_object_ptr<telegram_api::ReplyMarkup> &&reply_markup, int32 schedule_date,
            uint64 sequence_dispatcher_id) {
    dialog_id_ = dialog_id;

    if (false && input_media != nullptr) {
      on_error(0, Status::Error(400, "FILE_PART_1_MISSING"));
      stop();
      return;
    }

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Edit);
    if (input_peer == nullptr) {
      on_error(0, Status::Error(400, "Can't access the chat"));
      stop();
      return;
    }

    if (reply_markup != nullptr) {
      flags |= MessagesManager::SEND_MESSAGE_FLAG_HAS_REPLY_MARKUP;
    }
    if (!entities.empty()) {
      flags |= MessagesManager::SEND_MESSAGE_FLAG_HAS_ENTITIES;
    }
    if (!text.empty()) {
      flags |= MessagesManager::SEND_MESSAGE_FLAG_HAS_MESSAGE;
    }
    if (input_media != nullptr) {
      flags |= telegram_api::messages_editMessage::MEDIA_MASK;
    }
    if (schedule_date != 0) {
      flags |= telegram_api::messages_editMessage::SCHEDULE_DATE_MASK;
    }
    LOG(DEBUG) << "Edit message with flags " << flags;

    int32 server_message_id = schedule_date != 0 ? message_id.get_scheduled_server_message_id().get()
                                                 : message_id.get_server_message_id().get();
    auto query = G()->net_query_creator().create(telegram_api::messages_editMessage(
        flags, false /*ignored*/, std::move(input_peer), server_message_id, text, std::move(input_media),
        std::move(reply_markup), std::move(entities), schedule_date));

    query->debug("send to MessagesManager::MultiSequenceDispatcher");
    send_closure(td->messages_manager_->sequence_dispatcher_, &MultiSequenceDispatcher::send_with_callback,
                 std::move(query), actor_shared(this), sequence_dispatcher_id);
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_editMessage>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for EditMessageActor: " << to_string(ptr);
    auto pts = td->updates_manager_->get_update_edit_message_pts(ptr.get());
    auto promise = PromiseCreator::lambda(
        [promise = std::move(promise_), pts](Result<Unit> result) mutable { promise.set_value(std::move(pts)); });
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise));
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for EditMessage: " << status;
    if (!td->auth_manager_->is_bot() && status.message() == "MESSAGE_NOT_MODIFIED") {
      return promise_.set_value(0);
    }
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "EditMessageActor");
    promise_.set_error(std::move(status));
  }
};

class EditInlineMessageQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit EditInlineMessageQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(int32 flags, tl_object_ptr<telegram_api::inputBotInlineMessageID> input_bot_inline_message_id,
            const string &text, vector<tl_object_ptr<telegram_api::MessageEntity>> &&entities,
            tl_object_ptr<telegram_api::InputMedia> &&input_media,
            tl_object_ptr<telegram_api::ReplyMarkup> &&reply_markup) {
    CHECK(input_bot_inline_message_id != nullptr);

    // file in an inline message can't be uploaded to another datacenter,
    // so only previously uploaded files or URLs can be used in the InputMedia
    CHECK(!FileManager::extract_was_uploaded(input_media));

    if (reply_markup != nullptr) {
      flags |= MessagesManager::SEND_MESSAGE_FLAG_HAS_REPLY_MARKUP;
    }
    if (!entities.empty()) {
      flags |= MessagesManager::SEND_MESSAGE_FLAG_HAS_ENTITIES;
    }
    if (!text.empty()) {
      flags |= MessagesManager::SEND_MESSAGE_FLAG_HAS_MESSAGE;
    }
    if (input_media != nullptr) {
      flags |= telegram_api::messages_editInlineBotMessage::MEDIA_MASK;
    }
    LOG(DEBUG) << "Edit inline message with flags " << flags;

    auto dc_id = DcId::internal(input_bot_inline_message_id->dc_id_);
    send_query(G()->net_query_creator().create(
        telegram_api::messages_editInlineBotMessage(flags, false /*ignored*/, std::move(input_bot_inline_message_id),
                                                    text, std::move(input_media), std::move(reply_markup),
                                                    std::move(entities)),
        dc_id));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_editInlineBotMessage>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    LOG_IF(ERROR, !result_ptr.ok()) << "Receive false in result of editInlineMessage";

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for EditInlineMessageQuery: " << status;
    promise_.set_error(std::move(status));
  }
};

class SetGameScoreActor : public NetActorOnce {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit SetGameScoreActor(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, MessageId message_id, bool edit_message,
            tl_object_ptr<telegram_api::InputUser> input_user, int32 score, bool force, uint64 sequence_dispatcher_id) {
    int32 flags = 0;
    if (edit_message) {
      flags |= telegram_api::messages_setGameScore::EDIT_MESSAGE_MASK;
    }
    if (force) {
      flags |= telegram_api::messages_setGameScore::FORCE_MASK;
    }

    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Edit);
    if (input_peer == nullptr) {
      on_error(0, Status::Error(400, "Can't access the chat"));
      stop();
      return;
    }

    CHECK(input_user != nullptr);
    auto query = G()->net_query_creator().create(
        telegram_api::messages_setGameScore(flags, false /*ignored*/, false /*ignored*/, std::move(input_peer),
                                            message_id.get_server_message_id().get(), std::move(input_user), score));

    LOG(INFO) << "Set game score to " << score;

    query->debug("send to MessagesManager::MultiSequenceDispatcher");
    send_closure(td->messages_manager_->sequence_dispatcher_, &MultiSequenceDispatcher::send_with_callback,
                 std::move(query), actor_shared(this), sequence_dispatcher_id);
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_setGameScore>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for SetGameScore: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for SetGameScore: " << status;
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SetGameScoreActor");
    promise_.set_error(std::move(status));
  }
};

class SetInlineGameScoreQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit SetInlineGameScoreQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(tl_object_ptr<telegram_api::inputBotInlineMessageID> input_bot_inline_message_id, bool edit_message,
            tl_object_ptr<telegram_api::InputUser> input_user, int32 score, bool force) {
    CHECK(input_bot_inline_message_id != nullptr);
    CHECK(input_user != nullptr);

    int32 flags = 0;
    if (edit_message) {
      flags |= telegram_api::messages_setInlineGameScore::EDIT_MESSAGE_MASK;
    }
    if (force) {
      flags |= telegram_api::messages_setInlineGameScore::FORCE_MASK;
    }

    LOG(INFO) << "Set inline game score to " << score;
    auto dc_id = DcId::internal(input_bot_inline_message_id->dc_id_);
    send_query(G()->net_query_creator().create(
        telegram_api::messages_setInlineGameScore(flags, false /*ignored*/, false /*ignored*/,
                                                  std::move(input_bot_inline_message_id), std::move(input_user), score),
        dc_id));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_setInlineGameScore>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    LOG_IF(ERROR, !result_ptr.ok()) << "Receive false in result of setInlineGameScore";

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for SetInlineGameScoreQuery: " << status;
    promise_.set_error(std::move(status));
  }
};

class GetGameHighScoresQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  int64 random_id_;

 public:
  explicit GetGameHighScoresQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, MessageId message_id, tl_object_ptr<telegram_api::InputUser> input_user,
            int64 random_id) {
    dialog_id_ = dialog_id;
    random_id_ = random_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);

    CHECK(input_user != nullptr);
    send_query(G()->net_query_creator().create(telegram_api::messages_getGameHighScores(
        std::move(input_peer), message_id.get_server_message_id().get(), std::move(input_user))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getGameHighScores>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->messages_manager_->on_get_game_high_scores(random_id_, result_ptr.move_as_ok());
    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for GetGameHighScoresQuery: " << status;
    td->messages_manager_->on_get_game_high_scores(random_id_, nullptr);
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetGameHighScoresQuery");
    promise_.set_error(std::move(status));
  }
};

class GetInlineGameHighScoresQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  int64 random_id_;

 public:
  explicit GetInlineGameHighScoresQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(tl_object_ptr<telegram_api::inputBotInlineMessageID> input_bot_inline_message_id,
            tl_object_ptr<telegram_api::InputUser> input_user, int64 random_id) {
    CHECK(input_bot_inline_message_id != nullptr);
    CHECK(input_user != nullptr);

    random_id_ = random_id;

    auto dc_id = DcId::internal(input_bot_inline_message_id->dc_id_);
    send_query(G()->net_query_creator().create(
        telegram_api::messages_getInlineGameHighScores(std::move(input_bot_inline_message_id), std::move(input_user)),
        dc_id));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getInlineGameHighScores>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->messages_manager_->on_get_game_high_scores(random_id_, result_ptr.move_as_ok());
    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for GetInlineGameHighScoresQuery: " << status;
    td->messages_manager_->on_get_game_high_scores(random_id_, nullptr);
    promise_.set_error(std::move(status));
  }
};

class ForwardMessagesActor : public NetActorOnce {
  Promise<Unit> promise_;
  vector<int64> random_ids_;
  DialogId to_dialog_id_;

 public:
  explicit ForwardMessagesActor(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(int32 flags, DialogId to_dialog_id, DialogId from_dialog_id, const vector<MessageId> &message_ids,
            vector<int64> &&random_ids, int32 schedule_date, uint64 sequence_dispatcher_id) {
    LOG(INFO) << "Forward " << format::as_array(message_ids) << " from " << from_dialog_id << " to " << to_dialog_id;

    random_ids_ = random_ids;
    to_dialog_id_ = to_dialog_id;

    auto to_input_peer = td->messages_manager_->get_input_peer(to_dialog_id, AccessRights::Write);
    if (to_input_peer == nullptr) {
      on_error(0, Status::Error(400, "Have no write access to the chat"));
      stop();
      return;
    }

    auto from_input_peer = td->messages_manager_->get_input_peer(from_dialog_id, AccessRights::Read);
    if (from_input_peer == nullptr) {
      on_error(0, Status::Error(400, "Can't access the chat to forward messages from"));
      stop();
      return;
    }

    auto query = G()->net_query_creator().create(telegram_api::messages_forwardMessages(
        flags, false /*ignored*/, false /*ignored*/, false /*ignored*/, std::move(from_input_peer),
        MessagesManager::get_server_message_ids(message_ids), std::move(random_ids), std::move(to_input_peer),
        schedule_date));
    if (G()->shared_config().get_option_boolean("use_quick_ack")) {
      query->quick_ack_promise_ = PromiseCreator::lambda(
          [random_ids = random_ids_](Unit) {
            for (auto random_id : random_ids) {
              send_closure(G()->messages_manager(), &MessagesManager::on_send_message_get_quick_ack, random_id);
            }
          },
          PromiseCreator::Ignore());
    }
    send_closure(td->messages_manager_->sequence_dispatcher_, &MultiSequenceDispatcher::send_with_callback,
                 std::move(query), actor_shared(this), sequence_dispatcher_id);
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_forwardMessages>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for ForwardMessages for " << format::as_array(random_ids_) << ": " << to_string(ptr);
    auto sent_random_ids = UpdatesManager::get_sent_messages_random_ids(ptr.get());
    bool is_result_wrong = false;
    auto sent_random_ids_size = sent_random_ids.size();
    for (auto &random_id : random_ids_) {
      auto it = sent_random_ids.find(random_id);
      if (it == sent_random_ids.end()) {
        if (random_ids_.size() == 1) {
          is_result_wrong = true;
        }
        td->messages_manager_->on_send_message_fail(random_id, Status::Error(400, "Message was not forwarded"));
      } else {
        sent_random_ids.erase(it);
      }
    }
    if (!sent_random_ids.empty()) {
      is_result_wrong = true;
    }
    if (!is_result_wrong) {
      auto sent_messages = UpdatesManager::get_new_messages(ptr.get());
      if (sent_random_ids_size != sent_messages.size()) {
        is_result_wrong = true;
      }
      for (auto &sent_message : sent_messages) {
        if (MessagesManager::get_message_dialog_id(*sent_message) != to_dialog_id_) {
          is_result_wrong = true;
        }
      }
    }
    if (is_result_wrong) {
      LOG(ERROR) << "Receive wrong result for forwarding messages with random_ids " << format::as_array(random_ids_)
                 << " to " << to_dialog_id_ << ": " << oneline(to_string(ptr));
      td->updates_manager_->schedule_get_difference("Wrong forwardMessages result");
    }

    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for forward messages: " << status;
    if (G()->close_flag() && G()->parameters().use_message_db) {
      // do not send error, messages should be re-sent
      return;
    }
    // no on_get_dialog_error call, because two dialogs are involved
    for (auto &random_id : random_ids_) {
      td->messages_manager_->on_send_message_fail(random_id, status.clone());
    }
    promise_.set_error(std::move(status));
  }
};

class SendScreenshotNotificationQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  int64 random_id_;
  DialogId dialog_id_;

 public:
  explicit SendScreenshotNotificationQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, int64 random_id) {
    random_id_ = random_id;
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    CHECK(input_peer != nullptr);

    auto query = G()->net_query_creator().create(
        telegram_api::messages_sendScreenshotNotification(std::move(input_peer), 0, random_id));
    send_query(std::move(query));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_sendScreenshotNotification>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for SendScreenshotNotificationQuery for " << random_id_ << ": " << to_string(ptr);
    td->messages_manager_->check_send_message_result(random_id_, dialog_id_, ptr.get(),
                                                     "SendScreenshotNotificationQuery");
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for SendScreenshotNotificationQuery: " << status;
    if (G()->close_flag() && G()->parameters().use_message_db) {
      // do not send error, messages should be re-sent
      return;
    }
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SendScreenshotNotificationQuery");
    td->messages_manager_->on_send_message_fail(random_id_, status.clone());
    promise_.set_error(std::move(status));
  }
};

class SetTypingQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit SetTypingQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  NetQueryRef send(DialogId dialog_id, MessageId message_id, tl_object_ptr<telegram_api::SendMessageAction> &&action) {
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Write);
    CHECK(input_peer != nullptr);

    int32 flags = 0;
    if (message_id.is_valid()) {
      flags |= telegram_api::messages_setTyping::TOP_MSG_ID_MASK;
    }
    auto net_query = G()->net_query_creator().create(telegram_api::messages_setTyping(
        flags, std::move(input_peer), message_id.get_server_message_id().get(), std::move(action)));
    auto result = net_query.get_weak();
    send_query(std::move(net_query));
    return result;
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_setTyping>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    // ignore result

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (status.code() == NetQuery::Cancelled) {
      return promise_.set_value(Unit());
    }

    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "SetTypingQuery")) {
      LOG(INFO) << "Receive error for set typing: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class DeleteMessagesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  int32 query_count_;

 public:
  explicit DeleteMessagesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, vector<MessageId> &&message_ids, bool revoke) {
    LOG(INFO) << "Send deleteMessagesQuery to delete " << format::as_array(message_ids) << " in " << dialog_id;
    dialog_id_ = dialog_id;
    int32 flags = 0;
    if (revoke) {
      flags |= telegram_api::messages_deleteMessages::REVOKE_MASK;
    }

    query_count_ = 0;
    auto server_message_ids = MessagesManager::get_server_message_ids(message_ids);
    const size_t MAX_SLICE_SIZE = 100;
    for (size_t i = 0; i < server_message_ids.size(); i += MAX_SLICE_SIZE) {
      auto end_i = i + MAX_SLICE_SIZE;
      auto end = end_i < server_message_ids.size() ? server_message_ids.begin() + end_i : server_message_ids.end();
      vector<int32> slice(server_message_ids.begin() + i, end);

      query_count_++;
      send_query(G()->net_query_creator().create(
          telegram_api::messages_deleteMessages(flags, false /*ignored*/, std::move(slice))));
    }
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_deleteMessages>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto affected_messages = result_ptr.move_as_ok();
    CHECK(affected_messages->get_id() == telegram_api::messages_affectedMessages::ID);

    if (affected_messages->pts_count_ > 0) {
      td->updates_manager_->add_pending_pts_update(make_tl_object<dummyUpdate>(), affected_messages->pts_,
                                                   affected_messages->pts_count_, Promise<Unit>(),
                                                   "delete messages query");
    }
    if (--query_count_ == 0) {
      promise_.set_value(Unit());
    }
  }

  void on_error(uint64 id, Status status) override {
    if (!G()->is_expected_error(status)) {
      // MESSAGE_DELETE_FORBIDDEN can be returned in group chats when administrator rights was removed
      // MESSAGE_DELETE_FORBIDDEN can be returned in private chats for bots when revoke time limit exceeded
      if (status.message() != "MESSAGE_DELETE_FORBIDDEN" ||
          (dialog_id_.get_type() == DialogType::User && !td->auth_manager_->is_bot())) {
        LOG(ERROR) << "Receive error for delete messages: " << status;
      }
    }
    promise_.set_error(std::move(status));
  }
};

class DeleteChannelMessagesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  int32 query_count_;
  ChannelId channel_id_;

 public:
  explicit DeleteChannelMessagesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(ChannelId channel_id, vector<MessageId> &&message_ids) {
    channel_id_ = channel_id;
    LOG(INFO) << "Send deleteChannelMessagesQuery to delete " << format::as_array(message_ids) << " in the "
              << channel_id;

    query_count_ = 0;
    auto server_message_ids = MessagesManager::get_server_message_ids(message_ids);
    const size_t MAX_SLICE_SIZE = 100;
    for (size_t i = 0; i < server_message_ids.size(); i += MAX_SLICE_SIZE) {
      auto end_i = i + MAX_SLICE_SIZE;
      auto end = end_i < server_message_ids.size() ? server_message_ids.begin() + end_i : server_message_ids.end();
      vector<int32> slice(server_message_ids.begin() + i, end);

      query_count_++;
      auto input_channel = td->contacts_manager_->get_input_channel(channel_id);
      CHECK(input_channel != nullptr);
      send_query(G()->net_query_creator().create(
          telegram_api::channels_deleteMessages(std::move(input_channel), std::move(slice))));
    }
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::channels_deleteMessages>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto affected_messages = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for DeleteChannelMessagesQuery: " << to_string(affected_messages);
    CHECK(affected_messages->get_id() == telegram_api::messages_affectedMessages::ID);

    if (affected_messages->pts_count_ > 0) {
      td->messages_manager_->add_pending_channel_update(DialogId(channel_id_), make_tl_object<dummyUpdate>(),
                                                        affected_messages->pts_, affected_messages->pts_count_,
                                                        Promise<Unit>(), "DeleteChannelMessagesQuery");
    }
    if (--query_count_ == 0) {
      promise_.set_value(Unit());
    }
  }

  void on_error(uint64 id, Status status) override {
    if (!td->contacts_manager_->on_get_channel_error(channel_id_, status, "DeleteChannelMessagesQuery") &&
        status.message() != "MESSAGE_DELETE_FORBIDDEN") {
      LOG(ERROR) << "Receive error for delete channel messages: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class DeleteScheduledMessagesQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit DeleteScheduledMessagesQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, vector<MessageId> &&message_ids) {
    dialog_id_ = dialog_id;
    LOG(INFO) << "Send deleteScheduledMessagesQuery to delete " << format::as_array(message_ids);

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      return on_error(0, Status::Error(400, "Can't access the chat"));
    }
    send_query(G()->net_query_creator().create(telegram_api::messages_deleteScheduledMessages(
        std::move(input_peer), MessagesManager::get_scheduled_server_message_ids(message_ids))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_deleteScheduledMessages>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for DeleteScheduledMessagesQuery: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "DeleteScheduledMessagesQuery")) {
      LOG(ERROR) << "Receive error for delete scheduled messages: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class GetDialogNotifySettingsQuery : public Td::ResultHandler {
  DialogId dialog_id_;

 public:
  void send(DialogId dialog_id) {
    dialog_id_ = dialog_id;
    auto input_notify_peer = td->messages_manager_->get_input_notify_peer(dialog_id);
    CHECK(input_notify_peer != nullptr);
    send_query(G()->net_query_creator().create(telegram_api::account_getNotifySettings(std::move(input_notify_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::account_getNotifySettings>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    td->messages_manager_->on_update_dialog_notify_settings(dialog_id_, std::move(ptr), "GetDialogNotifySettingsQuery");
    td->messages_manager_->on_get_dialog_notification_settings_query_finished(dialog_id_, Status::OK());
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetDialogNotifySettingsQuery");
    td->messages_manager_->on_get_dialog_notification_settings_query_finished(dialog_id_, std::move(status));
  }
};

class GetNotifySettingsExceptionsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit GetNotifySettingsExceptionsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(NotificationSettingsScope scope, bool filter_scope, bool compare_sound) {
    int32 flags = 0;
    tl_object_ptr<telegram_api::InputNotifyPeer> input_notify_peer;
    if (filter_scope) {
      flags |= telegram_api::account_getNotifyExceptions::PEER_MASK;
      input_notify_peer = get_input_notify_peer(scope);
    }
    if (compare_sound) {
      flags |= telegram_api::account_getNotifyExceptions::COMPARE_SOUND_MASK;
    }
    send_query(G()->net_query_creator().create(
        telegram_api::account_getNotifyExceptions(flags, false /* ignored */, std::move(input_notify_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::account_getNotifyExceptions>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto updates_ptr = result_ptr.move_as_ok();
    auto dialog_ids = UpdatesManager::get_update_notify_settings_dialog_ids(updates_ptr.get());
    vector<tl_object_ptr<telegram_api::User>> users;
    vector<tl_object_ptr<telegram_api::Chat>> chats;
    switch (updates_ptr->get_id()) {
      case telegram_api::updatesCombined::ID: {
        auto updates = static_cast<telegram_api::updatesCombined *>(updates_ptr.get());
        users = std::move(updates->users_);
        chats = std::move(updates->chats_);
        reset_to_empty(updates->users_);
        reset_to_empty(updates->chats_);
        break;
      }
      case telegram_api::updates::ID: {
        auto updates = static_cast<telegram_api::updates *>(updates_ptr.get());
        users = std::move(updates->users_);
        chats = std::move(updates->chats_);
        reset_to_empty(updates->users_);
        reset_to_empty(updates->chats_);
        break;
      }
    }
    td->contacts_manager_->on_get_users(std::move(users), "GetNotifySettingsExceptionsQuery");
    td->contacts_manager_->on_get_chats(std::move(chats), "GetNotifySettingsExceptionsQuery");
    for (auto &dialog_id : dialog_ids) {
      td->messages_manager_->force_create_dialog(dialog_id, "GetNotifySettingsExceptionsQuery");
    }
    td->updates_manager_->on_get_updates(std::move(updates_ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class GetScopeNotifySettingsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  NotificationSettingsScope scope_;

 public:
  explicit GetScopeNotifySettingsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(NotificationSettingsScope scope) {
    scope_ = scope;
    auto input_notify_peer = get_input_notify_peer(scope);
    CHECK(input_notify_peer != nullptr);
    send_query(G()->net_query_creator().create(telegram_api::account_getNotifySettings(std::move(input_notify_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::account_getNotifySettings>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    td->messages_manager_->on_update_scope_notify_settings(scope_, std::move(ptr));

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    promise_.set_error(std::move(status));
  }
};

class UpdateDialogNotifySettingsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit UpdateDialogNotifySettingsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, const DialogNotificationSettings &new_settings) {
    dialog_id_ = dialog_id;

    auto input_notify_peer = td->messages_manager_->get_input_notify_peer(dialog_id);
    if (input_notify_peer == nullptr) {
      return on_error(0, Status::Error(500, "Can't update chat notification settings"));
    }

    int32 flags = 0;
    if (!new_settings.use_default_mute_until) {
      flags |= telegram_api::inputPeerNotifySettings::MUTE_UNTIL_MASK;
    }
    if (!new_settings.use_default_sound) {
      flags |= telegram_api::inputPeerNotifySettings::SOUND_MASK;
    }
    if (!new_settings.use_default_show_preview) {
      flags |= telegram_api::inputPeerNotifySettings::SHOW_PREVIEWS_MASK;
    }
    if (new_settings.silent_send_message) {
      flags |= telegram_api::inputPeerNotifySettings::SILENT_MASK;
    }
    send_query(G()->net_query_creator().create(telegram_api::account_updateNotifySettings(
        std::move(input_notify_peer), make_tl_object<telegram_api::inputPeerNotifySettings>(
                                          flags, new_settings.show_preview, new_settings.silent_send_message,
                                          new_settings.mute_until, new_settings.sound))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::account_updateNotifySettings>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    if (!result) {
      return on_error(id, Status::Error(400, "Receive false as result"));
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "UpdateDialogNotifySettingsQuery")) {
      LOG(INFO) << "Receive error for set chat notification settings: " << status;
    }

    if (!td->auth_manager_->is_bot() && td->messages_manager_->get_input_notify_peer(dialog_id_) != nullptr) {
      // trying to repair notification settings for this dialog
      td->messages_manager_->send_get_dialog_notification_settings_query(dialog_id_, Promise<>());
    }

    promise_.set_error(std::move(status));
  }
};

class UpdateScopeNotifySettingsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  NotificationSettingsScope scope_;

 public:
  explicit UpdateScopeNotifySettingsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(NotificationSettingsScope scope, const ScopeNotificationSettings &new_settings) {
    auto input_notify_peer = get_input_notify_peer(scope);
    CHECK(input_notify_peer != nullptr);
    int32 flags = telegram_api::inputPeerNotifySettings::MUTE_UNTIL_MASK |
                  telegram_api::inputPeerNotifySettings::SOUND_MASK |
                  telegram_api::inputPeerNotifySettings::SHOW_PREVIEWS_MASK;
    send_query(G()->net_query_creator().create(telegram_api::account_updateNotifySettings(
        std::move(input_notify_peer),
        make_tl_object<telegram_api::inputPeerNotifySettings>(flags, new_settings.show_preview, false,
                                                              new_settings.mute_until, new_settings.sound))));
    scope_ = scope;
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::account_updateNotifySettings>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    if (!result) {
      return on_error(id, Status::Error(400, "Receive false as result"));
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for set notification settings: " << status;

    if (!td->auth_manager_->is_bot()) {
      // trying to repair notification settings for this scope
      td->messages_manager_->send_get_scope_notification_settings_query(scope_, Promise<>());
    }

    promise_.set_error(std::move(status));
  }
};

class ResetNotifySettingsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;

 public:
  explicit ResetNotifySettingsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send() {
    send_query(G()->net_query_creator().create(telegram_api::account_resetNotifySettings()));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::account_resetNotifySettings>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    if (!result) {
      return on_error(id, Status::Error(400, "Receive false as result"));
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (!G()->is_expected_error(status)) {
      LOG(ERROR) << "Receive error for reset notification settings: " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class GetPeerSettingsQuery : public Td::ResultHandler {
  DialogId dialog_id_;

 public:
  void send(DialogId dialog_id) {
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);

    send_query(G()->net_query_creator().create(telegram_api::messages_getPeerSettings(std::move(input_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getPeerSettings>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->messages_manager_->on_get_peer_settings(dialog_id_, result_ptr.move_as_ok());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for get peer settings: " << status;
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetPeerSettingsQuery");
  }
};

class UpdatePeerSettingsQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit UpdatePeerSettingsQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, bool is_spam_dialog) {
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      return promise_.set_value(Unit());
    }

    if (is_spam_dialog) {
      send_query(G()->net_query_creator().create(telegram_api::messages_reportSpam(std::move(input_peer))));
    } else {
      send_query(G()->net_query_creator().create(telegram_api::messages_hidePeerSettingsBar(std::move(input_peer))));
    }
  }

  void on_result(uint64 id, BufferSlice packet) override {
    static_assert(std::is_same<telegram_api::messages_reportSpam::ReturnType,
                               telegram_api::messages_hidePeerSettingsBar::ReturnType>::value,
                  "");
    auto result_ptr = fetch_result<telegram_api::messages_reportSpam>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->messages_manager_->on_get_peer_settings(
        dialog_id_,
        make_tl_object<telegram_api::peerSettings>(0, false /*ignored*/, false /*ignored*/, false /*ignored*/,
                                                   false /*ignored*/, false /*ignored*/, false /*ignored*/,
                                                   false /*ignored*/, false /*ignored*/, 0),
        true);

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for update peer settings: " << status;
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "UpdatePeerSettingsQuery");
    td->messages_manager_->reget_dialog_action_bar(dialog_id_, "UpdatePeerSettingsQuery");
    promise_.set_error(std::move(status));
  }
};

class ReportEncryptedSpamQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit ReportEncryptedSpamQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id) {
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_encrypted_chat(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);
    LOG(INFO) << "Report spam in " << to_string(input_peer);

    send_query(G()->net_query_creator().create(telegram_api::messages_reportEncryptedSpam(std::move(input_peer))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_reportEncryptedSpam>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->messages_manager_->on_get_peer_settings(
        dialog_id_,
        make_tl_object<telegram_api::peerSettings>(0, false /*ignored*/, false /*ignored*/, false /*ignored*/,
                                                   false /*ignored*/, false /*ignored*/, false /*ignored*/,
                                                   false /*ignored*/, false /*ignored*/, 0),
        true);

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for report encrypted spam: " << status;
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "ReportEncryptedSpamQuery");
    td->messages_manager_->reget_dialog_action_bar(
        DialogId(td->contacts_manager_->get_secret_chat_user_id(dialog_id_.get_secret_chat_id())),
        "ReportEncryptedSpamQuery");
    promise_.set_error(std::move(status));
  }
};

class ReportPeerQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit ReportPeerQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, const vector<MessageId> &message_ids, ReportReason &&report_reason) {
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);

    if (message_ids.empty()) {
      send_query(G()->net_query_creator().create(telegram_api::account_reportPeer(
          std::move(input_peer), report_reason.get_input_report_reason(), report_reason.get_message())));
    } else {
      send_query(G()->net_query_creator().create(
          telegram_api::messages_report(std::move(input_peer), MessagesManager::get_server_message_ids(message_ids),
                                        report_reason.get_input_report_reason(), report_reason.get_message())));
    }
  }

  void on_result(uint64 id, BufferSlice packet) override {
    static_assert(
        std::is_same<telegram_api::account_reportPeer::ReturnType, telegram_api::messages_report::ReturnType>::value,
        "");
    auto result_ptr = fetch_result<telegram_api::account_reportPeer>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    if (!result) {
      return on_error(id, Status::Error(400, "Receive false as result"));
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for report peer: " << status;
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "ReportPeerQuery");
    td->messages_manager_->reget_dialog_action_bar(dialog_id_, "ReportPeerQuery");
    promise_.set_error(std::move(status));
  }
};

class ReportProfilePhotoQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;
  FileId file_id_;
  string file_reference_;
  ReportReason report_reason_;

 public:
  explicit ReportProfilePhotoQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, FileId file_id, tl_object_ptr<telegram_api::InputPhoto> &&input_photo,
            ReportReason &&report_reason) {
    dialog_id_ = dialog_id;
    file_id_ = file_id;
    file_reference_ = FileManager::extract_file_reference(input_photo);
    report_reason_ = std::move(report_reason);

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);

    send_query(G()->net_query_creator().create(telegram_api::account_reportProfilePhoto(
        std::move(input_peer), std::move(input_photo), report_reason_.get_input_report_reason(),
        report_reason_.get_message())));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::account_reportProfilePhoto>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    bool result = result_ptr.ok();
    if (!result) {
      return on_error(id, Status::Error(400, "Receive false as result"));
    }

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    LOG(INFO) << "Receive error for report chat photo: " << status;
    if (!td->auth_manager_->is_bot() && FileReferenceManager::is_file_reference_error(status)) {
      VLOG(file_references) << "Receive " << status << " for " << file_id_;
      td->file_manager_->delete_file_reference(file_id_, file_reference_);
      td->file_reference_manager_->repair_file_reference(
          file_id_,
          PromiseCreator::lambda([dialog_id = dialog_id_, file_id = file_id_, report_reason = std::move(report_reason_),
                                  promise = std::move(promise_)](Result<Unit> result) mutable {
            if (result.is_error()) {
              LOG(INFO) << "Reported photo " << file_id << " is likely to be deleted";
              return promise.set_value(Unit());
            }
            send_closure(G()->messages_manager(), &MessagesManager::report_dialog_photo, dialog_id, file_id,
                         std::move(report_reason), std::move(promise));
          }));
      return;
    }

    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "ReportProfilePhotoQuery");
    promise_.set_error(std::move(status));
  }
};

class EditPeerFoldersQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  DialogId dialog_id_;

 public:
  explicit EditPeerFoldersQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, FolderId folder_id) {
    dialog_id_ = dialog_id;

    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);

    vector<telegram_api::object_ptr<telegram_api::inputFolderPeer>> input_folder_peers;
    input_folder_peers.push_back(
        telegram_api::make_object<telegram_api::inputFolderPeer>(std::move(input_peer), folder_id.get()));
    send_query(G()->net_query_creator().create(telegram_api::folders_editPeerFolders(std::move(input_folder_peers))));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::folders_editPeerFolders>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(INFO) << "Receive result for EditPeerFoldersQuery: " << to_string(ptr);
    td->updates_manager_->on_get_updates(std::move(ptr), std::move(promise_));
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "EditPeerFoldersQuery")) {
      LOG(INFO) << "Receive error for EditPeerFoldersQuery: " << status;
    }

    // trying to repair folder ID for this dialog
    td->messages_manager_->get_dialog_info_full(dialog_id_, Auto());

    promise_.set_error(std::move(status));
  }
};

class GetStatsUrlQuery : public Td::ResultHandler {
  Promise<td_api::object_ptr<td_api::httpUrl>> promise_;
  DialogId dialog_id_;

 public:
  explicit GetStatsUrlQuery(Promise<td_api::object_ptr<td_api::httpUrl>> &&promise) : promise_(std::move(promise)) {
  }

  void send(DialogId dialog_id, const string &parameters, bool is_dark) {
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);
    int32 flags = 0;
    if (is_dark) {
      flags |= telegram_api::messages_getStatsURL::DARK_MASK;
    }
    send_query(G()->net_query_creator().create(
        telegram_api::messages_getStatsURL(flags, false /*ignored*/, std::move(input_peer), parameters)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_getStatsURL>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto result = result_ptr.move_as_ok();
    promise_.set_value(td_api::make_object<td_api::httpUrl>(result->url_));
  }

  void on_error(uint64 id, Status status) override {
    td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetStatsUrlQuery");
    promise_.set_error(std::move(status));
  }
};

class RequestUrlAuthQuery : public Td::ResultHandler {
  Promise<td_api::object_ptr<td_api::LoginUrlInfo>> promise_;
  string url_;
  DialogId dialog_id_;

 public:
  explicit RequestUrlAuthQuery(Promise<td_api::object_ptr<td_api::LoginUrlInfo>> &&promise)
      : promise_(std::move(promise)) {
  }

  void send(string url, DialogId dialog_id, MessageId message_id, int32 button_id) {
    url_ = std::move(url);
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);
    send_query(G()->net_query_creator().create(telegram_api::messages_requestUrlAuth(
        std::move(input_peer), message_id.get_server_message_id().get(), button_id)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_requestUrlAuth>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto result = result_ptr.move_as_ok();
    LOG(INFO) << "Receive " << to_string(result);
    switch (result->get_id()) {
      case telegram_api::urlAuthResultRequest::ID: {
        auto request = telegram_api::move_object_as<telegram_api::urlAuthResultRequest>(result);
        UserId bot_user_id = ContactsManager::get_user_id(request->bot_);
        if (!bot_user_id.is_valid()) {
          return on_error(id, Status::Error(500, "Receive invalid bot_user_id"));
        }
        td->contacts_manager_->on_get_user(std::move(request->bot_), "RequestUrlAuthQuery");
        bool request_write_access =
            (request->flags_ & telegram_api::urlAuthResultRequest::REQUEST_WRITE_ACCESS_MASK) != 0;
        promise_.set_value(td_api::make_object<td_api::loginUrlInfoRequestConfirmation>(
            url_, request->domain_, td->contacts_manager_->get_user_id_object(bot_user_id, "RequestUrlAuthQuery"),
            request_write_access));
        break;
      }
      case telegram_api::urlAuthResultAccepted::ID: {
        auto accepted = telegram_api::move_object_as<telegram_api::urlAuthResultAccepted>(result);
        promise_.set_value(td_api::make_object<td_api::loginUrlInfoOpen>(accepted->url_, true));
        break;
      }
      case telegram_api::urlAuthResultDefault::ID:
        promise_.set_value(td_api::make_object<td_api::loginUrlInfoOpen>(url_, false));
        break;
    }
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "RequestUrlAuthQuery")) {
      LOG(INFO) << "RequestUrlAuthQuery returned " << status;
    }
    promise_.set_value(td_api::make_object<td_api::loginUrlInfoOpen>(url_, false));
  }
};

class AcceptUrlAuthQuery : public Td::ResultHandler {
  Promise<td_api::object_ptr<td_api::httpUrl>> promise_;
  string url_;
  DialogId dialog_id_;

 public:
  explicit AcceptUrlAuthQuery(Promise<td_api::object_ptr<td_api::httpUrl>> &&promise) : promise_(std::move(promise)) {
  }

  void send(string url, DialogId dialog_id, MessageId message_id, int32 button_id, bool allow_write_access) {
    url_ = std::move(url);
    dialog_id_ = dialog_id;
    auto input_peer = td->messages_manager_->get_input_peer(dialog_id, AccessRights::Read);
    CHECK(input_peer != nullptr);
    int32 flags = 0;
    if (allow_write_access) {
      flags |= telegram_api::messages_acceptUrlAuth::WRITE_ALLOWED_MASK;
    }
    send_query(G()->net_query_creator().create(telegram_api::messages_acceptUrlAuth(
        flags, false /*ignored*/, std::move(input_peer), message_id.get_server_message_id().get(), button_id)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::messages_acceptUrlAuth>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto result = result_ptr.move_as_ok();
    LOG(INFO) << "Receive " << to_string(result);
    switch (result->get_id()) {
      case telegram_api::urlAuthResultRequest::ID:
        LOG(ERROR) << "Receive unexpected " << to_string(result);
        return on_error(id, Status::Error(500, "Receive unexpected urlAuthResultRequest"));
      case telegram_api::urlAuthResultAccepted::ID: {
        auto accepted = telegram_api::move_object_as<telegram_api::urlAuthResultAccepted>(result);
        promise_.set_value(td_api::make_object<td_api::httpUrl>(accepted->url_));
        break;
      }
      case telegram_api::urlAuthResultDefault::ID:
        promise_.set_value(td_api::make_object<td_api::httpUrl>(url_));
        break;
    }
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "AcceptUrlAuthQuery")) {
      LOG(INFO) << "AcceptUrlAuthQuery returned " << status;
    }
    promise_.set_error(std::move(status));
  }
};

class GetChannelDifferenceQuery : public Td::ResultHandler {
  DialogId dialog_id_;
  int32 pts_;
  int32 limit_;

 public:
  void send(DialogId dialog_id, tl_object_ptr<telegram_api::InputChannel> &&input_channel, int32 pts, int32 limit,
            bool force) {
    CHECK(pts >= 0);
    dialog_id_ = dialog_id;
    pts_ = pts;
    limit_ = limit;
    CHECK(input_channel != nullptr);

    int32 flags = 0;
    if (force) {
      flags |= telegram_api::updates_getChannelDifference::FORCE_MASK;
    }
    send_query(G()->net_query_creator().create(telegram_api::updates_getChannelDifference(
        flags, false /*ignored*/, std::move(input_channel), make_tl_object<telegram_api::channelMessagesFilterEmpty>(),
        pts, limit)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::updates_getChannelDifference>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->messages_manager_->on_get_channel_difference(dialog_id_, pts_, limit_, result_ptr.move_as_ok());
  }

  void on_error(uint64 id, Status status) override {
    if (!td->messages_manager_->on_get_dialog_error(dialog_id_, status, "GetChannelDifferenceQuery")) {
      LOG(ERROR) << "Receive updates.getChannelDifference error for " << dialog_id_ << " with pts " << pts_
                 << " and limit " << limit_ << ": " << status;
    }
    td->messages_manager_->on_get_channel_difference(dialog_id_, pts_, limit_, nullptr);
  }
};

class ResolveUsernameQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  string username_;

 public:
  explicit ResolveUsernameQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(const string &username) {
    username_ = username;

    LOG(INFO) << "Send ResolveUsernameQuery with username = " << username;
    send_query(G()->net_query_creator().create(telegram_api::contacts_resolveUsername(username)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::contacts_resolveUsername>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    auto ptr = result_ptr.move_as_ok();
    LOG(DEBUG) << "Receive result for ResolveUsernameQuery: " << to_string(ptr);
    td->contacts_manager_->on_get_users(std::move(ptr->users_), "ResolveUsernameQuery");
    td->contacts_manager_->on_get_chats(std::move(ptr->chats_), "ResolveUsernameQuery");

    td->messages_manager_->on_resolved_username(username_, DialogId(ptr->peer_));

    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    if (status.message() == Slice("USERNAME_NOT_OCCUPIED")) {
      td->messages_manager_->drop_username(username_);
    }
    promise_.set_error(std::move(status));
  }
};

class GetChannelAdminLogQuery : public Td::ResultHandler {
  Promise<Unit> promise_;
  ChannelId channel_id_;
  int64 random_id_;

 public:
  explicit GetChannelAdminLogQuery(Promise<Unit> &&promise) : promise_(std::move(promise)) {
  }

  void send(ChannelId channel_id, const string &query, int64 from_event_id, int32 limit,
            tl_object_ptr<telegram_api::channelAdminLogEventsFilter> filter,
            vector<tl_object_ptr<telegram_api::InputUser>> input_users, int64 random_id) {
    channel_id_ = channel_id;
    random_id_ = random_id;

    auto input_channel = td->contacts_manager_->get_input_channel(channel_id);
    CHECK(input_channel != nullptr);

    int32 flags = 0;
    if (filter != nullptr) {
      flags |= telegram_api::channels_getAdminLog::EVENTS_FILTER_MASK;
    }
    if (!input_users.empty()) {
      flags |= telegram_api::channels_getAdminLog::ADMINS_MASK;
    }

    send_query(G()->net_query_creator().create(telegram_api::channels_getAdminLog(
        flags, std::move(input_channel), query, std::move(filter), std::move(input_users), from_event_id, 0, limit)));
  }

  void on_result(uint64 id, BufferSlice packet) override {
    auto result_ptr = fetch_result<telegram_api::channels_getAdminLog>(packet);
    if (result_ptr.is_error()) {
      return on_error(id, result_ptr.move_as_error());
    }

    td->messages_manager_->on_get_event_log(channel_id_, random_id_, result_ptr.move_as_ok());
    promise_.set_value(Unit());
  }

  void on_error(uint64 id, Status status) override {
    td->contacts_manager_->on_get_channel_error(channel_id_, status, "GetChannelAdminLogQuery");
    td->messages_manager_->on_get_event_log(channel_id_, random_id_, nullptr);
    promise_.set_error(std::move(status));
  }
};

class MessagesManager::UploadMediaCallback : public FileManager::UploadCallback {
 public:
  void on_progress(FileId file_id) override {
  }
  void on_upload_ok(FileId file_id, tl_object_ptr<telegram_api::InputFile> input_file) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_media, file_id, std::move(input_file),
                       nullptr);
  }
  void on_upload_encrypted_ok(FileId file_id, tl_object_ptr<telegram_api::InputEncryptedFile> input_file) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_media, file_id, nullptr,
                       std::move(input_file));
  }
  void on_upload_secure_ok(FileId file_id, tl_object_ptr<telegram_api::InputSecureFile> input_file) override {
    UNREACHABLE();
  }
  void on_upload_error(FileId file_id, Status error) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_media_error, file_id, std::move(error));
  }
};

class MessagesManager::UploadThumbnailCallback : public FileManager::UploadCallback {
 public:
  void on_upload_ok(FileId file_id, tl_object_ptr<telegram_api::InputFile> input_file) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_thumbnail, file_id, std::move(input_file));
  }
  void on_upload_encrypted_ok(FileId file_id, tl_object_ptr<telegram_api::InputEncryptedFile> input_file) override {
    UNREACHABLE();
  }
  void on_upload_secure_ok(FileId file_id, tl_object_ptr<telegram_api::InputSecureFile> input_file) override {
    UNREACHABLE();
  }
  void on_upload_error(FileId file_id, Status error) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_thumbnail, file_id, nullptr);
  }
};

class MessagesManager::UploadDialogPhotoCallback : public FileManager::UploadCallback {
 public:
  void on_upload_ok(FileId file_id, tl_object_ptr<telegram_api::InputFile> input_file) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_dialog_photo, file_id,
                       std::move(input_file));
  }
  void on_upload_encrypted_ok(FileId file_id, tl_object_ptr<telegram_api::InputEncryptedFile> input_file) override {
    UNREACHABLE();
  }
  void on_upload_secure_ok(FileId file_id, tl_object_ptr<telegram_api::InputSecureFile> input_file) override {
    UNREACHABLE();
  }
  void on_upload_error(FileId file_id, Status error) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_dialog_photo_error, file_id,
                       std::move(error));
  }
};

class MessagesManager::UploadImportedMessagesCallback : public FileManager::UploadCallback {
 public:
  void on_upload_ok(FileId file_id, tl_object_ptr<telegram_api::InputFile> input_file) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_imported_messages, file_id,
                       std::move(input_file));
  }
  void on_upload_encrypted_ok(FileId file_id, tl_object_ptr<telegram_api::InputEncryptedFile> input_file) override {
    UNREACHABLE();
  }
  void on_upload_secure_ok(FileId file_id, tl_object_ptr<telegram_api::InputSecureFile> input_file) override {
    UNREACHABLE();
  }
  void on_upload_error(FileId file_id, Status error) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_imported_messages_error, file_id,
                       std::move(error));
  }
};

class MessagesManager::UploadImportedMessageAttachmentCallback : public FileManager::UploadCallback {
 public:
  void on_upload_ok(FileId file_id, tl_object_ptr<telegram_api::InputFile> input_file) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_imported_message_attachment, file_id,
                       std::move(input_file));
  }
  void on_upload_encrypted_ok(FileId file_id, tl_object_ptr<telegram_api::InputEncryptedFile> input_file) override {
    UNREACHABLE();
  }
  void on_upload_secure_ok(FileId file_id, tl_object_ptr<telegram_api::InputSecureFile> input_file) override {
    UNREACHABLE();
  }
  void on_upload_error(FileId file_id, Status error) override {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_upload_imported_message_attachment_error, file_id,
                       std::move(error));
  }
};

template <class StorerT>
void MessagesManager::Message::store(StorerT &storer) const {
  using td::store;
  bool has_sender = sender_user_id.is_valid();
  bool has_edit_date = edit_date > 0;
  bool has_random_id = random_id != 0;
  bool is_forwarded = forward_info != nullptr;
  bool is_reply = reply_to_message_id.is_valid();
  bool is_reply_to_random_id = reply_to_random_id != 0;
  bool is_via_bot = via_bot_user_id.is_valid();
  bool has_view_count = view_count > 0;
  bool has_reply_markup = reply_markup != nullptr;
  bool has_ttl = ttl != 0;
  bool has_author_signature = !author_signature.empty();
  bool has_forward_author_signature = is_forwarded && !forward_info->author_signature.empty();
  bool has_media_album_id = media_album_id != 0;
  bool has_forward_from =
      is_forwarded && (forward_info->from_dialog_id.is_valid() || forward_info->from_message_id.is_valid());
  bool has_send_date = message_id.is_yet_unsent() && send_date != 0;
  bool has_flags2 = true;
  bool has_notification_id = notification_id.is_valid();
  bool has_forward_sender_name = is_forwarded && !forward_info->sender_name.empty();
  bool has_send_error_code = send_error_code != 0;
  bool has_real_forward_from = real_forward_from_dialog_id.is_valid() && real_forward_from_message_id.is_valid();
  bool has_legacy_layer = legacy_layer != 0;
  bool has_restriction_reasons = !restriction_reasons.empty();
  bool has_forward_psa_type = is_forwarded && !forward_info->psa_type.empty();
  bool has_forward_count = forward_count > 0;
  bool has_reply_info = !reply_info.is_empty();
  bool has_sender_dialog_id = sender_dialog_id.is_valid();
  bool has_reply_in_dialog_id = is_reply && reply_in_dialog_id.is_valid();
  bool has_top_thread_message_id = top_thread_message_id.is_valid();
  bool has_thread_draft_message = thread_draft_message != nullptr;
  bool has_local_thread_message_ids = !local_thread_message_ids.empty();
  bool has_linked_top_thread_message_id = linked_top_thread_message_id.is_valid();
  bool has_interaction_info_update_date = interaction_info_update_date != 0;
  bool has_send_emoji = !send_emoji.empty();
  bool is_imported = is_forwarded && forward_info->is_imported;
  bool has_ttl_period = ttl_period != 0;
  BEGIN_STORE_FLAGS();
  STORE_FLAG(is_channel_post);
  STORE_FLAG(is_outgoing);
  STORE_FLAG(is_failed_to_send);
  STORE_FLAG(disable_notification);
  STORE_FLAG(contains_mention);
  STORE_FLAG(from_background);
  STORE_FLAG(disable_web_page_preview);
  STORE_FLAG(clear_draft);
  STORE_FLAG(have_previous);
  STORE_FLAG(have_next);
  STORE_FLAG(has_sender);
  STORE_FLAG(has_edit_date);
  STORE_FLAG(has_random_id);
  STORE_FLAG(is_forwarded);
  STORE_FLAG(is_reply);
  STORE_FLAG(is_reply_to_random_id);
  STORE_FLAG(is_via_bot);
  STORE_FLAG(has_view_count);
  STORE_FLAG(has_reply_markup);
  STORE_FLAG(has_ttl);
  STORE_FLAG(has_author_signature);
  STORE_FLAG(has_forward_author_signature);
  STORE_FLAG(had_reply_markup);
  STORE_FLAG(contains_unread_mention);
  STORE_FLAG(has_media_album_id);
  STORE_FLAG(has_forward_from);
  STORE_FLAG(in_game_share);
  STORE_FLAG(is_content_secret);
  STORE_FLAG(has_send_date);
  STORE_FLAG(has_flags2);
  END_STORE_FLAGS();
  if (has_flags2) {
    BEGIN_STORE_FLAGS();
    STORE_FLAG(has_notification_id);
    STORE_FLAG(is_mention_notification_disabled);
    STORE_FLAG(had_forward_info);
    STORE_FLAG(has_forward_sender_name);
    STORE_FLAG(has_send_error_code);
    STORE_FLAG(hide_via_bot);
    STORE_FLAG(is_bot_start_message);
    STORE_FLAG(has_real_forward_from);
    STORE_FLAG(has_legacy_layer);
    STORE_FLAG(hide_edit_date);
    STORE_FLAG(has_restriction_reasons);
    STORE_FLAG(is_from_scheduled);
    STORE_FLAG(is_copy);
    STORE_FLAG(has_forward_psa_type);
    STORE_FLAG(has_forward_count);
    STORE_FLAG(has_reply_info);
    STORE_FLAG(has_sender_dialog_id);
    STORE_FLAG(has_reply_in_dialog_id);
    STORE_FLAG(has_top_thread_message_id);
    STORE_FLAG(has_thread_draft_message);
    STORE_FLAG(has_local_thread_message_ids);
    STORE_FLAG(has_linked_top_thread_message_id);
    STORE_FLAG(is_pinned);
    STORE_FLAG(has_interaction_info_update_date);
    STORE_FLAG(has_send_emoji);
    STORE_FLAG(is_imported);
    STORE_FLAG(has_ttl_period);  // 25
    END_STORE_FLAGS();
  }

  store(message_id, storer);
  if (has_sender) {
    store(sender_user_id, storer);
  }
  store(date, storer);
  if (has_edit_date) {
    store(edit_date, storer);
  }
  if (has_send_date) {
    store(send_date, storer);
  }
  if (has_random_id) {
    store(random_id, storer);
  }
  if (is_forwarded) {
    store(forward_info->sender_user_id, storer);
    store(forward_info->date, storer);
    store(forward_info->sender_dialog_id, storer);
    store(forward_info->message_id, storer);
    if (has_forward_author_signature) {
      store(forward_info->author_signature, storer);
    }
    if (has_forward_sender_name) {
      store(forward_info->sender_name, storer);
    }
    if (has_forward_from) {
      store(forward_info->from_dialog_id, storer);
      store(forward_info->from_message_id, storer);
    }
    if (has_forward_psa_type) {
      store(forward_info->psa_type, storer);
    }
  }
  if (has_real_forward_from) {
    store(real_forward_from_dialog_id, storer);
    store(real_forward_from_message_id, storer);
  }
  if (is_reply) {
    store(reply_to_message_id, storer);
  }
  if (is_reply_to_random_id) {
    store(reply_to_random_id, storer);
  }
  if (is_via_bot) {
    store(via_bot_user_id, storer);
  }
  if (has_view_count) {
    store(view_count, storer);
  }
  if (has_forward_count) {
    store(forward_count, storer);
  }
  if (has_reply_info) {
    store(reply_info, storer);
  }
  if (has_ttl) {
    store(ttl, storer);
    store_time(ttl_expires_at, storer);
  }
  if (has_send_error_code) {
    store(send_error_code, storer);
    store(send_error_message, storer);
    if (send_error_code == 429) {
      store_time(try_resend_at, storer);
    }
  }
  if (has_author_signature) {
    store(author_signature, storer);
  }
  if (has_media_album_id) {
    store(media_album_id, storer);
  }
  if (has_notification_id) {
    store(notification_id, storer);
  }
  if (has_legacy_layer) {
    store(legacy_layer, storer);
  }
  if (has_restriction_reasons) {
    store(restriction_reasons, storer);
  }
  if (has_sender_dialog_id) {
    store(sender_dialog_id, storer);
  }
  if (has_reply_in_dialog_id) {
    store(reply_in_dialog_id, storer);
  }
  if (has_top_thread_message_id) {
    store(top_thread_message_id, storer);
  }
  if (has_thread_draft_message) {
    store(thread_draft_message, storer);
  }
  if (has_local_thread_message_ids) {
    store(local_thread_message_ids, storer);
  }
  if (has_linked_top_thread_message_id) {
    store(linked_top_thread_message_id, storer);
  }
  if (has_interaction_info_update_date) {
    store(interaction_info_update_date, storer);
  }
  if (has_send_emoji) {
    store(send_emoji, storer);
  }
  store_message_content(content.get(), storer);
  if (has_reply_markup) {
    store(reply_markup, storer);
  }
  if (has_ttl_period) {
    store(ttl_period, storer);
  }
}

// do not forget to resolve message dependencies
template <class ParserT>
void MessagesManager::Message::parse(ParserT &parser) {
  using td::parse;
  bool has_sender;
  bool has_edit_date;
  bool has_random_id;
  bool is_forwarded;
  bool is_reply;
  bool is_reply_to_random_id;
  bool is_via_bot;
  bool has_view_count;
  bool has_reply_markup;
  bool has_ttl;
  bool has_author_signature;
  bool has_forward_author_signature;
  bool has_media_album_id;
  bool has_forward_from;
  bool has_send_date;
  bool has_flags2;
  bool has_notification_id = false;
  bool has_forward_sender_name = false;
  bool has_send_error_code = false;
  bool has_real_forward_from = false;
  bool has_legacy_layer = false;
  bool has_restriction_reasons = false;
  bool has_forward_psa_type = false;
  bool has_forward_count = false;
  bool has_reply_info = false;
  bool has_sender_dialog_id = false;
  bool has_reply_in_dialog_id = false;
  bool has_top_thread_message_id = false;
  bool has_thread_draft_message = false;
  bool has_local_thread_message_ids = false;
  bool has_linked_top_thread_message_id = false;
  bool has_interaction_info_update_date = false;
  bool has_send_emoji = false;
  bool is_imported = false;
  bool has_ttl_period = false;
  BEGIN_PARSE_FLAGS();
  PARSE_FLAG(is_channel_post);
  PARSE_FLAG(is_outgoing);
  PARSE_FLAG(is_failed_to_send);
  PARSE_FLAG(disable_notification);
  PARSE_FLAG(contains_mention);
  PARSE_FLAG(from_background);
  PARSE_FLAG(disable_web_page_preview);
  PARSE_FLAG(clear_draft);
  PARSE_FLAG(have_previous);
  PARSE_FLAG(have_next);
  PARSE_FLAG(has_sender);
  PARSE_FLAG(has_edit_date);
  PARSE_FLAG(has_random_id);
  PARSE_FLAG(is_forwarded);
  PARSE_FLAG(is_reply);
  PARSE_FLAG(is_reply_to_random_id);
  PARSE_FLAG(is_via_bot);
  PARSE_FLAG(has_view_count);
  PARSE_FLAG(has_reply_markup);
  PARSE_FLAG(has_ttl);
  PARSE_FLAG(has_author_signature);
  PARSE_FLAG(has_forward_author_signature);
  PARSE_FLAG(had_reply_markup);
  PARSE_FLAG(contains_unread_mention);
  PARSE_FLAG(has_media_album_id);
  PARSE_FLAG(has_forward_from);
  PARSE_FLAG(in_game_share);
  PARSE_FLAG(is_content_secret);
  PARSE_FLAG(has_send_date);
  PARSE_FLAG(has_flags2);
  END_PARSE_FLAGS();
  if (has_flags2) {
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(has_notification_id);
    PARSE_FLAG(is_mention_notification_disabled);
    PARSE_FLAG(had_forward_info);
    PARSE_FLAG(has_forward_sender_name);
    PARSE_FLAG(has_send_error_code);
    PARSE_FLAG(hide_via_bot);
    PARSE_FLAG(is_bot_start_message);
    PARSE_FLAG(has_real_forward_from);
    PARSE_FLAG(has_legacy_layer);
    PARSE_FLAG(hide_edit_date);
    PARSE_FLAG(has_restriction_reasons);
    PARSE_FLAG(is_from_scheduled);
    PARSE_FLAG(is_copy);
    PARSE_FLAG(has_forward_psa_type);
    PARSE_FLAG(has_forward_count);
    PARSE_FLAG(has_reply_info);
    PARSE_FLAG(has_sender_dialog_id);
    PARSE_FLAG(has_reply_in_dialog_id);
    PARSE_FLAG(has_top_thread_message_id);
    PARSE_FLAG(has_thread_draft_message);
    PARSE_FLAG(has_local_thread_message_ids);
    PARSE_FLAG(has_linked_top_thread_message_id);
    PARSE_FLAG(is_pinned);
    PARSE_FLAG(has_interaction_info_update_date);
    PARSE_FLAG(has_send_emoji);
    PARSE_FLAG(is_imported);
    PARSE_FLAG(has_ttl_period);
    END_PARSE_FLAGS();
  }

  parse(message_id, parser);
  random_y = get_random_y(message_id);
  if (has_sender) {
    parse(sender_user_id, parser);
  }
  parse(date, parser);
  if (has_edit_date) {
    parse(edit_date, parser);
  }
  if (has_send_date) {
    CHECK(message_id.is_valid() || message_id.is_valid_scheduled());
    CHECK(message_id.is_yet_unsent());
    parse(send_date, parser);
  } else if (message_id.is_valid() && message_id.is_yet_unsent()) {
    send_date = date;  // for backward compatibility
  }
  if (has_random_id) {
    parse(random_id, parser);
  }
  if (is_forwarded) {
    forward_info = make_unique<MessageForwardInfo>();
    parse(forward_info->sender_user_id, parser);
    parse(forward_info->date, parser);
    parse(forward_info->sender_dialog_id, parser);
    parse(forward_info->message_id, parser);
    if (has_forward_author_signature) {
      parse(forward_info->author_signature, parser);
    }
    if (has_forward_sender_name) {
      parse(forward_info->sender_name, parser);
    }
    if (has_forward_from) {
      parse(forward_info->from_dialog_id, parser);
      parse(forward_info->from_message_id, parser);
    }
    if (has_forward_psa_type) {
      parse(forward_info->psa_type, parser);
    }
    forward_info->is_imported = is_imported;
  }
  if (has_real_forward_from) {
    parse(real_forward_from_dialog_id, parser);
    parse(real_forward_from_message_id, parser);
  }
  if (is_reply) {
    parse(reply_to_message_id, parser);
  }
  if (is_reply_to_random_id) {
    parse(reply_to_random_id, parser);
  }
  if (is_via_bot) {
    parse(via_bot_user_id, parser);
  }
  if (has_view_count) {
    parse(view_count, parser);
  }
  if (has_forward_count) {
    parse(forward_count, parser);
  }
  if (has_reply_info) {
    parse(reply_info, parser);
  }
  if (has_ttl) {
    parse(ttl, parser);
    parse_time(ttl_expires_at, parser);
  }
  if (has_send_error_code) {
    parse(send_error_code, parser);
    parse(send_error_message, parser);
    if (send_error_code == 429) {
      parse_time(try_resend_at, parser);
    }
  }
  if (has_author_signature) {
    parse(author_signature, parser);
  }
  if (has_media_album_id) {
    parse(media_album_id, parser);
  }
  if (has_notification_id) {
    parse(notification_id, parser);
  }
  if (has_legacy_layer) {
    parse(legacy_layer, parser);
  }
  if (has_restriction_reasons) {
    parse(restriction_reasons, parser);
  }
  if (has_sender_dialog_id) {
    parse(sender_dialog_id, parser);
  }
  if (has_reply_in_dialog_id) {
    parse(reply_in_dialog_id, parser);
  }
  if (has_top_thread_message_id) {
    parse(top_thread_message_id, parser);
  }
  if (has_thread_draft_message) {
    parse(thread_draft_message, parser);
  }
  if (has_local_thread_message_ids) {
    parse(local_thread_message_ids, parser);
  }
  if (has_linked_top_thread_message_id) {
    parse(linked_top_thread_message_id, parser);
  }
  if (has_interaction_info_update_date) {
    parse(interaction_info_update_date, parser);
  }
  if (has_send_emoji) {
    parse(send_emoji, parser);
  }
  parse_message_content(content, parser);
  if (has_reply_markup) {
    parse(reply_markup, parser);
  }
  if (has_ttl_period) {
    parse(ttl_period, parser);
  }

  is_content_secret |=
      is_secret_message_content(ttl, content->get_type());  // repair is_content_secret for old messages
  if (hide_edit_date && content->get_type() == MessageContentType::LiveLocation) {
    hide_edit_date = false;
  }
}

template <class StorerT>
void MessagesManager::NotificationGroupInfo::store(StorerT &storer) const {
  using td::store;
  store(group_id, storer);
  store(last_notification_date, storer);
  store(last_notification_id, storer);
  store(max_removed_notification_id, storer);
  store(max_removed_message_id, storer);
}

template <class ParserT>
void MessagesManager::NotificationGroupInfo::parse(ParserT &parser) {
  using td::parse;
  parse(group_id, parser);
  parse(last_notification_date, parser);
  parse(last_notification_id, parser);
  parse(max_removed_notification_id, parser);
  if (parser.version() >= static_cast<int32>(Version::AddNotificationGroupInfoMaxRemovedMessageId)) {
    parse(max_removed_message_id, parser);
  }
}

template <class StorerT>
void MessagesManager::Dialog::store(StorerT &storer) const {
  using td::store;
  const Message *last_database_message = nullptr;
  if (last_database_message_id.is_valid()) {
    last_database_message = get_message(this, last_database_message_id);
  }

  bool has_draft_message = draft_message != nullptr;
  bool has_last_database_message = last_database_message != nullptr;
  bool has_first_database_message_id = first_database_message_id.is_valid();
  bool has_first_database_message_id_by_index = true;
  bool has_message_count_by_index = true;
  bool has_client_data = !client_data.empty();
  bool has_last_read_all_mentions_message_id = last_read_all_mentions_message_id.is_valid();
  bool has_max_unavailable_message_id = max_unavailable_message_id.is_valid();
  bool has_local_unread_count = local_unread_count != 0;
  bool has_deleted_last_message = delete_last_message_date > 0;
  bool has_last_clear_history_message_id = last_clear_history_message_id.is_valid();
  bool has_last_database_message_id = !has_last_database_message && last_database_message_id.is_valid();
  bool has_message_notification_group =
      message_notification_group.group_id.is_valid() && !message_notification_group.try_reuse;
  bool has_mention_notification_group =
      mention_notification_group.group_id.is_valid() && !mention_notification_group.try_reuse;
  bool has_new_secret_chat_notification_id = new_secret_chat_notification_id.is_valid();
  bool has_pinned_message_notification = pinned_message_notification_message_id.is_valid();
  bool has_last_pinned_message_id = last_pinned_message_id.is_valid();
  bool has_flags2 = true;
  bool has_max_notification_message_id =
      max_notification_message_id.is_valid() && max_notification_message_id > last_new_message_id;
  bool has_folder_id = folder_id != FolderId();
  bool has_pending_read_channel_inbox = pending_read_channel_inbox_pts != 0;
  bool has_distance = distance >= 0;
  bool has_last_yet_unsent_message = last_message_id.is_valid() && last_message_id.is_yet_unsent();
  bool has_active_group_call_id = active_group_call_id.is_valid();
  bool has_message_ttl_setting = !message_ttl_setting.is_empty();
  BEGIN_STORE_FLAGS();
  STORE_FLAG(has_draft_message);
  STORE_FLAG(has_last_database_message);
  STORE_FLAG(know_can_report_spam);
  STORE_FLAG(can_report_spam);
  STORE_FLAG(has_first_database_message_id);
  STORE_FLAG(false);
  STORE_FLAG(has_first_database_message_id_by_index);
  STORE_FLAG(has_message_count_by_index);
  STORE_FLAG(has_client_data);
  STORE_FLAG(need_restore_reply_markup);
  STORE_FLAG(have_full_history);
  STORE_FLAG(has_last_read_all_mentions_message_id);
  STORE_FLAG(has_max_unavailable_message_id);
  STORE_FLAG(is_last_read_inbox_message_id_inited);
  STORE_FLAG(is_last_read_outbox_message_id_inited);
  STORE_FLAG(has_local_unread_count);
  STORE_FLAG(has_deleted_last_message);
  STORE_FLAG(has_last_clear_history_message_id);
  STORE_FLAG(is_last_message_deleted_locally);
  STORE_FLAG(has_contact_registered_message);
  STORE_FLAG(has_last_database_message_id);
  STORE_FLAG(need_repair_server_unread_count);
  STORE_FLAG(is_marked_as_unread);
  STORE_FLAG(has_message_notification_group);
  STORE_FLAG(has_mention_notification_group);
  STORE_FLAG(has_new_secret_chat_notification_id);
  STORE_FLAG(has_pinned_message_notification);
  STORE_FLAG(has_last_pinned_message_id);
  STORE_FLAG(is_last_pinned_message_id_inited);
  STORE_FLAG(has_flags2);
  END_STORE_FLAGS();

  store(dialog_id, storer);  // must be stored at offset 4

  if (has_flags2) {
    BEGIN_STORE_FLAGS();
    STORE_FLAG(has_max_notification_message_id);
    STORE_FLAG(has_folder_id);
    STORE_FLAG(is_folder_id_inited);
    STORE_FLAG(has_pending_read_channel_inbox);
    STORE_FLAG(know_action_bar);
    STORE_FLAG(can_add_contact);
    STORE_FLAG(can_block_user);
    STORE_FLAG(can_share_phone_number);
    STORE_FLAG(can_report_location);
    STORE_FLAG(has_scheduled_server_messages);
    STORE_FLAG(has_scheduled_database_messages);
    STORE_FLAG(need_repair_channel_server_unread_count);
    STORE_FLAG(can_unarchive);
    STORE_FLAG(has_distance);
    STORE_FLAG(hide_distance);
    STORE_FLAG(has_last_yet_unsent_message);
    STORE_FLAG(is_blocked);
    STORE_FLAG(is_is_blocked_inited);
    STORE_FLAG(has_active_group_call);
    STORE_FLAG(is_group_call_empty);
    STORE_FLAG(has_active_group_call_id);
    STORE_FLAG(can_invite_members);
    STORE_FLAG(has_message_ttl_setting);
    STORE_FLAG(is_message_ttl_setting_inited);
    END_STORE_FLAGS();
  }

  store(last_new_message_id, storer);
  store(server_unread_count, storer);
  if (has_local_unread_count) {
    store(local_unread_count, storer);
  }
  store(last_read_inbox_message_id, storer);
  store(last_read_outbox_message_id, storer);
  store(reply_markup_message_id, storer);
  store(notification_settings, storer);
  if (has_draft_message) {
    store(draft_message, storer);
  }
  store(last_clear_history_date, storer);
  store(order, storer);
  if (has_last_database_message) {
    store(*last_database_message, storer);
  }
  if (has_first_database_message_id) {
    store(first_database_message_id, storer);
  }
  if (has_deleted_last_message) {
    store(delete_last_message_date, storer);
    store(deleted_last_message_id, storer);
  }
  if (has_last_clear_history_message_id) {
    store(last_clear_history_message_id, storer);
  }

  if (has_first_database_message_id_by_index) {
    store(static_cast<int32>(first_database_message_id_by_index.size()), storer);
    for (auto first_message_id : first_database_message_id_by_index) {
      store(first_message_id, storer);
    }
  }
  if (has_message_count_by_index) {
    store(static_cast<int32>(message_count_by_index.size()), storer);
    for (auto message_count : message_count_by_index) {
      store(message_count, storer);
    }
  }
  if (has_client_data) {
    store(client_data, storer);
  }
  if (has_last_read_all_mentions_message_id) {
    store(last_read_all_mentions_message_id, storer);
  }
  if (has_max_unavailable_message_id) {
    store(max_unavailable_message_id, storer);
  }
  if (has_last_database_message_id) {
    store(last_database_message_id, storer);
  }
  if (has_message_notification_group) {
    store(message_notification_group, storer);
  }
  if (has_mention_notification_group) {
    store(mention_notification_group, storer);
  }
  if (has_new_secret_chat_notification_id) {
    store(new_secret_chat_notification_id, storer);
  }
  if (has_pinned_message_notification) {
    store(pinned_message_notification_message_id, storer);
  }
  if (has_last_pinned_message_id) {
    store(last_pinned_message_id, storer);
  }
  if (has_max_notification_message_id) {
    store(max_notification_message_id, storer);
  }
  if (has_folder_id) {
    store(folder_id, storer);
  }
  if (has_pending_read_channel_inbox) {
    store(pending_read_channel_inbox_pts, storer);
    store(pending_read_channel_inbox_max_message_id, storer);
    store(pending_read_channel_inbox_server_unread_count, storer);
  }
  if (has_distance) {
    store(distance, storer);
  }
  if (has_active_group_call_id) {
    store(active_group_call_id, storer);
  }
  if (has_message_ttl_setting) {
    store(message_ttl_setting, storer);
  }
}

// do not forget to resolve dialog dependencies including dependencies of last_message
template <class ParserT>
void MessagesManager::Dialog::parse(ParserT &parser) {
  using td::parse;
  bool has_draft_message;
  bool has_last_database_message;
  bool has_first_database_message_id;
  bool legacy_is_pinned;
  bool has_first_database_message_id_by_index;
  bool has_message_count_by_index;
  bool has_client_data;
  bool has_last_read_all_mentions_message_id;
  bool has_max_unavailable_message_id;
  bool has_local_unread_count;
  bool has_deleted_last_message;
  bool has_last_clear_history_message_id;
  bool has_last_database_message_id;
  bool has_message_notification_group;
  bool has_mention_notification_group;
  bool has_new_secret_chat_notification_id;
  bool has_pinned_message_notification;
  bool has_last_pinned_message_id;
  bool has_flags2;
  bool has_max_notification_message_id = false;
  bool has_folder_id = false;
  bool has_pending_read_channel_inbox = false;
  bool has_distance = false;
  bool has_active_group_call_id = false;
  bool has_message_ttl_setting = false;
  BEGIN_PARSE_FLAGS();
  PARSE_FLAG(has_draft_message);
  PARSE_FLAG(has_last_database_message);
  PARSE_FLAG(know_can_report_spam);
  PARSE_FLAG(can_report_spam);
  PARSE_FLAG(has_first_database_message_id);
  PARSE_FLAG(legacy_is_pinned);
  PARSE_FLAG(has_first_database_message_id_by_index);
  PARSE_FLAG(has_message_count_by_index);
  PARSE_FLAG(has_client_data);
  PARSE_FLAG(need_restore_reply_markup);
  PARSE_FLAG(have_full_history);
  PARSE_FLAG(has_last_read_all_mentions_message_id);
  PARSE_FLAG(has_max_unavailable_message_id);
  PARSE_FLAG(is_last_read_inbox_message_id_inited);
  PARSE_FLAG(is_last_read_outbox_message_id_inited);
  PARSE_FLAG(has_local_unread_count);
  PARSE_FLAG(has_deleted_last_message);
  PARSE_FLAG(has_last_clear_history_message_id);
  PARSE_FLAG(is_last_message_deleted_locally);
  PARSE_FLAG(has_contact_registered_message);
  PARSE_FLAG(has_last_database_message_id);
  PARSE_FLAG(need_repair_server_unread_count);
  PARSE_FLAG(is_marked_as_unread);
  PARSE_FLAG(has_message_notification_group);
  PARSE_FLAG(has_mention_notification_group);
  PARSE_FLAG(has_new_secret_chat_notification_id);
  PARSE_FLAG(has_pinned_message_notification);
  PARSE_FLAG(has_last_pinned_message_id);
  PARSE_FLAG(is_last_pinned_message_id_inited);
  PARSE_FLAG(has_flags2);
  END_PARSE_FLAGS();

  parse(dialog_id, parser);  // must be stored at offset 4

  if (has_flags2) {
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(has_max_notification_message_id);
    PARSE_FLAG(has_folder_id);
    PARSE_FLAG(is_folder_id_inited);
    PARSE_FLAG(has_pending_read_channel_inbox);
    PARSE_FLAG(know_action_bar);
    PARSE_FLAG(can_add_contact);
    PARSE_FLAG(can_block_user);
    PARSE_FLAG(can_share_phone_number);
    PARSE_FLAG(can_report_location);
    PARSE_FLAG(has_scheduled_server_messages);
    PARSE_FLAG(has_scheduled_database_messages);
    PARSE_FLAG(need_repair_channel_server_unread_count);
    PARSE_FLAG(can_unarchive);
    PARSE_FLAG(has_distance);
    PARSE_FLAG(hide_distance);
    PARSE_FLAG(had_last_yet_unsent_message);
    PARSE_FLAG(is_blocked);
    PARSE_FLAG(is_is_blocked_inited);
    PARSE_FLAG(has_active_group_call);
    PARSE_FLAG(is_group_call_empty);
    PARSE_FLAG(has_active_group_call_id);
    PARSE_FLAG(can_invite_members);
    PARSE_FLAG(has_message_ttl_setting);
    PARSE_FLAG(is_message_ttl_setting_inited);
    END_PARSE_FLAGS();
  } else {
    is_folder_id_inited = false;
    know_action_bar = false;
    can_add_contact = false;
    can_block_user = false;
    can_share_phone_number = false;
    can_report_location = false;
    has_scheduled_server_messages = false;
    has_scheduled_database_messages = false;
    need_repair_channel_server_unread_count = false;
    can_unarchive = false;
    hide_distance = false;
    had_last_yet_unsent_message = false;
    is_blocked = false;
    is_is_blocked_inited = false;
    has_active_group_call = false;
    is_group_call_empty = false;
    can_invite_members = false;
    is_message_ttl_setting_inited = false;
  }

  parse(last_new_message_id, parser);
  parse(server_unread_count, parser);
  if (has_local_unread_count) {
    parse(local_unread_count, parser);
  }
  parse(last_read_inbox_message_id, parser);
  if (last_read_inbox_message_id.is_valid()) {
    is_last_read_inbox_message_id_inited = true;
  }
  parse(last_read_outbox_message_id, parser);
  if (last_read_outbox_message_id.is_valid()) {
    is_last_read_outbox_message_id_inited = true;
  }
  parse(reply_markup_message_id, parser);
  parse(notification_settings, parser);
  if (has_draft_message) {
    parse(draft_message, parser);
  }
  parse(last_clear_history_date, parser);
  parse(order, parser);
  if (has_last_database_message) {
    parse(messages, parser);
  }
  if (has_first_database_message_id) {
    parse(first_database_message_id, parser);
  }
  if (legacy_is_pinned) {
    int64 legacy_pinned_order;
    parse(legacy_pinned_order, parser);
  }
  if (has_deleted_last_message) {
    parse(delete_last_message_date, parser);
    parse(deleted_last_message_id, parser);
  }
  if (has_last_clear_history_message_id) {
    parse(last_clear_history_message_id, parser);
  }

  if (has_first_database_message_id_by_index) {
    int32 size;
    parse(size, parser);
    if (size < 0) {
      // the log event is broken
      // it should be impossible, but has happenned at least once
      parser.set_error("Wrong first_database_message_id_by_index table size");
      return;
    }
    LOG_CHECK(static_cast<size_t>(size) <= first_database_message_id_by_index.size())
        << size << " " << first_database_message_id_by_index.size();
    for (int32 i = 0; i < size; i++) {
      parse(first_database_message_id_by_index[i], parser);
    }
  }
  if (has_message_count_by_index) {
    int32 size;
    parse(size, parser);
    if (size < 0) {
      // the log event is broken
      // it should be impossible, but has happenned at least once
      parser.set_error("Wrong message_count_by_index table size");
      return;
    }
    LOG_CHECK(static_cast<size_t>(size) <= message_count_by_index.size())
        << size << " " << message_count_by_index.size();
    for (int32 i = 0; i < size; i++) {
      parse(message_count_by_index[i], parser);
    }
  }
  unread_mention_count = message_count_by_index[message_search_filter_index(MessageSearchFilter::UnreadMention)];
  LOG(INFO) << "Set unread mention message count in " << dialog_id << " to " << unread_mention_count;
  if (unread_mention_count < 0) {
    unread_mention_count = 0;
  }
  if (has_client_data) {
    parse(client_data, parser);
  }
  if (has_last_read_all_mentions_message_id) {
    parse(last_read_all_mentions_message_id, parser);
  }
  if (has_max_unavailable_message_id) {
    parse(max_unavailable_message_id, parser);
  }
  if (has_last_database_message_id) {
    parse(last_database_message_id, parser);
  }
  if (has_message_notification_group) {
    parse(message_notification_group, parser);
  }
  if (has_mention_notification_group) {
    parse(mention_notification_group, parser);
  }
  if (has_new_secret_chat_notification_id) {
    parse(new_secret_chat_notification_id, parser);
  }
  if (has_pinned_message_notification) {
    parse(pinned_message_notification_message_id, parser);
  }
  if (has_last_pinned_message_id) {
    parse(last_pinned_message_id, parser);
  }
  if (has_max_notification_message_id) {
    parse(max_notification_message_id, parser);
  }
  if (has_folder_id) {
    parse(folder_id, parser);
  }
  if (has_pending_read_channel_inbox) {
    parse(pending_read_channel_inbox_pts, parser);
    parse(pending_read_channel_inbox_max_message_id, parser);
    parse(pending_read_channel_inbox_server_unread_count, parser);
  }
  if (has_distance) {
    parse(distance, parser);
  }
  if (has_active_group_call_id) {
    parse(active_group_call_id, parser);
  }
  if (has_message_ttl_setting) {
    parse(message_ttl_setting, parser);
  }
}

template <class StorerT>
void MessagesManager::CallsDbState::store(StorerT &storer) const {
  using td::store;
  store(static_cast<int32>(first_calls_database_message_id_by_index.size()), storer);
  for (auto first_message_id : first_calls_database_message_id_by_index) {
    store(first_message_id, storer);
  }
  store(static_cast<int32>(message_count_by_index.size()), storer);
  for (auto message_count : message_count_by_index) {
    store(message_count, storer);
  }
}

template <class ParserT>
void MessagesManager::CallsDbState::parse(ParserT &parser) {
  using td::parse;
  int32 size;
  parse(size, parser);
  LOG_CHECK(static_cast<size_t>(size) <= first_calls_database_message_id_by_index.size())
      << size << " " << first_calls_database_message_id_by_index.size();
  for (int32 i = 0; i < size; i++) {
    parse(first_calls_database_message_id_by_index[i], parser);
  }
  parse(size, parser);
  LOG_CHECK(static_cast<size_t>(size) <= message_count_by_index.size()) << size << " " << message_count_by_index.size();
  for (int32 i = 0; i < size; i++) {
    parse(message_count_by_index[i], parser);
  }
}

void MessagesManager::load_calls_db_state() {
  if (!G()->parameters().use_message_db) {
    return;
  }
  std::fill(calls_db_state_.message_count_by_index.begin(), calls_db_state_.message_count_by_index.end(), -1);
  auto value = G()->td_db()->get_sqlite_sync_pmc()->get("calls_db_state");
  if (value.empty()) {
    return;
  }
  log_event_parse(calls_db_state_, value).ensure();
  LOG(INFO) << "Save calls database state " << calls_db_state_.first_calls_database_message_id_by_index[0] << " ("
            << calls_db_state_.message_count_by_index[0] << ") "
            << calls_db_state_.first_calls_database_message_id_by_index[1] << " ("
            << calls_db_state_.message_count_by_index[1] << ")";
}

void MessagesManager::save_calls_db_state() {
  if (!G()->parameters().use_message_db) {
    return;
  }

  LOG(INFO) << "Save calls database state " << calls_db_state_.first_calls_database_message_id_by_index[0] << " ("
            << calls_db_state_.message_count_by_index[0] << ") "
            << calls_db_state_.first_calls_database_message_id_by_index[1] << " ("
            << calls_db_state_.message_count_by_index[1] << ")";
  G()->td_db()->get_sqlite_pmc()->set("calls_db_state", log_event_store(calls_db_state_).as_slice().str(), Auto());
}

MessagesManager::Dialog::~Dialog() {
  if (!G()->close_flag()) {
    LOG(ERROR) << "Destroy " << dialog_id;
  }
}

MessagesManager::MessagesManager(Td *td, ActorShared<> parent) : td_(td), parent_(std::move(parent)) {
  upload_media_callback_ = std::make_shared<UploadMediaCallback>();
  upload_thumbnail_callback_ = std::make_shared<UploadThumbnailCallback>();
  upload_dialog_photo_callback_ = std::make_shared<UploadDialogPhotoCallback>();
  upload_imported_messages_callback_ = std::make_shared<UploadImportedMessagesCallback>();
  upload_imported_message_attachment_callback_ = std::make_shared<UploadImportedMessageAttachmentCallback>();

  channel_get_difference_timeout_.set_callback(on_channel_get_difference_timeout_callback);
  channel_get_difference_timeout_.set_callback_data(static_cast<void *>(this));

  channel_get_difference_retry_timeout_.set_callback(on_channel_get_difference_timeout_callback);
  channel_get_difference_retry_timeout_.set_callback_data(static_cast<void *>(this));

  pending_message_views_timeout_.set_callback(on_pending_message_views_timeout_callback);
  pending_message_views_timeout_.set_callback_data(static_cast<void *>(this));

  pending_message_live_location_view_timeout_.set_callback(on_pending_message_live_location_view_timeout_callback);
  pending_message_live_location_view_timeout_.set_callback_data(static_cast<void *>(this));

  pending_draft_message_timeout_.set_callback(on_pending_draft_message_timeout_callback);
  pending_draft_message_timeout_.set_callback_data(static_cast<void *>(this));

  pending_read_history_timeout_.set_callback(on_pending_read_history_timeout_callback);
  pending_read_history_timeout_.set_callback_data(static_cast<void *>(this));

  pending_updated_dialog_timeout_.set_callback(on_pending_updated_dialog_timeout_callback);
  pending_updated_dialog_timeout_.set_callback_data(static_cast<void *>(this));

  pending_unload_dialog_timeout_.set_callback(on_pending_unload_dialog_timeout_callback);
  pending_unload_dialog_timeout_.set_callback_data(static_cast<void *>(this));

  dialog_unmute_timeout_.set_callback(on_dialog_unmute_timeout_callback);
  dialog_unmute_timeout_.set_callback_data(static_cast<void *>(this));

  pending_send_dialog_action_timeout_.set_callback(on_pending_send_dialog_action_timeout_callback);
  pending_send_dialog_action_timeout_.set_callback_data(static_cast<void *>(this));

  active_dialog_action_timeout_.set_callback(on_active_dialog_action_timeout_callback);
  active_dialog_action_timeout_.set_callback_data(static_cast<void *>(this));

  update_dialog_online_member_count_timeout_.set_callback(on_update_dialog_online_member_count_timeout_callback);
  update_dialog_online_member_count_timeout_.set_callback_data(static_cast<void *>(this));

  preload_folder_dialog_list_timeout_.set_callback(on_preload_folder_dialog_list_timeout_callback);
  preload_folder_dialog_list_timeout_.set_callback_data(static_cast<void *>(this));

  sequence_dispatcher_ = create_actor<MultiSequenceDispatcher>("multi sequence dispatcher");
}

MessagesManager::~MessagesManager() = default;

void MessagesManager::on_channel_get_difference_timeout_callback(void *messages_manager_ptr, int64 dialog_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::on_channel_get_difference_timeout,
                     DialogId(dialog_id_int));
}

void MessagesManager::on_pending_message_views_timeout_callback(void *messages_manager_ptr, int64 dialog_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::on_pending_message_views_timeout,
                     DialogId(dialog_id_int));
}

void MessagesManager::on_pending_message_live_location_view_timeout_callback(void *messages_manager_ptr,
                                                                             int64 task_id) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager),
                     &MessagesManager::view_message_live_location_on_server, task_id);
}

void MessagesManager::on_pending_draft_message_timeout_callback(void *messages_manager_ptr, int64 dialog_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager),
                     &MessagesManager::save_dialog_draft_message_on_server, DialogId(dialog_id_int));
}

void MessagesManager::on_pending_read_history_timeout_callback(void *messages_manager_ptr, int64 dialog_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::do_read_history_on_server,
                     DialogId(dialog_id_int));
}

void MessagesManager::on_pending_updated_dialog_timeout_callback(void *messages_manager_ptr, int64 dialog_id_int) {
  // no check for G()->close_flag() to save dialogs even while closing

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  // TODO it is unsafe to save dialog to database before binlog is flushed

  // no send_closure_later, because messages_manager can be not an actor while closing
  messages_manager->save_dialog_to_database(DialogId(dialog_id_int));
}

void MessagesManager::on_pending_unload_dialog_timeout_callback(void *messages_manager_ptr, int64 dialog_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::unload_dialog,
                     DialogId(dialog_id_int));
}

void MessagesManager::on_dialog_unmute_timeout_callback(void *messages_manager_ptr, int64 dialog_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  if (1 <= dialog_id_int && dialog_id_int <= 3) {
    send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::on_scope_unmute,
                       static_cast<NotificationSettingsScope>(dialog_id_int - 1));
  } else {
    send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::on_dialog_unmute,
                       DialogId(dialog_id_int));
  }
}

void MessagesManager::on_pending_send_dialog_action_timeout_callback(void *messages_manager_ptr, int64 dialog_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::on_send_dialog_action_timeout,
                     DialogId(dialog_id_int));
}

void MessagesManager::on_active_dialog_action_timeout_callback(void *messages_manager_ptr, int64 dialog_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::on_active_dialog_action_timeout,
                     DialogId(dialog_id_int));
}

void MessagesManager::on_update_dialog_online_member_count_timeout_callback(void *messages_manager_ptr,
                                                                            int64 dialog_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager),
                     &MessagesManager::on_update_dialog_online_member_count_timeout, DialogId(dialog_id_int));
}

void MessagesManager::on_preload_folder_dialog_list_timeout_callback(void *messages_manager_ptr, int64 folder_id_int) {
  if (G()->close_flag()) {
    return;
  }

  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::preload_folder_dialog_list,
                     FolderId(narrow_cast<int32>(folder_id_int)));
}

td_api::object_ptr<td_api::MessageSender> MessagesManager::get_message_sender_object_const(UserId user_id,
                                                                                           DialogId dialog_id) const {
  if (dialog_id.is_valid()) {
    CHECK(have_dialog(dialog_id));
    return td_api::make_object<td_api::messageSenderChat>(dialog_id.get());
  }
  if (!user_id.is_valid()) {
    // can happen only if the server sends a message with wrong sender
    user_id = td_->contacts_manager_->add_service_notifications_user();
  }
  return td_api::make_object<td_api::messageSenderUser>(
      td_->contacts_manager_->get_user_id_object(user_id, "get_message_sender_object"));
}

td_api::object_ptr<td_api::MessageSender> MessagesManager::get_message_sender_object(UserId user_id,
                                                                                     DialogId dialog_id) {
  if (dialog_id.is_valid() && !have_dialog(dialog_id)) {
    LOG(ERROR) << "Failed to find " << dialog_id;
    force_create_dialog(dialog_id, "get_message_sender_object");
  }
  if (!user_id.is_valid() && td_->auth_manager_->is_bot()) {
    td_->contacts_manager_->add_anonymous_bot_user();
    td_->contacts_manager_->add_service_notifications_user();
  }
  return get_message_sender_object_const(user_id, dialog_id);
}

td_api::object_ptr<td_api::MessageSender> MessagesManager::get_message_sender_object(DialogId dialog_id) {
  if (dialog_id.get_type() == DialogType::User) {
    return get_message_sender_object(dialog_id.get_user_id(), DialogId());
  }
  return get_message_sender_object(UserId(), dialog_id);
}

BufferSlice MessagesManager::get_dialog_database_value(const Dialog *d) {
  // can't use log_event_store, because it tries to parse stored Dialog
  LogEventStorerCalcLength storer_calc_length;
  store(*d, storer_calc_length);

  BufferSlice value_buffer{storer_calc_length.get_length()};
  auto value = value_buffer.as_slice();

  LogEventStorerUnsafe storer_unsafe(value.ubegin());
  store(*d, storer_unsafe);
  return value_buffer;
}

void MessagesManager::save_dialog_to_database(DialogId dialog_id) {
  CHECK(G()->parameters().use_message_db);
  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  LOG(INFO) << "Save " << dialog_id << " to database";
  vector<NotificationGroupKey> changed_group_keys;
  bool can_reuse_notification_group = false;
  auto add_group_key = [&](auto &group_info) {
    if (group_info.is_changed) {
      can_reuse_notification_group |= group_info.try_reuse;
      changed_group_keys.emplace_back(group_info.group_id, group_info.try_reuse ? DialogId() : dialog_id,
                                      group_info.last_notification_date);
      group_info.is_changed = false;
    }
  };
  add_group_key(d->message_notification_group);
  add_group_key(d->mention_notification_group);
  auto fixed_folder_id = d->folder_id == FolderId::archive() ? FolderId::archive() : FolderId::main();
  G()->td_db()->get_dialog_db_async()->add_dialog(
      dialog_id, fixed_folder_id, d->is_folder_id_inited ? d->order : 0, get_dialog_database_value(d),
      std::move(changed_group_keys), PromiseCreator::lambda([dialog_id, can_reuse_notification_group](Result<> result) {
        send_closure(G()->messages_manager(), &MessagesManager::on_save_dialog_to_database, dialog_id,
                     can_reuse_notification_group, result.is_ok());
      }));
}

void MessagesManager::on_save_dialog_to_database(DialogId dialog_id, bool can_reuse_notification_group, bool success) {
  LOG(INFO) << "Successfully saved " << dialog_id << " to database";

  if (success && can_reuse_notification_group && !G()->close_flag()) {
    auto d = get_dialog(dialog_id);
    CHECK(d != nullptr);
    try_reuse_notification_group(d->message_notification_group);
    try_reuse_notification_group(d->mention_notification_group);
  }

  // TODO erase some events from binlog
}

void MessagesManager::try_reuse_notification_group(NotificationGroupInfo &group_info) {
  if (!group_info.try_reuse) {
    return;
  }
  if (group_info.is_changed) {
    LOG(ERROR) << "Failed to reuse changed " << group_info.group_id;
    return;
  }
  group_info.try_reuse = false;
  if (!group_info.group_id.is_valid()) {
    LOG(ERROR) << "Failed to reuse invalid " << group_info.group_id;
    return;
  }
  CHECK(group_info.last_notification_id == NotificationId());
  CHECK(group_info.last_notification_date == 0);
  send_closure_later(G()->notification_manager(), &NotificationManager::try_reuse_notification_group_id,
                     group_info.group_id);
  notification_group_id_to_dialog_id_.erase(group_info.group_id);
  group_info.group_id = NotificationGroupId();
  group_info.max_removed_notification_id = NotificationId();
  group_info.max_removed_message_id = MessageId();
}

void MessagesManager::invalidate_message_indexes(Dialog *d) {
  CHECK(d != nullptr);
  bool is_secret = d->dialog_id.get_type() == DialogType::SecretChat;
  for (size_t i = 0; i < d->message_count_by_index.size(); i++) {
    if (is_secret || i == static_cast<size_t>(message_search_filter_index(MessageSearchFilter::FailedToSend))) {
      // always know all messages
      d->first_database_message_id_by_index[i] = MessageId::min();
      // keep the count
    } else {
      // some messages are unknown; drop first_database_message_id and count
      d->first_database_message_id_by_index[i] = MessageId();
      d->message_count_by_index[i] = -1;
    }
  }
}

void MessagesManager::update_message_count_by_index(Dialog *d, int diff, const Message *m) {
  auto index_mask = get_message_index_mask(d->dialog_id, m);
  index_mask &= ~message_search_filter_index_mask(
      MessageSearchFilter::UnreadMention);  // unread mention count has been already manually updated

  update_message_count_by_index(d, diff, index_mask);
}

void MessagesManager::update_message_count_by_index(Dialog *d, int diff, int32 index_mask) {
  if (index_mask == 0) {
    return;
  }

  LOG(INFO) << "Update message count by " << diff << " in index mask " << index_mask;
  int i = 0;
  for (auto &message_count : d->message_count_by_index) {
    if (((index_mask >> i) & 1) != 0 && message_count != -1) {
      message_count += diff;
      if (message_count < 0) {
        if (d->dialog_id.get_type() == DialogType::SecretChat ||
            i == message_search_filter_index(MessageSearchFilter::FailedToSend)) {
          message_count = 0;
        } else {
          message_count = -1;
        }
      }
      on_dialog_updated(d->dialog_id, "update_message_count_by_index");
    }
    i++;
  }

  i = static_cast<int>(MessageSearchFilter::Call) - 1;
  for (auto &message_count : calls_db_state_.message_count_by_index) {
    if (((index_mask >> i) & 1) != 0 && message_count != -1) {
      message_count += diff;
      if (message_count < 0) {
        if (d->dialog_id.get_type() == DialogType::SecretChat) {
          message_count = 0;
        } else {
          message_count = -1;
        }
      }
      save_calls_db_state();
    }
    i++;
  }
}

int32 MessagesManager::get_message_index_mask(DialogId dialog_id, const Message *m) const {
  CHECK(m != nullptr);
  if (m->message_id.is_scheduled() || m->message_id.is_yet_unsent()) {
    return 0;
  }
  if (m->is_failed_to_send) {
    return message_search_filter_index_mask(MessageSearchFilter::FailedToSend);
  }
  bool is_secret = dialog_id.get_type() == DialogType::SecretChat;
  if (!m->message_id.is_server() && !is_secret) {
    return 0;
  }

  int32 index_mask = 0;
  if (m->is_pinned) {
    index_mask |= message_search_filter_index_mask(MessageSearchFilter::Pinned);
  }
  // retain second condition just in case
  if (m->is_content_secret || (m->ttl > 0 && !is_secret)) {
    return index_mask;
  }
  index_mask |= get_message_content_index_mask(m->content.get(), td_, m->is_outgoing);
  if (m->contains_mention) {
    index_mask |= message_search_filter_index_mask(MessageSearchFilter::Mention);
    if (m->contains_unread_mention) {
      index_mask |= message_search_filter_index_mask(MessageSearchFilter::UnreadMention);
    }
  }
  LOG(INFO) << "Have index mask " << index_mask << " for " << m->message_id << " in " << dialog_id;
  return index_mask;
}

void MessagesManager::update_reply_count_by_message(Dialog *d, int diff, const Message *m) {
  if (td_->auth_manager_->is_bot() || !m->top_thread_message_id.is_valid() ||
      m->top_thread_message_id == m->message_id || !m->message_id.is_server()) {
    return;
  }

  auto replier_dialog_id =
      has_message_sender_user_id(d->dialog_id, m) ? DialogId(m->sender_user_id) : m->sender_dialog_id;
  update_message_reply_count(d, m->top_thread_message_id, replier_dialog_id, m->message_id,
                             diff < 0 ? G()->unix_time() : m->date, diff);
}

void MessagesManager::update_message_reply_count(Dialog *d, MessageId message_id, DialogId replier_dialog_id,
                                                 MessageId reply_message_id, int32 update_date, int diff,
                                                 bool is_recursive) {
  if (d == nullptr) {
    return;
  }

  Message *m = get_message(d, message_id);
  if (m == nullptr || !is_active_message_reply_info(d->dialog_id, m->reply_info)) {
    return;
  }
  LOG(INFO) << "Update reply count to " << message_id << " in " << d->dialog_id << " by " << diff << " from "
            << reply_message_id << " sent by " << replier_dialog_id;
  if (m->interaction_info_update_date < update_date &&
      m->reply_info.add_reply(replier_dialog_id, reply_message_id, diff)) {
    on_message_reply_info_changed(d->dialog_id, m);
    on_message_changed(d, m, true, "update_message_reply_count_by_message");
  }

  if (!is_recursive && is_discussion_message(d->dialog_id, m)) {
    update_message_reply_count(get_dialog(m->forward_info->from_dialog_id), m->forward_info->from_message_id,
                               replier_dialog_id, reply_message_id, update_date, diff, true);
  }
}

vector<MessageId> MessagesManager::get_message_ids(const vector<int64> &input_message_ids) {
  vector<MessageId> message_ids;
  message_ids.reserve(input_message_ids.size());
  for (auto &input_message_id : input_message_ids) {
    message_ids.push_back(MessageId(input_message_id));
  }
  return message_ids;
}

vector<int32> MessagesManager::get_server_message_ids(const vector<MessageId> &message_ids) {
  return transform(message_ids, [](MessageId message_id) { return message_id.get_server_message_id().get(); });
}

vector<int32> MessagesManager::get_scheduled_server_message_ids(const vector<MessageId> &message_ids) {
  return transform(message_ids,
                   [](MessageId message_id) { return message_id.get_scheduled_server_message_id().get(); });
}

tl_object_ptr<telegram_api::InputPeer> MessagesManager::get_input_peer(DialogId dialog_id,
                                                                       AccessRights access_rights) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      return td_->contacts_manager_->get_input_peer_user(dialog_id.get_user_id(), access_rights);
    case DialogType::Chat:
      return td_->contacts_manager_->get_input_peer_chat(dialog_id.get_chat_id(), access_rights);
    case DialogType::Channel:
      return td_->contacts_manager_->get_input_peer_channel(dialog_id.get_channel_id(), access_rights);
    case DialogType::SecretChat:
      return nullptr;
    case DialogType::None:
      return make_tl_object<telegram_api::inputPeerEmpty>();
    default:
      UNREACHABLE();
      return nullptr;
  }
}

tl_object_ptr<telegram_api::InputPeer> MessagesManager::get_input_peer_force(DialogId dialog_id) {
  switch (dialog_id.get_type()) {
    case DialogType::User: {
      UserId user_id = dialog_id.get_user_id();
      return make_tl_object<telegram_api::inputPeerUser>(user_id.get(), 0);
    }
    case DialogType::Chat: {
      ChatId chat_id = dialog_id.get_chat_id();
      return make_tl_object<telegram_api::inputPeerChat>(chat_id.get());
    }
    case DialogType::Channel: {
      ChannelId channel_id = dialog_id.get_channel_id();
      return make_tl_object<telegram_api::inputPeerChannel>(channel_id.get(), 0);
    }
    case DialogType::SecretChat:
    case DialogType::None:
      return make_tl_object<telegram_api::inputPeerEmpty>();
    default:
      UNREACHABLE();
      return nullptr;
  }
}

vector<tl_object_ptr<telegram_api::InputPeer>> MessagesManager::get_input_peers(const vector<DialogId> &dialog_ids,
                                                                                AccessRights access_rights) const {
  vector<tl_object_ptr<telegram_api::InputPeer>> input_peers;
  input_peers.reserve(dialog_ids.size());
  for (auto &dialog_id : dialog_ids) {
    auto input_peer = get_input_peer(dialog_id, access_rights);
    if (input_peer == nullptr) {
      LOG(ERROR) << "Have no access to " << dialog_id;
      continue;
    }
    input_peers.push_back(std::move(input_peer));
  }
  return input_peers;
}

tl_object_ptr<telegram_api::InputDialogPeer> MessagesManager::get_input_dialog_peer(DialogId dialog_id,
                                                                                    AccessRights access_rights) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::Channel:
    case DialogType::None:
      return make_tl_object<telegram_api::inputDialogPeer>(get_input_peer(dialog_id, access_rights));
    case DialogType::SecretChat:
      return nullptr;
    default:
      UNREACHABLE();
      return nullptr;
  }
}

vector<tl_object_ptr<telegram_api::InputDialogPeer>> MessagesManager::get_input_dialog_peers(
    const vector<DialogId> &dialog_ids, AccessRights access_rights) const {
  vector<tl_object_ptr<telegram_api::InputDialogPeer>> input_dialog_peers;
  input_dialog_peers.reserve(dialog_ids.size());
  for (auto &dialog_id : dialog_ids) {
    auto input_dialog_peer = get_input_dialog_peer(dialog_id, access_rights);
    if (input_dialog_peer == nullptr) {
      LOG(ERROR) << "Have no access to " << dialog_id;
      continue;
    }
    input_dialog_peers.push_back(std::move(input_dialog_peer));
  }
  return input_dialog_peers;
}

bool MessagesManager::have_input_peer(DialogId dialog_id, AccessRights access_rights) const {
  switch (dialog_id.get_type()) {
    case DialogType::User: {
      UserId user_id = dialog_id.get_user_id();
      return td_->contacts_manager_->have_input_peer_user(user_id, access_rights);
    }
    case DialogType::Chat: {
      ChatId chat_id = dialog_id.get_chat_id();
      return td_->contacts_manager_->have_input_peer_chat(chat_id, access_rights);
    }
    case DialogType::Channel: {
      ChannelId channel_id = dialog_id.get_channel_id();
      return td_->contacts_manager_->have_input_peer_channel(channel_id, access_rights);
    }
    case DialogType::SecretChat: {
      SecretChatId secret_chat_id = dialog_id.get_secret_chat_id();
      return td_->contacts_manager_->have_input_encrypted_peer(secret_chat_id, access_rights);
    }
    case DialogType::None:
      return false;
    default:
      UNREACHABLE();
      return false;
  }
}

bool MessagesManager::have_dialog_info(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User: {
      UserId user_id = dialog_id.get_user_id();
      return td_->contacts_manager_->have_user(user_id);
    }
    case DialogType::Chat: {
      ChatId chat_id = dialog_id.get_chat_id();
      return td_->contacts_manager_->have_chat(chat_id);
    }
    case DialogType::Channel: {
      ChannelId channel_id = dialog_id.get_channel_id();
      return td_->contacts_manager_->have_channel(channel_id);
    }
    case DialogType::SecretChat: {
      SecretChatId secret_chat_id = dialog_id.get_secret_chat_id();
      return td_->contacts_manager_->have_secret_chat(secret_chat_id);
    }
    case DialogType::None:
    default:
      return false;
  }
}

bool MessagesManager::have_dialog_info_force(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User: {
      UserId user_id = dialog_id.get_user_id();
      return td_->contacts_manager_->have_user_force(user_id);
    }
    case DialogType::Chat: {
      ChatId chat_id = dialog_id.get_chat_id();
      return td_->contacts_manager_->have_chat_force(chat_id);
    }
    case DialogType::Channel: {
      ChannelId channel_id = dialog_id.get_channel_id();
      return td_->contacts_manager_->have_channel_force(channel_id);
    }
    case DialogType::SecretChat: {
      SecretChatId secret_chat_id = dialog_id.get_secret_chat_id();
      return td_->contacts_manager_->have_secret_chat_force(secret_chat_id);
    }
    case DialogType::None:
    default:
      return false;
  }
}

tl_object_ptr<telegram_api::inputEncryptedChat> MessagesManager::get_input_encrypted_chat(
    DialogId dialog_id, AccessRights access_rights) const {
  switch (dialog_id.get_type()) {
    case DialogType::SecretChat: {
      SecretChatId secret_chat_id = dialog_id.get_secret_chat_id();
      return td_->contacts_manager_->get_input_encrypted_chat(secret_chat_id, access_rights);
    }
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::Channel:
    case DialogType::None:
    default:
      UNREACHABLE();
      return nullptr;
  }
}

bool MessagesManager::is_allowed_useless_update(const tl_object_ptr<telegram_api::Update> &update) {
  auto constructor_id = update->get_id();
  if (constructor_id == dummyUpdate::ID) {
    // allow dummyUpdate just in case
    return true;
  }
  if (constructor_id == telegram_api::updateNewMessage::ID ||
      constructor_id == telegram_api::updateNewChannelMessage::ID) {
    // new outgoing messages are received again if random_id coincide
    return true;
  }

  return false;
}

void MessagesManager::skip_old_pending_pts_update(tl_object_ptr<telegram_api::Update> &&update, int32 new_pts,
                                                  int32 old_pts, int32 pts_count, const char *source) {
  if (update->get_id() == telegram_api::updateNewMessage::ID) {
    auto update_new_message = static_cast<telegram_api::updateNewMessage *>(update.get());
    auto full_message_id = get_full_message_id(update_new_message->message_, false);
    if (update_message_ids_.find(full_message_id) != update_message_ids_.end()) {
      if (new_pts == old_pts) {  // otherwise message can be already deleted
        // apply sent message anyway
        on_get_message(std::move(update_new_message->message_), true, false, false, true, true,
                       "updateNewMessage with an awaited message");
        return;
      } else {
        LOG(ERROR) << "Receive awaited sent " << full_message_id << " from " << source << " with pts " << new_pts
                   << " and pts_count " << pts_count << ", but current pts is " << old_pts;
        dump_debug_message_op(get_dialog(full_message_id.get_dialog_id()), 3);
      }
    }
  }
  if (update->get_id() == updateSentMessage::ID) {
    auto update_sent_message = static_cast<updateSentMessage *>(update.get());
    if (being_sent_messages_.count(update_sent_message->random_id_) > 0) {
      if (new_pts == old_pts) {  // otherwise message can be already deleted
        // apply sent message anyway
        on_send_message_success(update_sent_message->random_id_, update_sent_message->message_id_,
                                update_sent_message->date_, update_sent_message->ttl_period_, FileId(),
                                "process old updateSentMessage");
        return;
      } else {
        LOG(ERROR) << "Receive awaited sent " << update_sent_message->message_id_ << " from " << source << " with pts "
                   << new_pts << " and pts_count " << pts_count << ", but current pts is " << old_pts;
        dump_debug_message_op(get_dialog(being_sent_messages_[update_sent_message->random_id_].get_dialog_id()), 3);
      }
    }
    return;
  }

  // very old or unuseful update
  LOG_IF(WARNING, new_pts == old_pts && pts_count == 0 && !is_allowed_useless_update(update))
      << "Receive useless update " << oneline(to_string(update)) << " from " << source;
}

MessagesManager::Dialog *MessagesManager::get_service_notifications_dialog() {
  UserId service_notifications_user_id = td_->contacts_manager_->add_service_notifications_user();
  DialogId service_notifications_dialog_id(service_notifications_user_id);
  force_create_dialog(service_notifications_dialog_id, "get_service_notifications_dialog");
  return get_dialog(service_notifications_dialog_id);
}

void MessagesManager::save_auth_notification_ids() {
  auto min_date = G()->unix_time() - AUTH_NOTIFICATION_ID_CACHE_TIME;
  vector<string> ids;
  for (auto &it : auth_notification_id_date_) {
    auto date = it.second;
    if (date < min_date) {
      continue;
    }
    ids.push_back(it.first);
    ids.push_back(to_string(date));
  }

  if (ids.empty()) {
    G()->td_db()->get_binlog_pmc()->erase("auth_notification_ids");
    return;
  }

  G()->td_db()->get_binlog_pmc()->set("auth_notification_ids", implode(ids, ','));
}

void MessagesManager::on_update_service_notification(tl_object_ptr<telegram_api::updateServiceNotification> &&update,
                                                     bool skip_new_entities, Promise<Unit> &&promise) {
  int32 ttl = 0;
  bool has_date = (update->flags_ & telegram_api::updateServiceNotification::INBOX_DATE_MASK) != 0;
  auto date = has_date ? update->inbox_date_ : G()->unix_time();
  if (date <= 0) {
    LOG(ERROR) << "Receive message date " << date << " in " << to_string(update);
    return;
  }
  bool is_auth_notification = begins_with(update->type_, "auth");
  if (is_auth_notification) {
    auto &old_date = auth_notification_id_date_[update->type_.substr(4)];
    if (date <= old_date) {
      LOG(INFO) << "Skip already applied " << to_string(update);
      return;
    }
    old_date = date;
  }

  bool is_authorized = td_->auth_manager_->is_authorized();
  bool is_user = is_authorized && !td_->auth_manager_->is_bot();
  auto contacts_manager = is_authorized ? td_->contacts_manager_.get() : nullptr;
  auto message_text = get_message_text(contacts_manager, std::move(update->message_), std::move(update->entities_),
                                       skip_new_entities, date, false, "on_update_service_notification");
  DialogId owner_dialog_id = is_user ? get_service_notifications_dialog()->dialog_id : DialogId();
  auto content = get_message_content(td_, std::move(message_text), std::move(update->media_), owner_dialog_id, false,
                                     UserId(), &ttl);
  bool is_content_secret = is_secret_message_content(ttl, content->get_type());

  if ((update->flags_ & telegram_api::updateServiceNotification::POPUP_MASK) != 0) {
    send_closure(G()->td(), &Td::send_update,
                 td_api::make_object<td_api::updateServiceNotification>(
                     update->type_, get_message_content_object(content.get(), td_, date, is_content_secret)));
  }
  if (has_date && is_user) {
    Dialog *d = get_service_notifications_dialog();
    CHECK(d != nullptr);
    auto dialog_id = d->dialog_id;
    CHECK(dialog_id.get_type() == DialogType::User);

    auto new_message = make_unique<Message>();
    set_message_id(new_message, get_next_local_message_id(d));
    new_message->sender_user_id = dialog_id.get_user_id();
    new_message->date = date;
    new_message->ttl = ttl;
    new_message->is_content_secret = is_content_secret;
    new_message->content = std::move(content);
    new_message->have_previous = true;
    new_message->have_next = true;

    bool need_update = true;
    bool need_update_dialog_pos = false;

    const Message *m = add_message_to_dialog(d, std::move(new_message), true, &need_update, &need_update_dialog_pos,
                                             "on_update_service_notification");
    if (m != nullptr && need_update) {
      send_update_new_message(d, m);
    }
    register_new_local_message_id(d, m);

    if (need_update_dialog_pos) {
      send_update_chat_last_message(d, "on_update_service_notification");
    }
  }
  promise.set_value(Unit());

  if (is_auth_notification) {
    save_auth_notification_ids();
  }
}

void MessagesManager::on_update_read_channel_inbox(tl_object_ptr<telegram_api::updateReadChannelInbox> &&update) {
  ChannelId channel_id(update->channel_id_);
  if (!channel_id.is_valid()) {
    LOG(ERROR) << "Receive invalid " << channel_id << " in updateReadChannelInbox";
    return;
  }

  FolderId folder_id;
  if ((update->flags_ & telegram_api::updateReadChannelInbox::FOLDER_ID_MASK) != 0) {
    folder_id = FolderId(update->folder_id_);
  }
  on_update_dialog_folder_id(DialogId(channel_id), folder_id);
  on_read_channel_inbox(channel_id, MessageId(ServerMessageId(update->max_id_)), update->still_unread_count_,
                        update->pts_, "updateReadChannelInbox");
}

void MessagesManager::on_update_read_channel_outbox(tl_object_ptr<telegram_api::updateReadChannelOutbox> &&update) {
  ChannelId channel_id(update->channel_id_);
  if (!channel_id.is_valid()) {
    LOG(ERROR) << "Receive invalid " << channel_id << " in updateReadChannelOutbox";
    return;
  }

  DialogId dialog_id = DialogId(channel_id);
  read_history_outbox(dialog_id, MessageId(ServerMessageId(update->max_id_)));
}

void MessagesManager::on_update_read_channel_messages_contents(
    tl_object_ptr<telegram_api::updateChannelReadMessagesContents> &&update) {
  ChannelId channel_id(update->channel_id_);
  if (!channel_id.is_valid()) {
    LOG(ERROR) << "Receive invalid " << channel_id << " in updateChannelReadMessagesContents";
    return;
  }

  DialogId dialog_id = DialogId(channel_id);

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(INFO) << "Receive read channel messages contents update in unknown " << dialog_id;
    return;
  }

  for (auto &server_message_id : update->messages_) {
    read_channel_message_content_from_updates(d, MessageId(ServerMessageId(server_message_id)));
  }
}

void MessagesManager::on_update_read_message_comments(DialogId dialog_id, MessageId message_id,
                                                      MessageId max_message_id, MessageId last_read_inbox_message_id,
                                                      MessageId last_read_outbox_message_id) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(INFO) << "Ignore update of read message comments in unknown " << dialog_id << " in updateReadDiscussion";
    return;
  }

  auto m = get_message_force(d, message_id, "on_update_read_message_comments");
  if (m == nullptr || !m->message_id.is_server() || m->top_thread_message_id != m->message_id ||
      !is_active_message_reply_info(dialog_id, m->reply_info)) {
    return;
  }
  if (m->reply_info.update_max_message_ids(max_message_id, last_read_inbox_message_id, last_read_outbox_message_id)) {
    on_message_reply_info_changed(dialog_id, m);
    on_message_changed(d, m, true, "on_update_read_message_comments");
  }
}

void MessagesManager::on_update_channel_too_long(tl_object_ptr<telegram_api::updateChannelTooLong> &&update,
                                                 bool force_apply) {
  ChannelId channel_id(update->channel_id_);
  if (!channel_id.is_valid()) {
    LOG(ERROR) << "Receive invalid " << channel_id << " in updateChannelTooLong";
    return;
  }

  DialogId dialog_id = DialogId(channel_id);
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    auto pts = load_channel_pts(dialog_id);
    if (pts > 0) {
      d = add_dialog(dialog_id);
      CHECK(d != nullptr);
      CHECK(d->pts == pts);
      update_dialog_pos(d, "on_update_channel_too_long");
    }
  }

  int32 update_pts = (update->flags_ & UPDATE_CHANNEL_TO_LONG_FLAG_HAS_PTS) ? update->pts_ : 0;

  if (d != nullptr) {
    if (update_pts == 0 || update_pts > d->pts) {
      get_channel_difference(dialog_id, d->pts, true, "on_update_channel_too_long 1");
    }
  } else {
    if (force_apply) {
      get_channel_difference(dialog_id, -1, true, "on_update_channel_too_long 2");
    } else {
      td_->updates_manager_->schedule_get_difference("on_update_channel_too_long 3");
    }
  }
}

void MessagesManager::on_update_message_view_count(FullMessageId full_message_id, int32 view_count) {
  if (view_count < 0) {
    LOG(ERROR) << "Receive " << view_count << " views in updateChannelMessageViews for " << full_message_id;
    return;
  }
  update_message_interaction_info(full_message_id, view_count, -1, false, nullptr);
}

void MessagesManager::on_update_message_forward_count(FullMessageId full_message_id, int32 forward_count) {
  if (forward_count < 0) {
    LOG(ERROR) << "Receive " << forward_count << " forwards in updateChannelMessageForwards for " << full_message_id;
    return;
  }
  update_message_interaction_info(full_message_id, -1, forward_count, false, nullptr);
}

void MessagesManager::on_update_message_interaction_info(FullMessageId full_message_id, int32 view_count,
                                                         int32 forward_count, bool has_reply_info,
                                                         tl_object_ptr<telegram_api::messageReplies> &&reply_info) {
  if (view_count < 0 || forward_count < 0) {
    LOG(ERROR) << "Receive " << view_count << "/" << forward_count << " interaction counters for " << full_message_id;
    return;
  }
  update_message_interaction_info(full_message_id, view_count, forward_count, has_reply_info, std::move(reply_info));
}

void MessagesManager::on_pending_message_views_timeout(DialogId dialog_id) {
  if (G()->close_flag()) {
    return;
  }

  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  const size_t MAX_MESSAGE_VIEWS = 100;  // server side limit
  vector<MessageId> message_ids;
  message_ids.reserve(min(d->pending_viewed_message_ids.size(), MAX_MESSAGE_VIEWS));
  for (auto message_id : d->pending_viewed_message_ids) {
    message_ids.push_back(message_id);
    if (message_ids.size() >= MAX_MESSAGE_VIEWS) {
      td_->create_handler<GetMessagesViewsQuery>()->send(dialog_id, std::move(message_ids), d->increment_view_counter);
      message_ids.clear();
    }
  }
  if (!message_ids.empty()) {
    td_->create_handler<GetMessagesViewsQuery>()->send(dialog_id, std::move(message_ids), d->increment_view_counter);
  }
  d->pending_viewed_message_ids.clear();
  d->increment_view_counter = false;
}

void MessagesManager::update_message_interaction_info(FullMessageId full_message_id, int32 view_count,
                                                      int32 forward_count, bool has_reply_info,
                                                      tl_object_ptr<telegram_api::messageReplies> &&reply_info) {
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return;
  }
  auto message_id = full_message_id.get_message_id();
  Message *m = get_message_force(d, message_id, "update_message_interaction_info");
  if (m == nullptr) {
    LOG(INFO) << "Ignore message interaction info about unknown " << full_message_id;
    if (!message_id.is_scheduled() && message_id > d->last_new_message_id &&
        dialog_id.get_type() == DialogType::Channel) {
      get_channel_difference(dialog_id, d->pts, true, "update_message_interaction_info");
    }
    return;
  }

  if (view_count < 0) {
    view_count = m->view_count;
  }
  if (forward_count < 0) {
    forward_count = m->forward_count;
  }
  bool is_empty_reply_info = reply_info == nullptr;
  MessageReplyInfo new_reply_info(std::move(reply_info), td_->auth_manager_->is_bot());
  if (new_reply_info.is_empty() && !is_empty_reply_info) {
    has_reply_info = false;
  }

  if (update_message_interaction_info(dialog_id, m, view_count, forward_count, has_reply_info,
                                      std::move(new_reply_info))) {
    on_message_changed(d, m, true, "update_message_interaction_info");
  }
}

bool MessagesManager::is_active_message_reply_info(DialogId dialog_id, const MessageReplyInfo &info) const {
  if (info.is_empty()) {
    return false;
  }
  if (dialog_id.get_type() != DialogType::Channel) {
    return false;
  }

  if (!info.is_comment) {
    return true;
  }
  if (!is_broadcast_channel(dialog_id)) {
    return true;
  }

  auto channel_id = dialog_id.get_channel_id();
  if (!td_->contacts_manager_->get_channel_has_linked_channel(channel_id)) {
    return false;
  }

  auto linked_channel_id = td_->contacts_manager_->get_channel_linked_channel_id(channel_id);
  if (!linked_channel_id.is_valid()) {
    // keep the comment button while linked channel is unknown
    send_closure_later(G()->contacts_manager(), &ContactsManager::load_channel_full, channel_id, false,
                       Promise<Unit>());
    return true;
  }

  return linked_channel_id == info.channel_id;
}

bool MessagesManager::is_visible_message_reply_info(DialogId dialog_id, const Message *m) const {
  CHECK(m != nullptr);
  if (!m->message_id.is_valid()) {
    return false;
  }
  bool is_broadcast = is_broadcast_channel(dialog_id);
  if (!m->message_id.is_server() && !(is_broadcast && m->message_id.is_yet_unsent())) {
    return false;
  }
  if (is_broadcast && (m->had_reply_markup || m->reply_markup != nullptr)) {
    return false;
  }
  return is_active_message_reply_info(dialog_id, m->reply_info);
}

void MessagesManager::on_message_reply_info_changed(DialogId dialog_id, const Message *m) const {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  if (is_visible_message_reply_info(dialog_id, m)) {
    send_update_message_interaction_info(dialog_id, m);
  }
}

td_api::object_ptr<td_api::messageInteractionInfo> MessagesManager::get_message_interaction_info_object(
    DialogId dialog_id, const Message *m) const {
  bool is_visible_reply_info = is_visible_message_reply_info(dialog_id, m);
  if (m->view_count == 0 && m->forward_count == 0 && !is_visible_reply_info) {
    return nullptr;
  }
  if (m->message_id.is_scheduled() && (m->forward_info == nullptr || is_broadcast_channel(dialog_id))) {
    return nullptr;
  }
  if (m->message_id.is_local() && m->forward_info == nullptr) {
    return nullptr;
  }

  td_api::object_ptr<td_api::messageReplyInfo> reply_info;
  if (is_visible_reply_info) {
    reply_info = m->reply_info.get_message_reply_info_object(td_->contacts_manager_.get(), this);
    CHECK(reply_info != nullptr);
  }

  return td_api::make_object<td_api::messageInteractionInfo>(m->view_count, m->forward_count, std::move(reply_info));
}

bool MessagesManager::update_message_interaction_info(DialogId dialog_id, Message *m, int32 view_count,
                                                      int32 forward_count, bool has_reply_info,
                                                      MessageReplyInfo &&reply_info) {
  CHECK(m != nullptr);
  m->interaction_info_update_date = G()->unix_time();  // doesn't force message saving
  if (m->message_id.is_valid_scheduled()) {
    has_reply_info = false;
  }
  bool need_update_reply_info = has_reply_info && m->reply_info.need_update_to(reply_info);
  if (has_reply_info && m->reply_info.channel_id == reply_info.channel_id) {
    if (need_update_reply_info) {
      reply_info.update_max_message_ids(m->reply_info);
    } else {
      if (m->reply_info.update_max_message_ids(reply_info) && view_count <= m->view_count &&
          forward_count <= m->forward_count) {
        on_message_reply_info_changed(dialog_id, m);
        on_message_changed(get_dialog(dialog_id), m, true, "update_message_interaction_info");
      }
    }
  }
  if (view_count > m->view_count || forward_count > m->forward_count || need_update_reply_info) {
    LOG(DEBUG) << "Update interaction info of " << FullMessageId{dialog_id, m->message_id} << " from " << m->view_count
               << '/' << m->forward_count << "/" << m->reply_info << " to " << view_count << '/' << forward_count << "/"
               << reply_info;
    bool need_update = false;
    if (view_count > m->view_count) {
      m->view_count = view_count;
      need_update = true;
    }
    if (forward_count > m->forward_count) {
      m->forward_count = forward_count;
      need_update = true;
    }
    if (need_update_reply_info) {
      if (m->reply_info.channel_id != reply_info.channel_id) {
        if (m->reply_info.channel_id.is_valid() && reply_info.channel_id.is_valid() && m->message_id.is_server()) {
          LOG(ERROR) << "Reply info changed from " << m->reply_info << " to " << reply_info;
        }
      }
      m->reply_info = std::move(reply_info);
      if (!m->top_thread_message_id.is_valid() && !is_broadcast_channel(dialog_id) &&
          is_visible_message_reply_info(dialog_id, m)) {
        m->top_thread_message_id = m->message_id;
      }
      need_update |= is_visible_message_reply_info(dialog_id, m);
    }
    if (need_update) {
      send_update_message_interaction_info(dialog_id, m);
    }
    return true;
  }
  return false;
}

void MessagesManager::on_update_live_location_viewed(FullMessageId full_message_id) {
  LOG(DEBUG) << "Live location was viewed in " << full_message_id;
  if (!are_active_live_location_messages_loaded_) {
    get_active_live_location_messages(PromiseCreator::lambda([actor_id = actor_id(this), full_message_id](Unit result) {
      send_closure(actor_id, &MessagesManager::on_update_live_location_viewed, full_message_id);
    }));
    return;
  }

  auto active_live_location_message_ids = get_active_live_location_messages(Auto());
  if (!td::contains(active_live_location_message_ids, full_message_id)) {
    LOG(DEBUG) << "Can't find " << full_message_id << " in " << active_live_location_message_ids;
    return;
  }

  send_update_message_live_location_viewed(full_message_id);
}

void MessagesManager::on_update_some_live_location_viewed(Promise<Unit> &&promise) {
  LOG(DEBUG) << "Some live location was viewed";
  if (!are_active_live_location_messages_loaded_) {
    get_active_live_location_messages(
        PromiseCreator::lambda([actor_id = actor_id(this), promise = std::move(promise)](Unit result) mutable {
          send_closure(actor_id, &MessagesManager::on_update_some_live_location_viewed, std::move(promise));
        }));
    return;
  }

  // update all live locations, because it is unknown, which exactly was viewed
  auto active_live_location_message_ids = get_active_live_location_messages(Auto());
  for (auto full_message_id : active_live_location_message_ids) {
    send_update_message_live_location_viewed(full_message_id);
  }

  promise.set_value(Unit());
}

void MessagesManager::on_external_update_message_content(FullMessageId full_message_id) {
  const Dialog *d = get_dialog(full_message_id.get_dialog_id());
  CHECK(d != nullptr);
  const Message *m = get_message(d, full_message_id.get_message_id());
  CHECK(m != nullptr);
  auto live_location_date = m->is_failed_to_send ? 0 : m->date;
  send_update_message_content(full_message_id.get_dialog_id(), m->message_id, m->content.get(), live_location_date,
                              m->is_content_secret, "on_external_update_message_content");
  if (m->message_id == d->last_message_id) {
    send_update_chat_last_message_impl(d, "on_external_update_message_content");
  }
}

bool MessagesManager::update_message_contains_unread_mention(Dialog *d, Message *m, bool contains_unread_mention,
                                                             const char *source) {
  LOG_CHECK(m != nullptr) << source;
  CHECK(!m->message_id.is_scheduled());
  if (!contains_unread_mention && m->contains_unread_mention) {
    remove_message_notification_id(d, m, true, true);  // should be called before contains_unread_mention is updated

    m->contains_unread_mention = false;
    if (d->unread_mention_count == 0) {
      if (is_dialog_inited(d)) {
        LOG(ERROR) << "Unread mention count of " << d->dialog_id << " became negative from " << source;
      }
    } else {
      set_dialog_unread_mention_count(d, d->unread_mention_count - 1);
      on_dialog_updated(d->dialog_id, "update_message_contains_unread_mention");
    }
    LOG(INFO) << "Update unread mention message count in " << d->dialog_id << " to " << d->unread_mention_count
              << " by reading " << m->message_id << " from " << source;

    send_closure(G()->td(), &Td::send_update,
                 make_tl_object<td_api::updateMessageMentionRead>(d->dialog_id.get(), m->message_id.get(),
                                                                  d->unread_mention_count));
    return true;
  }
  return false;
}

void MessagesManager::on_read_channel_inbox(ChannelId channel_id, MessageId max_message_id, int32 server_unread_count,
                                            int32 pts, const char *source) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(!max_message_id.is_scheduled());
  if (!max_message_id.is_valid() && server_unread_count <= 0) {
    return;
  }

  DialogId dialog_id(channel_id);
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(INFO) << "Receive read inbox in unknown " << dialog_id << " from " << source;
    return;
  }

  /*
  // dropping unread count can make things worse, so don't drop it
  if (server_unread_count > 0 && G()->parameters().use_message_db && d->is_last_read_inbox_message_id_inited) {
    server_unread_count = -1;
  }
  */

  if (d->pts == pts) {
    read_history_inbox(dialog_id, max_message_id, server_unread_count, source);
  } else if (d->pts > pts) {
    // outdated update, need to repair server_unread_count from the server
    repair_channel_server_unread_count(d);
  } else {
    // update from the future, keep it until it can be applied
    if (pts >= d->pending_read_channel_inbox_pts) {
      if (d->pending_read_channel_inbox_pts == 0) {
        channel_get_difference_retry_timeout_.add_timeout_in(dialog_id.get(), 0.001);
      }
      d->pending_read_channel_inbox_pts = pts;
      d->pending_read_channel_inbox_max_message_id = max_message_id;
      d->pending_read_channel_inbox_server_unread_count = server_unread_count;
      on_dialog_updated(dialog_id, "on_read_channel_inbox");
    }
  }
}

void MessagesManager::on_read_channel_outbox(ChannelId channel_id, MessageId max_message_id) {
  DialogId dialog_id(channel_id);
  CHECK(!max_message_id.is_scheduled());
  if (max_message_id.is_valid()) {
    read_history_outbox(dialog_id, max_message_id);
  }
}

void MessagesManager::on_update_channel_max_unavailable_message_id(ChannelId channel_id,
                                                                   MessageId max_unavailable_message_id) {
  if (!channel_id.is_valid()) {
    LOG(ERROR) << "Receive max_unavailable_message_id in invalid " << channel_id;
    return;
  }

  DialogId dialog_id(channel_id);
  CHECK(!max_unavailable_message_id.is_scheduled());
  if (!max_unavailable_message_id.is_valid() && max_unavailable_message_id != MessageId()) {
    LOG(ERROR) << "Receive wrong max_unavailable_message_id: " << max_unavailable_message_id;
    max_unavailable_message_id = MessageId();
  }
  set_dialog_max_unavailable_message_id(dialog_id, max_unavailable_message_id, true,
                                        "on_update_channel_max_unavailable_message_id");
}

void MessagesManager::on_update_dialog_online_member_count(DialogId dialog_id, int32 online_member_count,
                                                           bool is_from_server) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  if (!dialog_id.is_valid()) {
    LOG(ERROR) << "Receive number of online members in invalid " << dialog_id;
    return;
  }

  if (is_broadcast_channel(dialog_id)) {
    LOG_IF(ERROR, online_member_count != 0)
        << "Receive " << online_member_count << " as a number of online members in a channel " << dialog_id;
    return;
  }

  if (online_member_count < 0) {
    LOG(ERROR) << "Receive " << online_member_count << " as a number of online members in a " << dialog_id;
    return;
  }

  set_dialog_online_member_count(dialog_id, online_member_count, is_from_server,
                                 "on_update_channel_online_member_count");
}

void MessagesManager::on_update_delete_scheduled_messages(DialogId dialog_id,
                                                          vector<ScheduledServerMessageId> &&server_message_ids) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  if (!dialog_id.is_valid()) {
    LOG(ERROR) << "Receive deleted scheduled messages in invalid " << dialog_id;
    return;
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(INFO) << "Skip updateDeleteScheduledMessages in unknown " << dialog_id;
    return;
  }

  vector<int64> deleted_message_ids;
  for (auto server_message_id : server_message_ids) {
    if (!server_message_id.is_valid()) {
      LOG(ERROR) << "Incoming update tries to delete scheduled message " << server_message_id.get();
      continue;
    }

    auto message = do_delete_scheduled_message(d, MessageId(server_message_id, std::numeric_limits<int32>::max()), true,
                                               "on_update_delete_scheduled_messages");
    if (message != nullptr) {
      deleted_message_ids.push_back(message->message_id.get());
    }
  }

  send_update_delete_messages(dialog_id, std::move(deleted_message_ids), true, false);

  send_update_chat_has_scheduled_messages(d, true);
}

void MessagesManager::on_user_dialog_action(DialogId dialog_id, MessageId top_thread_message_id, UserId user_id,
                                            DialogAction action, int32 date, MessageContentType message_content_type) {
  if (td_->auth_manager_->is_bot() || !user_id.is_valid() || is_broadcast_channel(dialog_id)) {
    return;
  }
  if (top_thread_message_id != MessageId() && !top_thread_message_id.is_valid()) {
    LOG(ERROR) << "Ignore typing in the message thread of " << top_thread_message_id;
    return;
  }

  auto dialog_type = dialog_id.get_type();
  if (action == DialogAction::get_speaking_action()) {
    if ((dialog_type != DialogType::Chat && dialog_type != DialogType::Channel) || top_thread_message_id.is_valid()) {
      LOG(ERROR) << "Receive " << action << " in thread of " << top_thread_message_id << " in " << dialog_id;
      return;
    }
    const Dialog *d = get_dialog_force(dialog_id);
    if (d != nullptr && d->active_group_call_id.is_valid()) {
      auto group_call_id = td_->group_call_manager_->get_group_call_id(d->active_group_call_id, dialog_id);
      td_->group_call_manager_->on_user_speaking_in_group_call(group_call_id, user_id, date);
    }
    return;
  }
  {
    auto message_import_progress = action.get_importing_messages_action_progress();
    if (message_import_progress >= 0) {
      // TODO
      return;
    }
  }

  if (!td_->contacts_manager_->have_min_user(user_id)) {
    LOG(DEBUG) << "Ignore typing of unknown " << user_id;
    return;
  }
  if (!have_dialog(dialog_id)) {
    LOG(DEBUG) << "Ignore typing in unknown " << dialog_id;
    return;
  }

  bool is_canceled = action == DialogAction();
  if (!is_canceled || message_content_type != MessageContentType::None) {
    td_->contacts_manager_->on_update_user_local_was_online(user_id, date);
  }

  if (dialog_type == DialogType::User || dialog_type == DialogType::SecretChat) {
    if (!td_->contacts_manager_->is_user_bot(user_id) && !td_->contacts_manager_->is_user_status_exact(user_id) &&
        !get_dialog(dialog_id)->is_opened && !is_canceled) {
      return;
    }
  }

  if (is_canceled) {
    auto actions_it = active_dialog_actions_.find(dialog_id);
    if (actions_it == active_dialog_actions_.end()) {
      return;
    }

    auto &active_actions = actions_it->second;
    auto it = std::find_if(active_actions.begin(), active_actions.end(),
                           [user_id](const ActiveDialogAction &action) { return action.user_id == user_id; });
    if (it == active_actions.end()) {
      return;
    }

    if (!td_->contacts_manager_->is_user_bot(user_id) &&
        !it->action.is_cancelled_by_message_of_type(message_content_type)) {
      return;
    }

    LOG(DEBUG) << "Cancel action of " << user_id << " in " << dialog_id;
    top_thread_message_id = it->top_thread_message_id;
    active_actions.erase(it);
    if (active_actions.empty()) {
      active_dialog_actions_.erase(dialog_id);
      LOG(DEBUG) << "Cancel action timeout in " << dialog_id;
      active_dialog_action_timeout_.cancel_timeout(dialog_id.get());
    }
  } else {
    if (date < G()->unix_time_cached() - DIALOG_ACTION_TIMEOUT - 60) {
      LOG(DEBUG) << "Ignore too old action of " << user_id << " in " << dialog_id << " sent at " << date;
      return;
    }
    auto &active_actions = active_dialog_actions_[dialog_id];
    auto it = std::find_if(active_actions.begin(), active_actions.end(),
                           [user_id](const ActiveDialogAction &action) { return action.user_id == user_id; });
    MessageId prev_top_thread_message_id;
    DialogAction prev_action;
    if (it != active_actions.end()) {
      LOG(DEBUG) << "Re-add action of " << user_id << " in " << dialog_id;
      prev_top_thread_message_id = it->top_thread_message_id;
      prev_action = it->action;
      active_actions.erase(it);
    } else {
      LOG(DEBUG) << "Add action of " << user_id << " in " << dialog_id;
    }

    active_actions.emplace_back(top_thread_message_id, user_id, action, Time::now());
    if (top_thread_message_id == prev_top_thread_message_id && action == prev_action) {
      return;
    }
    if (top_thread_message_id != prev_top_thread_message_id && prev_top_thread_message_id.is_valid()) {
      send_update_user_chat_action(dialog_id, prev_top_thread_message_id, user_id, DialogAction());
    }
    if (active_actions.size() == 1u) {
      LOG(DEBUG) << "Set action timeout in " << dialog_id;
      active_dialog_action_timeout_.set_timeout_in(dialog_id.get(), DIALOG_ACTION_TIMEOUT);
    }
  }

  if (top_thread_message_id.is_valid()) {
    send_update_user_chat_action(dialog_id, MessageId(), user_id, action);
  }
  send_update_user_chat_action(dialog_id, top_thread_message_id, user_id, action);
}

void MessagesManager::cancel_user_dialog_action(DialogId dialog_id, const Message *m) {
  CHECK(m != nullptr);
  if (td_->auth_manager_->is_bot() || m->forward_info != nullptr || m->had_forward_info ||
      m->via_bot_user_id.is_valid() || m->hide_via_bot || m->is_channel_post || m->message_id.is_scheduled()) {
    return;
  }

  on_user_dialog_action(dialog_id, MessageId(), m->sender_user_id, DialogAction(), m->date, m->content->get_type());
}

void MessagesManager::add_pending_channel_update(DialogId dialog_id, tl_object_ptr<telegram_api::Update> &&update,
                                                 int32 new_pts, int32 pts_count, Promise<Unit> &&promise,
                                                 const char *source, bool is_postponed_update) {
  LOG(INFO) << "Receive from " << source << " pending " << to_string(update);
  CHECK(update != nullptr);
  if (dialog_id.get_type() != DialogType::Channel) {
    LOG(ERROR) << "Receive channel update in invalid " << dialog_id << " from " << source << ": "
               << oneline(to_string(update));
    promise.set_value(Unit());
    return;
  }
  if (pts_count < 0 || new_pts <= pts_count) {
    LOG(ERROR) << "Receive channel update from " << source << " with wrong pts = " << new_pts
               << " or pts_count = " << pts_count << ": " << oneline(to_string(update));
    promise.set_value(Unit());
    return;
  }

  auto channel_id = dialog_id.get_channel_id();
  if (!td_->contacts_manager_->have_channel(channel_id) && td_->contacts_manager_->have_min_channel(channel_id)) {
    td_->updates_manager_->schedule_get_difference("on_update_new_channel_message");
    promise.set_value(Unit());
    return;
  }

  // TODO need to save all updates that can change result of running queries not associated with pts (for example
  // getHistory) and apply them to result of these queries

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    auto pts = load_channel_pts(dialog_id);
    if (pts > 0) {
      if (!td_->contacts_manager_->have_channel(channel_id)) {
        // do not create dialog if there is no info about the channel
        LOG(INFO) << "There is no info about " << channel_id << ", so ignore " << oneline(to_string(update));
        promise.set_value(Unit());
        return;
      }

      d = add_dialog(dialog_id);
      CHECK(d != nullptr);
      CHECK(d->pts == pts);
      update_dialog_pos(d, "add_pending_channel_update");
    }
  }
  if (d == nullptr) {
    // if there is no dialog, it can be created by the update
    LOG(INFO) << "Receive pending update from " << source << " about unknown " << dialog_id;
    if (running_get_channel_difference(dialog_id)) {
      promise.set_value(Unit());
      return;
    }
  } else {
    int32 old_pts = d->pts;
    if (new_pts <= old_pts) {  // very old or unuseful update
      if (new_pts < old_pts - 19999 && !is_postponed_update) {
        // restore channel pts after delete_first_messages
        auto now = Time::now();
        if (now > last_channel_pts_jump_warning_time_ + 1) {
          LOG(ERROR) << "Restore pts in " << d->dialog_id << " from " << source << " after delete_first_messages from "
                     << old_pts << " to " << new_pts << " is temporarily disabled, pts_count = " << pts_count
                     << ", update is from " << source << ": " << oneline(to_string(update));
          last_channel_pts_jump_warning_time_ = now;
        }
        get_channel_difference(dialog_id, old_pts, true, "add_pending_channel_update old");
      }

      if (update->get_id() == telegram_api::updateNewChannelMessage::ID) {
        auto update_new_channel_message = static_cast<telegram_api::updateNewChannelMessage *>(update.get());
        auto message_id = get_message_id(update_new_channel_message->message_, false);
        FullMessageId full_message_id(dialog_id, message_id);
        if (update_message_ids_.find(full_message_id) != update_message_ids_.end()) {
          // apply sent channel message
          on_get_message(std::move(update_new_channel_message->message_), true, true, false, true, true,
                         "updateNewChannelMessage with an awaited message");
          promise.set_value(Unit());
          return;
        }
      }
      if (update->get_id() == updateSentMessage::ID) {
        auto update_sent_message = static_cast<updateSentMessage *>(update.get());
        if (being_sent_messages_.count(update_sent_message->random_id_) > 0) {
          // apply sent channel message
          on_send_message_success(update_sent_message->random_id_, update_sent_message->message_id_,
                                  update_sent_message->date_, update_sent_message->ttl_period_, FileId(),
                                  "process old updateSentChannelMessage");
          promise.set_value(Unit());
          return;
        }
      }

      LOG_IF(WARNING, new_pts == old_pts && pts_count == 0)
          << "Receive from " << source << " useless channel update " << oneline(to_string(update));
      LOG(INFO) << "Skip already applied channel update";
      promise.set_value(Unit());
      return;
    }

    if (running_get_channel_difference(dialog_id)) {
      LOG(INFO) << "Postpone channel update, because getChannelDifference is run";
      d->postponed_channel_updates.emplace(new_pts,
                                           PendingPtsUpdate(std::move(update), new_pts, pts_count, std::move(promise)));
      return;
    }

    if (old_pts != new_pts - pts_count) {
      LOG(INFO) << "Found a gap in the " << dialog_id << " with pts = " << old_pts << ". new_pts = " << new_pts
                << ", pts_count = " << pts_count << " in update from " << source;

      d->postponed_channel_updates.emplace(new_pts,
                                           PendingPtsUpdate(std::move(update), new_pts, pts_count, std::move(promise)));

      get_channel_difference(dialog_id, old_pts, true, "add_pending_channel_update pts mismatch");
      return;
    }
  }

  if (d == nullptr || pts_count > 0) {
    process_channel_update(std::move(update));
    LOG_CHECK(!running_get_channel_difference(dialog_id)) << '"' << active_get_channel_differencies_[dialog_id] << '"';
  } else {
    LOG_IF(INFO, update->get_id() != dummyUpdate::ID)
        << "Skip useless channel update from " << source << ": " << to_string(update);
  }

  if (d == nullptr) {
    d = get_dialog(dialog_id);
    if (d == nullptr) {
      LOG(INFO) << "Update didn't created " << dialog_id;
      promise.set_value(Unit());
      return;
    }
  }

  CHECK(new_pts > d->pts);
  set_channel_pts(d, new_pts, source);
  promise.set_value(Unit());
}

bool MessagesManager::is_old_channel_update(DialogId dialog_id, int32 new_pts) {
  CHECK(dialog_id.get_type() == DialogType::Channel);

  const Dialog *d = get_dialog_force(dialog_id);
  return new_pts <= (d == nullptr ? load_channel_pts(dialog_id) : d->pts);
}

void MessagesManager::process_pts_update(tl_object_ptr<telegram_api::Update> &&update) {
  switch (update->get_id()) {
    case dummyUpdate::ID:
      LOG(INFO) << "Process dummyUpdate";
      break;
    case telegram_api::updateNewMessage::ID: {
      auto update_new_message = move_tl_object_as<telegram_api::updateNewMessage>(update);
      LOG(INFO) << "Process updateNewMessage";
      on_get_message(std::move(update_new_message->message_), true, false, false, true, true, "updateNewMessage");
      break;
    }
    case updateSentMessage::ID: {
      auto update_sent_message = move_tl_object_as<updateSentMessage>(update);
      LOG(INFO) << "Process updateSentMessage " << update_sent_message->random_id_;
      on_send_message_success(update_sent_message->random_id_, update_sent_message->message_id_,
                              update_sent_message->date_, update_sent_message->ttl_period_, FileId(),
                              "process updateSentMessage");
      break;
    }
    case telegram_api::updateReadMessagesContents::ID: {
      auto read_contents_update = move_tl_object_as<telegram_api::updateReadMessagesContents>(update);
      LOG(INFO) << "Process updateReadMessageContents";
      for (auto &message_id : read_contents_update->messages_) {
        read_message_content_from_updates(MessageId(ServerMessageId(message_id)));
      }
      break;
    }
    case telegram_api::updateEditMessage::ID: {
      auto update_edit_message = move_tl_object_as<telegram_api::updateEditMessage>(update);
      auto full_message_id = on_get_message(std::move(update_edit_message->message_), false, false, false, false, false,
                                            "updateEditMessage");
      LOG(INFO) << "Process updateEditMessage";
      on_message_edited(full_message_id, update_edit_message->pts_);
      break;
    }
    case telegram_api::updateDeleteMessages::ID: {
      auto delete_update = move_tl_object_as<telegram_api::updateDeleteMessages>(update);
      LOG(INFO) << "Process updateDeleteMessages";
      vector<MessageId> message_ids;
      for (auto message : delete_update->messages_) {
        message_ids.push_back(MessageId(ServerMessageId(message)));
      }
      delete_messages_from_updates(message_ids);
      break;
    }
    case telegram_api::updateReadHistoryInbox::ID: {
      auto read_update = move_tl_object_as<telegram_api::updateReadHistoryInbox>(update);
      LOG(INFO) << "Process updateReadHistoryInbox";
      DialogId dialog_id(read_update->peer_);
      FolderId folder_id;
      if ((read_update->flags_ & telegram_api::updateReadHistoryInbox::FOLDER_ID_MASK) != 0) {
        folder_id = FolderId(read_update->folder_id_);
      }
      on_update_dialog_folder_id(dialog_id, folder_id);
      read_history_inbox(dialog_id, MessageId(ServerMessageId(read_update->max_id_)),
                         -1 /*read_update->still_unread_count*/, "updateReadHistoryInbox");
      break;
    }
    case telegram_api::updateReadHistoryOutbox::ID: {
      auto read_update = move_tl_object_as<telegram_api::updateReadHistoryOutbox>(update);
      LOG(INFO) << "Process updateReadHistoryOutbox";
      read_history_outbox(DialogId(read_update->peer_), MessageId(ServerMessageId(read_update->max_id_)));
      break;
    }
    case telegram_api::updatePinnedMessages::ID: {
      auto pinned_messages_update = move_tl_object_as<telegram_api::updatePinnedMessages>(update);
      LOG(INFO) << "Process updatePinnedMessages";
      vector<MessageId> message_ids;
      for (auto message : pinned_messages_update->messages_) {
        message_ids.push_back(MessageId(ServerMessageId(message)));
      }
      update_dialog_pinned_messages_from_updates(DialogId(pinned_messages_update->peer_), message_ids,
                                                 pinned_messages_update->pinned_);
      break;
    }
    default:
      UNREACHABLE();
  }
  CHECK(!td_->updates_manager_->running_get_difference());
}

void MessagesManager::process_channel_update(tl_object_ptr<telegram_api::Update> &&update) {
  switch (update->get_id()) {
    case dummyUpdate::ID:
      LOG(INFO) << "Process dummyUpdate";
      break;
    case updateSentMessage::ID: {
      auto update_sent_message = move_tl_object_as<updateSentMessage>(update);
      LOG(INFO) << "Process updateSentMessage " << update_sent_message->random_id_;
      on_send_message_success(update_sent_message->random_id_, update_sent_message->message_id_,
                              update_sent_message->date_, update_sent_message->ttl_period_, FileId(),
                              "process updateSentChannelMessage");
      break;
    }
    case telegram_api::updateNewChannelMessage::ID: {
      auto update_new_channel_message = move_tl_object_as<telegram_api::updateNewChannelMessage>(update);
      LOG(INFO) << "Process updateNewChannelMessage";
      on_get_message(std::move(update_new_channel_message->message_), true, true, false, true, true,
                     "updateNewChannelMessage");
      break;
    }
    case telegram_api::updateDeleteChannelMessages::ID: {
      auto delete_channel_messages_update = move_tl_object_as<telegram_api::updateDeleteChannelMessages>(update);
      LOG(INFO) << "Process updateDeleteChannelMessages";
      ChannelId channel_id(delete_channel_messages_update->channel_id_);
      if (!channel_id.is_valid()) {
        LOG(ERROR) << "Receive invalid " << channel_id;
        break;
      }

      vector<MessageId> message_ids;
      for (auto &message : delete_channel_messages_update->messages_) {
        message_ids.push_back(MessageId(ServerMessageId(message)));
      }

      auto dialog_id = DialogId(channel_id);
      delete_dialog_messages(dialog_id, message_ids, true, false);
      break;
    }
    case telegram_api::updateEditChannelMessage::ID: {
      auto update_edit_channel_message = move_tl_object_as<telegram_api::updateEditChannelMessage>(update);
      LOG(INFO) << "Process updateEditChannelMessage";
      auto full_message_id = on_get_message(std::move(update_edit_channel_message->message_), false, true, false, false,
                                            false, "updateEditChannelMessage");
      on_message_edited(full_message_id, update_edit_channel_message->pts_);
      break;
    }
    case telegram_api::updatePinnedChannelMessages::ID: {
      auto pinned_channel_messages_update = move_tl_object_as<telegram_api::updatePinnedChannelMessages>(update);
      LOG(INFO) << "Process updatePinnedChannelMessages";
      ChannelId channel_id(pinned_channel_messages_update->channel_id_);
      if (!channel_id.is_valid()) {
        LOG(ERROR) << "Receive invalid " << channel_id;
        break;
      }

      vector<MessageId> message_ids;
      for (auto &message : pinned_channel_messages_update->messages_) {
        message_ids.push_back(MessageId(ServerMessageId(message)));
      }

      update_dialog_pinned_messages_from_updates(DialogId(channel_id), message_ids,
                                                 pinned_channel_messages_update->pinned_);
      break;
    }
    default:
      UNREACHABLE();
  }
}

void MessagesManager::on_message_edited(FullMessageId full_message_id, int32 pts) {
  if (full_message_id == FullMessageId()) {
    return;
  }

  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog(dialog_id);
  Message *m = get_message(d, full_message_id.get_message_id());
  CHECK(m != nullptr);
  m->last_edit_pts = pts;
  if (td_->auth_manager_->is_bot()) {
    d->last_edited_message_id = m->message_id;
    send_update_message_edited(dialog_id, m);
  }
  update_used_hashtags(dialog_id, m);
}

string MessagesManager::get_notification_settings_scope_database_key(NotificationSettingsScope scope) {
  switch (scope) {
    case NotificationSettingsScope::Private:
      return "nsfpc";
    case NotificationSettingsScope::Group:
      return "nsfgc";
    case NotificationSettingsScope::Channel:
      return "nsfcc";
    default:
      UNREACHABLE();
      return "";
  }
}

void MessagesManager::save_scope_notification_settings(NotificationSettingsScope scope,
                                                       const ScopeNotificationSettings &new_settings) {
  string key = get_notification_settings_scope_database_key(scope);
  G()->td_db()->get_binlog_pmc()->set(key, log_event_store(new_settings).as_slice().str());
}

bool MessagesManager::update_dialog_notification_settings(DialogId dialog_id,
                                                          DialogNotificationSettings *current_settings,
                                                          const DialogNotificationSettings &new_settings) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return false;
  }

  bool need_update_server = current_settings->mute_until != new_settings.mute_until ||
                            current_settings->sound != new_settings.sound ||
                            current_settings->show_preview != new_settings.show_preview ||
                            current_settings->use_default_mute_until != new_settings.use_default_mute_until ||
                            current_settings->use_default_sound != new_settings.use_default_sound ||
                            current_settings->use_default_show_preview != new_settings.use_default_show_preview;
  bool need_update_local =
      current_settings->use_default_disable_pinned_message_notifications !=
          new_settings.use_default_disable_pinned_message_notifications ||
      current_settings->disable_pinned_message_notifications != new_settings.disable_pinned_message_notifications ||
      current_settings->use_default_disable_mention_notifications !=
          new_settings.use_default_disable_mention_notifications ||
      current_settings->disable_mention_notifications != new_settings.disable_mention_notifications;

  bool is_changed = need_update_server || need_update_local ||
                    current_settings->is_synchronized != new_settings.is_synchronized ||
                    current_settings->is_use_default_fixed != new_settings.is_use_default_fixed;

  if (is_changed) {
    Dialog *d = get_dialog(dialog_id);
    LOG_CHECK(d != nullptr) << "Wrong " << dialog_id << " in update_dialog_notification_settings";
    bool was_dialog_mentions_disabled = is_dialog_mention_notifications_disabled(d);

    VLOG(notifications) << "Update notification settings in " << dialog_id << " from " << *current_settings << " to "
                        << new_settings;

    update_dialog_unmute_timeout(d, current_settings->use_default_mute_until, current_settings->mute_until,
                                 new_settings.use_default_mute_until, new_settings.mute_until);

    *current_settings = new_settings;
    on_dialog_updated(dialog_id, "update_dialog_notification_settings");

    if (is_dialog_muted(d)) {
      // no check for was_muted to clean pending message notifications in chats with unsynchronized settings
      remove_all_dialog_notifications(d, false, "update_dialog_notification_settings 2");
    }
    if (is_dialog_pinned_message_notifications_disabled(d) && d->mention_notification_group.group_id.is_valid() &&
        d->pinned_message_notification_message_id.is_valid()) {
      remove_dialog_pinned_message_notification(d, "update_dialog_notification_settings 3");
    }
    if (was_dialog_mentions_disabled != is_dialog_mention_notifications_disabled(d)) {
      if (was_dialog_mentions_disabled) {
        update_dialog_mention_notification_count(d);
      } else {
        remove_dialog_mention_notifications(d);
      }
    }

    if (need_update_server || need_update_local) {
      send_closure(G()->td(), &Td::send_update,
                   make_tl_object<td_api::updateChatNotificationSettings>(
                       dialog_id.get(), get_chat_notification_settings_object(current_settings)));
    }
  }
  return need_update_server;
}

bool MessagesManager::update_scope_notification_settings(NotificationSettingsScope scope,
                                                         ScopeNotificationSettings *current_settings,
                                                         const ScopeNotificationSettings &new_settings) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return false;
  }

  bool need_update_server = current_settings->mute_until != new_settings.mute_until ||
                            current_settings->sound != new_settings.sound ||
                            current_settings->show_preview != new_settings.show_preview;
  bool need_update_local =
      current_settings->disable_pinned_message_notifications != new_settings.disable_pinned_message_notifications ||
      current_settings->disable_mention_notifications != new_settings.disable_mention_notifications;
  bool was_inited = current_settings->is_synchronized;
  bool is_inited = new_settings.is_synchronized;
  if (was_inited && !is_inited) {
    return false;  // just in case
  }
  bool is_changed = need_update_server || need_update_local || was_inited != is_inited;
  if (is_changed) {
    save_scope_notification_settings(scope, new_settings);

    VLOG(notifications) << "Update notification settings in " << scope << " from " << *current_settings << " to "
                        << new_settings;

    update_scope_unmute_timeout(scope, current_settings->mute_until, new_settings.mute_until);

    if (!current_settings->disable_pinned_message_notifications && new_settings.disable_pinned_message_notifications) {
      VLOG(notifications) << "Remove pinned message notifications in " << scope;
      for (auto &dialog : dialogs_) {
        Dialog *d = dialog.second.get();
        if (d->notification_settings.use_default_disable_pinned_message_notifications &&
            d->mention_notification_group.group_id.is_valid() && d->pinned_message_notification_message_id.is_valid() &&
            get_dialog_notification_setting_scope(d->dialog_id) == scope) {
          remove_dialog_pinned_message_notification(d, "update_scope_notification_settings");
        }
      }
    }
    if (current_settings->disable_mention_notifications != new_settings.disable_mention_notifications) {
      VLOG(notifications) << "Remove mention notifications in " << scope;
      for (auto &dialog : dialogs_) {
        Dialog *d = dialog.second.get();
        if (d->notification_settings.use_default_disable_mention_notifications &&
            get_dialog_notification_setting_scope(d->dialog_id) == scope) {
          if (current_settings->disable_mention_notifications) {
            update_dialog_mention_notification_count(d);
          } else {
            remove_dialog_mention_notifications(d);
          }
        }
      }
    }

    *current_settings = new_settings;

    send_closure(G()->td(), &Td::send_update, get_update_scope_notification_settings_object(scope));
  }
  return need_update_server;
}

void MessagesManager::schedule_dialog_unmute(DialogId dialog_id, bool use_default, int32 mute_until) {
  auto now = G()->unix_time_cached();
  if (!use_default && mute_until >= now && mute_until < now + 366 * 86400) {
    dialog_unmute_timeout_.set_timeout_in(dialog_id.get(), mute_until - now + 1);
  } else {
    dialog_unmute_timeout_.cancel_timeout(dialog_id.get());
  }
}

void MessagesManager::update_dialog_unmute_timeout(Dialog *d, bool &old_use_default, int32 &old_mute_until,
                                                   bool new_use_default, int32 new_mute_until) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  if (old_use_default == new_use_default && old_mute_until == new_mute_until) {
    return;
  }
  CHECK(d != nullptr);
  CHECK(old_mute_until >= 0);

  schedule_dialog_unmute(d->dialog_id, new_use_default, new_mute_until);

  bool was_muted = (old_use_default ? get_scope_mute_until(d->dialog_id) : old_mute_until) != 0;
  bool is_muted = (new_use_default ? get_scope_mute_until(d->dialog_id) : new_mute_until) != 0;
  if (was_muted != is_muted && need_unread_counter(d->order)) {
    auto unread_count = d->server_unread_count + d->local_unread_count;
    if (unread_count != 0 || d->is_marked_as_unread) {
      for (auto &list : get_dialog_lists(d)) {
        if (unread_count != 0 && list.is_message_unread_count_inited_) {
          int32 delta = was_muted ? -unread_count : unread_count;
          list.unread_message_muted_count_ += delta;
          send_update_unread_message_count(list, d->dialog_id, true, "update_dialog_unmute_timeout");
        }
        if (list.is_dialog_unread_count_inited_) {
          int32 delta = was_muted ? -1 : 1;
          list.unread_dialog_muted_count_ += delta;
          if (unread_count == 0 && d->is_marked_as_unread) {
            list.unread_dialog_muted_marked_count_ += delta;
          }
          send_update_unread_chat_count(list, d->dialog_id, true, "update_dialog_unmute_timeout");
        }
      }
    }
  }

  old_use_default = new_use_default;
  old_mute_until = new_mute_until;

  if (was_muted != is_muted && !dialog_filters_.empty()) {
    update_dialog_lists(d, get_dialog_positions(d), true, false, "update_dialog_unmute_timeout");
  }
}

void MessagesManager::schedule_scope_unmute(NotificationSettingsScope scope, int32 mute_until) {
  auto now = G()->unix_time_cached();
  if (mute_until >= now && mute_until < now + 366 * 86400) {
    dialog_unmute_timeout_.set_timeout_in(static_cast<int64>(scope) + 1, mute_until - now + 1);
  } else {
    dialog_unmute_timeout_.cancel_timeout(static_cast<int64>(scope) + 1);
  }
}

void MessagesManager::update_scope_unmute_timeout(NotificationSettingsScope scope, int32 &old_mute_until,
                                                  int32 new_mute_until) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  LOG(INFO) << "Update " << scope << " unmute timeout from " << old_mute_until << " to " << new_mute_until;
  if (old_mute_until == new_mute_until) {
    return;
  }
  CHECK(old_mute_until >= 0);

  schedule_scope_unmute(scope, new_mute_until);

  auto was_muted = old_mute_until != 0;
  auto is_muted = new_mute_until != 0;
  if (was_muted != is_muted) {
    if (G()->parameters().use_message_db) {
      std::unordered_map<DialogListId, int32, DialogListIdHash> delta;
      std::unordered_map<DialogListId, int32, DialogListIdHash> total_count;
      std::unordered_map<DialogListId, int32, DialogListIdHash> marked_count;
      std::unordered_set<DialogListId, DialogListIdHash> dialog_list_ids;
      for (auto &dialog : dialogs_) {
        Dialog *d = dialog.second.get();
        if (need_unread_counter(d->order) && d->notification_settings.use_default_mute_until &&
            get_dialog_notification_setting_scope(d->dialog_id) == scope) {
          int32 unread_count = d->server_unread_count + d->local_unread_count;
          if (unread_count != 0) {
            for (auto dialog_list_id : get_dialog_list_ids(d)) {
              delta[dialog_list_id] += unread_count;
              total_count[dialog_list_id]++;
              dialog_list_ids.insert(dialog_list_id);
            }
          } else if (d->is_marked_as_unread) {
            for (auto dialog_list_id : get_dialog_list_ids(d)) {
              total_count[dialog_list_id]++;
              marked_count[dialog_list_id]++;
              dialog_list_ids.insert(dialog_list_id);
            }
          }
        }
      }
      for (auto dialog_list_id : dialog_list_ids) {
        auto *list = get_dialog_list(dialog_list_id);
        CHECK(list != nullptr);
        if (delta[dialog_list_id] != 0 && list->is_message_unread_count_inited_) {
          if (was_muted) {
            list->unread_message_muted_count_ -= delta[dialog_list_id];
          } else {
            list->unread_message_muted_count_ += delta[dialog_list_id];
          }
          send_update_unread_message_count(*list, DialogId(), true, "update_scope_unmute_timeout");
        }
        if (total_count[dialog_list_id] != 0 && list->is_dialog_unread_count_inited_) {
          if (was_muted) {
            list->unread_dialog_muted_count_ -= total_count[dialog_list_id];
            list->unread_dialog_muted_marked_count_ -= marked_count[dialog_list_id];
          } else {
            list->unread_dialog_muted_count_ += total_count[dialog_list_id];
            list->unread_dialog_muted_marked_count_ += marked_count[dialog_list_id];
          }
          send_update_unread_chat_count(*list, DialogId(), true, "update_scope_unmute_timeout");
        }
      }
    }
  }

  old_mute_until = new_mute_until;

  if (was_muted != is_muted && !dialog_filters_.empty()) {
    for (auto &dialog : dialogs_) {
      Dialog *d = dialog.second.get();
      if (d->order != DEFAULT_ORDER && d->notification_settings.use_default_mute_until &&
          get_dialog_notification_setting_scope(d->dialog_id) == scope) {
        update_dialog_lists(d, get_dialog_positions(d), true, false, "update_scope_unmute_timeout");
      }
    }
  }
  if (!was_muted && is_muted) {
    for (auto &dialog : dialogs_) {
      Dialog *d = dialog.second.get();
      if (d->order != DEFAULT_ORDER && d->notification_settings.use_default_mute_until &&
          get_dialog_notification_setting_scope(d->dialog_id) == scope) {
        remove_all_dialog_notifications(d, false, "update_scope_unmute_timeout");
      }
    }
  }
}

void MessagesManager::on_dialog_unmute(DialogId dialog_id) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  if (d->notification_settings.use_default_mute_until) {
    return;
  }
  if (d->notification_settings.mute_until == 0) {
    return;
  }

  auto now = G()->unix_time();
  if (d->notification_settings.mute_until > now) {
    LOG(ERROR) << "Failed to unmute " << dialog_id << " in " << now << ", will be unmuted in "
               << d->notification_settings.mute_until;
    schedule_dialog_unmute(dialog_id, false, d->notification_settings.mute_until);
    return;
  }

  LOG(INFO) << "Unmute " << dialog_id;
  update_dialog_unmute_timeout(d, d->notification_settings.use_default_mute_until, d->notification_settings.mute_until,
                               false, 0);
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateChatNotificationSettings>(
                   dialog_id.get(), get_chat_notification_settings_object(&d->notification_settings)));
  on_dialog_updated(dialog_id, "on_dialog_unmute");
}

void MessagesManager::on_scope_unmute(NotificationSettingsScope scope) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  auto notification_settings = get_scope_notification_settings(scope);
  CHECK(notification_settings != nullptr);

  if (notification_settings->mute_until == 0) {
    return;
  }

  auto now = G()->unix_time();
  if (notification_settings->mute_until > now) {
    LOG(ERROR) << "Failed to unmute " << scope << " in " << now << ", will be unmuted in "
               << notification_settings->mute_until;
    schedule_scope_unmute(scope, notification_settings->mute_until);
    return;
  }

  LOG(INFO) << "Unmute " << scope;
  update_scope_unmute_timeout(scope, notification_settings->mute_until, 0);
  send_closure(G()->td(), &Td::send_update, get_update_scope_notification_settings_object(scope));
  save_scope_notification_settings(scope, *notification_settings);
}

void MessagesManager::on_update_dialog_notify_settings(
    DialogId dialog_id, tl_object_ptr<telegram_api::peerNotifySettings> &&peer_notify_settings, const char *source) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  VLOG(notifications) << "Receive notification settings for " << dialog_id << " from " << source << ": "
                      << to_string(peer_notify_settings);

  DialogNotificationSettings *current_settings = get_dialog_notification_settings(dialog_id, true);
  if (current_settings == nullptr) {
    return;
  }

  const DialogNotificationSettings notification_settings = ::td::get_dialog_notification_settings(
      std::move(peer_notify_settings), current_settings->use_default_disable_pinned_message_notifications,
      current_settings->disable_pinned_message_notifications,
      current_settings->use_default_disable_mention_notifications, current_settings->disable_mention_notifications);
  if (!notification_settings.is_synchronized) {
    return;
  }

  update_dialog_notification_settings(dialog_id, current_settings, notification_settings);
}

void MessagesManager::on_update_scope_notify_settings(
    NotificationSettingsScope scope, tl_object_ptr<telegram_api::peerNotifySettings> &&peer_notify_settings) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  auto old_notification_settings = get_scope_notification_settings(scope);
  CHECK(old_notification_settings != nullptr);

  const ScopeNotificationSettings notification_settings = ::td::get_scope_notification_settings(
      std::move(peer_notify_settings), old_notification_settings->disable_pinned_message_notifications,
      old_notification_settings->disable_mention_notifications);
  if (!notification_settings.is_synchronized) {
    return;
  }

  update_scope_notification_settings(scope, old_notification_settings, notification_settings);
}

bool MessagesManager::update_dialog_silent_send_message(Dialog *d, bool silent_send_message) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return false;
  }

  CHECK(d != nullptr);
  LOG_IF(WARNING, !d->notification_settings.is_synchronized)
      << "Have unknown notification settings in " << d->dialog_id;
  if (d->notification_settings.silent_send_message == silent_send_message) {
    return false;
  }

  LOG(INFO) << "Update silent send message in " << d->dialog_id << " to " << silent_send_message;
  d->notification_settings.silent_send_message = silent_send_message;

  on_dialog_updated(d->dialog_id, "update_dialog_silent_send_message");

  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateChatDefaultDisableNotification>(d->dialog_id.get(), silent_send_message));
  return true;
}

void MessagesManager::reget_dialog_action_bar(DialogId dialog_id, const char *source) {
  if (G()->close_flag() || !dialog_id.is_valid() || td_->auth_manager_->is_bot()) {
    return;
  }

  LOG(INFO) << "Reget action bar in " << dialog_id << " from " << source;
  switch (dialog_id.get_type()) {
    case DialogType::User:
      td_->contacts_manager_->reload_user_full(dialog_id.get_user_id());
      return;
    case DialogType::Chat:
    case DialogType::Channel:
      if (!have_input_peer(dialog_id, AccessRights::Read)) {
        return;
      }

      return td_->create_handler<GetPeerSettingsQuery>()->send(dialog_id);
    case DialogType::SecretChat:
    case DialogType::None:
    default:
      UNREACHABLE();
  }
}

void MessagesManager::repair_dialog_action_bar(Dialog *d, const char *source) {
  CHECK(d != nullptr);
  auto dialog_id = d->dialog_id;
  d->know_action_bar = false;
  if (have_input_peer(dialog_id, AccessRights::Read)) {
    create_actor<SleepActor>(
        "RepairChatActionBarActor", 1.0,
        PromiseCreator::lambda([actor_id = actor_id(this), dialog_id, source](Result<Unit> result) {
          send_closure(actor_id, &MessagesManager::reget_dialog_action_bar, dialog_id, source);
        }))
        .release();
  }
  // there is no need to change action bar
  on_dialog_updated(dialog_id, source);
}

void MessagesManager::hide_dialog_action_bar(DialogId dialog_id) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return;
  }
  hide_dialog_action_bar(d);
}

void MessagesManager::hide_dialog_action_bar(Dialog *d) {
  CHECK(d->dialog_id.get_type() != DialogType::SecretChat);
  if (!d->know_can_report_spam) {
    return;
  }
  if (!d->can_report_spam && !d->can_add_contact && !d->can_block_user && !d->can_share_phone_number &&
      !d->can_report_location && !d->can_unarchive && d->distance < 0 && !d->can_invite_members) {
    return;
  }

  d->can_report_spam = false;
  d->can_add_contact = false;
  d->can_block_user = false;
  d->can_share_phone_number = false;
  d->can_report_location = false;
  d->can_unarchive = false;
  d->distance = -1;
  d->can_invite_members = false;
  send_update_chat_action_bar(d);
}

void MessagesManager::remove_dialog_action_bar(DialogId dialog_id, Promise<Unit> &&promise) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_error(Status::Error(3, "Can't access the chat"));
  }

  if (dialog_id.get_type() == DialogType::SecretChat) {
    dialog_id = DialogId(td_->contacts_manager_->get_secret_chat_user_id(dialog_id.get_secret_chat_id()));
    d = get_dialog_force(dialog_id);
    if (d == nullptr) {
      return promise.set_error(Status::Error(3, "Chat with the user not found"));
    }
    if (!have_input_peer(dialog_id, AccessRights::Read)) {
      return promise.set_error(Status::Error(3, "Can't access the chat"));
    }
  }

  if (!d->know_can_report_spam) {
    return promise.set_error(Status::Error(3, "Can't update chat action bar"));
  }

  if (!d->can_report_spam && !d->can_add_contact && !d->can_block_user && !d->can_share_phone_number &&
      !d->can_report_location && !d->can_unarchive && d->distance < 0 && !d->can_invite_members) {
    return promise.set_value(Unit());
  }

  hide_dialog_action_bar(d);

  change_dialog_report_spam_state_on_server(dialog_id, false, 0, std::move(promise));
}

void MessagesManager::repair_dialog_active_group_call_id(DialogId dialog_id) {
  if (have_input_peer(dialog_id, AccessRights::Read)) {
    LOG(INFO) << "Repair active voice chat ID in " << dialog_id;
    create_actor<SleepActor>("RepairChatActiveVoiceChatId", 1.0,
                             PromiseCreator::lambda([actor_id = actor_id(this), dialog_id](Result<Unit> result) {
                               send_closure(actor_id, &MessagesManager::do_repair_dialog_active_group_call_id,
                                            dialog_id);
                             }))
        .release();
  }
}

void MessagesManager::do_repair_dialog_active_group_call_id(DialogId dialog_id) {
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  if (!d->has_active_group_call || d->active_group_call_id.is_valid()) {
    return;
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return;
  }

  reload_dialog_info_full(dialog_id);
}

class MessagesManager::ChangeDialogReportSpamStateOnServerLogEvent {
 public:
  DialogId dialog_id_;
  bool is_spam_dialog_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
    td::store(is_spam_dialog_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
    td::parse(is_spam_dialog_, parser);
  }
};

uint64 MessagesManager::save_change_dialog_report_spam_state_on_server_log_event(DialogId dialog_id,
                                                                                 bool is_spam_dialog) {
  ChangeDialogReportSpamStateOnServerLogEvent log_event{dialog_id, is_spam_dialog};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::ChangeDialogReportSpamStateOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::change_dialog_report_spam_state_on_server(DialogId dialog_id, bool is_spam_dialog,
                                                                uint64 log_event_id, Promise<Unit> &&promise) {
  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_change_dialog_report_spam_state_on_server_log_event(dialog_id, is_spam_dialog);
  }

  auto new_promise = get_erase_log_event_promise(log_event_id, std::move(promise));
  promise = std::move(new_promise);  // to prevent self-move

  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::Channel:
      return td_->create_handler<UpdatePeerSettingsQuery>(std::move(promise))->send(dialog_id, is_spam_dialog);
    case DialogType::SecretChat:
      if (is_spam_dialog) {
        return td_->create_handler<ReportEncryptedSpamQuery>(std::move(promise))->send(dialog_id);
      } else {
        auto user_id = td_->contacts_manager_->get_secret_chat_user_id(dialog_id.get_secret_chat_id());
        if (!user_id.is_valid()) {
          return promise.set_error(Status::Error(400, "Peer user not found"));
        }
        return td_->create_handler<UpdatePeerSettingsQuery>(std::move(promise))->send(DialogId(user_id), false);
      }
    case DialogType::None:
    default:
      UNREACHABLE();
      return;
  }
}

bool MessagesManager::can_report_dialog(DialogId dialog_id) const {
  // doesn't include possibility of report from action bar
  switch (dialog_id.get_type()) {
    case DialogType::User:
      return td_->contacts_manager_->can_report_user(dialog_id.get_user_id());
    case DialogType::Chat:
      return false;
    case DialogType::Channel:
      return !td_->contacts_manager_->get_channel_status(dialog_id.get_channel_id()).is_creator();
    case DialogType::SecretChat:
      return false;
    case DialogType::None:
    default:
      UNREACHABLE();
      return false;
  }
}

void MessagesManager::report_dialog(DialogId dialog_id, const vector<MessageId> &message_ids, ReportReason &&reason,
                                    Promise<Unit> &&promise) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_error(Status::Error(3, "Can't access the chat"));
  }

  Dialog *user_d = d;
  bool is_dialog_spam_report = false;
  bool can_report_spam = d->can_report_spam;
  if (reason.is_spam() && message_ids.empty()) {
    // report from action bar
    if (dialog_id.get_type() == DialogType::SecretChat) {
      auto user_dialog_id = DialogId(td_->contacts_manager_->get_secret_chat_user_id(dialog_id.get_secret_chat_id()));
      user_d = get_dialog_force(user_dialog_id);
      if (user_d == nullptr) {
        return promise.set_error(Status::Error(3, "Chat with the user not found"));
      }

      is_dialog_spam_report = user_d->know_can_report_spam;
      can_report_spam = user_d->can_report_spam;
    } else {
      is_dialog_spam_report = d->know_can_report_spam;
    }
  }

  if (is_dialog_spam_report && can_report_spam) {
    hide_dialog_action_bar(user_d);
    return change_dialog_report_spam_state_on_server(dialog_id, true, 0, std::move(promise));
  }

  if (!can_report_dialog(dialog_id)) {
    if (is_dialog_spam_report) {
      return promise.set_value(Unit());
    }

    return promise.set_error(Status::Error(3, "Chat can't be reported"));
  }

  vector<MessageId> server_message_ids;
  for (auto message_id : message_ids) {
    if (message_id.is_scheduled()) {
      return promise.set_error(Status::Error(3, "Can't report scheduled messages"));
    }
    if (message_id.is_valid() && message_id.is_server()) {
      server_message_ids.push_back(message_id);
    }
  }

  if (dialog_id.get_type() == DialogType::Channel && reason.is_unrelated_location()) {
    hide_dialog_action_bar(d);
  }

  td_->create_handler<ReportPeerQuery>(std::move(promise))->send(dialog_id, server_message_ids, std::move(reason));
}

void MessagesManager::report_dialog_photo(DialogId dialog_id, FileId file_id, ReportReason &&reason,
                                          Promise<Unit> &&promise) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_error(Status::Error(3, "Can't access the chat"));
  }

  if (!can_report_dialog(dialog_id)) {
    return promise.set_error(Status::Error(3, "Chat photo can't be reported"));
  }

  auto file_view = td_->file_manager_->get_file_view(file_id);
  if (file_view.empty()) {
    return promise.set_error(Status::Error(400, "Unknown file ID"));
  }
  if (file_view.get_type() != FileType::Photo || !file_view.has_remote_location() ||
      !file_view.remote_location().is_photo()) {
    return promise.set_error(Status::Error(400, "Only full chat photos can be reported"));
  }

  td_->create_handler<ReportProfilePhotoQuery>(std::move(promise))
      ->send(dialog_id, file_id, file_view.remote_location().as_input_photo(), std::move(reason));
}

void MessagesManager::on_get_peer_settings(DialogId dialog_id,
                                           tl_object_ptr<telegram_api::peerSettings> &&peer_settings,
                                           bool ignore_privacy_exception) {
  CHECK(peer_settings != nullptr);
  if (dialog_id.get_type() == DialogType::User && !ignore_privacy_exception) {
    auto need_phone_number_privacy_exception =
        (peer_settings->flags_ & telegram_api::peerSettings::NEED_CONTACTS_EXCEPTION_MASK) != 0;
    td_->contacts_manager_->on_update_user_need_phone_number_privacy_exception(dialog_id.get_user_id(),
                                                                               need_phone_number_privacy_exception);
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return;
  }

  auto can_report_spam = (peer_settings->flags_ & telegram_api::peerSettings::REPORT_SPAM_MASK) != 0;
  auto can_add_contact = (peer_settings->flags_ & telegram_api::peerSettings::ADD_CONTACT_MASK) != 0;
  auto can_block_user = (peer_settings->flags_ & telegram_api::peerSettings::BLOCK_CONTACT_MASK) != 0;
  auto can_share_phone_number = (peer_settings->flags_ & telegram_api::peerSettings::SHARE_CONTACT_MASK) != 0;
  auto can_report_location = (peer_settings->flags_ & telegram_api::peerSettings::REPORT_GEO_MASK) != 0;
  auto can_unarchive = (peer_settings->flags_ & telegram_api::peerSettings::AUTOARCHIVED_MASK) != 0;
  auto distance =
      (peer_settings->flags_ & telegram_api::peerSettings::GEO_DISTANCE_MASK) != 0 ? peer_settings->geo_distance_ : -1;
  auto can_invite_members = (peer_settings->flags_ & telegram_api::peerSettings::INVITE_MEMBERS_MASK) != 0;
  if (d->can_report_spam == can_report_spam && d->can_add_contact == can_add_contact &&
      d->can_block_user == can_block_user && d->can_share_phone_number == can_share_phone_number &&
      d->can_report_location == can_report_location && d->can_unarchive == can_unarchive && d->distance == distance &&
      d->can_invite_members == can_invite_members) {
    if (!d->know_action_bar || !d->know_can_report_spam) {
      d->know_can_report_spam = true;
      d->know_action_bar = true;
      on_dialog_updated(d->dialog_id, "on_get_peer_settings");
    }
    return;
  }

  d->know_can_report_spam = true;
  d->know_action_bar = true;
  d->can_report_spam = can_report_spam;
  d->can_add_contact = can_add_contact;
  d->can_block_user = can_block_user;
  d->can_share_phone_number = can_share_phone_number;
  d->can_report_location = can_report_location;
  d->can_unarchive = can_unarchive;
  d->distance = distance < 0 ? -1 : distance;
  d->can_invite_members = can_invite_members;

  fix_dialog_action_bar(d);

  send_update_chat_action_bar(d);
}

void MessagesManager::fix_dialog_action_bar(Dialog *d) {
  CHECK(d != nullptr);
  if (!d->know_action_bar) {
    return;
  }

  auto dialog_type = d->dialog_id.get_type();
  if (d->distance >= 0 && dialog_type != DialogType::User) {
    LOG(ERROR) << "Receive distance " << d->distance << " to " << d->dialog_id;
    d->distance = -1;
  }

  if (d->can_report_location) {
    if (dialog_type != DialogType::Channel) {
      LOG(ERROR) << "Receive can_report_location in " << d->dialog_id;
      d->can_report_location = false;
    } else if (d->can_report_spam || d->can_add_contact || d->can_block_user || d->can_share_phone_number ||
               d->can_unarchive || d->can_invite_members) {
      LOG(ERROR) << "Receive action bar " << d->can_report_spam << "/" << d->can_add_contact << "/" << d->can_block_user
                 << "/" << d->can_share_phone_number << "/" << d->can_report_location << "/" << d->can_unarchive << "/"
                 << d->can_invite_members;
      d->can_report_spam = false;
      d->can_add_contact = false;
      d->can_block_user = false;
      d->can_share_phone_number = false;
      d->can_unarchive = false;
      d->can_invite_members = false;
      CHECK(d->distance == -1);
    }
  }
  if (d->can_invite_members) {
    if (dialog_type != DialogType::Chat && (dialog_type != DialogType::Channel || is_broadcast_channel(d->dialog_id))) {
      LOG(ERROR) << "Receive can_invite_members in " << d->dialog_id;
      d->can_invite_members = false;
    } else if (d->can_report_spam || d->can_add_contact || d->can_block_user || d->can_share_phone_number ||
               d->can_unarchive) {
      LOG(ERROR) << "Receive action bar " << d->can_report_spam << "/" << d->can_add_contact << "/" << d->can_block_user
                 << "/" << d->can_share_phone_number << "/" << d->can_unarchive << "/" << d->can_invite_members;
      d->can_report_spam = false;
      d->can_add_contact = false;
      d->can_block_user = false;
      d->can_share_phone_number = false;
      d->can_unarchive = false;
      CHECK(d->distance == -1);
    }
  }
  if (dialog_type == DialogType::User) {
    auto user_id = d->dialog_id.get_user_id();
    bool is_me = user_id == td_->contacts_manager_->get_my_id();
    bool is_blocked = d->is_blocked;
    bool is_deleted = td_->contacts_manager_->is_user_deleted(user_id);
    bool is_contact = td_->contacts_manager_->is_user_contact(user_id);
    if (is_me || is_blocked) {
      d->can_report_spam = false;
      d->can_unarchive = false;
    }
    if (is_me || is_blocked || is_deleted) {
      d->can_share_phone_number = false;
    }
    if (is_me || is_blocked || is_deleted || is_contact) {
      d->can_block_user = false;
      d->can_add_contact = false;
    }
  }
  if (d->folder_id != FolderId::archive()) {
    d->can_unarchive = false;
  }
  if (d->can_share_phone_number) {
    CHECK(!d->can_report_location);
    CHECK(!d->can_invite_members);
    if (dialog_type != DialogType::User) {
      LOG(ERROR) << "Receive can_share_phone_number in " << d->dialog_id;
      d->can_share_phone_number = false;
    } else if (d->can_report_spam || d->can_add_contact || d->can_block_user || d->can_unarchive || d->distance >= 0) {
      LOG(ERROR) << "Receive action bar " << d->can_report_spam << "/" << d->can_add_contact << "/" << d->can_block_user
                 << "/" << d->can_share_phone_number << "/" << d->can_unarchive << "/" << d->distance;
      d->can_report_spam = false;
      d->can_add_contact = false;
      d->can_block_user = false;
      d->can_unarchive = false;
    }
  }
  if (d->can_block_user) {
    CHECK(!d->can_report_location);
    CHECK(!d->can_invite_members);
    CHECK(!d->can_share_phone_number);
    if (dialog_type != DialogType::User) {
      LOG(ERROR) << "Receive can_block_user in " << d->dialog_id;
      d->can_block_user = false;
    } else if (!d->can_report_spam || !d->can_add_contact) {
      LOG(ERROR) << "Receive action bar " << d->can_report_spam << "/" << d->can_add_contact << "/"
                 << d->can_block_user;
      d->can_report_spam = true;
      d->can_add_contact = true;
    }
  }
  if (d->can_add_contact) {
    CHECK(!d->can_report_location);
    CHECK(!d->can_invite_members);
    CHECK(!d->can_share_phone_number);
    if (dialog_type != DialogType::User) {
      LOG(ERROR) << "Receive can_add_contact in " << d->dialog_id;
      d->can_add_contact = false;
    } else if (d->can_report_spam != d->can_block_user) {
      LOG(ERROR) << "Receive action bar " << d->can_report_spam << "/" << d->can_add_contact << "/"
                 << d->can_block_user;
      d->can_report_spam = false;
      d->can_block_user = false;
      d->can_unarchive = false;
    }
  }
  if (!d->can_block_user) {
    d->distance = -1;
  }
  if (!d->can_report_spam) {
    d->can_unarchive = false;
  }
}

void MessagesManager::get_dialog_statistics_url(DialogId dialog_id, const string &parameters, bool is_dark,
                                                Promise<td_api::object_ptr<td_api::httpUrl>> &&promise) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_error(Status::Error(3, "Can't access the chat"));
  }
  if (dialog_id.get_type() == DialogType::SecretChat) {
    return promise.set_error(Status::Error(500, "There is no statistics for secret chats"));
  }

  td_->create_handler<GetStatsUrlQuery>(std::move(promise))->send(dialog_id, parameters, is_dark);
}

Result<string> MessagesManager::get_login_button_url(DialogId dialog_id, MessageId message_id, int32 button_id) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(3, "Chat not found");
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return Status::Error(3, "Can't access the chat");
  }

  auto m = get_message_force(d, message_id, "get_login_button_url");
  if (m == nullptr) {
    return Status::Error(5, "Message not found");
  }
  if (m->reply_markup == nullptr || m->reply_markup->type != ReplyMarkup::Type::InlineKeyboard) {
    return Status::Error(5, "Message has no inline keyboard");
  }
  if (message_id.is_scheduled()) {
    return Status::Error(5, "Can't use login buttons from scheduled messages");
  }
  if (!message_id.is_server()) {
    // it shouldn't have UrlAuth buttons anyway
    return Status::Error(5, "Message is not server");
  }
  if (dialog_id.get_type() == DialogType::SecretChat) {
    // secret chat messages can't have reply markup, so this shouldn't happen now
    return Status::Error(5, "Message is in a secret chat");
  }

  for (auto &row : m->reply_markup->inline_keyboard) {
    for (auto &button : row) {
      if (button.type == InlineKeyboardButton::Type::UrlAuth && button.id == button_id) {
        return button.data;
      }
    }
  }

  return Status::Error(5, "Button not found");
}

void MessagesManager::get_login_url_info(DialogId dialog_id, MessageId message_id, int32 button_id,
                                         Promise<td_api::object_ptr<td_api::LoginUrlInfo>> &&promise) {
  auto r_url = get_login_button_url(dialog_id, message_id, button_id);
  if (r_url.is_error()) {
    return promise.set_error(r_url.move_as_error());
  }

  td_->create_handler<RequestUrlAuthQuery>(std::move(promise))
      ->send(r_url.move_as_ok(), dialog_id, message_id, button_id);
}

void MessagesManager::get_login_url(DialogId dialog_id, MessageId message_id, int32 button_id, bool allow_write_access,
                                    Promise<td_api::object_ptr<td_api::httpUrl>> &&promise) {
  auto r_url = get_login_button_url(dialog_id, message_id, button_id);
  if (r_url.is_error()) {
    return promise.set_error(r_url.move_as_error());
  }

  td_->create_handler<AcceptUrlAuthQuery>(std::move(promise))
      ->send(r_url.move_as_ok(), dialog_id, message_id, button_id, allow_write_access);
}

void MessagesManager::load_secret_thumbnail(FileId thumbnail_file_id) {
  class Callback : public FileManager::DownloadCallback {
   public:
    explicit Callback(Promise<> download_promise) : download_promise_(std::move(download_promise)) {
    }

    void on_download_ok(FileId file_id) override {
      download_promise_.set_value(Unit());
    }
    void on_download_error(FileId file_id, Status error) override {
      download_promise_.set_error(std::move(error));
    }

   private:
    Promise<> download_promise_;
  };

  auto thumbnail_promise = PromiseCreator::lambda([actor_id = actor_id(this),
                                                   thumbnail_file_id](Result<BufferSlice> r_thumbnail) {
    BufferSlice thumbnail_slice;
    if (r_thumbnail.is_ok()) {
      thumbnail_slice = r_thumbnail.move_as_ok();
    }
    send_closure(actor_id, &MessagesManager::on_load_secret_thumbnail, thumbnail_file_id, std::move(thumbnail_slice));
  });

  auto download_promise = PromiseCreator::lambda(
      [thumbnail_file_id, thumbnail_promise = std::move(thumbnail_promise)](Result<Unit> r_download) mutable {
        if (r_download.is_error()) {
          thumbnail_promise.set_error(r_download.move_as_error());
          return;
        }
        send_closure(G()->file_manager(), &FileManager::get_content, thumbnail_file_id, std::move(thumbnail_promise));
      });

  send_closure(G()->file_manager(), &FileManager::download, thumbnail_file_id,
               std::make_shared<Callback>(std::move(download_promise)), 1, -1, -1);
}

void MessagesManager::on_upload_media(FileId file_id, tl_object_ptr<telegram_api::InputFile> input_file,
                                      tl_object_ptr<telegram_api::InputEncryptedFile> input_encrypted_file) {
  LOG(INFO) << "File " << file_id << " has been uploaded";

  auto it = being_uploaded_files_.find(file_id);
  if (it == being_uploaded_files_.end()) {
    // callback may be called just before the file upload was cancelled
    return;
  }

  auto full_message_id = it->second.first;
  auto thumbnail_file_id = it->second.second;

  being_uploaded_files_.erase(it);

  Message *m = get_message(full_message_id);
  if (m == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel, do not need to send or edit it
    // file upload should be already cancelled in cancel_send_message_query, it shouldn't happen
    LOG(ERROR) << "Message with a media has already been deleted";
    return;
  }

  bool is_edit = m->message_id.is_any_server();
  auto dialog_id = full_message_id.get_dialog_id();
  auto can_send_status = can_send_message(dialog_id);
  if (!is_edit && can_send_status.is_error()) {
    // user has left the chat during upload of the file or lost their privileges
    LOG(INFO) << "Can't send a message to " << dialog_id << ": " << can_send_status.error();

    fail_send_message(full_message_id, can_send_status.move_as_error());
    return;
  }

  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::Channel:
      if (input_file && thumbnail_file_id.is_valid()) {
        // TODO: download thumbnail if needed (like in secret chats)
        LOG(INFO) << "Ask to upload thumbnail " << thumbnail_file_id;
        CHECK(being_uploaded_thumbnails_.find(thumbnail_file_id) == being_uploaded_thumbnails_.end());
        being_uploaded_thumbnails_[thumbnail_file_id] = {full_message_id, file_id, std::move(input_file)};
        td_->file_manager_->upload(thumbnail_file_id, upload_thumbnail_callback_, 32, m->message_id.get());
      } else {
        do_send_media(dialog_id, m, file_id, thumbnail_file_id, std::move(input_file), nullptr);
      }
      break;
    case DialogType::SecretChat:
      if (thumbnail_file_id.is_valid()) {
        LOG(INFO) << "Ask to load thumbnail " << thumbnail_file_id;
        CHECK(being_loaded_secret_thumbnails_.find(thumbnail_file_id) == being_loaded_secret_thumbnails_.end());
        being_loaded_secret_thumbnails_[thumbnail_file_id] = {full_message_id, file_id,
                                                              std::move(input_encrypted_file)};

        load_secret_thumbnail(thumbnail_file_id);
      } else {
        do_send_secret_media(dialog_id, m, file_id, thumbnail_file_id, std::move(input_encrypted_file), BufferSlice());
      }
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
      break;
  }
}

void MessagesManager::do_send_media(DialogId dialog_id, Message *m, FileId file_id, FileId thumbnail_file_id,
                                    tl_object_ptr<telegram_api::InputFile> input_file,
                                    tl_object_ptr<telegram_api::InputFile> input_thumbnail) {
  CHECK(m != nullptr);

  bool have_input_file = input_file != nullptr;
  bool have_input_thumbnail = input_thumbnail != nullptr;
  LOG(INFO) << "Do send media file " << file_id << " with thumbnail " << thumbnail_file_id
            << ", have_input_file = " << have_input_file << ", have_input_thumbnail = " << have_input_thumbnail
            << ", TTL = " << m->ttl;

  MessageContent *content = nullptr;
  if (m->message_id.is_any_server()) {
    content = m->edited_content.get();
    if (content == nullptr) {
      LOG(ERROR) << "Message has no edited content";
      return;
    }
  } else {
    content = m->content.get();
  }

  auto input_media = get_input_media(content, td_, std::move(input_file), std::move(input_thumbnail), file_id,
                                     thumbnail_file_id, m->ttl, true);
  LOG_CHECK(input_media != nullptr) << to_string(get_message_object(dialog_id, m)) << ' ' << have_input_file << ' '
                                    << have_input_thumbnail << ' ' << file_id << ' ' << thumbnail_file_id << ' '
                                    << m->ttl;

  on_message_media_uploaded(dialog_id, m, std::move(input_media), file_id, thumbnail_file_id);
}

void MessagesManager::do_send_secret_media(DialogId dialog_id, Message *m, FileId file_id, FileId thumbnail_file_id,
                                           tl_object_ptr<telegram_api::InputEncryptedFile> input_encrypted_file,
                                           BufferSlice thumbnail) {
  CHECK(dialog_id.get_type() == DialogType::SecretChat);
  CHECK(m != nullptr);
  CHECK(m->message_id.is_valid());
  CHECK(m->message_id.is_yet_unsent());

  bool have_input_file = input_encrypted_file != nullptr;
  LOG(INFO) << "Do send secret media file " << file_id << " with thumbnail " << thumbnail_file_id
            << ", have_input_file = " << have_input_file;

  auto layer = td_->contacts_manager_->get_secret_chat_layer(dialog_id.get_secret_chat_id());
  on_secret_message_media_uploaded(
      dialog_id, m,
      get_secret_input_media(m->content.get(), td_, std::move(input_encrypted_file), std::move(thumbnail), layer),
      file_id, thumbnail_file_id);
}

void MessagesManager::on_upload_media_error(FileId file_id, Status status) {
  if (G()->close_flag()) {
    // do not fail upload if closing
    return;
  }

  LOG(WARNING) << "File " << file_id << " has upload error " << status;
  CHECK(status.is_error());

  auto it = being_uploaded_files_.find(file_id);
  if (it == being_uploaded_files_.end()) {
    // callback may be called just before the file upload was cancelled
    return;
  }

  auto full_message_id = it->second.first;

  being_uploaded_files_.erase(it);

  bool is_edit = full_message_id.get_message_id().is_any_server();
  if (is_edit) {
    fail_edit_message_media(full_message_id, Status::Error(status.code() > 0 ? status.code() : 500, status.message()));
  } else {
    fail_send_message(full_message_id, std::move(status));
  }
}

void MessagesManager::on_load_secret_thumbnail(FileId thumbnail_file_id, BufferSlice thumbnail) {
  if (G()->close_flag()) {
    // do not send secret media if closing, thumbnail may be wrong
    return;
  }

  LOG(INFO) << "SecretThumbnail " << thumbnail_file_id << " has been loaded with size " << thumbnail.size();

  auto it = being_loaded_secret_thumbnails_.find(thumbnail_file_id);
  if (it == being_loaded_secret_thumbnails_.end()) {
    // just in case, as in on_upload_thumbnail
    return;
  }

  auto full_message_id = it->second.full_message_id;
  auto file_id = it->second.file_id;
  auto input_file = std::move(it->second.input_file);

  being_loaded_secret_thumbnails_.erase(it);

  Message *m = get_message(full_message_id);
  if (m == nullptr) {
    // message has already been deleted by the user, do not need to send it
    // cancel file upload of the main file to allow next upload with the same file to succeed
    LOG(INFO) << "Message with a media has already been deleted";
    cancel_upload_file(file_id);
    return;
  }
  CHECK(m->message_id.is_yet_unsent());

  if (thumbnail.empty()) {
    delete_message_content_thumbnail(m->content.get(), td_);
  }

  auto dialog_id = full_message_id.get_dialog_id();
  auto can_send_status = can_send_message(dialog_id);
  if (can_send_status.is_error()) {
    // secret chat was closed during load of the file
    LOG(INFO) << "Can't send a message to " << dialog_id << ": " << can_send_status.error();

    fail_send_message(full_message_id, can_send_status.move_as_error());
    return;
  }

  do_send_secret_media(dialog_id, m, file_id, thumbnail_file_id, std::move(input_file), std::move(thumbnail));
}

void MessagesManager::on_upload_thumbnail(FileId thumbnail_file_id,
                                          tl_object_ptr<telegram_api::InputFile> thumbnail_input_file) {
  if (G()->close_flag()) {
    // do not fail upload if closing
    return;
  }

  LOG(INFO) << "Thumbnail " << thumbnail_file_id << " has been uploaded as " << to_string(thumbnail_input_file);

  auto it = being_uploaded_thumbnails_.find(thumbnail_file_id);
  if (it == being_uploaded_thumbnails_.end()) {
    // callback may be called just before the thumbnail upload was cancelled
    return;
  }

  auto full_message_id = it->second.full_message_id;
  auto file_id = it->second.file_id;
  auto input_file = std::move(it->second.input_file);

  being_uploaded_thumbnails_.erase(it);

  Message *m = get_message(full_message_id);
  if (m == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel, do not need to send or edit it
    // thumbnail file upload should be already cancelled in cancel_send_message_query
    LOG(ERROR) << "Message with a media has already been deleted";
    return;
  }

  bool is_edit = m->message_id.is_any_server();

  if (thumbnail_input_file == nullptr) {
    delete_message_content_thumbnail(is_edit ? m->edited_content.get() : m->content.get(), td_);
  }

  auto dialog_id = full_message_id.get_dialog_id();
  auto can_send_status = can_send_message(dialog_id);
  if (!is_edit && can_send_status.is_error()) {
    // user has left the chat during upload of the thumbnail or lost their privileges
    LOG(INFO) << "Can't send a message to " << dialog_id << ": " << can_send_status.error();

    fail_send_message(full_message_id, can_send_status.move_as_error());
    return;
  }

  do_send_media(dialog_id, m, file_id, thumbnail_file_id, std::move(input_file), std::move(thumbnail_input_file));
}

void MessagesManager::on_upload_dialog_photo(FileId file_id, tl_object_ptr<telegram_api::InputFile> input_file) {
  LOG(INFO) << "File " << file_id << " has been uploaded";

  auto it = being_uploaded_dialog_photos_.find(file_id);
  if (it == being_uploaded_dialog_photos_.end()) {
    // just in case, as in on_upload_media
    return;
  }

  DialogId dialog_id = it->second.dialog_id;
  double main_frame_timestamp = it->second.main_frame_timestamp;
  bool is_animation = it->second.is_animation;
  bool is_reupload = it->second.is_reupload;
  Promise<Unit> promise = std::move(it->second.promise);

  being_uploaded_dialog_photos_.erase(it);

  FileView file_view = td_->file_manager_->get_file_view(file_id);
  CHECK(!file_view.is_encrypted());
  if (input_file == nullptr && file_view.has_remote_location()) {
    if (file_view.main_remote_location().is_web()) {
      return promise.set_error(Status::Error(400, "Can't use web photo as profile photo"));
    }
    if (is_reupload) {
      return promise.set_error(Status::Error(400, "Failed to reupload the file"));
    }

    if (is_animation) {
      CHECK(file_view.get_type() == FileType::Animation);
      // delete file reference and forcely reupload the file
      auto file_reference = FileManager::extract_file_reference(file_view.main_remote_location().as_input_document());
      td_->file_manager_->delete_file_reference(file_id, file_reference);
      upload_dialog_photo(dialog_id, file_id, is_animation, main_frame_timestamp, true, std::move(promise), {-1});
    } else {
      CHECK(file_view.get_type() == FileType::Photo);
      auto input_photo = file_view.main_remote_location().as_input_photo();
      auto input_chat_photo = make_tl_object<telegram_api::inputChatPhoto>(std::move(input_photo));
      send_edit_dialog_photo_query(dialog_id, file_id, std::move(input_chat_photo), std::move(promise));
    }
    return;
  }
  CHECK(input_file != nullptr);

  int32 flags = 0;
  tl_object_ptr<telegram_api::InputFile> photo_input_file;
  tl_object_ptr<telegram_api::InputFile> video_input_file;
  if (is_animation) {
    flags |= telegram_api::inputChatUploadedPhoto::VIDEO_MASK;
    video_input_file = std::move(input_file);

    if (main_frame_timestamp != 0.0) {
      flags |= telegram_api::inputChatUploadedPhoto::VIDEO_START_TS_MASK;
    }
  } else {
    flags |= telegram_api::inputChatUploadedPhoto::FILE_MASK;
    photo_input_file = std::move(input_file);
  }

  auto input_chat_photo = make_tl_object<telegram_api::inputChatUploadedPhoto>(
      flags, std::move(photo_input_file), std::move(video_input_file), main_frame_timestamp);
  send_edit_dialog_photo_query(dialog_id, file_id, std::move(input_chat_photo), std::move(promise));
}

void MessagesManager::on_upload_dialog_photo_error(FileId file_id, Status status) {
  if (G()->close_flag()) {
    // do not fail upload if closing
    return;
  }

  LOG(INFO) << "File " << file_id << " has upload error " << status;
  CHECK(status.is_error());

  auto it = being_uploaded_dialog_photos_.find(file_id);
  if (it == being_uploaded_dialog_photos_.end()) {
    // just in case, as in on_upload_media_error
    return;
  }

  Promise<Unit> promise = std::move(it->second.promise);

  being_uploaded_dialog_photos_.erase(it);

  promise.set_error(std::move(status));
}

void MessagesManager::on_upload_imported_messages(FileId file_id, tl_object_ptr<telegram_api::InputFile> input_file) {
  LOG(INFO) << "File " << file_id << " has been uploaded";

  auto it = being_uploaded_imported_messages_.find(file_id);
  if (it == being_uploaded_imported_messages_.end()) {
    // just in case, as in on_upload_media
    return;
  }

  CHECK(it->second != nullptr);
  DialogId dialog_id = it->second->dialog_id;
  vector<FileId> attached_file_ids = std::move(it->second->attached_file_ids);
  bool is_reupload = it->second->is_reupload;
  Promise<Unit> promise = std::move(it->second->promise);

  being_uploaded_imported_messages_.erase(it);

  TRY_STATUS_PROMISE(promise, can_send_message(dialog_id));

  FileView file_view = td_->file_manager_->get_file_view(file_id);
  CHECK(!file_view.is_encrypted());
  if (input_file == nullptr && file_view.has_remote_location()) {
    if (file_view.main_remote_location().is_web()) {
      return promise.set_error(Status::Error(400, "Can't use web file"));
    }
    if (is_reupload) {
      return promise.set_error(Status::Error(400, "Failed to reupload the file"));
    }

    CHECK(file_view.get_type() == FileType::Document);
    // delete file reference and forcely reupload the file
    auto file_reference = FileManager::extract_file_reference(file_view.main_remote_location().as_input_document());
    td_->file_manager_->delete_file_reference(file_id, file_reference);
    upload_imported_messages(dialog_id, file_id, std::move(attached_file_ids), true, std::move(promise), {-1});
    return;
  }
  CHECK(input_file != nullptr);

  td_->create_handler<InitHistoryImportQuery>(std::move(promise))
      ->send(dialog_id, file_id, std::move(input_file), std::move(attached_file_ids));
}

void MessagesManager::on_upload_imported_messages_error(FileId file_id, Status status) {
  if (G()->close_flag()) {
    // do not fail upload if closing
    return;
  }

  LOG(INFO) << "File " << file_id << " has upload error " << status;
  CHECK(status.is_error());

  auto it = being_uploaded_imported_messages_.find(file_id);
  if (it == being_uploaded_imported_messages_.end()) {
    // just in case, as in on_upload_media_error
    return;
  }

  Promise<Unit> promise = std::move(it->second->promise);

  being_uploaded_imported_messages_.erase(it);

  promise.set_error(std::move(status));
}

void MessagesManager::on_upload_imported_message_attachment(FileId file_id,
                                                            tl_object_ptr<telegram_api::InputFile> input_file) {
  LOG(INFO) << "File " << file_id << " has been uploaded";

  auto it = being_uploaded_imported_message_attachments_.find(file_id);
  if (it == being_uploaded_imported_message_attachments_.end()) {
    // just in case, as in on_upload_media
    return;
  }

  CHECK(it->second != nullptr);
  DialogId dialog_id = it->second->dialog_id;
  int64 import_id = it->second->import_id;
  bool is_reupload = it->second->is_reupload;
  Promise<Unit> promise = std::move(it->second->promise);

  being_uploaded_imported_message_attachments_.erase(it);

  FileView file_view = td_->file_manager_->get_file_view(file_id);
  CHECK(!file_view.is_encrypted());
  if (input_file == nullptr && file_view.has_remote_location()) {
    if (file_view.main_remote_location().is_web()) {
      return promise.set_error(Status::Error(400, "Can't use web file"));
    }
    if (is_reupload) {
      return promise.set_error(Status::Error(400, "Failed to reupload the file"));
    }

    // delete file reference and forcely reupload the file
    auto file_reference =
        file_view.get_type() == FileType::Photo
            ? FileManager::extract_file_reference(file_view.main_remote_location().as_input_photo())
            : FileManager::extract_file_reference(file_view.main_remote_location().as_input_document());
    td_->file_manager_->delete_file_reference(file_id, file_reference);
    upload_imported_message_attachment(dialog_id, import_id, file_id, true, std::move(promise), {-1});
    return;
  }
  CHECK(input_file != nullptr);

  auto suggested_path = file_view.suggested_path();
  const PathView path_view(suggested_path);
  td_->create_handler<UploadImportedMediaQuery>(std::move(promise))
      ->send(dialog_id, import_id, path_view.file_name().str(), file_id,
             get_fake_input_media(td_, std::move(input_file), file_id));
}

void MessagesManager::on_upload_imported_message_attachment_error(FileId file_id, Status status) {
  if (G()->close_flag()) {
    // do not fail upload if closing
    return;
  }

  LOG(INFO) << "File " << file_id << " has upload error " << status;
  CHECK(status.is_error());

  auto it = being_uploaded_imported_message_attachments_.find(file_id);
  if (it == being_uploaded_imported_message_attachments_.end()) {
    // just in case, as in on_upload_media_error
    return;
  }

  Promise<Unit> promise = std::move(it->second->promise);

  being_uploaded_imported_message_attachments_.erase(it);

  promise.set_error(std::move(status));
}

void MessagesManager::before_get_difference() {
  running_get_difference_ = true;

  // scheduled messages are not returned in getDifference, so we must always reget them after it
  scheduled_messages_sync_generation_++;
}

void MessagesManager::after_get_difference() {
  CHECK(!td_->updates_manager_->running_get_difference());

  running_get_difference_ = false;

  if (!pending_on_get_dialogs_.empty()) {
    LOG(INFO) << "Apply postponed results of getDialogs";
    for (auto &res : pending_on_get_dialogs_) {
      on_get_dialogs(res.folder_id, std::move(res.dialogs), res.total_count, std::move(res.messages),
                     std::move(res.promise));
    }
    pending_on_get_dialogs_.clear();
  }

  if (!postponed_chat_read_inbox_updates_.empty()) {
    LOG(INFO) << "Send postponed chat read inbox updates";
    auto dialog_ids = std::move(postponed_chat_read_inbox_updates_);
    for (auto dialog_id : dialog_ids) {
      send_update_chat_read_inbox(get_dialog(dialog_id), false, "after_get_difference");
    }
  }
  while (!postponed_unread_message_count_updates_.empty()) {
    auto *list = get_dialog_list(*postponed_unread_message_count_updates_.begin());
    CHECK(list != nullptr);
    send_update_unread_message_count(*list, DialogId(), true, "after_get_difference");
  }
  while (!postponed_unread_chat_count_updates_.empty()) {
    auto *list = get_dialog_list(*postponed_unread_chat_count_updates_.begin());
    CHECK(list != nullptr);
    send_update_unread_chat_count(*list, DialogId(), true, "after_get_difference");
  }

  vector<FullMessageId> update_message_ids_to_delete;
  for (auto &it : update_message_ids_) {
    // there can be unhandled updateMessageId updates after getDifference even for ordinary chats,
    // because despite updates coming during getDifference have already been applied,
    // some of them could be postponed because of pts gap
    auto full_message_id = it.first;
    auto dialog_id = full_message_id.get_dialog_id();
    auto message_id = full_message_id.get_message_id();
    CHECK(message_id.is_valid());
    CHECK(message_id.is_server());
    switch (dialog_id.get_type()) {
      case DialogType::Channel:
        // get channel difference may prevent updates from being applied
        if (running_get_channel_difference(dialog_id)) {
          break;
        }
      // fallthrough
      case DialogType::User:
      case DialogType::Chat: {
        if (!have_message_force({dialog_id, it.second}, "after get difference")) {
          // The sent message has already been deleted by the user or sent to inaccessible channel.
          // The sent message may never be received, but we will need updateMessageId in case the message is received
          // to delete it from the server and not add to the chat.
          // But if the chat is inaccessible or the message is in an inaccessible chat part, then we will not be able to
          // add the message or delete it from the server. In this case we forget updateMessageId for such messages in
          // order to not check them over and over.
          const Dialog *d = get_dialog(dialog_id);
          if (!have_input_peer(dialog_id, AccessRights::Read) ||
              (d != nullptr &&
               message_id <= td::max(d->last_clear_history_message_id, d->max_unavailable_message_id))) {
            update_message_ids_to_delete.push_back(it.first);
          }
          break;
        }

        const Dialog *d = get_dialog(dialog_id);
        CHECK(d != nullptr);
        if (dialog_id.get_type() == DialogType::Channel || message_id <= d->last_new_message_id) {
          LOG(ERROR) << "Receive updateMessageId from " << it.second << " to " << full_message_id
                     << " but not receive corresponding message, last_new_message_id = " << d->last_new_message_id;
        }
        if (dialog_id.get_type() != DialogType::Channel && message_id <= d->last_new_message_id) {
          dump_debug_message_op(get_dialog(dialog_id));
        }
        if (message_id <= d->last_new_message_id) {
          get_message_from_server(it.first, PromiseCreator::lambda([this, full_message_id](Result<Unit> result) {
                                    if (result.is_error()) {
                                      LOG(WARNING)
                                          << "Failed to get missing " << full_message_id << ": " << result.error();
                                    } else {
                                      LOG(WARNING) << "Successfully get missing " << full_message_id << ": "
                                                   << to_string(get_message_object(full_message_id));
                                    }
                                  }));
        } else if (dialog_id.get_type() == DialogType::Channel) {
          LOG(INFO) << "Schedule getDifference in " << dialog_id.get_channel_id();
          channel_get_difference_retry_timeout_.add_timeout_in(dialog_id.get(), 0.001);
        }
        break;
      }
      case DialogType::SecretChat:
        break;
      case DialogType::None:
      default:
        UNREACHABLE();
        break;
    }
  }
  for (auto full_message_id : update_message_ids_to_delete) {
    update_message_ids_.erase(full_message_id);
  }

  if (!td_->auth_manager_->is_bot()) {
    if (!G()->td_db()->get_binlog_pmc()->isset("fetched_marks_as_unread")) {
      td_->create_handler<GetDialogUnreadMarksQuery>()->send();
    }

    load_notification_settings();

    auto dialog_list_id = DialogListId(FolderId::archive());
    auto *list = get_dialog_list(dialog_list_id);
    CHECK(list != nullptr);
    if (!list->is_dialog_unread_count_inited_) {
      get_dialogs(dialog_list_id, MIN_DIALOG_DATE, static_cast<int32>(list->pinned_dialogs_.size() + 2), false,
                  PromiseCreator::lambda([dialog_list_id](Unit) {
                    if (!G()->close_flag()) {
                      LOG(INFO) << "Inited total chat count in " << dialog_list_id;
                    }
                  }));
    }
  }
}

void MessagesManager::on_get_empty_messages(DialogId dialog_id, vector<MessageId> empty_message_ids) {
  if (!empty_message_ids.empty()) {
    delete_dialog_messages(dialog_id, std::move(empty_message_ids), true, true);
  }
}

MessagesManager::MessagesInfo MessagesManager::on_get_messages(
    tl_object_ptr<telegram_api::messages_Messages> &&messages_ptr, const char *source) {
  CHECK(messages_ptr != nullptr);
  LOG(DEBUG) << "Receive result for " << source << ": " << to_string(messages_ptr);

  vector<tl_object_ptr<telegram_api::User>> users;
  vector<tl_object_ptr<telegram_api::Chat>> chats;
  MessagesInfo result;
  switch (messages_ptr->get_id()) {
    case telegram_api::messages_messages::ID: {
      auto messages = move_tl_object_as<telegram_api::messages_messages>(messages_ptr);

      users = std::move(messages->users_);
      chats = std::move(messages->chats_);
      result.total_count = narrow_cast<int32>(messages->messages_.size());
      result.messages = std::move(messages->messages_);
      break;
    }
    case telegram_api::messages_messagesSlice::ID: {
      auto messages = move_tl_object_as<telegram_api::messages_messagesSlice>(messages_ptr);

      users = std::move(messages->users_);
      chats = std::move(messages->chats_);
      result.total_count = messages->count_;
      result.messages = std::move(messages->messages_);
      break;
    }
    case telegram_api::messages_channelMessages::ID: {
      auto messages = move_tl_object_as<telegram_api::messages_channelMessages>(messages_ptr);

      users = std::move(messages->users_);
      chats = std::move(messages->chats_);
      result.total_count = messages->count_;
      result.messages = std::move(messages->messages_);
      result.is_channel_messages = true;
      break;
    }
    case telegram_api::messages_messagesNotModified::ID:
      LOG(ERROR) << "Server returned messagesNotModified in response to " << source;
      break;
    default:
      UNREACHABLE();
      break;
  }

  td_->contacts_manager_->on_get_users(std::move(users), source);
  td_->contacts_manager_->on_get_chats(std::move(chats), source);

  return result;
}

void MessagesManager::get_channel_difference_if_needed(DialogId dialog_id, MessagesInfo &&messages_info,
                                                       Promise<MessagesInfo> &&promise) {
  for (auto &message : messages_info.messages) {
    if (need_channel_difference_to_add_message(dialog_id, message)) {
      return run_after_channel_difference(dialog_id,
                                          PromiseCreator::lambda([messages_info = std::move(messages_info),
                                                                  promise = std::move(promise)](Unit ignored) mutable {
                                            if (G()->close_flag()) {
                                              return promise.set_error(Status::Error(500, "Request aborted"));
                                            }
                                            promise.set_value(std::move(messages_info));
                                          }));
    }
  }
  promise.set_value(std::move(messages_info));
}

void MessagesManager::on_get_messages(vector<tl_object_ptr<telegram_api::Message>> &&messages, bool is_channel_message,
                                      bool is_scheduled, const char *source) {
  LOG(DEBUG) << "Receive " << messages.size() << " messages";
  for (auto &message : messages) {
    on_get_message(std::move(message), false, is_channel_message, is_scheduled, false, false, source);
  }
}

void MessagesManager::on_get_history(DialogId dialog_id, MessageId from_message_id, int32 offset, int32 limit,
                                     bool from_the_end, vector<tl_object_ptr<telegram_api::Message>> &&messages) {
  LOG(INFO) << "Receive " << messages.size() << " history messages " << (from_the_end ? "from the end " : "") << "in "
            << dialog_id << " from " << from_message_id << " with offset " << offset << " and limit " << limit;
  CHECK(-limit < offset && offset <= 0);
  CHECK(offset < 0 || from_the_end);
  CHECK(!from_message_id.is_scheduled());

  // the server can return less messages than requested if some of messages are deleted during request
  // but if it happens, it is likely that there are no more messages on the server
  bool have_full_history = from_the_end && narrow_cast<int32>(messages.size()) < limit && messages.size() <= 1;
  Dialog *d = get_dialog(dialog_id);

  if (messages.empty()) {
    if (d != nullptr) {
      if (have_full_history) {
        d->have_full_history = true;
        on_dialog_updated(dialog_id, "set have_full_history");
      }

      if (from_the_end && d->have_full_history && d->messages == nullptr && !d->last_database_message_id.is_valid()) {
        set_dialog_is_empty(d, "on_get_history empty");
      }
    }

    // be aware that in some cases an empty answer may be returned, because of the race of getHistory and deleteMessages
    // and not because there are no more messages
    return;
  }

  {
    // check that messages are received in decreasing message_id order
    MessageId cur_message_id = MessageId::max();
    for (const auto &message : messages) {
      MessageId message_id = get_message_id(message, false);
      if (message_id >= cur_message_id) {
        string error = PSTRING() << "Receive messages in the wrong order in history of " << dialog_id << " from "
                                 << from_message_id << " with offset " << offset << ", limit " << limit
                                 << ", from_the_end = " << from_the_end << ": ";
        for (const auto &debug_message : messages) {
          error += to_string(debug_message);
        }
        // TODO move to ERROR
        LOG(FATAL) << error;
        return;
      }
      cur_message_id = message_id;
    }
  }

  // be aware that dialog may not yet exist
  // be aware that returned messages are guaranteed to be consecutive messages, but if !from_the_end they
  // may be older (if some messages was deleted) or newer (if some messages were added) than an expected answer
  // be aware that any subset of the returned messages may be already deleted and returned as MessageEmpty
  bool is_channel_message = dialog_id.get_type() == DialogType::Channel;
  MessageId first_added_message_id;
  MessageId last_received_message_id = get_message_id(messages[0], false);
  MessageId last_added_message_id;
  bool have_next = false;

  if (narrow_cast<int32>(messages.size()) < limit + offset && messages.size() <= 1 && d != nullptr) {
    MessageId first_received_message_id = get_message_id(messages.back(), false);
    if (first_received_message_id >= from_message_id && d->first_database_message_id.is_valid() &&
        first_received_message_id >= d->first_database_message_id) {
      // it is likely that there are no more history messages on the server
      have_full_history = true;
    }
  }

  bool prev_have_full_history = false;
  MessageId prev_last_new_message_id;
  MessageId prev_first_database_message_id;
  MessageId prev_last_database_message_id;
  MessageId prev_last_message_id;
  if (d != nullptr) {
    prev_last_new_message_id = d->last_new_message_id;
    prev_first_database_message_id = d->first_database_message_id;
    prev_last_database_message_id = d->last_database_message_id;
    prev_last_message_id = d->last_message_id;
    prev_have_full_history = d->have_full_history;
  }

  if (from_the_end && d != nullptr) {
    auto last_server_message_id = get_message_id(messages[0], false);
    // delete all server messages with ID > last_server_message_id
    vector<MessageId> message_ids;
    find_newer_messages(d->messages.get(), last_server_message_id, message_ids);
    if (!message_ids.empty()) {
      bool need_update_dialog_pos = false;
      vector<int64> deleted_message_ids;
      for (auto message_id : message_ids) {
        CHECK(message_id > last_server_message_id);
        if (message_id.is_server()) {
          auto message = delete_message(d, message_id, true, &need_update_dialog_pos, "on_get_gistory 1");
          CHECK(message != nullptr);
          deleted_message_ids.push_back(message->message_id.get());
        }
      }
      if (need_update_dialog_pos) {
        send_update_chat_last_message(d, "on_get_gistory 2");
      }

      if (!deleted_message_ids.empty()) {
        send_update_delete_messages(dialog_id, std::move(deleted_message_ids), true, false);

        message_ids.clear();
        find_newer_messages(d->messages.get(), last_server_message_id, message_ids);
      }

      // connect all messages with ID > last_server_message_id
      for (size_t i = 0; i + 1 < message_ids.size(); i++) {
        auto m = get_message(d, message_ids[i]);
        CHECK(m != nullptr);
        if (!m->have_next) {
          m->have_next = true;
          attach_message_to_next(d, message_ids[i], "on_get_history 3");
        }
      }
    }
  }

  for (auto &message : messages) {
    if (!have_next && from_the_end && d != nullptr && get_message_id(message, false) < d->last_message_id) {
      // last message in the dialog should be attached to the next message if there is some
      have_next = true;
    }

    auto message_dialog_id = get_message_dialog_id(message);
    if (message_dialog_id != dialog_id) {
      LOG(ERROR) << "Receive " << get_message_id(message, false) << " in wrong " << message_dialog_id << " instead of "
                 << dialog_id << ": " << oneline(to_string(message));
      continue;
    }

    auto full_message_id =
        on_get_message(std::move(message), false, is_channel_message, false, false, have_next, "get history");
    auto message_id = full_message_id.get_message_id();
    if (message_id.is_valid()) {
      if (!last_added_message_id.is_valid()) {
        last_added_message_id = message_id;
      }

      if (!have_next) {
        if (d == nullptr) {
          d = get_dialog(dialog_id);
          CHECK(d != nullptr);
        }
        have_next = true;
      } else if (first_added_message_id.is_valid()) {
        Message *next_message = get_message(d, first_added_message_id);
        CHECK(next_message != nullptr);
        if (!next_message->have_previous) {
          LOG(INFO) << "Fix have_previous for " << first_added_message_id;
          next_message->have_previous = true;
          attach_message_to_previous(d, first_added_message_id, "on_get_history");
        }
      }
      first_added_message_id = message_id;
      if (!message_id.is_yet_unsent()) {
        // message should be already saved to database in on_get_message
        // add_message_to_database(d, get_message(d, message_id), "on_get_history");
      }
    }
  }

  if (d == nullptr) {
    return;
  }

  if (have_full_history) {
    d->have_full_history = true;
    on_dialog_updated(dialog_id, "set have_full_history 2");
  }

  //  LOG_IF(ERROR, d->first_message_id.is_valid() && d->first_message_id > first_received_message_id)
  //      << "Receive " << first_received_message_id << ", but first chat message is " << d->first_message_id;

  bool intersect_last_database_message_ids =
      last_added_message_id >= d->first_database_message_id && d->last_database_message_id >= first_added_message_id;
  bool need_update_database_message_ids =
      last_added_message_id.is_valid() && (from_the_end || intersect_last_database_message_ids);
  if (from_the_end) {
    if (!d->last_new_message_id.is_valid()) {
      set_dialog_last_new_message_id(
          d, last_added_message_id.is_valid() ? last_added_message_id : last_received_message_id, "on_get_history");
    }
    if (last_added_message_id.is_valid() && last_added_message_id > d->last_message_id) {
      CHECK(d->last_new_message_id.is_valid());
      set_dialog_last_message_id(d, last_added_message_id, "on_get_history");
      send_update_chat_last_message(d, "on_get_history");
    }
  }

  if (need_update_database_message_ids) {
    if (from_the_end && !intersect_last_database_message_ids && d->last_database_message_id.is_valid()) {
      if (d->last_database_message_id < first_added_message_id || last_added_message_id == d->last_message_id) {
        set_dialog_first_database_message_id(d, MessageId(), "on_get_history 1");
        set_dialog_last_database_message_id(d, MessageId(), "on_get_history 1");
      } else {
        auto min_message_id = td::min(d->first_database_message_id, d->last_message_id);
        CHECK(last_added_message_id < min_message_id);
        if (min_message_id <= last_added_message_id.get_next_message_id(MessageType::Server)) {
          // connect local messages with last received server message
          set_dialog_first_database_message_id(d, last_added_message_id, "on_get_history 2");
        } else {
          LOG(WARNING) << "Have last " << d->last_message_id << " and first database " << d->first_database_message_id
                       << " in " << dialog_id << ", but received history from the end only up to "
                       << last_added_message_id;
          // can't connect messages, because there can be unknown server messages after last_added_message_id
        }
      }
    }
    if (!d->last_database_message_id.is_valid()) {
      CHECK(d->last_message_id.is_valid());
      MessagesConstIterator it(d, d->last_message_id);
      MessageId new_first_database_message_id;
      while (*it != nullptr) {
        auto message_id = (*it)->message_id;
        if (message_id.is_server() || message_id.is_local()) {
          if (!d->last_database_message_id.is_valid()) {
            set_dialog_last_database_message_id(d, message_id, "on_get_history");
          }
          new_first_database_message_id = message_id;
          try_restore_dialog_reply_markup(d, *it);
        }
        --it;
      }
      if (new_first_database_message_id.is_valid()) {
        set_dialog_first_database_message_id(d, new_first_database_message_id, "on_get_history");
      }
    } else {
      LOG_CHECK(d->last_new_message_id.is_valid())
          << dialog_id << " " << from_the_end << " " << d->first_database_message_id << " "
          << d->last_database_message_id << " " << first_added_message_id << " " << last_added_message_id << " "
          << d->last_message_id << " " << d->last_new_message_id << " " << d->have_full_history << " "
          << prev_last_new_message_id << " " << prev_first_database_message_id << " " << prev_last_database_message_id
          << " " << prev_last_message_id << " " << prev_have_full_history << " " << d->debug_last_new_message_id << " "
          << d->debug_first_database_message_id << " " << d->debug_last_database_message_id << " " << from_message_id
          << " " << offset << " " << limit << " " << messages.size() << " " << last_received_message_id << " "
          << d->debug_set_dialog_last_database_message_id;
      CHECK(d->first_database_message_id.is_valid());
      {
        MessagesConstIterator it(d, d->first_database_message_id);
        if (*it != nullptr && ((*it)->message_id == d->first_database_message_id || (*it)->have_next)) {
          MessageId new_first_database_message_id = d->first_database_message_id;
          while (*it != nullptr) {
            auto message_id = (*it)->message_id;
            if ((message_id.is_server() || message_id.is_local()) && message_id < new_first_database_message_id) {
              new_first_database_message_id = message_id;
              try_restore_dialog_reply_markup(d, *it);
            }
            --it;
          }
          if (new_first_database_message_id != d->first_database_message_id) {
            set_dialog_first_database_message_id(d, new_first_database_message_id, "on_get_history 2");
          }
        }
      }
      {
        MessagesConstIterator it(d, d->last_database_message_id);
        if (*it != nullptr && ((*it)->message_id == d->last_database_message_id || (*it)->have_next)) {
          MessageId new_last_database_message_id = d->last_database_message_id;
          while (*it != nullptr) {
            auto message_id = (*it)->message_id;
            if ((message_id.is_server() || message_id.is_local()) && message_id > new_last_database_message_id) {
              new_last_database_message_id = message_id;
            }
            ++it;
          }
          if (new_last_database_message_id != d->last_database_message_id) {
            set_dialog_last_database_message_id(d, new_last_database_message_id, "on_get_history 2");
          }
        }
      }
    }
    LOG_CHECK(d->first_database_message_id.is_valid())
        << dialog_id << " " << from_the_end << " " << d->first_database_message_id << " " << d->last_database_message_id
        << " " << first_added_message_id << " " << last_added_message_id << " " << d->last_message_id << " "
        << d->last_new_message_id << " " << d->have_full_history << " " << prev_last_new_message_id << " "
        << prev_first_database_message_id << " " << prev_last_database_message_id << " " << prev_last_message_id << " "
        << prev_have_full_history << " " << d->debug_last_new_message_id << " " << d->debug_first_database_message_id
        << " " << d->debug_last_database_message_id << " " << from_message_id << " " << offset << " " << limit << " "
        << messages.size() << " " << last_received_message_id << " " << d->debug_set_dialog_last_database_message_id;

    CHECK(d->last_database_message_id.is_valid());

    for (auto &first_message_id : d->first_database_message_id_by_index) {
      if (first_added_message_id < first_message_id && first_message_id <= last_added_message_id) {
        first_message_id = first_added_message_id;
      }
    }
  }
}

vector<DialogId> MessagesManager::get_peers_dialog_ids(vector<tl_object_ptr<telegram_api::Peer>> &&peers) {
  vector<DialogId> result;
  result.reserve(peers.size());
  for (auto &peer : peers) {
    DialogId dialog_id(peer);
    if (dialog_id.is_valid()) {
      force_create_dialog(dialog_id, "get_peers_dialog_ids");
      result.push_back(dialog_id);
    }
  }
  return result;
}

void MessagesManager::on_get_public_dialogs_search_result(const string &query,
                                                          vector<tl_object_ptr<telegram_api::Peer>> &&my_peers,
                                                          vector<tl_object_ptr<telegram_api::Peer>> &&peers) {
  auto it = search_public_dialogs_queries_.find(query);
  CHECK(it != search_public_dialogs_queries_.end());
  CHECK(!it->second.empty());
  auto promises = std::move(it->second);
  search_public_dialogs_queries_.erase(it);

  found_public_dialogs_[query] = get_peers_dialog_ids(std::move(peers));
  found_on_server_dialogs_[query] = get_peers_dialog_ids(std::move(my_peers));

  for (auto &promise : promises) {
    promise.set_value(Unit());
  }
}

void MessagesManager::on_failed_public_dialogs_search(const string &query, Status &&error) {
  auto it = search_public_dialogs_queries_.find(query);
  CHECK(it != search_public_dialogs_queries_.end());
  CHECK(!it->second.empty());
  auto promises = std::move(it->second);
  search_public_dialogs_queries_.erase(it);

  found_public_dialogs_[query];     // negative cache
  found_on_server_dialogs_[query];  // negative cache

  for (auto &promise : promises) {
    promise.set_error(error.clone());
  }
}

void MessagesManager::on_get_dialog_messages_search_result(DialogId dialog_id, const string &query,
                                                           DialogId sender_dialog_id, MessageId from_message_id,
                                                           int32 offset, int32 limit, MessageSearchFilter filter,
                                                           MessageId top_thread_message_id, int64 random_id,
                                                           int32 total_count,
                                                           vector<tl_object_ptr<telegram_api::Message>> &&messages) {
  LOG(INFO) << "Receive " << messages.size() << " found messages in " << dialog_id;
  if (!dialog_id.is_valid()) {
    CHECK(query.empty());
    CHECK(!sender_dialog_id.is_valid());
    CHECK(!top_thread_message_id.is_valid());
    auto it = found_call_messages_.find(random_id);
    CHECK(it != found_call_messages_.end());

    MessageId first_added_message_id;
    if (messages.empty()) {
      // messages may be empty because there are no more messages or they can't be found due to global limit
      // anyway pretend that there are no more messages
      first_added_message_id = MessageId::min();
    }

    auto &result = it->second.second;
    CHECK(result.empty());
    int32 added_message_count = 0;
    for (auto &message : messages) {
      auto new_full_message_id =
          on_get_message(std::move(message), false, false, false, false, false, "search call messages");
      if (new_full_message_id != FullMessageId()) {
        result.push_back(new_full_message_id);
        added_message_count++;
      }

      auto message_id = new_full_message_id.get_message_id();
      if (message_id < first_added_message_id || !first_added_message_id.is_valid()) {
        first_added_message_id = message_id;
      }
    }
    if (total_count < added_message_count) {
      LOG(ERROR) << "Receive total_count = " << total_count << ", but added " << added_message_count
                 << " messages out of " << messages.size();
      total_count = added_message_count;
    }
    if (G()->parameters().use_message_db) {
      bool update_state = false;

      auto &old_message_count = calls_db_state_.message_count_by_index[call_message_search_filter_index(filter)];
      if (old_message_count != total_count) {
        LOG(INFO) << "Update calls database message count to " << total_count;
        old_message_count = total_count;
        update_state = true;
      }

      auto &old_first_db_message_id =
          calls_db_state_.first_calls_database_message_id_by_index[call_message_search_filter_index(filter)];
      bool from_the_end = !from_message_id.is_valid() || from_message_id >= MessageId::max();
      LOG(INFO) << "Have from_the_end = " << from_the_end << ", old_first_db_message_id = " << old_first_db_message_id
                << ", first_added_message_id = " << first_added_message_id << ", from_message_id = " << from_message_id;
      if ((from_the_end || (old_first_db_message_id.is_valid() && old_first_db_message_id <= from_message_id)) &&
          (!old_first_db_message_id.is_valid() || first_added_message_id < old_first_db_message_id)) {
        LOG(INFO) << "Update calls database first message to " << first_added_message_id;
        old_first_db_message_id = first_added_message_id;
        update_state = true;
      }
      if (update_state) {
        save_calls_db_state();
      }
    }
    it->second.first = total_count;
    return;
  }

  auto it = found_dialog_messages_.find(random_id);
  CHECK(it != found_dialog_messages_.end());

  auto &result = it->second.second;
  CHECK(result.empty());
  MessageId first_added_message_id;
  if (messages.empty()) {
    // messages may be empty because there are no more messages or they can't be found due to global limit
    // anyway pretend that there are no more messages
    first_added_message_id = MessageId::min();
  }
  bool can_be_in_different_dialog = top_thread_message_id.is_valid() && is_broadcast_channel(dialog_id);
  DialogId real_dialog_id;
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  for (auto &message : messages) {
    auto new_full_message_id = on_get_message(std::move(message), false, dialog_id.get_type() == DialogType::Channel,
                                              false, false, false, "SearchMessagesQuery");
    if (new_full_message_id == FullMessageId()) {
      total_count--;
      continue;
    }

    if (new_full_message_id.get_dialog_id() != dialog_id) {
      if (!can_be_in_different_dialog) {
        LOG(ERROR) << "Receive " << new_full_message_id << " instead of a message in " << dialog_id;
        total_count--;
        continue;
      } else {
        if (!real_dialog_id.is_valid()) {
          real_dialog_id = new_full_message_id.get_dialog_id();
          found_dialog_messages_dialog_id_[random_id] = real_dialog_id;
        } else if (new_full_message_id.get_dialog_id() != real_dialog_id) {
          LOG(ERROR) << "Receive " << new_full_message_id << " instead of a message in " << real_dialog_id << " or "
                     << dialog_id;
          total_count--;
          continue;
        }
      }
    }

    auto message_id = new_full_message_id.get_message_id();
    if (filter == MessageSearchFilter::UnreadMention && message_id <= d->last_read_all_mentions_message_id &&
        !real_dialog_id.is_valid()) {
      total_count--;
      continue;
    }

    // TODO check that messages are returned in decreasing message_id order
    if (message_id < first_added_message_id || !first_added_message_id.is_valid()) {
      first_added_message_id = message_id;
    }
    result.push_back(message_id);
  }
  if (total_count < static_cast<int32>(result.size())) {
    LOG(ERROR) << "Receive " << result.size() << " valid messages out of " << total_count << " in " << messages.size()
               << " messages";
    total_count = static_cast<int32>(result.size());
  }
  if (query.empty() && !sender_dialog_id.is_valid() && filter != MessageSearchFilter::Empty &&
      !top_thread_message_id.is_valid()) {
    bool from_the_end = !from_message_id.is_valid() ||
                        (d->last_message_id != MessageId() && from_message_id > d->last_message_id) ||
                        from_message_id >= MessageId::max();
    if (G()->parameters().use_message_db) {
      bool update_dialog = false;

      auto &old_message_count = d->message_count_by_index[message_search_filter_index(filter)];
      if (old_message_count != total_count) {
        old_message_count = total_count;
        if (filter == MessageSearchFilter::UnreadMention) {
          d->unread_mention_count = old_message_count;
          update_dialog_mention_notification_count(d);
          send_update_chat_unread_mention_count(d);
        }
        update_dialog = true;
      }

      auto &old_first_db_message_id = d->first_database_message_id_by_index[message_search_filter_index(filter)];
      if ((from_the_end || (old_first_db_message_id.is_valid() && old_first_db_message_id <= from_message_id)) &&
          (!old_first_db_message_id.is_valid() || first_added_message_id < old_first_db_message_id)) {
        old_first_db_message_id = first_added_message_id;
        update_dialog = true;
      }
      if (update_dialog) {
        on_dialog_updated(dialog_id, "search results");
      }
    }

    if (from_the_end && filter == MessageSearchFilter::Pinned) {
      set_dialog_last_pinned_message_id(d, result.empty() ? MessageId() : result[0]);
    }
  }

  it->second.first = total_count;
}

void MessagesManager::on_failed_dialog_messages_search(DialogId dialog_id, int64 random_id) {
  if (!dialog_id.is_valid()) {
    auto it = found_call_messages_.find(random_id);
    CHECK(it != found_call_messages_.end());
    found_call_messages_.erase(it);
    return;
  }

  auto it = found_dialog_messages_.find(random_id);
  CHECK(it != found_dialog_messages_.end());
  found_dialog_messages_.erase(it);
}

void MessagesManager::on_get_messages_search_result(const string &query, int32 offset_date, DialogId offset_dialog_id,
                                                    MessageId offset_message_id, int32 limit,
                                                    MessageSearchFilter filter, int32 min_date, int32 max_date,
                                                    int64 random_id, int32 total_count,
                                                    vector<tl_object_ptr<telegram_api::Message>> &&messages) {
  LOG(INFO) << "Receive " << messages.size() << " found messages";
  auto it = found_messages_.find(random_id);
  CHECK(it != found_messages_.end());

  auto &result = it->second.second;
  CHECK(result.empty());
  for (auto &message : messages) {
    auto dialog_id = get_message_dialog_id(message);
    auto new_full_message_id = on_get_message(std::move(message), false, dialog_id.get_type() == DialogType::Channel,
                                              false, false, false, "search messages");
    if (new_full_message_id != FullMessageId()) {
      CHECK(dialog_id == new_full_message_id.get_dialog_id());
      result.push_back(new_full_message_id);
    } else {
      total_count--;
    }
  }
  if (total_count < static_cast<int32>(result.size())) {
    LOG(ERROR) << "Receive " << result.size() << " valid messages out of " << total_count << " in " << messages.size()
               << " messages";
    total_count = static_cast<int32>(result.size());
  }
  it->second.first = total_count;
}

void MessagesManager::on_failed_messages_search(int64 random_id) {
  auto it = found_messages_.find(random_id);
  CHECK(it != found_messages_.end());
  found_messages_.erase(it);
}

void MessagesManager::on_get_scheduled_server_messages(DialogId dialog_id, uint32 generation,
                                                       vector<tl_object_ptr<telegram_api::Message>> &&messages,
                                                       bool is_not_modified) {
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  if (generation < d->scheduled_messages_sync_generation) {
    LOG(INFO) << "Ignore scheduled messages with old generation " << generation << " instead of "
              << d->scheduled_messages_sync_generation << " in " << dialog_id;
    return;
  }
  d->scheduled_messages_sync_generation = generation;

  if (is_not_modified) {
    LOG(INFO) << "Scheduled messages are mot modified in " << dialog_id;
    return;
  }

  vector<MessageId> old_message_ids;
  find_old_messages(d->scheduled_messages.get(),
                    MessageId(ScheduledServerMessageId(), std::numeric_limits<int32>::max(), true), old_message_ids);
  std::unordered_map<ScheduledServerMessageId, MessageId, ScheduledServerMessageIdHash> old_server_message_ids;
  for (auto &message_id : old_message_ids) {
    if (message_id.is_scheduled_server()) {
      old_server_message_ids[message_id.get_scheduled_server_message_id()] = message_id;
    }
  }

  bool is_channel_message = dialog_id.get_type() == DialogType::Channel;
  bool has_scheduled_server_messages = false;
  for (auto &message : messages) {
    auto message_dialog_id = get_message_dialog_id(message);
    if (message_dialog_id != dialog_id) {
      LOG(ERROR) << "Receive " << get_message_id(message, true) << " in wrong " << message_dialog_id << " instead of "
                 << dialog_id << ": " << oneline(to_string(message));
      continue;
    }

    auto full_message_id = on_get_message(std::move(message), d->sent_scheduled_messages, is_channel_message, true,
                                          false, false, "on_get_scheduled_server_messages");
    auto message_id = full_message_id.get_message_id();
    if (message_id.is_valid_scheduled()) {
      CHECK(message_id.is_scheduled_server());
      old_server_message_ids.erase(message_id.get_scheduled_server_message_id());
      has_scheduled_server_messages = true;
    }
  }
  on_update_dialog_has_scheduled_server_messages(dialog_id, has_scheduled_server_messages);

  for (auto it : old_server_message_ids) {
    auto message_id = it.second;
    auto message = do_delete_scheduled_message(d, message_id, true, "on_get_scheduled_server_messages");
    CHECK(message != nullptr);
    send_update_delete_messages(dialog_id, {message->message_id.get()}, true, false);
  }

  send_update_chat_has_scheduled_messages(d, false);
}

void MessagesManager::on_get_recent_locations(DialogId dialog_id, int32 limit, int64 random_id, int32 total_count,
                                              vector<tl_object_ptr<telegram_api::Message>> &&messages) {
  LOG(INFO) << "Receive " << messages.size() << " recent locations in " << dialog_id;
  auto it = found_dialog_recent_location_messages_.find(random_id);
  CHECK(it != found_dialog_recent_location_messages_.end());

  auto &result = it->second.second;
  CHECK(result.empty());
  for (auto &message : messages) {
    auto new_full_message_id = on_get_message(std::move(message), false, dialog_id.get_type() == DialogType::Channel,
                                              false, false, false, "get recent locations");
    if (new_full_message_id != FullMessageId()) {
      if (new_full_message_id.get_dialog_id() != dialog_id) {
        LOG(ERROR) << "Receive " << new_full_message_id << " instead of a message in " << dialog_id;
        total_count--;
        continue;
      }
      auto m = get_message(new_full_message_id);
      CHECK(m != nullptr);
      if (m->content->get_type() != MessageContentType::LiveLocation) {
        LOG(ERROR) << "Receive a message of wrong type " << m->content->get_type() << " in on_get_recent_locations in "
                   << dialog_id;
        total_count--;
        continue;
      }

      result.push_back(m->message_id);
    } else {
      total_count--;
    }
  }
  if (total_count < static_cast<int32>(result.size())) {
    LOG(ERROR) << "Receive " << result.size() << " valid messages out of " << total_count << " in " << messages.size()
               << " messages";
    total_count = static_cast<int32>(result.size());
  }
  it->second.first = total_count;
}

void MessagesManager::on_get_recent_locations_failed(int64 random_id) {
  auto it = found_dialog_recent_location_messages_.find(random_id);
  CHECK(it != found_dialog_recent_location_messages_.end());
  found_dialog_recent_location_messages_.erase(it);
}

void MessagesManager::on_get_message_public_forwards_result(int64 random_id, int32 total_count,
                                                            vector<tl_object_ptr<telegram_api::Message>> &&messages) {
  LOG(INFO) << "Receive " << messages.size() << " forwarded messages";
  auto it = found_message_public_forwards_.find(random_id);
  CHECK(it != found_message_public_forwards_.end());

  auto &result = it->second.full_message_ids;
  CHECK(result.empty());
  FullMessageId last_full_message_id;
  for (auto &message : messages) {
    auto dialog_id = get_message_dialog_id(message);
    auto new_full_message_id = on_get_message(std::move(message), false, dialog_id.get_type() == DialogType::Channel,
                                              false, false, false, "get message public forwards");
    if (new_full_message_id != FullMessageId()) {
      CHECK(dialog_id == new_full_message_id.get_dialog_id());
      result.push_back(new_full_message_id);
      last_full_message_id = new_full_message_id;
    } else {
      total_count--;
    }
  }
  if (total_count < static_cast<int32>(result.size())) {
    LOG(ERROR) << "Receive " << result.size() << " valid messages out of " << total_count << " in " << messages.size()
               << " messages";
    total_count = static_cast<int32>(result.size());
  }
  if (!result.empty()) {
    auto m = get_message(last_full_message_id);
    CHECK(m != nullptr);
    it->second.next_offset = PSTRING() << m->date << "," << last_full_message_id.get_dialog_id().get() << ","
                                       << m->message_id.get_server_message_id().get();
  }

  it->second.total_count = total_count;
}

void MessagesManager::on_failed_get_message_public_forwards(int64 random_id) {
  auto it = found_message_public_forwards_.find(random_id);
  CHECK(it != found_message_public_forwards_.end());
  found_message_public_forwards_.erase(it);
}

void MessagesManager::delete_messages_from_updates(const vector<MessageId> &message_ids) {
  std::unordered_map<DialogId, vector<int64>, DialogIdHash> deleted_message_ids;
  std::unordered_map<DialogId, bool, DialogIdHash> need_update_dialog_pos;
  for (auto message_id : message_ids) {
    if (!message_id.is_valid() || !message_id.is_server()) {
      LOG(ERROR) << "Incoming update tries to delete " << message_id;
      continue;
    }

    Dialog *d = get_dialog_by_message_id(message_id);
    if (d != nullptr) {
      auto message = delete_message(d, message_id, true, &need_update_dialog_pos[d->dialog_id], "updates");
      CHECK(message != nullptr);
      LOG_CHECK(message->message_id == message_id) << message_id << " " << message->message_id << " " << d->dialog_id;
      deleted_message_ids[d->dialog_id].push_back(message->message_id.get());
    }
    if (last_clear_history_message_id_to_dialog_id_.count(message_id)) {
      d = get_dialog(last_clear_history_message_id_to_dialog_id_[message_id]);
      CHECK(d != nullptr);
      auto message = delete_message(d, message_id, true, &need_update_dialog_pos[d->dialog_id], "updates");
      CHECK(message == nullptr);
    }
  }
  for (auto &it : need_update_dialog_pos) {
    if (it.second) {
      auto dialog_id = it.first;
      Dialog *d = get_dialog(dialog_id);
      CHECK(d != nullptr);
      send_update_chat_last_message(d, "delete_messages_from_updates");
    }
  }
  for (auto &it : deleted_message_ids) {
    auto dialog_id = it.first;
    send_update_delete_messages(dialog_id, std::move(it.second), true, false);
  }
}

void MessagesManager::delete_dialog_messages(DialogId dialog_id, const vector<MessageId> &message_ids,
                                             bool from_updates, bool skip_update_for_not_found_messages) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(INFO) << "Ignore deleteChannelMessages for unknown " << dialog_id;
    CHECK(from_updates);
    CHECK(dialog_id.get_type() == DialogType::Channel);
    return;
  }

  vector<int64> deleted_message_ids;
  bool need_update_dialog_pos = false;
  for (auto message_id : message_ids) {
    CHECK(!message_id.is_scheduled());
    if (from_updates) {
      if (!message_id.is_valid() || (!message_id.is_server() && dialog_id.get_type() != DialogType::SecretChat)) {
        LOG(ERROR) << "Incoming update tries to delete " << message_id;
        continue;
      }
    } else {
      CHECK(message_id.is_valid());
    }

    bool was_already_deleted = d->deleted_message_ids.count(message_id) != 0;
    auto message = delete_message(d, message_id, true, &need_update_dialog_pos, "delete_dialog_messages");
    if (message == nullptr) {
      if (!skip_update_for_not_found_messages && !was_already_deleted) {
        deleted_message_ids.push_back(message_id.get());
      }
    } else {
      deleted_message_ids.push_back(message->message_id.get());
    }
  }
  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "delete_dialog_messages");
  }
  send_update_delete_messages(dialog_id, std::move(deleted_message_ids), true, false);
}

void MessagesManager::update_dialog_pinned_messages_from_updates(DialogId dialog_id,
                                                                 const vector<MessageId> &message_ids, bool is_pin) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(INFO) << "Ignore updatePinnedMessages for unknown " << dialog_id;
    return;
  }

  for (auto message_id : message_ids) {
    if (!message_id.is_valid() || (!message_id.is_server() && dialog_id.get_type() != DialogType::SecretChat)) {
      LOG(ERROR) << "Incoming update tries to pin/unpin " << message_id << " in " << dialog_id;
      continue;
    }

    Message *m = get_message_force(d, message_id, "update_dialog_pinned_messages_from_updates");
    if (m != nullptr && update_message_is_pinned(d, m, is_pin, "update_dialog_pinned_messages_from_updates")) {
      on_message_changed(d, m, true, "update_dialog_pinned_messages_from_updates");
    }
  }
}

bool MessagesManager::update_message_is_pinned(Dialog *d, Message *m, bool is_pinned, const char *source) {
  CHECK(m != nullptr);
  CHECK(!m->message_id.is_scheduled());
  if (m->is_pinned == is_pinned) {
    return false;
  }

  LOG(INFO) << "Update message is_pinned of " << m->message_id << " in " << d->dialog_id << " to " << is_pinned
            << " from " << source;
  auto old_index_mask = get_message_index_mask(d->dialog_id, m);
  m->is_pinned = is_pinned;
  auto new_index_mask = get_message_index_mask(d->dialog_id, m);
  update_message_count_by_index(d, -1, old_index_mask & ~new_index_mask);
  update_message_count_by_index(d, +1, new_index_mask & ~old_index_mask);

  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateMessageIsPinned>(d->dialog_id.get(), m->message_id.get(), is_pinned));
  if (is_pinned) {
    if (d->is_last_pinned_message_id_inited && m->message_id > d->last_pinned_message_id) {
      on_update_dialog_last_pinned_message_id(d->dialog_id, m->message_id);
    }
  } else {
    if (d->is_last_pinned_message_id_inited && m->message_id == d->last_pinned_message_id) {
      if (d->message_count_by_index[message_search_filter_index(MessageSearchFilter::Pinned)] == 0) {
        set_dialog_last_pinned_message_id(d, MessageId());
      } else {
        drop_dialog_last_pinned_message_id(d);
      }
    }
  }
  return true;
}

string MessagesManager::get_message_search_text(const Message *m) const {
  if (m->is_content_secret) {
    return string();
  }
  return get_message_content_search_text(td_, m->content.get());
}

bool MessagesManager::can_forward_message(DialogId from_dialog_id, const Message *m) {
  if (m == nullptr) {
    return false;
  }
  if (m->ttl > 0) {
    return false;
  }
  if (m->message_id.is_scheduled()) {
    return false;
  }
  switch (from_dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::Channel:
      // ok
      break;
    case DialogType::SecretChat:
      return false;
    case DialogType::None:
    default:
      UNREACHABLE();
      return false;
  }

  return can_forward_message_content(m->content.get());
}

bool MessagesManager::can_get_message_statistics(FullMessageId full_message_id) {
  return can_get_message_statistics(full_message_id.get_dialog_id(),
                                    get_message_force(full_message_id, "can_get_message_statistics"));
}

bool MessagesManager::can_get_message_statistics(DialogId dialog_id, const Message *m) const {
  if (td_->auth_manager_->is_bot()) {
    return false;
  }
  if (m == nullptr || m->message_id.is_scheduled() || !m->message_id.is_server() || m->view_count == 0 ||
      m->had_forward_info || (m->forward_info != nullptr && m->forward_info->message_id.is_valid())) {
    return false;
  }
  return td_->contacts_manager_->can_get_channel_message_statistics(dialog_id);
}

bool MessagesManager::can_delete_channel_message(DialogParticipantStatus status, const Message *m, bool is_bot) {
  if (m == nullptr) {
    return true;
  }
  if (m->message_id.is_local() || m->message_id.is_yet_unsent()) {
    return true;
  }
  if (m->message_id.is_scheduled()) {
    if (m->is_channel_post) {
      return status.can_post_messages();
    }
    return true;
  }

  if (is_bot && G()->unix_time_cached() >= m->date + 2 * 86400) {
    // bots can't delete messages older than 2 days
    return false;
  }

  CHECK(m->message_id.is_server());
  if (m->message_id.get_server_message_id().get() == 1) {
    return false;
  }
  auto content_type = m->content->get_type();
  if (content_type == MessageContentType::ChannelMigrateFrom || content_type == MessageContentType::ChannelCreate) {
    return false;
  }

  if (status.can_delete_messages()) {
    return true;
  }

  if (!m->is_outgoing) {
    return false;
  }

  if (m->is_channel_post || is_service_message_content(content_type)) {
    return status.can_post_messages();
  }

  return true;
}

bool MessagesManager::can_delete_message(DialogId dialog_id, const Message *m) const {
  if (m == nullptr) {
    return true;
  }
  if (m->message_id.is_local() || m->message_id.is_yet_unsent()) {
    return true;
  }
  switch (dialog_id.get_type()) {
    case DialogType::User:
      return true;
    case DialogType::Chat:
      return true;
    case DialogType::Channel: {
      auto dialog_status = td_->contacts_manager_->get_channel_permissions(dialog_id.get_channel_id());
      return can_delete_channel_message(dialog_status, m, td_->auth_manager_->is_bot());
    }
    case DialogType::SecretChat:
      return true;
    case DialogType::None:
    default:
      UNREACHABLE();
      return false;
  }
}

bool MessagesManager::can_revoke_message(DialogId dialog_id, const Message *m) const {
  if (m == nullptr) {
    return true;
  }
  if (m->message_id.is_local()) {
    return false;
  }
  if (dialog_id == get_my_dialog_id()) {
    return false;
  }
  if (m->message_id.is_scheduled()) {
    return false;
  }
  if (m->message_id.is_yet_unsent()) {
    return true;
  }
  CHECK(m->message_id.is_server());

  const int32 DEFAULT_REVOKE_TIME_LIMIT = td_->auth_manager_->is_bot() ? 2 * 86400 : std::numeric_limits<int32>::max();
  auto content_type = m->content->get_type();
  switch (dialog_id.get_type()) {
    case DialogType::User: {
      bool can_revoke_incoming = G()->shared_config().get_option_boolean("revoke_pm_inbox", true);
      int64 revoke_time_limit =
          G()->shared_config().get_option_integer("revoke_pm_time_limit", DEFAULT_REVOKE_TIME_LIMIT);

      if (G()->unix_time_cached() - m->date < 86400 && content_type == MessageContentType::Dice) {
        return false;
      }
      return ((m->is_outgoing && !is_service_message_content(content_type)) ||
              (can_revoke_incoming && content_type != MessageContentType::ScreenshotTaken)) &&
             G()->unix_time_cached() - m->date <= revoke_time_limit;
    }
    case DialogType::Chat: {
      bool is_appointed_administrator =
          td_->contacts_manager_->is_appointed_chat_administrator(dialog_id.get_chat_id());
      int64 revoke_time_limit = G()->shared_config().get_option_integer("revoke_time_limit", DEFAULT_REVOKE_TIME_LIMIT);

      return ((m->is_outgoing && !is_service_message_content(content_type)) || is_appointed_administrator) &&
             G()->unix_time_cached() - m->date <= revoke_time_limit;
    }
    case DialogType::Channel:
      return true;  // any server message that can be deleted will be deleted for all participants
    case DialogType::SecretChat:
      // all non-service messages will be deleted for everyone if secret chat is active
      return td_->contacts_manager_->get_secret_chat_state(dialog_id.get_secret_chat_id()) == SecretChatState::Active &&
             !is_service_message_content(content_type);
    case DialogType::None:
    default:
      UNREACHABLE();
      return false;
  }
}

void MessagesManager::delete_messages(DialogId dialog_id, const vector<MessageId> &input_message_ids, bool revoke,
                                      Promise<Unit> &&promise) {
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(6, "Chat is not found"));
  }

  if (input_message_ids.empty()) {
    return promise.set_value(Unit());
  }

  auto dialog_type = dialog_id.get_type();
  bool is_secret = dialog_type == DialogType::SecretChat;

  vector<MessageId> message_ids;
  message_ids.reserve(input_message_ids.size());
  vector<MessageId> deleted_server_message_ids;

  vector<MessageId> deleted_scheduled_server_message_ids;
  for (auto message_id : input_message_ids) {
    if (!message_id.is_valid() && !message_id.is_valid_scheduled()) {
      return promise.set_error(Status::Error(6, "Invalid message identifier"));
    }

    message_id = get_persistent_message_id(d, message_id);
    message_ids.push_back(message_id);
    auto m = get_message_force(d, message_id, "delete_messages");
    if (m != nullptr) {
      if (m->message_id.is_scheduled()) {
        if (m->message_id.is_scheduled_server()) {
          deleted_scheduled_server_message_ids.push_back(m->message_id);
        }
      } else {
        if (m->message_id.is_server() || is_secret) {
          deleted_server_message_ids.push_back(m->message_id);
        }
      }
    }
  }

  bool is_bot = td_->auth_manager_->is_bot();
  for (auto message_id : message_ids) {
    auto m = get_message(d, message_id);
    if (!can_delete_message(dialog_id, m)) {
      return promise.set_error(Status::Error(6, "Message can't be deleted"));
    }
    if (is_bot && !message_id.is_scheduled() && message_id.is_server() && !can_revoke_message(dialog_id, m)) {
      return promise.set_error(Status::Error(6, "Message can't be deleted for everyone"));
    }
  }

  MultiPromiseActorSafe mpas{"DeleteMessagesFromServerMultiPromiseActor"};
  mpas.add_promise(std::move(promise));

  auto lock = mpas.get_promise();
  delete_messages_from_server(dialog_id, std::move(deleted_server_message_ids), revoke, 0, mpas.get_promise());
  delete_scheduled_messages_from_server(dialog_id, std::move(deleted_scheduled_server_message_ids), 0,
                                        mpas.get_promise());
  lock.set_value(Unit());

  bool need_update_dialog_pos = false;
  bool need_update_chat_has_scheduled_messages = false;
  vector<int64> deleted_message_ids;
  for (auto message_id : message_ids) {
    need_update_chat_has_scheduled_messages |= message_id.is_scheduled();
    auto m = delete_message(d, message_id, true, &need_update_dialog_pos, DELETE_MESSAGE_USER_REQUEST_SOURCE);
    if (m == nullptr) {
      LOG(INFO) << "Can't delete " << message_id << " because it is not found";
    } else {
      deleted_message_ids.push_back(m->message_id.get());
    }
  }

  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "delete_messages");
  }
  send_update_delete_messages(dialog_id, std::move(deleted_message_ids), true, false);

  if (need_update_chat_has_scheduled_messages) {
    send_update_chat_has_scheduled_messages(d, true);
  }
}

void MessagesManager::delete_message_from_server(DialogId dialog_id, MessageId message_id, bool revoke) {
  if (message_id.is_valid()) {
    CHECK(message_id.is_server());
    delete_messages_from_server(dialog_id, {message_id}, revoke, 0, Auto());
  } else {
    CHECK(message_id.is_scheduled_server());
    delete_scheduled_messages_from_server(dialog_id, {message_id}, 0, Auto());
  }
}

class MessagesManager::DeleteMessagesFromServerLogEvent {
 public:
  DialogId dialog_id_;
  vector<MessageId> message_ids_;
  bool revoke_;

  template <class StorerT>
  void store(StorerT &storer) const {
    BEGIN_STORE_FLAGS();
    STORE_FLAG(revoke_);
    END_STORE_FLAGS();

    td::store(dialog_id_, storer);
    td::store(message_ids_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(revoke_);
    END_PARSE_FLAGS();

    td::parse(dialog_id_, parser);
    td::parse(message_ids_, parser);
  }
};

uint64 MessagesManager::save_delete_messages_from_server_log_event(DialogId dialog_id,
                                                                   const vector<MessageId> &message_ids, bool revoke) {
  DeleteMessagesFromServerLogEvent log_event{dialog_id, message_ids, revoke};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::DeleteMessagesFromServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::delete_messages_from_server(DialogId dialog_id, vector<MessageId> message_ids, bool revoke,
                                                  uint64 log_event_id, Promise<Unit> &&promise) {
  if (message_ids.empty()) {
    return promise.set_value(Unit());
  }
  LOG(INFO) << (revoke ? "Revoke " : "Delete ") << format::as_array(message_ids) << " in " << dialog_id
            << " from server";

  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_delete_messages_from_server_log_event(dialog_id, message_ids, revoke);
  }

  auto new_promise = get_erase_log_event_promise(log_event_id, std::move(promise));
  promise = std::move(new_promise);  // to prevent self-move

  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
      td_->create_handler<DeleteMessagesQuery>(std::move(promise))->send(dialog_id, std::move(message_ids), revoke);
      break;
    case DialogType::Channel:
      td_->create_handler<DeleteChannelMessagesQuery>(std::move(promise))
          ->send(dialog_id.get_channel_id(), std::move(message_ids));
      break;
    case DialogType::SecretChat: {
      vector<int64> random_ids;
      auto d = get_dialog_force(dialog_id);
      CHECK(d != nullptr);
      for (auto &message_id : message_ids) {
        auto *m = get_message(d, message_id);
        if (m != nullptr) {
          random_ids.push_back(m->random_id);
        }
      }
      if (!random_ids.empty()) {
        send_closure(G()->secret_chats_manager(), &SecretChatsManager::delete_messages, dialog_id.get_secret_chat_id(),
                     std::move(random_ids), std::move(promise));
      } else {
        promise.set_value(Unit());
      }
      break;
    }
    case DialogType::None:
    default:
      UNREACHABLE();
  }
}

class MessagesManager::DeleteScheduledMessagesFromServerLogEvent {
 public:
  DialogId dialog_id_;
  vector<MessageId> message_ids_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
    td::store(message_ids_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
    td::parse(message_ids_, parser);
  }
};

uint64 MessagesManager::save_delete_scheduled_messages_from_server_log_event(DialogId dialog_id,
                                                                             const vector<MessageId> &message_ids) {
  DeleteScheduledMessagesFromServerLogEvent log_event{dialog_id, message_ids};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::DeleteScheduledMessagesFromServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::delete_scheduled_messages_from_server(DialogId dialog_id, vector<MessageId> message_ids,
                                                            uint64 log_event_id, Promise<Unit> &&promise) {
  if (message_ids.empty()) {
    return promise.set_value(Unit());
  }
  LOG(INFO) << "Delete " << format::as_array(message_ids) << " in " << dialog_id << " from server";

  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_delete_scheduled_messages_from_server_log_event(dialog_id, message_ids);
  }

  auto new_promise = get_erase_log_event_promise(log_event_id, std::move(promise));
  promise = std::move(new_promise);  // to prevent self-move

  td_->create_handler<DeleteScheduledMessagesQuery>(std::move(promise))->send(dialog_id, std::move(message_ids));
}

void MessagesManager::delete_dialog_history(DialogId dialog_id, bool remove_from_dialog_list, bool revoke,
                                            Promise<Unit> &&promise) {
  LOG(INFO) << "Receive deleteChatHistory request to delete all messages in " << dialog_id
            << ", remove_from_chat_list is " << remove_from_dialog_list << ", revoke is " << revoke;

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_error(Status::Error(3, "Chat info not found"));
  }

  if (is_dialog_sponsored(d)) {
    auto chat_source = sponsored_dialog_source_.get_chat_source_object();
    if (chat_source == nullptr || chat_source->get_id() != td_api::chatSourcePublicServiceAnnouncement::ID) {
      return promise.set_error(Status::Error(3, "Can't delete the chat"));
    }
    if (!remove_from_dialog_list) {
      return promise.set_error(
          Status::Error(3, "Can't delete only chat history without removing the chat from the chat list"));
    }

    removed_sponsored_dialog_id_ = dialog_id;
    remove_sponsored_dialog();

    td_->create_handler<HidePromoDataQuery>()->send(dialog_id);
    promise.set_value(Unit());
    return;
  }

  auto dialog_type = dialog_id.get_type();
  switch (dialog_type) {
    case DialogType::User:
    case DialogType::Chat:
      // ok
      break;
    case DialogType::Channel:
      if (is_broadcast_channel(dialog_id)) {
        return promise.set_error(Status::Error(3, "Can't delete chat history in a channel"));
      }
      if (td_->contacts_manager_->is_channel_public(dialog_id.get_channel_id())) {
        return promise.set_error(Status::Error(3, "Can't delete chat history in a public supergroup"));
      }
      break;
    case DialogType::SecretChat:
      // ok
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
      break;
  }

  auto last_new_message_id = d->last_new_message_id;
  if (dialog_type != DialogType::SecretChat && last_new_message_id == MessageId()) {
    // TODO get dialog from the server and delete history from last message identifier
  }

  bool allow_error = d->messages == nullptr;

  delete_all_dialog_messages(d, remove_from_dialog_list, true);

  if (last_new_message_id.is_valid() && last_new_message_id == d->max_unavailable_message_id && !revoke) {
    // history has already been cleared, nothing to do
    promise.set_value(Unit());
    return;
  }

  set_dialog_max_unavailable_message_id(dialog_id, last_new_message_id, false, "delete_dialog_history");

  delete_dialog_history_from_server(dialog_id, last_new_message_id, remove_from_dialog_list, revoke, allow_error, 0,
                                    std::move(promise));
}

class MessagesManager::DeleteDialogHistoryFromServerLogEvent {
 public:
  DialogId dialog_id_;
  MessageId max_message_id_;
  bool remove_from_dialog_list_;
  bool revoke_;

  template <class StorerT>
  void store(StorerT &storer) const {
    BEGIN_STORE_FLAGS();
    STORE_FLAG(remove_from_dialog_list_);
    STORE_FLAG(revoke_);
    END_STORE_FLAGS();

    td::store(dialog_id_, storer);
    td::store(max_message_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(remove_from_dialog_list_);
    PARSE_FLAG(revoke_);
    END_PARSE_FLAGS();

    td::parse(dialog_id_, parser);
    td::parse(max_message_id_, parser);
  }
};

uint64 MessagesManager::save_delete_dialog_history_from_server_log_event(DialogId dialog_id, MessageId max_message_id,
                                                                         bool remove_from_dialog_list, bool revoke) {
  DeleteDialogHistoryFromServerLogEvent log_event{dialog_id, max_message_id, remove_from_dialog_list, revoke};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::DeleteDialogHistoryFromServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::delete_dialog_history_from_server(DialogId dialog_id, MessageId max_message_id,
                                                        bool remove_from_dialog_list, bool revoke, bool allow_error,
                                                        uint64 log_event_id, Promise<Unit> &&promise) {
  LOG(INFO) << "Delete history in " << dialog_id << " up to " << max_message_id << " from server";

  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id =
        save_delete_dialog_history_from_server_log_event(dialog_id, max_message_id, remove_from_dialog_list, revoke);
  }

  auto new_promise = get_erase_log_event_promise(log_event_id, std::move(promise));
  promise = std::move(new_promise);  // to prevent self-move

  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
      td_->create_handler<DeleteHistoryQuery>(std::move(promise))
          ->send(dialog_id, max_message_id, remove_from_dialog_list, revoke);
      break;
    case DialogType::Channel:
      td_->create_handler<DeleteChannelHistoryQuery>(std::move(promise))
          ->send(dialog_id.get_channel_id(), max_message_id, allow_error);
      break;
    case DialogType::SecretChat:
      send_closure(G()->secret_chats_manager(), &SecretChatsManager::delete_all_messages,
                   dialog_id.get_secret_chat_id(), std::move(promise));
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
      break;
  }
}

void MessagesManager::delete_all_call_messages(bool revoke, Promise<Unit> &&promise) {
  delete_all_call_messages_from_server(revoke, 0, std::move(promise));
}

class MessagesManager::DeleteAllCallMessagesFromServerLogEvent {
 public:
  bool revoke_;

  template <class StorerT>
  void store(StorerT &storer) const {
    BEGIN_STORE_FLAGS();
    STORE_FLAG(revoke_);
    END_STORE_FLAGS();
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(revoke_);
    END_PARSE_FLAGS();
  }
};

uint64 MessagesManager::save_delete_all_call_messages_from_server_log_event(bool revoke) {
  DeleteAllCallMessagesFromServerLogEvent log_event{revoke};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::DeleteAllCallMessagesFromServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::delete_all_call_messages_from_server(bool revoke, uint64 log_event_id, Promise<Unit> &&promise) {
  if (log_event_id == 0) {
    log_event_id = save_delete_all_call_messages_from_server_log_event(revoke);
  }

  auto new_promise = get_erase_log_event_promise(log_event_id, std::move(promise));
  promise = std::move(new_promise);  // to prevent self-move

  td_->create_handler<DeletePhoneCallHistoryQuery>(std::move(promise))->send(revoke);
}

void MessagesManager::find_messages(const Message *m, vector<MessageId> &message_ids,
                                    const std::function<bool(const Message *)> &condition) {
  if (m == nullptr) {
    return;
  }

  find_messages(m->left.get(), message_ids, condition);

  if (condition(m)) {
    message_ids.push_back(m->message_id);
  }

  find_messages(m->right.get(), message_ids, condition);
}

void MessagesManager::find_old_messages(const Message *m, MessageId max_message_id, vector<MessageId> &message_ids) {
  if (m == nullptr) {
    return;
  }

  find_old_messages(m->left.get(), max_message_id, message_ids);

  if (m->message_id <= max_message_id) {
    message_ids.push_back(m->message_id);

    find_old_messages(m->right.get(), max_message_id, message_ids);
  }
}

void MessagesManager::find_newer_messages(const Message *m, MessageId min_message_id, vector<MessageId> &message_ids) {
  if (m == nullptr) {
    return;
  }

  if (m->message_id > min_message_id) {
    find_newer_messages(m->left.get(), min_message_id, message_ids);

    message_ids.push_back(m->message_id);
  }

  find_newer_messages(m->right.get(), min_message_id, message_ids);
}

void MessagesManager::find_unloadable_messages(const Dialog *d, int32 unload_before_date, const Message *m,
                                               vector<MessageId> &message_ids, int32 &left_to_unload) const {
  if (m == nullptr) {
    return;
  }

  find_unloadable_messages(d, unload_before_date, m->left.get(), message_ids, left_to_unload);

  if (can_unload_message(d, m)) {
    if (m->last_access_date <= unload_before_date) {
      message_ids.push_back(m->message_id);
    } else {
      left_to_unload++;
    }
  }

  find_unloadable_messages(d, unload_before_date, m->right.get(), message_ids, left_to_unload);
}

void MessagesManager::delete_dialog_messages_from_user(DialogId dialog_id, UserId user_id, Promise<Unit> &&promise) {
  bool is_bot = td_->auth_manager_->is_bot();
  if (is_bot) {
    return promise.set_error(Status::Error(3, "Method is not available for bots"));
  }

  LOG(INFO) << "Receive deleteChatMessagesFromUser request to delete all messages in " << dialog_id << " from the user "
            << user_id;
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Write)) {
    return promise.set_error(Status::Error(3, "Not enough rights"));
  }

  if (!td_->contacts_manager_->have_input_user(user_id)) {
    return promise.set_error(Status::Error(3, "User not found"));
  }

  ChannelId channel_id;
  DialogParticipantStatus channel_status = DialogParticipantStatus::Left();
  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::SecretChat:
      return promise.set_error(Status::Error(3, "All messages from a user can be deleted only in supergroup chats"));
    case DialogType::Channel: {
      channel_id = dialog_id.get_channel_id();
      auto channel_type = td_->contacts_manager_->get_channel_type(channel_id);
      if (channel_type != ChannelType::Megagroup) {
        return promise.set_error(Status::Error(3, "The method is available only for supergroup chats"));
      }
      channel_status = td_->contacts_manager_->get_channel_permissions(channel_id);
      if (!channel_status.can_delete_messages()) {
        return promise.set_error(Status::Error(5, "Need delete messages administator right in the supergroup chat"));
      }
      channel_id = dialog_id.get_channel_id();
      break;
    }
    case DialogType::None:
    default:
      UNREACHABLE();
      break;
  }
  CHECK(channel_id.is_valid());

  if (G()->parameters().use_message_db) {
    LOG(INFO) << "Delete all messages from " << user_id << " in " << dialog_id << " from database";
    G()->td_db()->get_messages_db_async()->delete_dialog_messages_from_user(dialog_id, user_id,
                                                                            Auto());  // TODO Promise
  }

  vector<MessageId> message_ids;
  find_messages(d->messages.get(), message_ids, [user_id](const Message *m) { return m->sender_user_id == user_id; });

  vector<int64> deleted_message_ids;
  bool need_update_dialog_pos = false;
  for (auto message_id : message_ids) {
    auto m = get_message(d, message_id);
    CHECK(m != nullptr);
    CHECK(m->sender_user_id == user_id);
    CHECK(m->message_id == message_id);
    if (can_delete_channel_message(channel_status, m, is_bot)) {
      auto p = delete_message(d, message_id, true, &need_update_dialog_pos, "delete messages from user");
      CHECK(p.get() == m);
      deleted_message_ids.push_back(p->message_id.get());
    }
  }

  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "delete_messages_from_user");
  }

  send_update_delete_messages(dialog_id, std::move(deleted_message_ids), true, false);

  delete_all_channel_messages_from_user_on_server(channel_id, user_id, 0, std::move(promise));
}

class MessagesManager::DeleteAllChannelMessagesFromUserOnServerLogEvent {
 public:
  ChannelId channel_id_;
  UserId user_id_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(channel_id_, storer);
    td::store(user_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(channel_id_, parser);
    td::parse(user_id_, parser);
  }
};

uint64 MessagesManager::save_delete_all_channel_messages_from_user_on_server_log_event(ChannelId channel_id,
                                                                                       UserId user_id) {
  DeleteAllChannelMessagesFromUserOnServerLogEvent log_event{channel_id, user_id};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::DeleteAllChannelMessagesFromUserOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::delete_all_channel_messages_from_user_on_server(ChannelId channel_id, UserId user_id,
                                                                      uint64 log_event_id, Promise<Unit> &&promise) {
  if (log_event_id == 0 && G()->parameters().use_chat_info_db) {
    log_event_id = save_delete_all_channel_messages_from_user_on_server_log_event(channel_id, user_id);
  }

  td_->create_handler<DeleteUserHistoryQuery>(get_erase_log_event_promise(log_event_id, std::move(promise)))
      ->send(channel_id, user_id);
}

int32 MessagesManager::get_unload_dialog_delay() const {
  constexpr int32 DIALOG_UNLOAD_DELAY = 60;        // seconds
  constexpr int32 DIALOG_UNLOAD_BOT_DELAY = 1800;  // seconds

  CHECK(is_message_unload_enabled());
  auto default_unload_delay = td_->auth_manager_->is_bot() ? DIALOG_UNLOAD_BOT_DELAY : DIALOG_UNLOAD_DELAY;
  return narrow_cast<int32>(G()->shared_config().get_option_integer("message_unload_delay", default_unload_delay));
}

void MessagesManager::unload_dialog(DialogId dialog_id) {
  if (G()->close_flag()) {
    return;
  }

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  CHECK(d->has_unload_timeout);

  if (!is_message_unload_enabled()) {
    // just in case
    d->has_unload_timeout = false;
    return;
  }

  vector<MessageId> to_unload_message_ids;
  int32 left_to_unload = 0;
  find_unloadable_messages(d, G()->unix_time_cached() - get_unload_dialog_delay() + 2, d->messages.get(),
                           to_unload_message_ids, left_to_unload);

  vector<int64> unloaded_message_ids;
  for (auto message_id : to_unload_message_ids) {
    unload_message(d, message_id);
    unloaded_message_ids.push_back(message_id.get());
  }

  if (!unloaded_message_ids.empty()) {
    if (!G()->parameters().use_message_db) {
      d->have_full_history = false;
    }

    send_closure_later(
        G()->td(), &Td::send_update,
        make_tl_object<td_api::updateDeleteMessages>(dialog_id.get(), std::move(unloaded_message_ids), false, true));
  }

  if (left_to_unload > 0) {
    LOG(DEBUG) << "Need to unload " << left_to_unload << " messages more in " << dialog_id;
    pending_unload_dialog_timeout_.add_timeout_in(d->dialog_id.get(), get_unload_dialog_delay());
  } else {
    d->has_unload_timeout = false;
  }
}

void MessagesManager::delete_all_dialog_messages(Dialog *d, bool remove_from_dialog_list, bool is_permanently_deleted) {
  CHECK(d != nullptr);
  LOG(INFO) << "Delete all messages in " << d->dialog_id
            << " with remove_from_dialog_list = " << remove_from_dialog_list
            << " and is_permanently_deleted = " << is_permanently_deleted;
  if (is_debug_message_op_enabled()) {
    d->debug_message_op.emplace_back(Dialog::MessageOp::DeleteAll, MessageId(), MessageContentType::None,
                                     remove_from_dialog_list, false, false, "");
  }

  if (d->server_unread_count + d->local_unread_count > 0) {
    MessageId max_message_id =
        d->last_database_message_id.is_valid() ? d->last_database_message_id : d->last_new_message_id;
    if (max_message_id.is_valid()) {
      read_history_inbox(d->dialog_id, max_message_id, -1, "delete_all_dialog_messages 1");
    }
    if (d->server_unread_count != 0 || d->local_unread_count != 0) {
      set_dialog_last_read_inbox_message_id(d, MessageId::min(), 0, 0, true, "delete_all_dialog_messages 2");
    }
  }

  if (d->unread_mention_count > 0) {
    set_dialog_unread_mention_count(d, 0);
    send_update_chat_unread_mention_count(d);
  }

  bool has_last_message_id = d->last_message_id != MessageId();
  int32 last_message_date = 0;
  MessageId last_clear_history_message_id;
  if (!remove_from_dialog_list) {
    if (has_last_message_id) {
      auto m = get_message(d, d->last_message_id);
      CHECK(m != nullptr);
      last_message_date = m->date;
      last_clear_history_message_id = d->last_message_id;
    } else {
      last_message_date = d->last_clear_history_date;
      last_clear_history_message_id = d->last_clear_history_message_id;
    }
  }

  vector<int64> deleted_message_ids;
  do_delete_all_dialog_messages(d, d->messages, is_permanently_deleted, deleted_message_ids);
  delete_all_dialog_messages_from_database(d, MessageId::max(), "delete_all_dialog_messages 3");
  if (is_permanently_deleted) {
    for (auto id : deleted_message_ids) {
      d->deleted_message_ids.insert(MessageId{id});
    }
  }

  if (d->reply_markup_message_id != MessageId()) {
    set_dialog_reply_markup(d, MessageId());
  }

  set_dialog_first_database_message_id(d, MessageId(), "delete_all_dialog_messages 4");
  set_dialog_last_database_message_id(d, MessageId(), "delete_all_dialog_messages 5");
  set_dialog_last_clear_history_date(d, last_message_date, last_clear_history_message_id,
                                     "delete_all_dialog_messages 6");
  d->last_read_all_mentions_message_id = MessageId();                            // it is not needed anymore
  d->message_notification_group.max_removed_notification_id = NotificationId();  // it is not needed anymore
  d->message_notification_group.max_removed_message_id = MessageId();            // it is not needed anymore
  d->mention_notification_group.max_removed_notification_id = NotificationId();  // it is not needed anymore
  d->mention_notification_group.max_removed_message_id = MessageId();            // it is not needed anymore
  std::fill(d->message_count_by_index.begin(), d->message_count_by_index.end(), 0);
  d->notification_id_to_message_id.clear();

  if (has_last_message_id) {
    set_dialog_last_message_id(d, MessageId(), "delete_all_dialog_messages 7");
    send_update_chat_last_message(d, "delete_all_dialog_messages 8");
  }
  if (remove_from_dialog_list) {
    set_dialog_order(d, DEFAULT_ORDER, true, false, "delete_all_dialog_messages 9");
  } else {
    update_dialog_pos(d, "delete_all_dialog_messages 10");
  }

  on_dialog_updated(d->dialog_id, "delete_all_dialog_messages 11");

  send_update_delete_messages(d->dialog_id, std::move(deleted_message_ids), is_permanently_deleted, false);
}

void MessagesManager::on_dialog_deleted(DialogId dialog_id, Promise<Unit> &&promise) {
  LOG(INFO) << "Delete " << dialog_id;
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_value(Unit());
  }

  delete_all_dialog_messages(d, true, false);
  if (dialog_id.get_type() != DialogType::SecretChat) {
    d->have_full_history = false;
    d->need_restore_reply_markup = true;
  }
  if (remove_recently_found_dialog_internal(dialog_id)) {
    save_recently_found_dialogs();
  }

  close_dialog(d);
  promise.set_value(Unit());
}

void MessagesManager::on_update_dialog_group_call_rights(DialogId dialog_id) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  auto d = get_dialog(dialog_id);
  if (d == nullptr) {
    // nothing to do
    return;
  }

  if (d->active_group_call_id.is_valid()) {
    td_->group_call_manager_->on_update_group_call_rights(d->active_group_call_id);
  }
}

void MessagesManager::read_all_dialog_mentions(DialogId dialog_id, Promise<Unit> &&promise) {
  bool is_bot = td_->auth_manager_->is_bot();
  if (is_bot) {
    return promise.set_error(Status::Error(3, "Method is not available for bots"));
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  LOG(INFO) << "Receive readAllChatMentions request in " << dialog_id << " with " << d->unread_mention_count
            << " unread mentions";
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_error(Status::Error(3, "Chat is not accessible"));
  }
  if (dialog_id.get_type() == DialogType::SecretChat) {
    CHECK(d->unread_mention_count == 0);
    return promise.set_value(Unit());
  }

  if (d->last_new_message_id > d->last_read_all_mentions_message_id) {
    d->last_read_all_mentions_message_id = d->last_new_message_id;
    on_dialog_updated(dialog_id, "read_all_dialog_mentions");
  }

  vector<MessageId> message_ids;
  find_messages(d->messages.get(), message_ids, [](const Message *m) { return m->contains_unread_mention; });

  LOG(INFO) << "Found " << message_ids.size() << " messages with unread mentions in memory";
  bool is_update_sent = false;
  for (auto message_id : message_ids) {
    auto m = get_message(d, message_id);
    CHECK(m != nullptr);
    CHECK(m->contains_unread_mention);
    CHECK(m->message_id == message_id);
    CHECK(m->message_id.is_valid());
    remove_message_notification_id(d, m, true, false);  // should be called before contains_unread_mention is updated
    m->contains_unread_mention = false;

    send_closure(G()->td(), &Td::send_update,
                 make_tl_object<td_api::updateMessageMentionRead>(dialog_id.get(), m->message_id.get(), 0));
    is_update_sent = true;
    on_message_changed(d, m, true, "read_all_dialog_mentions");
  }

  if (d->unread_mention_count != 0) {
    set_dialog_unread_mention_count(d, 0);
    if (!is_update_sent) {
      send_update_chat_unread_mention_count(d);
    } else {
      LOG(INFO) << "Update unread mention message count in " << dialog_id << " to " << d->unread_mention_count;
      on_dialog_updated(dialog_id, "read_all_dialog_mentions");
    }
  }
  remove_message_dialog_notifications(d, MessageId::max(), true, "read_all_dialog_mentions");

  read_all_dialog_mentions_on_server(dialog_id, 0, std::move(promise));
}

class MessagesManager::ReadAllDialogMentionsOnServerLogEvent {
 public:
  DialogId dialog_id_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
  }
};

uint64 MessagesManager::save_read_all_dialog_mentions_on_server_log_event(DialogId dialog_id) {
  ReadAllDialogMentionsOnServerLogEvent log_event{dialog_id};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::ReadAllDialogMentionsOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::read_all_dialog_mentions_on_server(DialogId dialog_id, uint64 log_event_id,
                                                         Promise<Unit> &&promise) {
  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_read_all_dialog_mentions_on_server_log_event(dialog_id);
  }

  LOG(INFO) << "Read all mentions on server in " << dialog_id;
  td_->create_handler<ReadMentionsQuery>(get_erase_log_event_promise(log_event_id, std::move(promise)))
      ->send(dialog_id);
}

void MessagesManager::read_message_content_from_updates(MessageId message_id) {
  if (!message_id.is_valid() || !message_id.is_server()) {
    LOG(ERROR) << "Incoming update tries to read content of " << message_id;
    return;
  }

  Dialog *d = get_dialog_by_message_id(message_id);
  if (d != nullptr) {
    Message *m = get_message(d, message_id);
    CHECK(m != nullptr);
    read_message_content(d, m, false, "read_message_content_from_updates");
  }
}

void MessagesManager::read_channel_message_content_from_updates(Dialog *d, MessageId message_id) {
  CHECK(d != nullptr);
  if (!message_id.is_valid() || !message_id.is_server()) {
    LOG(ERROR) << "Incoming update tries to read content of " << message_id << " in " << d->dialog_id;
    return;
  }

  Message *m = get_message_force(d, message_id, "read_channel_message_content_from_updates");
  if (m != nullptr) {
    read_message_content(d, m, false, "read_channel_message_content_from_updates");
  } else if (message_id > d->last_new_message_id) {
    get_channel_difference(d->dialog_id, d->pts, true, "read_channel_message_content_from_updates");
  }
}

bool MessagesManager::read_message_content(Dialog *d, Message *m, bool is_local_read, const char *source) {
  LOG_CHECK(m != nullptr) << source;
  CHECK(!m->message_id.is_scheduled());
  bool is_mention_read = update_message_contains_unread_mention(d, m, false, "read_message_content");
  bool is_content_read =
      update_opened_message_content(m->content.get()) | ttl_on_open(d, m, Time::now(), is_local_read);

  LOG(INFO) << "Read message content of " << m->message_id << " in " << d->dialog_id
            << ": is_mention_read = " << is_mention_read << ", is_content_read = " << is_content_read;
  if (is_mention_read || is_content_read) {
    on_message_changed(d, m, true, "read_message_content");
    if (is_content_read) {
      send_closure(G()->td(), &Td::send_update,
                   make_tl_object<td_api::updateMessageContentOpened>(d->dialog_id.get(), m->message_id.get()));
    }
    return true;
  }
  return false;
}

bool MessagesManager::has_incoming_notification(DialogId dialog_id, const Message *m) const {
  if (m->is_from_scheduled) {
    return true;
  }
  return !m->is_outgoing && dialog_id != get_my_dialog_id();
}

int32 MessagesManager::calc_new_unread_count_from_last_unread(Dialog *d, MessageId max_message_id,
                                                              MessageType type) const {
  CHECK(!max_message_id.is_scheduled());
  MessagesConstIterator it(d, max_message_id);
  if (*it == nullptr || (*it)->message_id != max_message_id) {
    return -1;
  }

  int32 unread_count = type == MessageType::Server ? d->server_unread_count : d->local_unread_count;
  while (*it != nullptr && (*it)->message_id > d->last_read_inbox_message_id) {
    if (has_incoming_notification(d->dialog_id, *it) && (*it)->message_id.get_type() == type) {
      unread_count--;
    }
    --it;
  }
  if (*it == nullptr || (*it)->message_id != d->last_read_inbox_message_id) {
    return -1;
  }

  LOG(INFO) << "Found " << unread_count << " unread messages in " << d->dialog_id << " from last unread message";
  return unread_count;
}

int32 MessagesManager::calc_new_unread_count_from_the_end(Dialog *d, MessageId max_message_id, MessageType type,
                                                          int32 hint_unread_count) const {
  CHECK(!max_message_id.is_scheduled());
  int32 unread_count = 0;
  MessagesConstIterator it(d, MessageId::max());
  while (*it != nullptr && (*it)->message_id > max_message_id) {
    if (has_incoming_notification(d->dialog_id, *it) && (*it)->message_id.get_type() == type) {
      unread_count++;
    }
    --it;
  }

  bool is_count_exact = d->last_message_id.is_valid() && *it != nullptr;
  if (hint_unread_count >= 0) {
    if (is_count_exact) {
      if (hint_unread_count == unread_count) {
        return hint_unread_count;
      }
    } else {
      if (hint_unread_count >= unread_count) {
        return hint_unread_count;
      }
    }

    // hint_unread_count is definitely wrong, ignore it

    if (need_unread_counter(d->order)) {
      LOG(ERROR) << "Receive hint_unread_count = " << hint_unread_count << ", but found " << unread_count
                 << " unread messages in " << d->dialog_id;
    }
  }

  if (!is_count_exact) {
    // unread count is likely to be calculated wrong, so ignore it
    return -1;
  }

  LOG(INFO) << "Found " << unread_count << " unread messages in " << d->dialog_id << " from the end";
  return unread_count;
}

int32 MessagesManager::calc_new_unread_count(Dialog *d, MessageId max_message_id, MessageType type,
                                             int32 hint_unread_count) const {
  CHECK(!max_message_id.is_scheduled());
  if (d->is_empty) {
    return 0;
  }

  if (!d->last_read_inbox_message_id.is_valid()) {
    return calc_new_unread_count_from_the_end(d, max_message_id, type, hint_unread_count);
  }

  if (!d->last_message_id.is_valid() ||
      (d->last_message_id.get() - max_message_id.get() > max_message_id.get() - d->last_read_inbox_message_id.get())) {
    int32 unread_count = calc_new_unread_count_from_last_unread(d, max_message_id, type);
    return unread_count >= 0 ? unread_count
                             : calc_new_unread_count_from_the_end(d, max_message_id, type, hint_unread_count);
  } else {
    int32 unread_count = calc_new_unread_count_from_the_end(d, max_message_id, type, hint_unread_count);
    return unread_count >= 0 ? unread_count : calc_new_unread_count_from_last_unread(d, max_message_id, type);
  }
}

void MessagesManager::repair_server_unread_count(DialogId dialog_id, int32 unread_count) {
  if (td_->auth_manager_->is_bot() || !have_input_peer(dialog_id, AccessRights::Read)) {
    return;
  }
  if (pending_read_history_timeout_.has_timeout(dialog_id.get())) {
    return;  // postpone until read history request is sent
  }

  LOG(INFO) << "Repair server unread count in " << dialog_id << " from " << unread_count;
  create_actor<SleepActor>("RepairServerUnreadCountSleepActor", 0.2,
                           PromiseCreator::lambda([actor_id = actor_id(this), dialog_id](Result<Unit> result) {
                             send_closure(actor_id, &MessagesManager::send_get_dialog_query, dialog_id, Promise<Unit>(),
                                          0, "repair_server_unread_count");
                           }))
      .release();
}

void MessagesManager::repair_channel_server_unread_count(Dialog *d) {
  CHECK(d != nullptr);
  CHECK(d->dialog_id.get_type() == DialogType::Channel);

  if (td_->auth_manager_->is_bot()) {
    return;
  }
  if (d->last_read_inbox_message_id >= d->last_new_message_id) {
    // all messages are already read
    return;
  }
  if (!need_unread_counter(d->order)) {
    // there is no unread count in left channels
    return;
  }
  if (!d->need_repair_channel_server_unread_count) {
    d->need_repair_channel_server_unread_count = true;
    on_dialog_updated(d->dialog_id, "repair_channel_server_unread_count");
  }

  LOG(INFO) << "Reload ChannelFull for " << d->dialog_id << " to repair unread message counts";
  get_dialog_info_full(d->dialog_id, Promise<Unit>());
}

void MessagesManager::read_history_inbox(DialogId dialog_id, MessageId max_message_id, int32 unread_count,
                                         const char *source) {
  CHECK(!max_message_id.is_scheduled());

  if (td_->auth_manager_->is_bot()) {
    return;
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d != nullptr) {
    if (d->need_repair_channel_server_unread_count) {
      d->need_repair_channel_server_unread_count = false;
      on_dialog_updated(dialog_id, "read_history_inbox");
    }

    // there can be updateReadHistoryInbox up to message 0, if messages where read and then all messages where deleted
    if (!max_message_id.is_valid() && max_message_id != MessageId()) {
      LOG(ERROR) << "Receive read inbox update in " << dialog_id << " up to " << max_message_id << " from " << source;
      return;
    }
    if (d->is_last_read_inbox_message_id_inited && max_message_id <= d->last_read_inbox_message_id) {
      LOG(INFO) << "Receive read inbox update in " << dialog_id << " up to " << max_message_id << " from " << source
                << ", but all messages have already been read up to " << d->last_read_inbox_message_id;
      if (max_message_id == d->last_read_inbox_message_id && unread_count >= 0 &&
          unread_count != d->server_unread_count) {
        set_dialog_last_read_inbox_message_id(d, MessageId::min(), unread_count, d->local_unread_count, true, source);
      }
      return;
    }

    if (max_message_id != MessageId() && max_message_id.is_yet_unsent()) {
      LOG(ERROR) << "Tried to update last read inbox message in " << dialog_id << " with " << max_message_id << " from "
                 << source;
      return;
    }

    if (max_message_id != MessageId() && unread_count > 0 && max_message_id >= d->last_new_message_id &&
        max_message_id >= d->last_message_id && max_message_id >= d->last_database_message_id) {
      if (d->last_new_message_id.is_valid()) {
        LOG(ERROR) << "Have unknown " << unread_count << " unread messages up to " << max_message_id << " in "
                   << dialog_id << " with last_new_message_id = " << d->last_new_message_id
                   << ", last_message_id = " << d->last_message_id
                   << ", last_database_message_id = " << d->last_database_message_id;
      }
      unread_count = 0;
    }

    LOG_IF(INFO, d->last_new_message_id.is_valid() && max_message_id > d->last_new_message_id &&
                     max_message_id > d->max_notification_message_id && max_message_id.is_server() &&
                     dialog_id.get_type() != DialogType::Channel && !running_get_difference_)
        << "Receive read inbox update up to unknown " << max_message_id << " in " << dialog_id << " from " << source
        << ". Last new is " << d->last_new_message_id << ", unread_count = " << unread_count
        << ". Possible only for deleted incoming message";

    if (dialog_id.get_type() == DialogType::SecretChat) {
      ttl_read_history(d, false, max_message_id, d->last_read_inbox_message_id, Time::now());
    }

    if (max_message_id > d->last_new_message_id && dialog_id.get_type() == DialogType::Channel) {
      LOG(INFO) << "Schedule getDifference in " << dialog_id.get_channel_id();
      channel_get_difference_retry_timeout_.add_timeout_in(dialog_id.get(), 0.001);
    }

    int32 server_unread_count = calc_new_unread_count(d, max_message_id, MessageType::Server, unread_count);
    int32 local_unread_count =
        d->local_unread_count == 0 ? 0 : calc_new_unread_count(d, max_message_id, MessageType::Local, -1);

    if (server_unread_count < 0) {
      server_unread_count = unread_count >= 0 ? unread_count : d->server_unread_count;
      if (dialog_id.get_type() != DialogType::SecretChat && have_input_peer(dialog_id, AccessRights::Read) &&
          need_unread_counter(d->order)) {
        d->need_repair_server_unread_count = true;
        repair_server_unread_count(dialog_id, server_unread_count);
      }
    }
    if (local_unread_count < 0) {
      // TODO repair local unread count
      local_unread_count = d->local_unread_count;
    }

    set_dialog_last_read_inbox_message_id(d, max_message_id, server_unread_count, local_unread_count, true, source);

    if (d->is_marked_as_unread && max_message_id != MessageId()) {
      set_dialog_is_marked_as_unread(d, false);
    }
  } else {
    LOG(INFO) << "Receive read inbox about unknown " << dialog_id << " from " << source;
  }
}

void MessagesManager::read_history_outbox(DialogId dialog_id, MessageId max_message_id, int32 read_date) {
  CHECK(!max_message_id.is_scheduled());

  if (td_->auth_manager_->is_bot()) {
    return;
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d != nullptr) {
    if (!max_message_id.is_valid()) {
      LOG(ERROR) << "Receive read outbox update in " << dialog_id << " with " << max_message_id;
      return;
    }
    if (max_message_id <= d->last_read_outbox_message_id) {
      LOG(INFO) << "Receive read outbox update up to " << max_message_id
                << ", but all messages have already been read up to " << d->last_read_outbox_message_id;
      return;
    }

    if (max_message_id.is_yet_unsent()) {
      LOG(ERROR) << "Tried to update last read outbox message with " << max_message_id;
      return;
    }

    // it is impossible for just sent outgoing messages because updates are ordered by pts
    LOG_IF(INFO, d->last_new_message_id.is_valid() && max_message_id > d->last_new_message_id &&
                     dialog_id.get_type() != DialogType::Channel)
        << "Receive read outbox update about unknown " << max_message_id << " in " << dialog_id << " with last new "
        << d->last_new_message_id << ". Possible only for deleted outgoing message";

    if (dialog_id.get_type() == DialogType::SecretChat) {
      double server_time = Time::now();
      double read_time = server_time;
      if (read_date <= 0) {
        LOG(ERROR) << "Receive wrong read date " << read_date << " in " << dialog_id;
      } else if (read_date < server_time) {
        read_time = read_date;
      }
      ttl_read_history(d, true, max_message_id, d->last_read_outbox_message_id, read_time);
    }

    set_dialog_last_read_outbox_message_id(d, max_message_id);
  } else {
    LOG(INFO) << "Receive read outbox update about unknown " << dialog_id;
  }
}

bool MessagesManager::need_unread_counter(int64 dialog_order) {
  return dialog_order != DEFAULT_ORDER;
}

int32 MessagesManager::get_dialog_total_count(const DialogList &list) const {
  int32 sponsored_dialog_count = 0;
  if (sponsored_dialog_id_.is_valid() && list.dialog_list_id == DialogListId(FolderId::main())) {
    auto d = get_dialog(sponsored_dialog_id_);
    CHECK(d != nullptr);
    if (is_dialog_sponsored(d)) {
      sponsored_dialog_count = 1;
    }
  }
  if (list.server_dialog_total_count_ != -1 && list.secret_chat_total_count_ != -1) {
    return std::max(list.server_dialog_total_count_ + list.secret_chat_total_count_,
                    list.in_memory_dialog_total_count_) +
           sponsored_dialog_count;
  }
  if (list.list_last_dialog_date_ == MAX_DIALOG_DATE) {
    return list.in_memory_dialog_total_count_ + sponsored_dialog_count;
  }
  return list.in_memory_dialog_total_count_ + sponsored_dialog_count + 1;
}

void MessagesManager::repair_server_dialog_total_count(DialogListId dialog_list_id) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }
  if (!dialog_list_id.is_folder()) {
    // can repair total count only in folders
    return;
  }

  send_closure(td_->create_net_actor<GetDialogListActor>(Promise<Unit>()), &GetDialogListActor::send,
               dialog_list_id.get_folder_id(), 2147483647, ServerMessageId(), DialogId(), 1,
               get_sequence_dispatcher_id(DialogId(), MessageContentType::None));
}

void MessagesManager::repair_secret_chat_total_count(DialogListId dialog_list_id) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  if (G()->parameters().use_message_db && dialog_list_id.is_folder()) {
    // race-prone
    G()->td_db()->get_dialog_db_async()->get_secret_chat_count(
        dialog_list_id.get_folder_id(),
        PromiseCreator::lambda([actor_id = actor_id(this), dialog_list_id](Result<int32> result) {
          if (result.is_error()) {
            return;
          }
          send_closure(actor_id, &MessagesManager::on_get_secret_chat_total_count, dialog_list_id, result.move_as_ok());
        }));
  } else {
    int32 total_count = 0;
    auto *list = get_dialog_list(dialog_list_id);
    CHECK(list != nullptr);
    for (auto &folder_id : get_dialog_list_folder_ids(*list)) {
      const auto *folder_list = get_dialog_list(DialogListId(folder_id));
      CHECK(folder_list != nullptr);
      if (folder_list->need_unread_count_recalc_) {
        // can't repair total secret chat count yet
        return;
      }

      const auto *folder = get_dialog_folder(folder_id);
      CHECK(folder != nullptr);
      for (const auto &dialog_date : folder->ordered_dialogs_) {
        auto dialog_id = dialog_date.get_dialog_id();
        if (dialog_id.get_type() == DialogType::SecretChat && dialog_date.get_order() != DEFAULT_ORDER) {
          total_count++;
        }
      }
    }
    on_get_secret_chat_total_count(dialog_list_id, total_count);
  }
}

void MessagesManager::on_get_secret_chat_total_count(DialogListId dialog_list_id, int32 total_count) {
  if (G()->close_flag()) {
    return;
  }

  CHECK(!td_->auth_manager_->is_bot());
  auto *list = get_dialog_list(dialog_list_id);
  if (list == nullptr) {
    // just in case
    return;
  }
  CHECK(total_count >= 0);
  if (list->secret_chat_total_count_ != total_count) {
    auto old_dialog_total_count = get_dialog_total_count(*list);
    list->secret_chat_total_count_ = total_count;
    if (list->is_dialog_unread_count_inited_) {
      if (old_dialog_total_count != get_dialog_total_count(*list)) {
        send_update_unread_chat_count(*list, DialogId(), true, "on_get_secret_chat_total_count");
      } else {
        save_unread_chat_count(*list);
      }
    }
  }
}

void MessagesManager::recalc_unread_count(DialogListId dialog_list_id, int32 old_dialog_total_count) {
  if (td_->auth_manager_->is_bot() || !G()->parameters().use_message_db) {
    return;
  }

  auto *list_ptr = get_dialog_list(dialog_list_id);
  CHECK(list_ptr != nullptr);
  auto &list = *list_ptr;
  if (!list.need_unread_count_recalc_) {
    return;
  }
  LOG(INFO) << "Recalculate unread counts in " << dialog_list_id;
  list.need_unread_count_recalc_ = false;
  list.is_message_unread_count_inited_ = true;
  list.is_dialog_unread_count_inited_ = true;

  int32 message_total_count = 0;
  int32 message_muted_count = 0;
  int32 dialog_total_count = 0;
  int32 dialog_muted_count = 0;
  int32 dialog_marked_count = 0;
  int32 dialog_muted_marked_count = 0;
  int32 server_dialog_total_count = 0;
  int32 secret_chat_total_count = 0;
  for (auto folder_id : get_dialog_list_folder_ids(list)) {
    const auto &folder = *get_dialog_folder(folder_id);
    for (const auto &dialog_date : folder.ordered_dialogs_) {
      if (dialog_date.get_order() == DEFAULT_ORDER) {
        break;
      }

      auto dialog_id = dialog_date.get_dialog_id();
      Dialog *d = get_dialog(dialog_id);
      CHECK(d != nullptr);
      if (!is_dialog_in_list(d, dialog_list_id)) {
        continue;
      }

      int unread_count = d->server_unread_count + d->local_unread_count;
      if (need_unread_counter(d->order) && (unread_count > 0 || d->is_marked_as_unread)) {
        message_total_count += unread_count;
        dialog_total_count++;
        if (unread_count == 0 && d->is_marked_as_unread) {
          dialog_marked_count++;
        }

        LOG(DEBUG) << "Have " << unread_count << " messages in " << dialog_id;
        if (is_dialog_muted(d)) {
          message_muted_count += unread_count;
          dialog_muted_count++;
          if (unread_count == 0 && d->is_marked_as_unread) {
            dialog_muted_marked_count++;
          }
        }
      }
      if (d->order != DEFAULT_ORDER) {  // must not count sponsored dialog, which is added independently
        if (dialog_id.get_type() == DialogType::SecretChat) {
          secret_chat_total_count++;
        } else {
          server_dialog_total_count++;
        }
      }
    }
  }

  if (list.unread_message_total_count_ != message_total_count ||
      list.unread_message_muted_count_ != message_muted_count) {
    list.unread_message_total_count_ = message_total_count;
    list.unread_message_muted_count_ = message_muted_count;
    send_update_unread_message_count(list, DialogId(), true, "recalc_unread_count");
  }

  if (old_dialog_total_count == -1) {
    old_dialog_total_count = get_dialog_total_count(list);
  }
  bool need_save = false;
  if (list.list_last_dialog_date_ == MAX_DIALOG_DATE) {
    if (server_dialog_total_count != list.server_dialog_total_count_ ||
        secret_chat_total_count != list.secret_chat_total_count_) {
      list.server_dialog_total_count_ = server_dialog_total_count;
      list.secret_chat_total_count_ = secret_chat_total_count;
      need_save = true;
    }
  } else {
    repair_server_dialog_total_count(dialog_list_id);

    if (list.secret_chat_total_count_ == -1) {
      repair_secret_chat_total_count(dialog_list_id);
    }
  }
  if (list.unread_dialog_total_count_ != dialog_total_count || list.unread_dialog_muted_count_ != dialog_muted_count ||
      list.unread_dialog_marked_count_ != dialog_marked_count ||
      list.unread_dialog_muted_marked_count_ != dialog_muted_marked_count ||
      old_dialog_total_count != get_dialog_total_count(list)) {
    list.unread_dialog_total_count_ = dialog_total_count;
    list.unread_dialog_muted_count_ = dialog_muted_count;
    list.unread_dialog_marked_count_ = dialog_marked_count;
    list.unread_dialog_muted_marked_count_ = dialog_muted_marked_count;
    send_update_unread_chat_count(list, DialogId(), true, "recalc_unread_count");
  } else if (need_save) {
    save_unread_chat_count(list);
  }
}

void MessagesManager::set_dialog_last_read_inbox_message_id(Dialog *d, MessageId message_id, int32 server_unread_count,
                                                            int32 local_unread_count, bool force_update,
                                                            const char *source) {
  CHECK(!message_id.is_scheduled());

  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  LOG(INFO) << "Update last read inbox message in " << d->dialog_id << " from " << d->last_read_inbox_message_id
            << " to " << message_id << " and update unread message count from " << d->server_unread_count << " + "
            << d->local_unread_count << " to " << server_unread_count << " + " << local_unread_count << " from "
            << source;
  if (message_id != MessageId::min()) {
    d->last_read_inbox_message_id = message_id;
    d->is_last_read_inbox_message_id_inited = true;
  }
  int32 old_unread_count = d->server_unread_count + d->local_unread_count;
  d->server_unread_count = server_unread_count;
  d->local_unread_count = local_unread_count;

  if (need_unread_counter(d->order)) {
    const int32 new_unread_count = d->server_unread_count + d->local_unread_count;
    for (auto &list : get_dialog_lists(d)) {
      int32 delta = new_unread_count - old_unread_count;
      if (delta != 0 && list.is_message_unread_count_inited_) {
        list.unread_message_total_count_ += delta;
        if (is_dialog_muted(d)) {
          list.unread_message_muted_count_ += delta;
        }
        send_update_unread_message_count(list, d->dialog_id, force_update, source);
      }
      delta = static_cast<int32>(new_unread_count != 0) - static_cast<int32>(old_unread_count != 0);
      if (delta != 0 && list.is_dialog_unread_count_inited_) {
        if (d->is_marked_as_unread) {
          list.unread_dialog_marked_count_ -= delta;
        } else {
          list.unread_dialog_total_count_ += delta;
        }
        if (is_dialog_muted(d)) {
          if (d->is_marked_as_unread) {
            list.unread_dialog_muted_marked_count_ -= delta;
          } else {
            list.unread_dialog_muted_count_ += delta;
          }
        }
        send_update_unread_chat_count(list, d->dialog_id, force_update, source);
      }
    }

    bool was_unread = old_unread_count != 0 || d->is_marked_as_unread;
    bool is_unread = new_unread_count != 0 || d->is_marked_as_unread;
    if (!dialog_filters_.empty() && was_unread != is_unread) {
      update_dialog_lists(d, get_dialog_positions(d), true, false, "set_dialog_last_read_inbox_message_id");
    }
  }

  if (message_id != MessageId::min() && d->last_read_inbox_message_id.is_valid() &&
      (d->order != DEFAULT_ORDER || is_dialog_sponsored(d))) {
    VLOG(notifications) << "Remove some notifications in " << d->dialog_id
                        << " after updating last read inbox message to " << message_id
                        << " and unread message count to " << server_unread_count << " + " << local_unread_count
                        << " from " << source;
    if (d->message_notification_group.group_id.is_valid()) {
      auto total_count = get_dialog_pending_notification_count(d, false);
      if (total_count == 0) {
        set_dialog_last_notification(d->dialog_id, d->message_notification_group, 0, NotificationId(),
                                     "set_dialog_last_read_inbox_message_id");
      }
      if (!d->pending_new_message_notifications.empty()) {
        for (auto &it : d->pending_new_message_notifications) {
          if (it.second <= message_id) {
            it.first = DialogId();
          }
        }
        flush_pending_new_message_notifications(d->dialog_id, false, DialogId(UserId(1)));
      }
      total_count -= static_cast<int32>(d->pending_new_message_notifications.size());
      if (total_count < 0) {
        LOG(ERROR) << "Total message notification count is " << total_count << " in " << d->dialog_id
                   << " with old unread_count = " << old_unread_count << " and " << d->pending_new_message_notifications
                   << " pending new message notifications after reading history up to " << message_id;
        total_count = 0;
      }
      send_closure_later(G()->notification_manager(), &NotificationManager::remove_notification_group,
                         d->message_notification_group.group_id, NotificationId(), d->last_read_inbox_message_id,
                         total_count, Slice(source) == Slice("view_messages"), Promise<Unit>());
    }

    if (d->mention_notification_group.group_id.is_valid() && d->pinned_message_notification_message_id.is_valid() &&
        d->pinned_message_notification_message_id <= d->last_read_inbox_message_id) {
      // remove pinned message notification when it is read
      remove_dialog_pinned_message_notification(d, "set_dialog_last_read_inbox_message_id 2");
    }
  }

  send_update_chat_read_inbox(d, force_update, source);
}

void MessagesManager::set_dialog_last_read_outbox_message_id(Dialog *d, MessageId message_id) {
  CHECK(!message_id.is_scheduled());

  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  LOG(INFO) << "Update last read outbox message in " << d->dialog_id << " from " << d->last_read_outbox_message_id
            << " to " << message_id;
  d->last_read_outbox_message_id = message_id;
  d->is_last_read_outbox_message_id_inited = true;
  send_update_chat_read_outbox(d);
}

void MessagesManager::set_dialog_max_unavailable_message_id(DialogId dialog_id, MessageId max_unavailable_message_id,
                                                            bool from_update, const char *source) {
  CHECK(!max_unavailable_message_id.is_scheduled());

  Dialog *d = get_dialog_force(dialog_id);
  if (d != nullptr) {
    if (max_unavailable_message_id > d->last_new_message_id && from_update) {
      if (d->last_new_message_id.is_valid()) {
        if (!td_->auth_manager_->is_bot()) {
          LOG(ERROR) << "Tried to set " << dialog_id << " max unavailable message to " << max_unavailable_message_id
                     << " from " << source << ", but last new message is " << d->last_new_message_id;
        }
        max_unavailable_message_id = d->last_new_message_id;
      } else if (max_unavailable_message_id.is_valid() && max_unavailable_message_id.is_server()) {
        set_dialog_last_new_message_id(d, max_unavailable_message_id, source);
      }
    }

    if (d->max_unavailable_message_id == max_unavailable_message_id) {
      return;
    }

    if (max_unavailable_message_id.is_valid() && max_unavailable_message_id.is_yet_unsent()) {
      LOG(ERROR) << "Tried to update " << dialog_id << " last read outbox message with " << max_unavailable_message_id
                 << " from " << source;
      return;
    }
    LOG(INFO) << "Set max unavailable message to " << max_unavailable_message_id << " in " << dialog_id << " from "
              << source;

    on_dialog_updated(dialog_id, "set_dialog_max_unavailable_message_id");

    if (d->max_unavailable_message_id > max_unavailable_message_id) {
      d->max_unavailable_message_id = max_unavailable_message_id;
      return;
    }

    d->max_unavailable_message_id = max_unavailable_message_id;

    vector<MessageId> message_ids;
    find_old_messages(d->messages.get(), max_unavailable_message_id, message_ids);

    vector<int64> deleted_message_ids;
    bool need_update_dialog_pos = false;
    for (auto message_id : message_ids) {
      if (message_id.is_yet_unsent()) {
        continue;
      }

      auto m = get_message(d, message_id);
      CHECK(m != nullptr);
      CHECK(m->message_id <= max_unavailable_message_id);
      CHECK(m->message_id == message_id);
      auto p =
          delete_message(d, message_id, !from_update, &need_update_dialog_pos, "set_dialog_max_unavailable_message_id");
      CHECK(p.get() == m);
      deleted_message_ids.push_back(p->message_id.get());
    }

    if (need_update_dialog_pos) {
      send_update_chat_last_message(d, "set_dialog_max_unavailable_message_id");
    }

    send_update_delete_messages(dialog_id, std::move(deleted_message_ids), !from_update, false);

    if (d->server_unread_count + d->local_unread_count > 0) {
      read_history_inbox(dialog_id, max_unavailable_message_id, -1, "set_dialog_max_unavailable_message_id");
    }
  } else {
    LOG(INFO) << "Receive max unavailable message in unknown " << dialog_id << " from " << source;
  }
}

void MessagesManager::set_dialog_online_member_count(DialogId dialog_id, int32 online_member_count, bool is_from_server,
                                                     const char *source) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  Dialog *d = get_dialog(dialog_id);
  if (d == nullptr) {
    return;
  }

  auto &info = dialog_online_member_counts_[dialog_id];
  LOG(INFO) << "Change number of online members from " << info.online_member_count << " to " << online_member_count
            << " in " << dialog_id << " from " << source;
  bool need_update = d->is_opened && (!info.is_update_sent || info.online_member_count != online_member_count);
  info.online_member_count = online_member_count;
  info.updated_time = Time::now();

  if (need_update) {
    info.is_update_sent = true;
    send_update_chat_online_member_count(dialog_id, online_member_count);
  }
  if (d->is_opened) {
    if (is_from_server) {
      update_dialog_online_member_count_timeout_.set_timeout_in(dialog_id.get(), ONLINE_MEMBER_COUNT_UPDATE_TIME);
    } else {
      update_dialog_online_member_count_timeout_.add_timeout_in(dialog_id.get(), ONLINE_MEMBER_COUNT_UPDATE_TIME);
    }
  }
}

void MessagesManager::on_update_dialog_online_member_count_timeout(DialogId dialog_id) {
  if (G()->close_flag()) {
    return;
  }

  LOG(INFO) << "Expired timeout for number of online members in " << dialog_id;
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  if (!d->is_opened) {
    send_update_chat_online_member_count(dialog_id, 0);
    return;
  }

  if (dialog_id.get_type() == DialogType::Channel && !is_broadcast_channel(dialog_id)) {
    auto participant_count = td_->contacts_manager_->get_channel_participant_count(dialog_id.get_channel_id());
    if (participant_count == 0 || participant_count >= 195) {
      td_->create_handler<GetOnlinesQuery>()->send(dialog_id);
    } else {
      td_->contacts_manager_->get_channel_participants(dialog_id.get_channel_id(),
                                                       td_api::make_object<td_api::supergroupMembersFilterRecent>(),
                                                       string(), 0, 200, 200, true, Auto());
    }
    return;
  }
  if (dialog_id.get_type() == DialogType::Chat) {
    // we need actual online status state, so we need to reget chat participants
    td_->contacts_manager_->repair_chat_participants(dialog_id.get_chat_id());
    return;
  }
}

MessageId MessagesManager::get_message_id(const tl_object_ptr<telegram_api::Message> &message_ptr, bool is_scheduled) {
  switch (message_ptr->get_id()) {
    case telegram_api::messageEmpty::ID: {
      auto message = static_cast<const telegram_api::messageEmpty *>(message_ptr.get());
      return is_scheduled ? MessageId() : MessageId(ServerMessageId(message->id_));
    }
    case telegram_api::message::ID: {
      auto message = static_cast<const telegram_api::message *>(message_ptr.get());
      return is_scheduled ? MessageId(ScheduledServerMessageId(message->id_), message->date_)
                          : MessageId(ServerMessageId(message->id_));
    }
    case telegram_api::messageService::ID: {
      auto message = static_cast<const telegram_api::messageService *>(message_ptr.get());
      return is_scheduled ? MessageId(ScheduledServerMessageId(message->id_), message->date_)
                          : MessageId(ServerMessageId(message->id_));
    }
    default:
      UNREACHABLE();
      return MessageId();
  }
}

DialogId MessagesManager::get_message_dialog_id(const tl_object_ptr<telegram_api::Message> &message_ptr) {
  switch (message_ptr->get_id()) {
    case telegram_api::messageEmpty::ID: {
      auto message = static_cast<const telegram_api::messageEmpty *>(message_ptr.get());
      return message->peer_id_ == nullptr ? DialogId() : DialogId(message->peer_id_);
    }
    case telegram_api::message::ID: {
      auto message = static_cast<const telegram_api::message *>(message_ptr.get());
      return DialogId(message->peer_id_);
    }
    case telegram_api::messageService::ID: {
      auto message = static_cast<const telegram_api::messageService *>(message_ptr.get());
      return DialogId(message->peer_id_);
    }
    default:
      UNREACHABLE();
      return DialogId();
  }
}

FullMessageId MessagesManager::get_full_message_id(const tl_object_ptr<telegram_api::Message> &message_ptr,
                                                   bool is_scheduled) {
  return {get_message_dialog_id(message_ptr), get_message_id(message_ptr, is_scheduled)};
}

int32 MessagesManager::get_message_date(const tl_object_ptr<telegram_api::Message> &message_ptr) {
  switch (message_ptr->get_id()) {
    case telegram_api::messageEmpty::ID:
      return 0;
    case telegram_api::message::ID: {
      auto message = static_cast<const telegram_api::message *>(message_ptr.get());
      return message->date_;
    }
    case telegram_api::messageService::ID: {
      auto message = static_cast<const telegram_api::messageService *>(message_ptr.get());
      return message->date_;
    }
    default:
      UNREACHABLE();
      return 0;
  }
}

void MessagesManager::ttl_read_history(Dialog *d, bool is_outgoing, MessageId from_message_id,
                                       MessageId till_message_id, double view_date) {
  CHECK(!from_message_id.is_scheduled());
  CHECK(!till_message_id.is_scheduled());

  // TODO: protect with log event
  suffix_load_till_message_id(d, till_message_id,
                              PromiseCreator::lambda([actor_id = actor_id(this), dialog_id = d->dialog_id, is_outgoing,
                                                      from_message_id, till_message_id, view_date](Result<Unit>) {
                                send_closure(actor_id, &MessagesManager::ttl_read_history_impl, dialog_id, is_outgoing,
                                             from_message_id, till_message_id, view_date);
                              }));
}

void MessagesManager::ttl_read_history_impl(DialogId dialog_id, bool is_outgoing, MessageId from_message_id,
                                            MessageId till_message_id, double view_date) {
  CHECK(!from_message_id.is_scheduled());
  CHECK(!till_message_id.is_scheduled());

  auto *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  auto now = Time::now();
  for (auto it = MessagesIterator(d, from_message_id); *it && (*it)->message_id >= till_message_id; --it) {
    auto *m = *it;
    if (m->is_outgoing == is_outgoing) {
      ttl_on_view(d, m, view_date, now);
    }
  }
}

void MessagesManager::ttl_on_view(const Dialog *d, Message *m, double view_date, double now) {
  if (m->ttl > 0 && m->ttl_expires_at == 0 && !m->message_id.is_scheduled() && !m->message_id.is_yet_unsent() &&
      !m->is_failed_to_send && !m->is_content_secret) {
    m->ttl_expires_at = m->ttl + view_date;
    ttl_register_message(d->dialog_id, m, now);
    on_message_changed(d, m, true, "ttl_on_view");
  }
}

bool MessagesManager::ttl_on_open(Dialog *d, Message *m, double now, bool is_local_read) {
  CHECK(!m->message_id.is_scheduled());
  if (m->ttl > 0 && m->ttl_expires_at == 0) {
    if (!is_local_read && d->dialog_id.get_type() != DialogType::SecretChat) {
      on_message_ttl_expired(d, m);
    } else {
      m->ttl_expires_at = m->ttl + now;
      ttl_register_message(d->dialog_id, m, now);
    }
    return true;
  }
  return false;
}

void MessagesManager::ttl_register_message(DialogId dialog_id, const Message *m, double now) {
  CHECK(m != nullptr);
  CHECK(m->ttl_expires_at != 0);
  CHECK(!m->message_id.is_scheduled());

  auto it_flag = ttl_nodes_.emplace(dialog_id, m->message_id, false);
  CHECK(it_flag.second);
  auto it = it_flag.first;

  ttl_heap_.insert(m->ttl_expires_at, it->as_heap_node());
  ttl_update_timeout(now);
}

void MessagesManager::ttl_period_register_message(DialogId dialog_id, const Message *m, double server_time) {
  CHECK(m != nullptr);
  CHECK(m->ttl_period != 0);
  CHECK(!m->message_id.is_scheduled());

  auto it_flag = ttl_nodes_.emplace(dialog_id, m->message_id, true);
  CHECK(it_flag.second);
  auto it = it_flag.first;

  auto now = Time::now();
  ttl_heap_.insert(now + (m->date + m->ttl_period - server_time), it->as_heap_node());
  ttl_update_timeout(now);
}

void MessagesManager::ttl_unregister_message(DialogId dialog_id, const Message *m, const char *source) {
  if (m->ttl_expires_at == 0) {
    return;
  }
  CHECK(!m->message_id.is_scheduled());

  auto it = ttl_nodes_.find(TtlNode(dialog_id, m->message_id, false));

  // expect m->ttl == 0, but m->ttl_expires_at > 0 from binlog
  LOG_CHECK(it != ttl_nodes_.end()) << dialog_id << " " << m->message_id << " " << source << " " << G()->close_flag()
                                    << " " << m->ttl << " " << m->ttl_expires_at << " " << Time::now() << " "
                                    << m->from_database;

  auto *heap_node = it->as_heap_node();
  if (heap_node->in_heap()) {
    ttl_heap_.erase(heap_node);
  }
  ttl_nodes_.erase(it);
  ttl_update_timeout(Time::now());
}

void MessagesManager::ttl_period_unregister_message(DialogId dialog_id, const Message *m) {
  if (m->ttl_period == 0) {
    return;
  }
  CHECK(!m->message_id.is_scheduled());

  auto it = ttl_nodes_.find(TtlNode(dialog_id, m->message_id, true));

  CHECK(it != ttl_nodes_.end());

  auto *heap_node = it->as_heap_node();
  if (heap_node->in_heap()) {
    ttl_heap_.erase(heap_node);
  }
  ttl_nodes_.erase(it);
  ttl_update_timeout(Time::now());
}

void MessagesManager::ttl_loop(double now) {
  std::unordered_map<DialogId, std::vector<MessageId>, DialogIdHash> to_delete;
  while (!ttl_heap_.empty() && ttl_heap_.top_key() < now) {
    TtlNode *ttl_node = TtlNode::from_heap_node(ttl_heap_.pop());
    auto full_message_id = ttl_node->full_message_id_;
    auto dialog_id = full_message_id.get_dialog_id();
    if (dialog_id.get_type() == DialogType::SecretChat || ttl_node->by_ttl_period_) {
      to_delete[dialog_id].push_back(full_message_id.get_message_id());
    } else {
      auto d = get_dialog(dialog_id);
      CHECK(d != nullptr);
      auto m = get_message(d, full_message_id.get_message_id());
      CHECK(m != nullptr);
      on_message_ttl_expired(d, m);
      on_message_changed(d, m, true, "ttl_loop");
    }
  }
  for (auto &it : to_delete) {
    delete_dialog_messages(it.first, it.second, false, true);
  }
  ttl_update_timeout(now);
}

void MessagesManager::ttl_update_timeout(double now) {
  if (ttl_heap_.empty()) {
    if (!ttl_slot_.empty()) {
      ttl_slot_.cancel_timeout();
    }
    return;
  }
  ttl_slot_.set_event(EventCreator::yield(actor_id()));
  ttl_slot_.set_timeout_in(ttl_heap_.top_key() - now);
}

void MessagesManager::on_message_ttl_expired(Dialog *d, Message *m) {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  CHECK(m->ttl > 0);
  CHECK(d->dialog_id.get_type() != DialogType::SecretChat);
  ttl_unregister_message(d->dialog_id, m, "on_message_ttl_expired");
  unregister_message_content(td_, m->content.get(), {d->dialog_id, m->message_id}, "on_message_ttl_expired");
  remove_message_file_sources(d->dialog_id, m);
  on_message_ttl_expired_impl(d, m);
  register_message_content(td_, m->content.get(), {d->dialog_id, m->message_id}, "on_message_ttl_expired");
  send_update_message_content(d->dialog_id, m->message_id, m->content.get(), m->date, m->is_content_secret,
                              "on_message_ttl_expired");
}

void MessagesManager::on_message_ttl_expired_impl(Dialog *d, Message *m) {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  CHECK(m->message_id.is_valid());
  CHECK(m->ttl > 0);
  CHECK(d->dialog_id.get_type() != DialogType::SecretChat);
  delete_message_files(d->dialog_id, m);
  update_expired_message_content(m->content);
  m->ttl = 0;
  m->ttl_expires_at = 0;
  if (m->reply_markup != nullptr) {
    if (m->reply_markup->type != ReplyMarkup::Type::InlineKeyboard) {
      if (!td_->auth_manager_->is_bot()) {
        if (d->reply_markup_message_id == m->message_id) {
          set_dialog_reply_markup(d, MessageId());
        }
      }
      m->had_reply_markup = true;
    }
    m->reply_markup = nullptr;
  }
  remove_message_notification_id(d, m, true, true);
  update_message_contains_unread_mention(d, m, false, "on_message_ttl_expired_impl");
  m->contains_mention = false;
  m->reply_to_message_id = MessageId();
  m->reply_in_dialog_id = DialogId();
  m->top_thread_message_id = MessageId();
  m->linked_top_thread_message_id = MessageId();
  m->is_content_secret = false;
}

void MessagesManager::loop() {
  auto token = get_link_token();
  if (token == YieldType::TtlDb) {
    ttl_db_loop(G()->server_time());
  } else {
    ttl_loop(Time::now());
  }
}

class MessagesManager::DialogFiltersLogEvent {
 public:
  int32 updated_date = 0;
  const vector<unique_ptr<DialogFilter>> *server_dialog_filters_in;
  const vector<unique_ptr<DialogFilter>> *dialog_filters_in;
  vector<unique_ptr<DialogFilter>> server_dialog_filters_out;
  vector<unique_ptr<DialogFilter>> dialog_filters_out;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(updated_date, storer);
    td::store(*server_dialog_filters_in, storer);
    td::store(*dialog_filters_in, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(updated_date, parser);
    td::parse(server_dialog_filters_out, parser);
    td::parse(dialog_filters_out, parser);
  }
};

void MessagesManager::tear_down() {
  parent_.reset();
}

void MessagesManager::start_up() {
  init();
}

void MessagesManager::create_folders() {
  LOG(INFO) << "Create folders";
  dialog_folders_[FolderId::main()].folder_id = FolderId::main();
  dialog_folders_[FolderId::archive()].folder_id = FolderId::archive();

  add_dialog_list(DialogListId(FolderId::main()));
  add_dialog_list(DialogListId(FolderId::archive()));
}

void MessagesManager::init() {
  if (is_inited_) {
    return;
  }
  is_inited_ = true;

  always_wait_for_mailbox();

  start_time_ = Time::now();
  last_channel_pts_jump_warning_time_ = start_time_ - 3600;

  bool is_authorized = td_->auth_manager_->is_authorized();
  bool was_authorized_user = td_->auth_manager_->was_authorized() && !td_->auth_manager_->is_bot();
  if (was_authorized_user) {
    create_folders();  // ensure that Main and Archive dialog lists are created
  }
  if (is_authorized && td_->auth_manager_->is_bot()) {
    disable_get_dialog_filter_ = true;
  }

  if (was_authorized_user) {
    vector<NotificationSettingsScope> scopes{NotificationSettingsScope::Private, NotificationSettingsScope::Group,
                                             NotificationSettingsScope::Channel};
    for (auto scope : scopes) {
      auto notification_settings_string =
          G()->td_db()->get_binlog_pmc()->get(get_notification_settings_scope_database_key(scope));
      if (!notification_settings_string.empty()) {
        auto current_settings = get_scope_notification_settings(scope);
        CHECK(current_settings != nullptr);
        log_event_parse(*current_settings, notification_settings_string).ensure();

        VLOG(notifications) << "Loaded notification settings in " << scope << ": " << *current_settings;

        schedule_scope_unmute(scope, current_settings->mute_until);

        send_closure(G()->td(), &Td::send_update, get_update_scope_notification_settings_object(scope));
      }
    }
    if (!channels_notification_settings_.is_synchronized && is_authorized) {
      channels_notification_settings_ = chats_notification_settings_;
      channels_notification_settings_.disable_pinned_message_notifications = false;
      channels_notification_settings_.disable_mention_notifications = false;
      channels_notification_settings_.is_synchronized = false;
      send_get_scope_notification_settings_query(NotificationSettingsScope::Channel, Promise<>());
    }
  }
  G()->td_db()->get_binlog_pmc()->erase("nsfac");

  if (was_authorized_user) {
    auto dialog_filters = G()->td_db()->get_binlog_pmc()->get("dialog_filters");
    if (!dialog_filters.empty()) {
      DialogFiltersLogEvent log_event;
      if (log_event_parse(log_event, dialog_filters).is_ok()) {
        dialog_filters_updated_date_ = G()->ignore_background_updates() ? 0 : log_event.updated_date;
        std::unordered_set<DialogFilterId, DialogFilterIdHash> server_dialog_filter_ids;
        for (auto &dialog_filter : log_event.server_dialog_filters_out) {
          if (server_dialog_filter_ids.insert(dialog_filter->dialog_filter_id).second) {
            server_dialog_filters_.push_back(std::move(dialog_filter));
          }
        }
        for (auto &dialog_filter : log_event.dialog_filters_out) {
          add_dialog_filter(std::move(dialog_filter), false, "binlog");
        }
        LOG(INFO) << "Loaded server chat filters " << get_dialog_filter_ids(server_dialog_filters_)
                  << " and local chat filters " << get_dialog_filter_ids(dialog_filters_);
      } else {
        LOG(ERROR) << "Failed to parse chat filters from binlog";
      }
    }
    send_update_chat_filters();  // always send updateChatFilters
  }

  if (G()->parameters().use_message_db && was_authorized_user) {
    // erase old keys
    G()->td_db()->get_binlog_pmc()->erase("last_server_dialog_date");
    G()->td_db()->get_binlog_pmc()->erase("unread_message_count");
    G()->td_db()->get_binlog_pmc()->erase("unread_dialog_count");

    auto last_database_server_dialog_dates = G()->td_db()->get_binlog_pmc()->prefix_get("last_server_dialog_date");
    for (auto &it : last_database_server_dialog_dates) {
      auto r_folder_id = to_integer_safe<int32>(it.first);
      if (r_folder_id.is_error()) {
        LOG(ERROR) << "Can't parse folder ID from " << it.first;
        continue;
      }

      string order_str;
      string dialog_id_str;
      std::tie(order_str, dialog_id_str) = split(it.second);

      auto r_order = to_integer_safe<int64>(order_str);
      auto r_dialog_id = to_integer_safe<int64>(dialog_id_str);
      if (r_order.is_error() || r_dialog_id.is_error()) {
        LOG(ERROR) << "Can't parse " << it.second;
      } else {
        FolderId folder_id(r_folder_id.ok());
        auto *folder = get_dialog_folder(folder_id);
        CHECK(folder != nullptr);
        DialogDate dialog_date(r_order.ok(), DialogId(r_dialog_id.ok()));
        if (folder->last_database_server_dialog_date_ < dialog_date) {
          folder->last_database_server_dialog_date_ = dialog_date;
        }
        LOG(INFO) << "Loaded last_database_server_dialog_date_ " << folder->last_database_server_dialog_date_ << " in "
                  << folder_id;
      }
    }

    auto sponsored_dialog_id_string = G()->td_db()->get_binlog_pmc()->get("sponsored_dialog_id");
    if (!sponsored_dialog_id_string.empty()) {
      auto dialog_id_source = split(Slice(sponsored_dialog_id_string));
      auto r_dialog_id = to_integer_safe<int64>(dialog_id_source.first);
      auto r_source = DialogSource::unserialize(dialog_id_source.second);
      if (r_dialog_id.is_error() || r_source.is_error()) {
        LOG(ERROR) << "Can't parse " << sponsored_dialog_id_string;
      } else {
        DialogId dialog_id(r_dialog_id.ok());

        const Dialog *d = get_dialog_force(dialog_id);
        if (d != nullptr) {
          LOG(INFO) << "Loaded sponsored " << dialog_id;
          add_sponsored_dialog(d, r_source.move_as_ok());
        } else {
          LOG(ERROR) << "Can't load " << dialog_id;
        }
      }
    }

    auto pinned_dialog_ids = G()->td_db()->get_binlog_pmc()->prefix_get("pinned_dialog_ids");
    for (auto &it : pinned_dialog_ids) {
      auto r_folder_id = to_integer_safe<int32>(it.first);
      if (r_folder_id.is_error()) {
        LOG(ERROR) << "Can't parse folder ID from " << it.first;
        continue;
      }
      FolderId folder_id(r_folder_id.ok());

      auto r_dialog_ids = transform(full_split(Slice(it.second), ','), [](Slice str) -> Result<DialogId> {
        TRY_RESULT(dialog_id_int, to_integer_safe<int64>(str));
        DialogId dialog_id(dialog_id_int);
        if (!dialog_id.is_valid()) {
          return Status::Error("Have invalid dialog ID");
        }
        return dialog_id;
      });
      if (std::any_of(r_dialog_ids.begin(), r_dialog_ids.end(),
                      [](auto &r_dialog_id) { return r_dialog_id.is_error(); })) {
        LOG(ERROR) << "Can't parse " << it.second;
        reload_pinned_dialogs(DialogListId(folder_id), Auto());
      } else {
        auto *list = get_dialog_list(DialogListId(folder_id));
        CHECK(list != nullptr);
        CHECK(list->pinned_dialogs_.empty());
        for (auto &r_dialog_id : reversed(r_dialog_ids)) {
          auto dialog_id = r_dialog_id.move_as_ok();
          auto order = get_next_pinned_dialog_order();
          list->pinned_dialogs_.emplace_back(order, dialog_id);
          list->pinned_dialog_id_orders_.emplace(dialog_id, order);
        }
        std::reverse(list->pinned_dialogs_.begin(), list->pinned_dialogs_.end());
        list->are_pinned_dialogs_inited_ = true;
        update_list_last_pinned_dialog_date(*list);

        LOG(INFO) << "Loaded pinned chats " << list->pinned_dialogs_ << " in " << folder_id;
      }
    }

    auto unread_message_counts = G()->td_db()->get_binlog_pmc()->prefix_get("unread_message_count");
    for (auto &it : unread_message_counts) {
      auto r_dialog_list_id = to_integer_safe<int64>(it.first);
      if (r_dialog_list_id.is_error()) {
        LOG(ERROR) << "Can't parse dialog list ID from " << it.first;
        continue;
      }
      string total_count;
      string muted_count;
      std::tie(total_count, muted_count) = split(it.second);

      auto r_total_count = to_integer_safe<int32>(total_count);
      auto r_muted_count = to_integer_safe<int32>(muted_count);
      if (r_total_count.is_error() || r_muted_count.is_error()) {
        LOG(ERROR) << "Can't parse " << it.second;
      } else {
        DialogListId dialog_list_id(r_dialog_list_id.ok());
        auto *list = get_dialog_list(dialog_list_id);
        if (list != nullptr) {
          list->unread_message_total_count_ = r_total_count.ok();
          list->unread_message_muted_count_ = r_muted_count.ok();
          list->is_message_unread_count_inited_ = true;
          send_update_unread_message_count(*list, DialogId(), true, "load unread_message_count", true);
        } else {
          G()->td_db()->get_binlog_pmc()->erase("unread_message_count" + it.first);
        }
      }
    }

    auto unread_dialog_counts = G()->td_db()->get_binlog_pmc()->prefix_get("unread_dialog_count");
    for (auto &it : unread_dialog_counts) {
      auto r_dialog_list_id = to_integer_safe<int64>(it.first);
      if (r_dialog_list_id.is_error()) {
        LOG(ERROR) << "Can't parse dialog list ID from " << it.first;
        continue;
      }

      auto counts = transform(full_split(Slice(it.second)), [](Slice str) { return to_integer_safe<int32>(str); });
      if ((counts.size() != 4 && counts.size() != 6) ||
          std::any_of(counts.begin(), counts.end(), [](auto &c) { return c.is_error(); })) {
        LOG(ERROR) << "Can't parse " << it.second;
      } else {
        DialogListId dialog_list_id(r_dialog_list_id.ok());
        auto *list = get_dialog_list(dialog_list_id);
        if (list != nullptr) {
          list->unread_dialog_total_count_ = counts[0].ok();
          list->unread_dialog_muted_count_ = counts[1].ok();
          list->unread_dialog_marked_count_ = counts[2].ok();
          list->unread_dialog_muted_marked_count_ = counts[3].ok();
          if (counts.size() == 6) {
            list->server_dialog_total_count_ = counts[4].ok();
            list->secret_chat_total_count_ = counts[5].ok();
          }
          if (list->server_dialog_total_count_ == -1) {
            repair_server_dialog_total_count(dialog_list_id);
          }
          if (list->secret_chat_total_count_ == -1) {
            repair_secret_chat_total_count(dialog_list_id);
          }
          list->is_dialog_unread_count_inited_ = true;
          send_update_unread_chat_count(*list, DialogId(), true, "load unread_dialog_count", true);
        } else {
          G()->td_db()->get_binlog_pmc()->erase("unread_dialog_count" + it.first);
        }
      }
    }
  } else {
    G()->td_db()->get_binlog_pmc()->erase_by_prefix("pinned_dialog_ids");
    G()->td_db()->get_binlog_pmc()->erase_by_prefix("last_server_dialog_date");
    G()->td_db()->get_binlog_pmc()->erase_by_prefix("unread_message_count");
    G()->td_db()->get_binlog_pmc()->erase_by_prefix("unread_dialog_count");
    G()->td_db()->get_binlog_pmc()->erase("sponsored_dialog_id");
  }
  G()->td_db()->get_binlog_pmc()->erase("dialog_pinned_current_order");

  if (G()->parameters().use_message_db) {
    ttl_db_loop_start(G()->server_time());
  }

  load_calls_db_state();

  if (was_authorized_user && is_authorized) {
    if (need_synchronize_dialog_filters()) {
      reload_dialog_filters();
    } else {
      auto cache_time = get_dialog_filters_cache_time();
      schedule_dialog_filters_reload(cache_time - max(0, G()->unix_time() - dialog_filters_updated_date_));
    }
  }

  auto auth_notification_ids_string = G()->td_db()->get_binlog_pmc()->get("auth_notification_ids");
  if (!auth_notification_ids_string.empty()) {
    VLOG(notifications) << "Loaded auth_notification_ids = " << auth_notification_ids_string;
    auto ids = full_split(auth_notification_ids_string, ',');
    CHECK(ids.size() % 2 == 0);
    bool is_changed = false;
    auto min_date = G()->unix_time() - AUTH_NOTIFICATION_ID_CACHE_TIME;
    for (size_t i = 0; i < ids.size(); i += 2) {
      auto date = to_integer_safe<int32>(ids[i + 1]).ok();
      if (date < min_date) {
        is_changed = true;
        continue;
      }
      auth_notification_id_date_.emplace(std::move(ids[i]), date);
    }
    if (is_changed) {
      save_auth_notification_ids();
    }
  }

  /*
  FI LE *f = std::f open("error.txt", "r");
  if (f != nullptr) {
    DialogId dialog_id(ChannelId(123456));
    force_create_dialog(dialog_id, "test");
    Dialog *d = get_dialog(dialog_id);
    CHECK(d != nullptr);

    delete_all_dialog_messages(d, true, false);

    d->last_new_message_id = MessageId();
    d->last_read_inbox_message_id = MessageId();
    d->last_read_outbox_message_id = MessageId();
    d->is_last_read_inbox_message_id_inited = false;
    d->is_last_read_outbox_message_id_inited = false;

    struct MessageBasicInfo {
      MessageId message_id;
      bool have_previous;
      bool have_next;
    };
    vector<MessageBasicInfo> messages_info;
    std::function<void(Message *m)> get_messages_info = [&](Message *m) {
      if (m == nullptr) {
        return;
      }
      get_messages_info(m->left.get());
      messages_info.push_back(MessageBasicInfo{m->message_id, m->have_previous, m->have_next});
      get_messages_info(m->right.get());
    };

    char buf[1280];
    while (std::f gets(buf, sizeof(buf), f) != nullptr) {
      Slice log_string(buf, std::strlen(buf));
      Slice op = log_string.substr(0, log_string.find(' '));
      if (op != "MessageOpAdd" && op != "MessageOpDelete") {
        LOG(ERROR) << "Unsupported op " << op;
        continue;
      }
      log_string.remove_prefix(log_string.find(' ') + 1);

      if (!begins_with(log_string, "at ")) {
        LOG(ERROR) << "Date expected, found " << log_string;
        continue;
      }
      log_string.remove_prefix(3);
      auto date_slice = log_string.substr(0, log_string.find(' '));
      log_string.remove_prefix(date_slice.size());

      bool is_server = false;
      if (begins_with(log_string, " server message ")) {
        log_string.remove_prefix(16);
        is_server = true;
      } else if (begins_with(log_string, " yet unsent message ")) {
        log_string.remove_prefix(20);
      } else if (begins_with(log_string, " local message ")) {
        log_string.remove_prefix(15);
      } else {
        LOG(ERROR) << "Message id expected, found " << log_string;
        continue;
      }

      auto server_message_id = to_integer<int32>(log_string);
      auto add = 0;
      if (!is_server) {
        log_string.remove_prefix(log_string.find('.') + 1);
        add = to_integer<int32>(log_string);
      }
      log_string.remove_prefix(log_string.find(' ') + 1);

      auto message_id = MessageId(MessageId(ServerMessageId(server_message_id)).get() + add);

      auto content_type = log_string.substr(0, log_string.find(' '));
      log_string.remove_prefix(log_string.find(' ') + 1);

      auto read_bool = [](Slice &str) {
        if (begins_with(str, "true ")) {
          str.remove_prefix(5);
          return true;
        }
        if (begins_with(str, "false ")) {
          str.remove_prefix(6);
          return false;
        }
        LOG(ERROR) << "Bool expected, found " << str;
        return false;
      };

      bool from_update = read_bool(log_string);
      bool have_previous = read_bool(log_string);
      bool have_next = read_bool(log_string);

      if (op == "MessageOpAdd") {
        auto m = make_unique<Message>();
        set_message_id(m, message_id);
        m->date = G()->unix_time();
        m->content = create_text_message_content("text", {}, {});

        m->have_previous = have_previous;
        m->have_next = have_next;

        bool need_update = from_update;
        bool need_update_dialog_pos = false;
        if (add_message_to_dialog(dialog_id, std::move(m), from_update, &need_update, &need_update_dialog_pos,
                                  "Unknown source") == nullptr) {
          LOG(ERROR) << "Can't add message " << message_id;
        }
      } else {
        bool need_update_dialog_pos = false;
        auto m = delete_message(d, message_id, true, &need_update_dialog_pos, "Unknown source");
        CHECK(m != nullptr);
      }

      messages_info.clear();
      get_messages_info(d->messages.get());

      for (size_t i = 0; i + 1 < messages_info.size(); i++) {
        if (messages_info[i].have_next != messages_info[i + 1].have_previous) {
          LOG(ERROR) << messages_info[i].message_id << " has have_next = " << messages_info[i].have_next << ", but "
                     << messages_info[i + 1].message_id
                     << " has have_previous = " << messages_info[i + 1].have_previous;
        }
      }
      if (!messages_info.empty()) {
        if (messages_info.back().have_next != false) {
          LOG(ERROR) << messages_info.back().message_id << " has have_next = true, but there is no next message";
        }
        if (messages_info[0].have_previous != false) {
          LOG(ERROR) << messages_info[0].message_id << " has have_previous = true, but there is no previous message";
        }
      }
    }

    messages_info.clear();
    get_messages_info(d->messages.get());
    for (auto &info : messages_info) {
      bool need_update_dialog_pos = false;
      auto m = delete_message(d, info.message_id, true, &need_update_dialog_pos, "Unknown source");
      CHECK(m != nullptr);
    }

    std::f close(f);
  }
  */
}

void MessagesManager::on_authorization_success() {
  CHECK(td_->auth_manager_->is_authorized());
  if (td_->auth_manager_->is_bot()) {
    disable_get_dialog_filter_ = true;
    return;
  }

  create_folders();

  reload_dialog_filters();
}

void MessagesManager::ttl_db_loop_start(double server_now) {
  ttl_db_expires_from_ = 0;
  ttl_db_expires_till_ = static_cast<int32>(server_now) + 15 /* 15 seconds */;
  ttl_db_has_query_ = false;

  ttl_db_loop(server_now);
}

void MessagesManager::ttl_db_loop(double server_now) {
  LOG(INFO) << "Begin ttl_db loop: " << tag("expires_from", ttl_db_expires_from_)
            << tag("expires_till", ttl_db_expires_till_) << tag("has_query", ttl_db_has_query_);
  if (ttl_db_has_query_) {
    return;
  }

  auto now = static_cast<int32>(server_now);

  if (ttl_db_expires_till_ < 0) {
    LOG(INFO) << "Finish ttl_db loop";
    return;
  }

  if (now < ttl_db_expires_from_) {
    ttl_db_slot_.set_event(EventCreator::yield(actor_shared(this, YieldType::TtlDb)));
    auto wakeup_in = ttl_db_expires_from_ - server_now;
    ttl_db_slot_.set_timeout_in(wakeup_in);
    LOG(INFO) << "Set ttl_db timeout in " << wakeup_in;
    return;
  }

  ttl_db_has_query_ = true;
  int32 limit = 50;
  LOG(INFO) << "Send ttl_db query " << tag("expires_from", ttl_db_expires_from_)
            << tag("expires_till", ttl_db_expires_till_) << tag("limit", limit);
  G()->td_db()->get_messages_db_async()->get_expiring_messages(
      ttl_db_expires_from_, ttl_db_expires_till_, limit,
      PromiseCreator::lambda(
          [actor_id = actor_id(this)](Result<std::pair<std::vector<std::pair<DialogId, BufferSlice>>, int32>> result) {
            send_closure(actor_id, &MessagesManager::ttl_db_on_result, std::move(result), false);
          }));
}

void MessagesManager::ttl_db_on_result(Result<std::pair<std::vector<std::pair<DialogId, BufferSlice>>, int32>> r_result,
                                       bool dummy) {
  if (G()->close_flag()) {
    return;
  }

  auto result = r_result.move_as_ok();
  ttl_db_has_query_ = false;
  ttl_db_expires_from_ = ttl_db_expires_till_;
  ttl_db_expires_till_ = result.second;

  LOG(INFO) << "Receive ttl_db query result " << tag("new expires_till", ttl_db_expires_till_)
            << tag("got messages", result.first.size());
  for (auto &dialog_message : result.first) {
    on_get_message_from_database(dialog_message.first, get_dialog_force(dialog_message.first), dialog_message.second,
                                 false, "ttl_db_on_result");
  }
  ttl_db_loop(G()->server_time());
}

void MessagesManager::on_send_secret_message_error(int64 random_id, Status error, Promise<> promise) {
  promise.set_value(Unit());  // TODO: set after error is saved

  auto it = being_sent_messages_.find(random_id);
  if (it != being_sent_messages_.end()) {
    auto full_message_id = it->second;
    auto *m = get_message(full_message_id);
    if (m != nullptr) {
      auto file_id = get_message_content_upload_file_id(m->content.get());
      if (file_id.is_valid()) {
        if (G()->close_flag() && G()->parameters().use_message_db) {
          // do not send error, message will be re-sent
          return;
        }
        if (begins_with(error.message(), "FILE_PART_") && ends_with(error.message(), "_MISSING")) {
          on_send_message_file_part_missing(random_id, to_integer<int32>(error.message().substr(10)));
          return;
        }

        if (error.code() != 429 && error.code() < 500 && !G()->close_flag()) {
          td_->file_manager_->delete_partial_remote_location(file_id);
        }
      }
    }
  }

  on_send_message_fail(random_id, std::move(error));
}

void MessagesManager::on_send_secret_message_success(int64 random_id, MessageId message_id, int32 date,
                                                     tl_object_ptr<telegram_api::EncryptedFile> file_ptr,
                                                     Promise<> promise) {
  promise.set_value(Unit());  // TODO: set after message is saved

  FileId new_file_id;
  if (file_ptr != nullptr && file_ptr->get_id() == telegram_api::encryptedFile::ID) {
    auto file = move_tl_object_as<telegram_api::encryptedFile>(file_ptr);
    if (!DcId::is_valid(file->dc_id_)) {
      LOG(ERROR) << "Wrong dc_id = " << file->dc_id_ << " in file " << to_string(file);
    } else {
      DialogId owner_dialog_id;
      auto it = being_sent_messages_.find(random_id);
      if (it != being_sent_messages_.end()) {
        owner_dialog_id = it->second.get_dialog_id();
      }

      new_file_id = td_->file_manager_->register_remote(
          FullRemoteFileLocation(FileType::Encrypted, file->id_, file->access_hash_, DcId::internal(file->dc_id_), ""),
          FileLocationSource::FromServer, owner_dialog_id, 0, file->size_, to_string(static_cast<uint64>(file->id_)));
    }
  }

  on_send_message_success(random_id, message_id, date, 0, new_file_id, "process send_secret_message_success");
}

void MessagesManager::delete_secret_messages(SecretChatId secret_chat_id, std::vector<int64> random_ids,
                                             Promise<> promise) {
  LOG(DEBUG) << "On delete messages in " << secret_chat_id << " with random_ids " << random_ids;
  CHECK(secret_chat_id.is_valid());

  DialogId dialog_id(secret_chat_id);
  if (!have_dialog_force(dialog_id)) {
    LOG(ERROR) << "Ignore delete secret messages in unknown " << dialog_id;
    promise.set_value(Unit());
    return;
  }

  auto pending_secret_message = make_unique<PendingSecretMessage>();
  pending_secret_message->success_promise = std::move(promise);
  pending_secret_message->type = PendingSecretMessage::Type::DeleteMessages;
  pending_secret_message->dialog_id = dialog_id;
  pending_secret_message->random_ids = std::move(random_ids);

  add_secret_message(std::move(pending_secret_message));
}

void MessagesManager::finish_delete_secret_messages(DialogId dialog_id, std::vector<int64> random_ids,
                                                    Promise<> promise) {
  LOG(INFO) << "Delete messages with random_ids " << random_ids << " in " << dialog_id;
  promise.set_value(Unit());  // TODO: set after event is saved

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  vector<MessageId> to_delete_message_ids;
  for (auto &random_id : random_ids) {
    auto message_id = get_message_id_by_random_id(d, random_id, "delete_secret_messages");
    if (!message_id.is_valid()) {
      LOG(INFO) << "Can't find message with random_id " << random_id;
      continue;
    }
    const Message *m = get_message(d, message_id);
    CHECK(m != nullptr);
    if (!is_service_message_content(m->content->get_type())) {
      to_delete_message_ids.push_back(message_id);
    } else {
      LOG(INFO) << "Skip deletion of service " << message_id;
    }
  }
  delete_dialog_messages(dialog_id, to_delete_message_ids, true, false);
}

void MessagesManager::delete_secret_chat_history(SecretChatId secret_chat_id, bool remove_from_dialog_list,
                                                 MessageId last_message_id, Promise<> promise) {
  LOG(DEBUG) << "Delete history in " << secret_chat_id << " up to " << last_message_id;
  CHECK(secret_chat_id.is_valid());
  CHECK(!last_message_id.is_scheduled());

  DialogId dialog_id(secret_chat_id);
  if (!have_dialog_force(dialog_id)) {
    LOG(ERROR) << "Ignore delete history in unknown " << dialog_id;
    promise.set_value(Unit());
    return;
  }

  auto pending_secret_message = make_unique<PendingSecretMessage>();
  pending_secret_message->success_promise = std::move(promise);
  pending_secret_message->type = PendingSecretMessage::Type::DeleteHistory;
  pending_secret_message->dialog_id = dialog_id;
  pending_secret_message->last_message_id = last_message_id;
  pending_secret_message->remove_from_dialog_list = remove_from_dialog_list;

  add_secret_message(std::move(pending_secret_message));
}

void MessagesManager::finish_delete_secret_chat_history(DialogId dialog_id, bool remove_from_dialog_list,
                                                        MessageId last_message_id, Promise<> promise) {
  LOG(DEBUG) << "Delete history in " << dialog_id << " up to " << last_message_id;
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  // TODO: probably last_message_id is not needed
  delete_all_dialog_messages(d, remove_from_dialog_list, true);
  promise.set_value(Unit());  // TODO: set after event is saved
}

void MessagesManager::read_secret_chat_outbox(SecretChatId secret_chat_id, int32 up_to_date, int32 read_date) {
  if (!secret_chat_id.is_valid()) {
    LOG(ERROR) << "Receive read secret chat outbox in the invalid " << secret_chat_id;
    return;
  }
  auto dialog_id = DialogId(secret_chat_id);
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return;
  }

  if (read_date > 0) {
    auto user_id = td_->contacts_manager_->get_secret_chat_user_id(secret_chat_id);
    if (user_id.is_valid()) {
      td_->contacts_manager_->on_update_user_local_was_online(user_id, read_date);
    }
  }

  // TODO: protect with log event
  suffix_load_till_date(
      d, up_to_date,
      PromiseCreator::lambda([actor_id = actor_id(this), dialog_id, up_to_date, read_date](Result<Unit> result) {
        send_closure(actor_id, &MessagesManager::read_secret_chat_outbox_inner, dialog_id, up_to_date, read_date);
      }));
}

void MessagesManager::read_secret_chat_outbox_inner(DialogId dialog_id, int32 up_to_date, int32 read_date) {
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  auto end = MessagesConstIterator(d, MessageId::max());
  while (*end && (*end)->date > up_to_date) {
    --end;
  }
  if (!*end) {
    LOG(INFO) << "Ignore read_secret_chat_outbox in " << dialog_id << " at " << up_to_date
              << ": no messages with such date are known";
    return;
  }
  auto max_message_id = (*end)->message_id;
  read_history_outbox(dialog_id, max_message_id, read_date);
}

void MessagesManager::open_secret_message(SecretChatId secret_chat_id, int64 random_id, Promise<> promise) {
  promise.set_value(Unit());  // TODO: set after event is saved
  DialogId dialog_id(secret_chat_id);
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(ERROR) << "Ignore opening secret chat message in unknown " << dialog_id;
    return;
  }

  auto message_id = get_message_id_by_random_id(d, random_id, "open_secret_message");
  if (!message_id.is_valid()) {
    return;
  }
  Message *m = get_message(d, message_id);
  CHECK(m != nullptr);
  if (m->message_id.is_yet_unsent() || m->is_failed_to_send || !m->is_outgoing) {
    LOG(ERROR) << "Peer has opened wrong " << message_id << " in " << dialog_id;
    return;
  }

  read_message_content(d, m, false, "open_secret_message");
}

void MessagesManager::on_update_secret_chat_state(SecretChatId secret_chat_id, SecretChatState state) {
  if (state == SecretChatState::Closed && !td_->auth_manager_->is_bot()) {
    DialogId dialog_id(secret_chat_id);
    Dialog *d = get_dialog_force(dialog_id);
    if (d != nullptr) {
      if (d->new_secret_chat_notification_id.is_valid()) {
        remove_new_secret_chat_notification(d, true);
      }
      if (d->message_notification_group.group_id.is_valid() && get_dialog_pending_notification_count(d, false) == 0 &&
          !d->message_notification_group.last_notification_id.is_valid()) {
        CHECK(d->message_notification_group.last_notification_date == 0);
        d->message_notification_group.try_reuse = true;
        d->message_notification_group.is_changed = true;
        on_dialog_updated(d->dialog_id, "on_update_secret_chat_state");
      }
      CHECK(!d->mention_notification_group.group_id.is_valid());  // there can't be unread mentions in secret chats
    }
  }
}

void MessagesManager::on_get_secret_message(SecretChatId secret_chat_id, UserId user_id, MessageId message_id,
                                            int32 date, tl_object_ptr<telegram_api::encryptedFile> file,
                                            tl_object_ptr<secret_api::decryptedMessage> message, Promise<> promise) {
  LOG(DEBUG) << "On get " << to_string(message);
  CHECK(message != nullptr);
  CHECK(secret_chat_id.is_valid());
  CHECK(user_id.is_valid());
  CHECK(message_id.is_valid());
  CHECK(date > 0);

  auto pending_secret_message = make_unique<PendingSecretMessage>();
  pending_secret_message->success_promise = std::move(promise);
  MessageInfo &message_info = pending_secret_message->message_info;
  message_info.dialog_id = DialogId(secret_chat_id);
  message_info.message_id = message_id;
  message_info.sender_user_id = user_id;
  message_info.date = date;
  message_info.random_id = message->random_id_;
  message_info.ttl = message->ttl_;

  Dialog *d = get_dialog_force(message_info.dialog_id);
  if (d == nullptr) {
    LOG(ERROR) << "Ignore secret message in unknown " << message_info.dialog_id;
    pending_secret_message->success_promise.set_error(Status::Error(500, "Chat not found"));
    return;
  }

  pending_secret_message->load_data_multipromise.add_promise(Auto());
  auto lock_promise = pending_secret_message->load_data_multipromise.get_promise();

  int32 flags = MESSAGE_FLAG_HAS_UNREAD_CONTENT | MESSAGE_FLAG_HAS_FROM_ID;
  if ((message->flags_ & secret_api::decryptedMessage::REPLY_TO_RANDOM_ID_MASK) != 0) {
    message_info.reply_to_message_id = get_message_id_by_random_id(
        get_dialog(message_info.dialog_id), message->reply_to_random_id_, "on_get_secret_message");
    if (message_info.reply_to_message_id.is_valid()) {
      flags |= MESSAGE_FLAG_IS_REPLY;
    }
  }
  if ((message->flags_ & secret_api::decryptedMessage::ENTITIES_MASK) != 0) {
    flags |= MESSAGE_FLAG_HAS_ENTITIES;
  }
  if ((message->flags_ & secret_api::decryptedMessage::MEDIA_MASK) != 0) {
    flags |= MESSAGE_FLAG_HAS_MEDIA;
  }
  if ((message->flags_ & secret_api::decryptedMessage::SILENT_MASK) != 0) {
    flags |= MESSAGE_FLAG_IS_SILENT;
  }

  if (!clean_input_string(message->via_bot_name_)) {
    LOG(WARNING) << "Receive invalid bot username " << message->via_bot_name_;
    message->via_bot_name_.clear();
  }
  if (!message->via_bot_name_.empty()) {
    auto request_promise = PromiseCreator::lambda(
        [actor_id = actor_id(this), via_bot_username = message->via_bot_name_, message_info_ptr = &message_info,
         promise = pending_secret_message->load_data_multipromise.get_promise()](Unit) mutable {
          send_closure(actor_id, &MessagesManager::on_resolve_secret_chat_message_via_bot_username, via_bot_username,
                       message_info_ptr, std::move(promise));
        });
    search_public_dialog(message->via_bot_name_, false, std::move(request_promise));
  }
  if ((message->flags_ & secret_api::decryptedMessage::GROUPED_ID_MASK) != 0 && message->grouped_id_ != 0) {
    message_info.media_album_id = message->grouped_id_;
    flags |= MESSAGE_FLAG_HAS_MEDIA_ALBUM_ID;
  }

  message_info.flags = flags;
  message_info.content = get_secret_message_content(
      td_, std::move(message->message_), std::move(file), std::move(message->media_), std::move(message->entities_),
      message_info.dialog_id, pending_secret_message->load_data_multipromise);

  add_secret_message(std::move(pending_secret_message), std::move(lock_promise));
}

void MessagesManager::on_resolve_secret_chat_message_via_bot_username(const string &via_bot_username,
                                                                      MessageInfo *message_info_ptr,
                                                                      Promise<Unit> &&promise) {
  if (!G()->close_flag()) {
    auto dialog_id = resolve_dialog_username(via_bot_username);
    if (dialog_id.is_valid() && dialog_id.get_type() == DialogType::User) {
      auto user_id = dialog_id.get_user_id();
      auto r_bot_data = td_->contacts_manager_->get_bot_data(user_id);
      if (r_bot_data.is_ok() && r_bot_data.ok().is_inline) {
        message_info_ptr->flags |= MESSAGE_FLAG_IS_SENT_VIA_BOT;
        message_info_ptr->via_bot_user_id = user_id;
      }
    }
  }
  promise.set_value(Unit());
}

void MessagesManager::on_secret_chat_screenshot_taken(SecretChatId secret_chat_id, UserId user_id, MessageId message_id,
                                                      int32 date, int64 random_id, Promise<> promise) {
  LOG(DEBUG) << "On screenshot taken in " << secret_chat_id;
  CHECK(secret_chat_id.is_valid());
  CHECK(user_id.is_valid());
  CHECK(message_id.is_valid());
  CHECK(date > 0);

  auto pending_secret_message = make_unique<PendingSecretMessage>();
  pending_secret_message->success_promise = std::move(promise);
  MessageInfo &message_info = pending_secret_message->message_info;
  message_info.dialog_id = DialogId(secret_chat_id);
  message_info.message_id = message_id;
  message_info.sender_user_id = user_id;
  message_info.date = date;
  message_info.random_id = random_id;
  message_info.flags = MESSAGE_FLAG_HAS_FROM_ID;
  message_info.content = create_screenshot_taken_message_content();

  Dialog *d = get_dialog_force(message_info.dialog_id);
  if (d == nullptr) {
    LOG(ERROR) << "Ignore secret message in unknown " << message_info.dialog_id;
    pending_secret_message->success_promise.set_error(Status::Error(500, "Chat not found"));
    return;
  }

  add_secret_message(std::move(pending_secret_message));
}

void MessagesManager::on_secret_chat_ttl_changed(SecretChatId secret_chat_id, UserId user_id, MessageId message_id,
                                                 int32 date, int32 ttl, int64 random_id, Promise<> promise) {
  LOG(DEBUG) << "On TTL set in " << secret_chat_id << " to " << ttl;
  CHECK(secret_chat_id.is_valid());
  CHECK(user_id.is_valid());
  CHECK(message_id.is_valid());
  CHECK(date > 0);
  if (ttl < 0) {
    LOG(WARNING) << "Receive wrong TTL = " << ttl;
    promise.set_value(Unit());
    return;
  }

  auto pending_secret_message = make_unique<PendingSecretMessage>();
  pending_secret_message->success_promise = std::move(promise);
  MessageInfo &message_info = pending_secret_message->message_info;
  message_info.dialog_id = DialogId(secret_chat_id);
  message_info.message_id = message_id;
  message_info.sender_user_id = user_id;
  message_info.date = date;
  message_info.random_id = random_id;
  message_info.flags = MESSAGE_FLAG_HAS_FROM_ID;
  message_info.content = create_chat_set_ttl_message_content(ttl);

  Dialog *d = get_dialog_force(message_info.dialog_id);
  if (d == nullptr) {
    LOG(ERROR) << "Ignore secret message in unknown " << message_info.dialog_id;
    pending_secret_message->success_promise.set_error(Status::Error(500, "Chat not found"));
    return;
  }

  add_secret_message(std::move(pending_secret_message));
}

void MessagesManager::add_secret_message(unique_ptr<PendingSecretMessage> pending_secret_message,
                                         Promise<Unit> lock_promise) {
  auto &multipromise = pending_secret_message->load_data_multipromise;
  multipromise.set_ignore_errors(true);
  int64 token = pending_secret_messages_.add(std::move(pending_secret_message));

  multipromise.add_promise(PromiseCreator::lambda([token, actor_id = actor_id(this),
                                                   this](Result<Unit> result) mutable {
    if (result.is_ok() && !G()->close_flag()) {  // if we aren't closing
      this->pending_secret_messages_.finish(token, [actor_id](unique_ptr<PendingSecretMessage> pending_secret_message) {
        send_closure_later(actor_id, &MessagesManager::finish_add_secret_message, std::move(pending_secret_message));
      });
    }
  }));

  if (!lock_promise) {
    lock_promise = multipromise.get_promise();
  }
  lock_promise.set_value(Unit());
}

void MessagesManager::finish_add_secret_message(unique_ptr<PendingSecretMessage> pending_secret_message) {
  if (G()->close_flag()) {
    return;
  }

  if (pending_secret_message->type == PendingSecretMessage::Type::DeleteMessages) {
    return finish_delete_secret_messages(pending_secret_message->dialog_id,
                                         std::move(pending_secret_message->random_ids),
                                         std::move(pending_secret_message->success_promise));
  }
  if (pending_secret_message->type == PendingSecretMessage::Type::DeleteHistory) {
    return finish_delete_secret_chat_history(
        pending_secret_message->dialog_id, pending_secret_message->remove_from_dialog_list,
        pending_secret_message->last_message_id, std::move(pending_secret_message->success_promise));
  }

  auto d = get_dialog(pending_secret_message->message_info.dialog_id);
  CHECK(d != nullptr);
  auto random_id = pending_secret_message->message_info.random_id;
  auto message_id = get_message_id_by_random_id(d, random_id, "finish_add_secret_message");
  if (message_id.is_valid()) {
    if (message_id != pending_secret_message->message_info.message_id) {
      LOG(WARNING) << "Ignore duplicate " << pending_secret_message->message_info.message_id
                   << " received earlier with " << message_id << " and random_id " << random_id;
    }
  } else {
    on_get_message(std::move(pending_secret_message->message_info), true, false, true, true,
                   "finish add secret message");
  }
  pending_secret_message->success_promise.set_value(Unit());  // TODO: set after message is saved
}

MessagesManager::MessageInfo MessagesManager::parse_telegram_api_message(
    tl_object_ptr<telegram_api::Message> message_ptr, bool is_scheduled, const char *source) const {
  LOG(DEBUG) << "Receive from " << source << " " << to_string(message_ptr);
  LOG_CHECK(message_ptr != nullptr) << source;

  MessageInfo message_info;
  message_info.message_id = get_message_id(message_ptr, is_scheduled);
  switch (message_ptr->get_id()) {
    case telegram_api::messageEmpty::ID:
      message_info.message_id = MessageId();
      break;
    case telegram_api::message::ID: {
      auto message = move_tl_object_as<telegram_api::message>(message_ptr);

      message_info.dialog_id = DialogId(message->peer_id_);
      if (message->from_id_ != nullptr) {
        message_info.sender_dialog_id = DialogId(message->from_id_);
      } else {
        message_info.sender_dialog_id = message_info.dialog_id;
      }
      message_info.date = message->date_;
      message_info.forward_header = std::move(message->fwd_from_);
      message_info.reply_header = std::move(message->reply_to_);
      if (message->flags_ & MESSAGE_FLAG_IS_SENT_VIA_BOT) {
        message_info.via_bot_user_id = UserId(message->via_bot_id_);
        if (!message_info.via_bot_user_id.is_valid()) {
          LOG(ERROR) << "Receive invalid " << message_info.via_bot_user_id << " from " << source;
          message_info.via_bot_user_id = UserId();
        }
      }
      if (message->flags_ & MESSAGE_FLAG_HAS_INTERACTION_INFO) {
        message_info.view_count = message->views_;
        message_info.forward_count = message->forwards_;
      }
      if (message->flags_ & MESSAGE_FLAG_HAS_REPLY_INFO) {
        message_info.reply_info = std::move(message->replies_);
      }
      if (message->flags_ & MESSAGE_FLAG_HAS_EDIT_DATE) {
        message_info.edit_date = message->edit_date_;
      }
      if (message->flags_ & MESSAGE_FLAG_HAS_MEDIA_ALBUM_ID) {
        message_info.media_album_id = message->grouped_id_;
      }
      if (message->flags_ & MESSAGE_FLAG_HAS_TTL_PERIOD) {
        message_info.ttl_period = message->ttl_period_;
      }
      message_info.flags = message->flags_;
      bool is_content_read = (message->flags_ & MESSAGE_FLAG_HAS_UNREAD_CONTENT) == 0;
      if (is_message_auto_read(message_info.dialog_id, (message->flags_ & MESSAGE_FLAG_IS_OUT) != 0)) {
        is_content_read = true;
      }
      if (is_scheduled) {
        is_content_read = false;
      }
      auto new_source = PSTRING() << FullMessageId(message_info.dialog_id, message_info.message_id) << " from "
                                  << source;
      message_info.content = get_message_content(
          td_,
          get_message_text(td_->contacts_manager_.get(), std::move(message->message_), std::move(message->entities_),
                           true, message_info.forward_header ? message_info.forward_header->date_ : message_info.date,
                           message_info.media_album_id != 0, new_source.c_str()),
          std::move(message->media_), message_info.dialog_id, is_content_read, message_info.via_bot_user_id,
          &message_info.ttl);
      message_info.reply_markup =
          message->flags_ & MESSAGE_FLAG_HAS_REPLY_MARKUP ? std::move(message->reply_markup_) : nullptr;
      message_info.restriction_reasons = get_restriction_reasons(std::move(message->restriction_reason_));
      message_info.author_signature = std::move(message->post_author_);
      break;
    }
    case telegram_api::messageService::ID: {
      auto message = move_tl_object_as<telegram_api::messageService>(message_ptr);

      message_info.dialog_id = DialogId(message->peer_id_);
      if (message->from_id_ != nullptr) {
        message_info.sender_dialog_id = DialogId(message->from_id_);
      } else {
        message_info.sender_dialog_id = message_info.dialog_id;
      }
      message_info.date = message->date_;
      if (message->flags_ & MESSAGE_FLAG_HAS_TTL_PERIOD) {
        message_info.ttl_period = message->ttl_period_;
      }
      message_info.flags = message->flags_;
      auto reply_to_message_id =
          MessageId(ServerMessageId(message->reply_to_ == nullptr ? 0 : message->reply_to_->reply_to_msg_id_));
      message_info.content =
          get_action_message_content(td_, std::move(message->action_), message_info.dialog_id, reply_to_message_id);
      break;
    }
    default:
      UNREACHABLE();
      break;
  }
  if (message_info.sender_dialog_id.is_valid() && message_info.sender_dialog_id.get_type() == DialogType::User) {
    message_info.sender_user_id = message_info.sender_dialog_id.get_user_id();
    message_info.sender_dialog_id = DialogId();
  }
  return message_info;
}

std::pair<DialogId, unique_ptr<MessagesManager::Message>> MessagesManager::create_message(MessageInfo &&message_info,
                                                                                          bool is_channel_message) {
  DialogId dialog_id = message_info.dialog_id;
  MessageId message_id = message_info.message_id;
  if ((!message_id.is_valid() && !message_id.is_valid_scheduled()) || !dialog_id.is_valid()) {
    if (message_id != MessageId() || dialog_id != DialogId()) {
      LOG(ERROR) << "Receive " << message_id << " in " << dialog_id;
    }
    return {DialogId(), nullptr};
  }
  if (message_id.is_yet_unsent() || message_id.is_local()) {
    LOG(ERROR) << "Receive " << message_id;
    return {DialogId(), nullptr};
  }

  CHECK(message_info.content != nullptr);

  auto dialog_type = dialog_id.get_type();
  UserId sender_user_id = message_info.sender_user_id;
  DialogId sender_dialog_id = message_info.sender_dialog_id;
  if (!sender_user_id.is_valid()) {
    if (sender_user_id != UserId()) {
      LOG(ERROR) << "Receive invalid " << sender_user_id;
      sender_user_id = UserId();
    }
    if (!is_broadcast_channel(dialog_id) && td_->auth_manager_->is_bot()) {
      if (dialog_id == sender_dialog_id) {
        td_->contacts_manager_->add_anonymous_bot_user();
      } else {
        td_->contacts_manager_->add_service_notifications_user();
      }
    }
  }
  if (sender_dialog_id.is_valid()) {
    if (dialog_type == DialogType::User || dialog_type == DialogType::SecretChat) {
      LOG(ERROR) << "Receive " << message_id << " sent by " << sender_dialog_id << " in " << dialog_id;
      return {DialogId(), nullptr};
    }
  } else if (sender_dialog_id != DialogId()) {
    LOG(ERROR) << "Receive invalid " << sender_dialog_id;
    sender_dialog_id = DialogId();
  }
  if (message_id.is_scheduled()) {
    is_channel_message = (dialog_type == DialogType::Channel);
  }

  int32 flags = message_info.flags;
  bool is_outgoing = (flags & MESSAGE_FLAG_IS_OUT) != 0;
  bool is_silent = (flags & MESSAGE_FLAG_IS_SILENT) != 0;
  bool is_channel_post = (flags & MESSAGE_FLAG_IS_POST) != 0;
  bool is_legacy = (flags & MESSAGE_FLAG_IS_LEGACY) != 0;
  bool hide_edit_date = (flags & MESSAGE_FLAG_HIDE_EDIT_DATE) != 0;
  bool is_from_scheduled = (flags & MESSAGE_FLAG_IS_FROM_SCHEDULED) != 0;
  bool is_pinned = (flags & MESSAGE_FLAG_IS_PINNED) != 0;

  LOG_IF(ERROR, is_channel_message != (dialog_type == DialogType::Channel))
      << "is_channel_message is wrong for " << message_id << " received in the " << dialog_id;
  LOG_IF(ERROR, is_channel_post && !is_broadcast_channel(dialog_id))
      << "is_channel_post is true for " << message_id << " received in the " << dialog_id;

  UserId my_id = td_->contacts_manager_->get_my_id();
  DialogId my_dialog_id = DialogId(my_id);
  if (dialog_id == my_dialog_id && (sender_user_id != my_id || sender_dialog_id.is_valid())) {
    LOG(ERROR) << "Receive " << sender_user_id << "/" << sender_dialog_id << " as a sender of " << message_id
               << " instead of self";
    sender_user_id = my_id;
    sender_dialog_id = DialogId();
  }

  bool supposed_to_be_outgoing = sender_user_id == my_id && !(dialog_id == my_dialog_id && !message_id.is_scheduled());
  if (sender_user_id.is_valid() && supposed_to_be_outgoing != is_outgoing) {
    LOG(ERROR) << "Receive wrong message out flag: me is " << my_id << ", message is from " << sender_user_id
               << ", flags = " << flags << " for " << message_id << " in " << dialog_id;
    is_outgoing = supposed_to_be_outgoing;

    /*
    // it is useless to call getChannelsDifference, because the channel pts will be increased already
    if (dialog_type == DialogType::Channel && !running_get_difference_ && !running_get_channel_difference(dialog_id) &&
        get_channel_difference_to_log_event_id_.count(dialog_id) == 0) {
      // it is safer to completely ignore the message and re-get it through getChannelsDifference
      Dialog *d = get_dialog(dialog_id);
      if (d != nullptr) {
        channel_get_difference_retry_timeout_.add_timeout_in(dialog_id.get(), 0.001);
        return {DialogId(), nullptr};
      }
    }
    */
  }

  MessageId reply_to_message_id = message_info.reply_to_message_id;
  DialogId reply_in_dialog_id;
  MessageId top_thread_message_id;
  if (message_info.reply_header != nullptr) {
    reply_to_message_id = MessageId(ServerMessageId(message_info.reply_header->reply_to_msg_id_));
    auto reply_to_peer_id = std::move(message_info.reply_header->reply_to_peer_id_);
    if (reply_to_peer_id != nullptr) {
      reply_in_dialog_id = DialogId(reply_to_peer_id);
      if (!reply_in_dialog_id.is_valid()) {
        LOG(ERROR) << " Receive reply in invalid " << to_string(reply_to_peer_id);
        reply_to_message_id = MessageId();
        reply_in_dialog_id = DialogId();
      }
    }
    if (reply_to_message_id.is_valid() && !td_->auth_manager_->is_bot()) {
      if ((message_info.reply_header->flags_ & telegram_api::messageReplyHeader::REPLY_TO_TOP_ID_MASK) != 0) {
        top_thread_message_id = MessageId(ServerMessageId(message_info.reply_header->reply_to_top_id_));
      } else if (!is_broadcast_channel(dialog_id)) {
        top_thread_message_id = reply_to_message_id;
      }
    }
  }
  fix_server_reply_to_message_id(dialog_id, message_id, reply_in_dialog_id, reply_to_message_id);
  fix_server_reply_to_message_id(dialog_id, message_id, reply_in_dialog_id, top_thread_message_id);

  UserId via_bot_user_id = message_info.via_bot_user_id;
  if (!via_bot_user_id.is_valid()) {
    via_bot_user_id = UserId();
  }

  int32 date = message_info.date;
  if (date <= 0) {
    LOG(ERROR) << "Wrong date = " << date << " received in " << message_id << " in " << dialog_id;
    date = 1;
  }

  int32 edit_date = message_info.edit_date;
  if (edit_date < 0) {
    LOG(ERROR) << "Wrong edit_date = " << edit_date << " received in " << message_id << " in " << dialog_id;
    edit_date = 0;
  }

  auto content_type = message_info.content->get_type();
  if (hide_edit_date && td_->auth_manager_->is_bot()) {
    hide_edit_date = false;
  }
  if (hide_edit_date && content_type == MessageContentType::LiveLocation) {
    hide_edit_date = false;
  }

  int32 ttl_period = message_info.ttl_period;
  if (ttl_period < 0 || message_id.is_scheduled()) {
    LOG(ERROR) << "Wrong TTL period = " << ttl_period << " received in " << message_id << " in " << dialog_id;
    ttl_period = 0;
  }

  int32 ttl = message_info.ttl;
  bool is_content_secret = is_secret_message_content(ttl, content_type);  // should be calculated before TTL is adjusted
  if (ttl < 0 || message_id.is_scheduled()) {
    LOG(ERROR) << "Wrong TTL = " << ttl << " received in " << message_id << " in " << dialog_id;
    ttl = 0;
  } else if (ttl > 0) {
    ttl = max(ttl, get_message_content_duration(message_info.content.get(), td_) + 1);
  }

  int32 view_count = message_info.view_count;
  if (view_count < 0) {
    LOG(ERROR) << "Wrong view_count = " << view_count << " received in " << message_id << " in " << dialog_id;
    view_count = 0;
  }
  int32 forward_count = message_info.forward_count;
  if (forward_count < 0) {
    LOG(ERROR) << "Wrong forward_count = " << forward_count << " received in " << message_id << " in " << dialog_id;
    forward_count = 0;
  }
  MessageReplyInfo reply_info(std::move(message_info.reply_info), td_->auth_manager_->is_bot());
  if (!top_thread_message_id.is_valid() && !is_broadcast_channel(dialog_id) &&
      is_active_message_reply_info(dialog_id, reply_info)) {
    top_thread_message_id = message_id;
  }
  if (top_thread_message_id.is_valid() && dialog_type != DialogType::Channel) {
    top_thread_message_id = MessageId();
  }

  bool has_forward_info = message_info.forward_header != nullptr;

  LOG(INFO) << "Receive " << message_id << " in " << dialog_id << " from " << sender_user_id << "/" << sender_dialog_id;

  auto message = make_unique<Message>();
  set_message_id(message, message_id);
  message->sender_user_id = sender_user_id;
  message->sender_dialog_id = sender_dialog_id;
  message->date = date;
  message->ttl_period = ttl_period;
  message->ttl = ttl;
  message->edit_date = edit_date;
  message->random_id = message_info.random_id;
  message->forward_info = get_message_forward_info(std::move(message_info.forward_header));
  message->reply_to_message_id = reply_to_message_id;
  message->reply_in_dialog_id = reply_in_dialog_id;
  message->top_thread_message_id = top_thread_message_id;
  message->via_bot_user_id = via_bot_user_id;
  message->restriction_reasons = std::move(message_info.restriction_reasons);
  message->author_signature = std::move(message_info.author_signature);
  message->is_outgoing = is_outgoing;
  message->is_channel_post = is_channel_post;
  message->contains_mention =
      !is_outgoing && dialog_type != DialogType::User &&
      ((flags & MESSAGE_FLAG_HAS_MENTION) != 0 || content_type == MessageContentType::PinMessage);
  message->contains_unread_mention =
      !message_id.is_scheduled() && message_id.is_server() && message->contains_mention &&
      (flags & MESSAGE_FLAG_HAS_UNREAD_CONTENT) != 0 &&
      (dialog_type == DialogType::Chat || (dialog_type == DialogType::Channel && !is_broadcast_channel(dialog_id)));
  message->disable_notification = is_silent;
  message->is_content_secret = is_content_secret;
  message->hide_edit_date = hide_edit_date;
  message->is_from_scheduled = is_from_scheduled;
  message->is_pinned = is_pinned;
  message->view_count = view_count;
  message->forward_count = forward_count;
  message->reply_info = std::move(reply_info);
  message->legacy_layer = (is_legacy ? MTPROTO_LAYER : 0);
  message->content = std::move(message_info.content);
  message->reply_markup = get_reply_markup(std::move(message_info.reply_markup), td_->auth_manager_->is_bot(), false,
                                           message->contains_mention || dialog_type == DialogType::User);

  if (content_type == MessageContentType::ExpiredPhoto || content_type == MessageContentType::ExpiredVideo) {
    CHECK(message->ttl == 0);  // ttl is ignored/set to 0 if the message has already been expired
    if (message->reply_markup != nullptr) {
      if (message->reply_markup->type != ReplyMarkup::Type::InlineKeyboard) {
        message->had_reply_markup = true;
      }
      message->reply_markup = nullptr;
    }
    message->reply_to_message_id = MessageId();
    message->reply_in_dialog_id = DialogId();
    message->top_thread_message_id = MessageId();
    message->linked_top_thread_message_id = MessageId();
  }

  if (message_info.media_album_id != 0) {
    if (!is_allowed_media_group_content(content_type)) {
      LOG(ERROR) << "Receive media group id " << message_info.media_album_id << " in " << message_id << " from "
                 << dialog_id << " with content "
                 << oneline(to_string(
                        get_message_content_object(message->content.get(), td_, message->date, is_content_secret)));
    } else {
      message->media_album_id = message_info.media_album_id;
    }
  }

  if (message->forward_info == nullptr && has_forward_info) {
    message->had_forward_info = true;
  }

  return {dialog_id, std::move(message)};
}

MessageId MessagesManager::find_old_message_id(DialogId dialog_id, MessageId message_id) const {
  if (message_id.is_scheduled()) {
    CHECK(message_id.is_scheduled_server());
    auto dialog_it = update_scheduled_message_ids_.find(dialog_id);
    if (dialog_it != update_scheduled_message_ids_.end()) {
      auto it = dialog_it->second.find(message_id.get_scheduled_server_message_id());
      if (it != dialog_it->second.end()) {
        return it->second;
      }
    }
  } else {
    CHECK(message_id.is_server());
    auto it = update_message_ids_.find(FullMessageId(dialog_id, message_id));
    if (it != update_message_ids_.end()) {
      return it->second;
    }
  }
  return MessageId();
}

void MessagesManager::delete_update_message_id(DialogId dialog_id, MessageId message_id) {
  if (message_id.is_scheduled()) {
    CHECK(message_id.is_scheduled_server());
    auto dialog_it = update_scheduled_message_ids_.find(dialog_id);
    CHECK(dialog_it != update_scheduled_message_ids_.end());
    auto erased_count = dialog_it->second.erase(message_id.get_scheduled_server_message_id());
    CHECK(erased_count > 0);
    if (dialog_it->second.empty()) {
      update_scheduled_message_ids_.erase(dialog_it);
    }
  } else {
    CHECK(message_id.is_server());
    auto erased_count = update_message_ids_.erase(FullMessageId(dialog_id, message_id));
    CHECK(erased_count > 0);
  }
}

FullMessageId MessagesManager::on_get_message(tl_object_ptr<telegram_api::Message> message_ptr, bool from_update,
                                              bool is_channel_message, bool is_scheduled, bool have_previous,
                                              bool have_next, const char *source) {
  return on_get_message(parse_telegram_api_message(std::move(message_ptr), is_scheduled, source), from_update,
                        is_channel_message, have_previous, have_next, source);
}

FullMessageId MessagesManager::on_get_message(MessageInfo &&message_info, bool from_update, bool is_channel_message,
                                              bool have_previous, bool have_next, const char *source) {
  DialogId dialog_id;
  unique_ptr<Message> new_message;
  std::tie(dialog_id, new_message) = create_message(std::move(message_info), is_channel_message);
  if (new_message == nullptr) {
    return FullMessageId();
  }
  MessageId message_id = new_message->message_id;

  new_message->have_previous = have_previous;
  new_message->have_next = have_next;

  bool need_update = from_update;
  bool need_update_dialog_pos = false;

  MessageId old_message_id = find_old_message_id(dialog_id, message_id);
  bool is_sent_message = false;
  if (old_message_id.is_valid()) {
    LOG(INFO) << "Found temporary " << old_message_id << " for " << FullMessageId{dialog_id, message_id};
  }
  if (old_message_id.is_valid() || old_message_id.is_valid_scheduled()) {
    Dialog *d = get_dialog(dialog_id);
    CHECK(d != nullptr);

    if (!from_update && !message_id.is_scheduled()) {
      if (message_id <= d->last_new_message_id) {
        if (get_message_force(d, message_id, "receive missed unsent message not from update") != nullptr) {
          LOG(ERROR) << "New " << old_message_id << "/" << message_id << " in " << dialog_id << " from " << source
                     << " has id less than last_new_message_id = " << d->last_new_message_id;
          return FullMessageId();
        }
        // if there is no message yet, then it is likely was missed because of a server bug and is being repaired via
        // get_message_from_server from after_get_difference
        // TODO move to INFO
        LOG(ERROR) << "Receive " << old_message_id << "/" << message_id << " in " << dialog_id << " from " << source
                   << " with id less than last_new_message_id = " << d->last_new_message_id
                   << " and trying to add it anyway";
      } else {
        LOG(ERROR) << "Ignore " << old_message_id << "/" << message_id << " received not through update from " << source
                   << ": "
                   << oneline(to_string(get_message_object(dialog_id, new_message.get())));  // TODO move to INFO
        dump_debug_message_op(d, 3);                                                         // TODO remove
        if (dialog_id.get_type() == DialogType::Channel && have_input_peer(dialog_id, AccessRights::Read)) {
          channel_get_difference_retry_timeout_.add_timeout_in(dialog_id.get(), 0.001);
        }
        return FullMessageId();
      }
    }

    delete_update_message_id(dialog_id, message_id);

    if (!new_message->is_outgoing && dialog_id != get_my_dialog_id()) {
      // sent message is not from me
      LOG(ERROR) << "Sent in " << dialog_id << " " << message_id << " is sent by " << new_message->sender_user_id << "/"
                 << new_message->sender_dialog_id;
      return FullMessageId();
    }

    being_readded_message_id_ = {dialog_id, old_message_id};
    unique_ptr<Message> old_message =
        delete_message(d, old_message_id, false, &need_update_dialog_pos, "add sent message");
    if (old_message == nullptr) {
      // message has already been deleted by the user or sent to inaccessible channel
      // don't need to send update to the user, because the message has already been deleted
      LOG(INFO) << "Delete already deleted sent " << new_message->message_id << " from server";
      delete_message_from_server(dialog_id, new_message->message_id, true);
      being_readded_message_id_ = FullMessageId();
      return FullMessageId();
    }

    need_update = false;

    set_message_id(new_message, old_message_id);
    new_message->from_database = false;
    new_message->have_previous = false;
    new_message->have_next = false;
    update_message(d, old_message.get(), std::move(new_message), &need_update_dialog_pos);
    new_message = std::move(old_message);

    set_message_id(new_message, message_id);
    send_update_message_send_succeeded(d, old_message_id, new_message.get());

    if (!message_id.is_scheduled()) {
      is_sent_message = true;
    }

    if (!from_update) {
      new_message->have_previous = have_previous;
      new_message->have_next = have_next;
    } else {
      new_message->have_previous = true;
      new_message->have_next = true;
    }
  }

  const Message *m = add_message_to_dialog(dialog_id, std::move(new_message), from_update, &need_update,
                                           &need_update_dialog_pos, source);
  being_readded_message_id_ = FullMessageId();
  Dialog *d = get_dialog(dialog_id);
  if (m == nullptr) {
    if (need_update_dialog_pos && d != nullptr) {
      send_update_chat_last_message(d, "on_get_message");
    }

    return FullMessageId();
  }

  CHECK(d != nullptr);

  auto pcc_it = pending_created_dialogs_.find(dialog_id);
  if (from_update && pcc_it != pending_created_dialogs_.end()) {
    pcc_it->second.set_value(Unit());

    pending_created_dialogs_.erase(pcc_it);
  }

  if (need_update) {
    send_update_new_message(d, m);
  }

  if (is_sent_message) {
    try_add_active_live_location(dialog_id, m);

    // add_message_to_dialog will not update counts, because need_update == false
    update_message_count_by_index(d, +1, m);
  }

  if (is_sent_message || need_update) {
    update_reply_count_by_message(d, +1, m);
    update_forward_count(dialog_id, m);
  }

  if (dialog_id.get_type() == DialogType::Channel && !have_input_peer(dialog_id, AccessRights::Read)) {
    auto p = delete_message(d, message_id, false, &need_update_dialog_pos, "get a message in inaccessible chat");
    CHECK(p.get() == m);
    // CHECK(d->messages == nullptr);
    send_update_delete_messages(dialog_id, {p->message_id.get()}, false, false);
    // don't need to update dialog pos
    return FullMessageId();
  }

  if (m->message_id.is_scheduled()) {
    send_update_chat_has_scheduled_messages(d, false);
  }

  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "on_get_message");
  }

  // set dialog reply markup only after updateNewMessage and updateChatLastMessage are sent
  if (need_update && m->reply_markup != nullptr && !m->message_id.is_scheduled() &&
      m->reply_markup->type != ReplyMarkup::Type::InlineKeyboard && m->reply_markup->is_personal &&
      !td_->auth_manager_->is_bot()) {
    set_dialog_reply_markup(d, message_id);
  }

  return FullMessageId(dialog_id, message_id);
}

void MessagesManager::set_dialog_last_message_id(Dialog *d, MessageId last_message_id, const char *source) {
  CHECK(!last_message_id.is_scheduled());

  LOG(INFO) << "Set " << d->dialog_id << " last message to " << last_message_id << " from " << source;
  d->last_message_id = last_message_id;

  if (!last_message_id.is_valid()) {
    d->suffix_load_first_message_id_ = MessageId();
    d->suffix_load_done_ = false;
  }
  if (last_message_id.is_valid() && d->delete_last_message_date != 0) {
    d->delete_last_message_date = 0;
    d->deleted_last_message_id = MessageId();
    d->is_last_message_deleted_locally = false;
    on_dialog_updated(d->dialog_id, "update_delete_last_message_date");
  }
  if (d->pending_last_message_date != 0) {
    d->pending_last_message_date = 0;
    d->pending_last_message_id = MessageId();
  }
}

void MessagesManager::set_dialog_first_database_message_id(Dialog *d, MessageId first_database_message_id,
                                                           const char *source) {
  CHECK(!first_database_message_id.is_scheduled());
  if (first_database_message_id == d->first_database_message_id) {
    return;
  }

  LOG(INFO) << "Set " << d->dialog_id << " first database message to " << first_database_message_id << " from "
            << source;
  d->first_database_message_id = first_database_message_id;
  on_dialog_updated(d->dialog_id, "set_dialog_first_database_message_id");
}

void MessagesManager::set_dialog_last_database_message_id(Dialog *d, MessageId last_database_message_id,
                                                          const char *source, bool is_loaded_from_database) {
  CHECK(!last_database_message_id.is_scheduled());
  if (last_database_message_id == d->last_database_message_id) {
    return;
  }

  LOG(INFO) << "Set " << d->dialog_id << " last database message to " << last_database_message_id << " from " << source;
  d->debug_set_dialog_last_database_message_id = source;
  d->last_database_message_id = last_database_message_id;
  if (!is_loaded_from_database) {
    on_dialog_updated(d->dialog_id, "set_dialog_last_database_message_id");
  }
}

void MessagesManager::remove_dialog_newer_messages(Dialog *d, MessageId from_message_id, const char *source) {
  LOG(INFO) << "Remove messages in " << d->dialog_id << " newer than " << from_message_id << " from " << source;
  CHECK(!d->last_new_message_id.is_valid());

  delete_all_dialog_messages_from_database(d, MessageId::max(), "remove_dialog_newer_messages");
  set_dialog_first_database_message_id(d, MessageId(), "remove_dialog_newer_messages");
  set_dialog_last_database_message_id(d, MessageId(), source);
  if (d->dialog_id.get_type() != DialogType::SecretChat) {
    d->have_full_history = false;
  }
  invalidate_message_indexes(d);

  vector<MessageId> to_delete_message_ids;
  find_newer_messages(d->messages.get(), from_message_id, to_delete_message_ids);
  td::remove_if(to_delete_message_ids, [](MessageId message_id) { return message_id.is_yet_unsent(); });
  if (!to_delete_message_ids.empty()) {
    LOG(INFO) << "Delete " << format::as_array(to_delete_message_ids) << " newer than " << from_message_id << " in "
              << d->dialog_id << " from " << source;

    vector<int64> deleted_message_ids;
    bool need_update_dialog_pos = false;
    for (auto message_id : to_delete_message_ids) {
      auto message = delete_message(d, message_id, false, &need_update_dialog_pos, "remove_dialog_newer_messages");
      if (message != nullptr) {
        deleted_message_ids.push_back(message->message_id.get());
      }
    }
    if (need_update_dialog_pos) {
      send_update_chat_last_message(d, "remove_dialog_newer_messages");
    }
    send_update_delete_messages(d->dialog_id, std::move(deleted_message_ids), false, false);
  }
}

void MessagesManager::set_dialog_last_new_message_id(Dialog *d, MessageId last_new_message_id, const char *source) {
  CHECK(!last_new_message_id.is_scheduled());

  LOG_CHECK(last_new_message_id > d->last_new_message_id)
      << last_new_message_id << " " << d->last_new_message_id << " " << source;
  CHECK(d->dialog_id.get_type() == DialogType::SecretChat || last_new_message_id.is_server());
  if (!d->last_new_message_id.is_valid()) {
    remove_dialog_newer_messages(d, last_new_message_id, source);

    auto last_new_message = get_message(d, last_new_message_id);
    if (last_new_message != nullptr) {
      add_message_to_database(d, last_new_message, "set_dialog_last_new_message_id");
      set_dialog_first_database_message_id(d, last_new_message_id, "set_dialog_last_new_message_id");
      set_dialog_last_database_message_id(d, last_new_message_id, "set_dialog_last_new_message_id");
      try_restore_dialog_reply_markup(d, last_new_message);
    }
  }

  LOG(INFO) << "Set " << d->dialog_id << " last new message to " << last_new_message_id << " from " << source;
  d->last_new_message_id = last_new_message_id;
  on_dialog_updated(d->dialog_id, source);
}

void MessagesManager::set_dialog_last_clear_history_date(Dialog *d, int32 date, MessageId last_clear_history_message_id,
                                                         const char *source, bool is_loaded_from_database) {
  CHECK(!last_clear_history_message_id.is_scheduled());

  if (d->last_clear_history_message_id == last_clear_history_message_id && d->last_clear_history_date == date) {
    return;
  }

  LOG(INFO) << "Set " << d->dialog_id << " last clear history date to " << date << " of "
            << last_clear_history_message_id << " from " << source;
  if (d->last_clear_history_message_id.is_valid()) {
    switch (d->dialog_id.get_type()) {
      case DialogType::User:
      case DialogType::Chat:
        last_clear_history_message_id_to_dialog_id_.erase(d->last_clear_history_message_id);
        break;
      case DialogType::Channel:
      case DialogType::SecretChat:
        // nothing to do
        break;
      case DialogType::None:
      default:
        UNREACHABLE();
    }
  }

  d->last_clear_history_date = date;
  d->last_clear_history_message_id = last_clear_history_message_id;
  if (!is_loaded_from_database) {
    on_dialog_updated(d->dialog_id, "set_dialog_last_clear_history_date");
  }

  if (d->last_clear_history_message_id.is_valid()) {
    switch (d->dialog_id.get_type()) {
      case DialogType::User:
      case DialogType::Chat:
        last_clear_history_message_id_to_dialog_id_[d->last_clear_history_message_id] = d->dialog_id;
        break;
      case DialogType::Channel:
      case DialogType::SecretChat:
        // nothing to do
        break;
      case DialogType::None:
      default:
        UNREACHABLE();
    }
  }
}

void MessagesManager::set_dialog_unread_mention_count(Dialog *d, int32 unread_mention_count) {
  CHECK(d->unread_mention_count != unread_mention_count);
  CHECK(unread_mention_count >= 0);

  d->unread_mention_count = unread_mention_count;
  d->message_count_by_index[message_search_filter_index(MessageSearchFilter::UnreadMention)] = unread_mention_count;
}

void MessagesManager::set_dialog_is_empty(Dialog *d, const char *source) {
  LOG(INFO) << "Set " << d->dialog_id << " is_empty to true from " << source;
  d->is_empty = true;

  if (d->server_unread_count + d->local_unread_count > 0) {
    MessageId max_message_id =
        d->last_database_message_id.is_valid() ? d->last_database_message_id : d->last_new_message_id;
    if (max_message_id.is_valid()) {
      read_history_inbox(d->dialog_id, max_message_id, -1, "set_dialog_is_empty");
    }
    if (d->server_unread_count != 0 || d->local_unread_count != 0) {
      set_dialog_last_read_inbox_message_id(d, MessageId::min(), 0, 0, true, "set_dialog_is_empty");
    }
  }
  if (d->unread_mention_count > 0) {
    set_dialog_unread_mention_count(d, 0);
    send_update_chat_unread_mention_count(d);
  }
  if (d->reply_markup_message_id != MessageId()) {
    set_dialog_reply_markup(d, MessageId());
  }
  std::fill(d->message_count_by_index.begin(), d->message_count_by_index.end(), 0);
  d->notification_id_to_message_id.clear();

  if (d->delete_last_message_date != 0) {
    if (d->is_last_message_deleted_locally && d->last_clear_history_date == 0) {
      set_dialog_last_clear_history_date(d, d->delete_last_message_date, d->deleted_last_message_id,
                                         "set_dialog_is_empty");
    }
    d->delete_last_message_date = 0;
    d->deleted_last_message_id = MessageId();
    d->is_last_message_deleted_locally = false;

    on_dialog_updated(d->dialog_id, "set_dialog_is_empty");
  }
  if (d->pending_last_message_date != 0) {
    d->pending_last_message_date = 0;
    d->pending_last_message_id = MessageId();
  }
  if (d->last_database_message_id.is_valid()) {
    set_dialog_first_database_message_id(d, MessageId(), "set_dialog_is_empty");
    set_dialog_last_database_message_id(d, MessageId(), "set_dialog_is_empty");
  }

  update_dialog_pos(d, source);
}

int64 MessagesManager::get_dialog_pinned_order(DialogListId dialog_list_id, DialogId dialog_id) const {
  return get_dialog_pinned_order(get_dialog_list(dialog_list_id), dialog_id);
}

int64 MessagesManager::get_dialog_pinned_order(const DialogList *list, DialogId dialog_id) {
  if (list != nullptr && !list->pinned_dialogs_.empty()) {
    auto it = list->pinned_dialog_id_orders_.find(dialog_id);
    if (it != list->pinned_dialog_id_orders_.end()) {
      return it->second;
    }
  }
  return DEFAULT_ORDER;
}

bool MessagesManager::set_dialog_is_pinned(DialogId dialog_id, bool is_pinned) {
  if (td_->auth_manager_->is_bot()) {
    return false;
  }

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  return set_dialog_is_pinned(DialogListId(d->folder_id), d, is_pinned);
}

bool MessagesManager::set_dialog_is_pinned(DialogListId dialog_list_id, Dialog *d, bool is_pinned,
                                           bool need_update_dialog_lists) {
  if (td_->auth_manager_->is_bot()) {
    return false;
  }

  CHECK(d != nullptr);
  if (d->order == DEFAULT_ORDER && is_pinned) {
    // the chat can't be pinned
    return false;
  }

  auto positions = get_dialog_positions(d);
  auto *list = get_dialog_list(dialog_list_id);
  if (list == nullptr) {
    return false;
  }
  if (!list->are_pinned_dialogs_inited_) {
    return false;
  }
  bool was_pinned = false;
  for (size_t pos = 0; pos < list->pinned_dialogs_.size(); pos++) {
    auto &pinned_dialog = list->pinned_dialogs_[pos];
    if (pinned_dialog.get_dialog_id() == d->dialog_id) {
      // the dialog was already pinned
      if (is_pinned) {
        if (pos == 0) {
          return false;
        }
        auto order = get_next_pinned_dialog_order();
        pinned_dialog = DialogDate(order, d->dialog_id);
        std::rotate(list->pinned_dialogs_.begin(), list->pinned_dialogs_.begin() + pos,
                    list->pinned_dialogs_.begin() + pos + 1);
        list->pinned_dialog_id_orders_[d->dialog_id] = order;
      } else {
        list->pinned_dialogs_.erase(list->pinned_dialogs_.begin() + pos);
        list->pinned_dialog_id_orders_.erase(d->dialog_id);
      }
      was_pinned = true;
      break;
    }
  }
  if (!was_pinned) {
    if (!is_pinned) {
      return false;
    }
    auto order = get_next_pinned_dialog_order();
    list->pinned_dialogs_.insert(list->pinned_dialogs_.begin(), {order, d->dialog_id});
    list->pinned_dialog_id_orders_.emplace(d->dialog_id, order);
  }

  LOG(INFO) << "Set " << d->dialog_id << " is pinned in " << dialog_list_id << " to " << is_pinned;
  if (dialog_list_id.is_folder() && G()->parameters().use_message_db) {
    G()->td_db()->get_binlog_pmc()->set(
        PSTRING() << "pinned_dialog_ids" << dialog_list_id.get_folder_id().get(),
        implode(transform(list->pinned_dialogs_,
                          [](auto &pinned_dialog) { return PSTRING() << pinned_dialog.get_dialog_id().get(); }),
                ','));
  }

  if (need_update_dialog_lists) {
    update_dialog_lists(d, std::move(positions), true, false, "set_dialog_is_pinned");
  }
  return true;
}

void MessagesManager::set_dialog_reply_markup(Dialog *d, MessageId message_id) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(!message_id.is_scheduled());

  if (d->reply_markup_message_id != message_id) {
    on_dialog_updated(d->dialog_id, "set_dialog_reply_markup");
  }

  d->need_restore_reply_markup = false;

  if (d->reply_markup_message_id.is_valid() || message_id.is_valid()) {
    LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in set_dialog_reply_markup";
    d->reply_markup_message_id = message_id;
    send_closure(G()->td(), &Td::send_update,
                 make_tl_object<td_api::updateChatReplyMarkup>(d->dialog_id.get(), message_id.get()));
  }
}

void MessagesManager::try_restore_dialog_reply_markup(Dialog *d, const Message *m) {
  if (!d->need_restore_reply_markup || td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(!m->message_id.is_scheduled());
  if (m->had_reply_markup) {
    LOG(INFO) << "Restore deleted reply markup in " << d->dialog_id;
    set_dialog_reply_markup(d, MessageId());
  } else if (m->reply_markup != nullptr && m->reply_markup->type != ReplyMarkup::Type::InlineKeyboard &&
             m->reply_markup->is_personal) {
    LOG(INFO) << "Restore reply markup in " << d->dialog_id << " to " << m->message_id;
    set_dialog_reply_markup(d, m->message_id);
  }
}

void MessagesManager::set_dialog_pinned_message_notification(Dialog *d, MessageId message_id, const char *source) {
  CHECK(d != nullptr);
  CHECK(!message_id.is_scheduled());
  auto old_message_id = d->pinned_message_notification_message_id;
  if (old_message_id == message_id) {
    return;
  }
  VLOG(notifications) << "Change pinned message notification in " << d->dialog_id << " from " << old_message_id
                      << " to " << message_id;
  if (old_message_id.is_valid()) {
    auto m = get_message_force(d, old_message_id, source);
    if (m != nullptr && m->notification_id.is_valid() && is_message_notification_active(d, m)) {
      // Can't remove pinned_message_notification_message_id  before the call,
      // because the notification needs to be still active inside remove_message_notification_id
      remove_message_notification_id(d, m, true, false, true);
      on_message_changed(d, m, false, source);
    } else {
      send_closure_later(G()->notification_manager(), &NotificationManager::remove_temporary_notification_by_message_id,
                         d->mention_notification_group.group_id, old_message_id, false, source);
    }
  }
  d->pinned_message_notification_message_id = message_id;
  on_dialog_updated(d->dialog_id, source);
}

void MessagesManager::remove_dialog_pinned_message_notification(Dialog *d, const char *source) {
  set_dialog_pinned_message_notification(d, MessageId(), source);
}

void MessagesManager::remove_dialog_mention_notifications(Dialog *d) {
  auto notification_group_id = d->mention_notification_group.group_id;
  if (!notification_group_id.is_valid()) {
    return;
  }
  if (d->unread_mention_count == 0) {
    return;
  }
  CHECK(!d->being_added_message_id.is_valid());

  VLOG(notifications) << "Remove mention notifications in " << d->dialog_id;

  vector<MessageId> message_ids;
  std::unordered_set<NotificationId, NotificationIdHash> removed_notification_ids_set;
  find_messages(d->messages.get(), message_ids, [](const Message *m) { return m->contains_unread_mention; });
  VLOG(notifications) << "Found unread mentions in " << message_ids;
  for (auto &message_id : message_ids) {
    auto m = get_message(d, message_id);
    CHECK(m != nullptr);
    CHECK(m->message_id.is_valid());
    if (m->notification_id.is_valid() && is_message_notification_active(d, m) &&
        is_from_mention_notification_group(d, m)) {
      removed_notification_ids_set.insert(m->notification_id);
    }
  }

  message_ids = td_->notification_manager_->get_notification_group_message_ids(notification_group_id);
  VLOG(notifications) << "Found active mention notifications in " << message_ids;
  for (auto &message_id : message_ids) {
    CHECK(!message_id.is_scheduled());
    if (message_id != d->pinned_message_notification_message_id) {
      auto m = get_message_force(d, message_id, "remove_dialog_mention_notifications");
      if (m != nullptr && m->notification_id.is_valid() && is_message_notification_active(d, m)) {
        CHECK(is_from_mention_notification_group(d, m));
        removed_notification_ids_set.insert(m->notification_id);
      }
    }
  }

  vector<NotificationId> removed_notification_ids(removed_notification_ids_set.begin(),
                                                  removed_notification_ids_set.end());
  for (size_t i = 0; i < removed_notification_ids.size(); i++) {
    send_closure_later(G()->notification_manager(), &NotificationManager::remove_notification, notification_group_id,
                       removed_notification_ids[i], false, i + 1 == removed_notification_ids.size(), Promise<Unit>(),
                       "remove_dialog_mention_notifications");
  }
}

bool MessagesManager::set_dialog_last_notification(DialogId dialog_id, NotificationGroupInfo &group_info,
                                                   int32 last_notification_date, NotificationId last_notification_id,
                                                   const char *source) {
  if (group_info.last_notification_date != last_notification_date ||
      group_info.last_notification_id != last_notification_id) {
    VLOG(notifications) << "Set " << group_info.group_id << '/' << dialog_id << " last notification to "
                        << last_notification_id << " sent at " << last_notification_date << " from " << source;
    group_info.last_notification_date = last_notification_date;
    group_info.last_notification_id = last_notification_id;
    group_info.is_changed = true;
    on_dialog_updated(dialog_id, "set_dialog_last_notification");
    return true;
  }
  return false;
}

void MessagesManager::on_update_sent_text_message(int64 random_id,
                                                  tl_object_ptr<telegram_api::MessageMedia> message_media,
                                                  vector<tl_object_ptr<telegram_api::MessageEntity>> &&entities) {
  int32 message_media_id = message_media == nullptr ? telegram_api::messageMediaEmpty::ID : message_media->get_id();
  LOG_IF(ERROR, message_media_id != telegram_api::messageMediaWebPage::ID &&
                    message_media_id != telegram_api::messageMediaEmpty::ID)
      << "Receive non web-page media for text message: " << oneline(to_string(message_media));

  auto it = being_sent_messages_.find(random_id);
  if (it == being_sent_messages_.end()) {
    // result of sending message has already been received through getDifference
    return;
  }

  auto full_message_id = it->second;
  auto dialog_id = full_message_id.get_dialog_id();
  auto m = get_message_force(full_message_id, "on_update_sent_text_message");
  if (m == nullptr) {
    // message has already been deleted
    return;
  }
  full_message_id = FullMessageId(dialog_id, m->message_id);

  if (m->content->get_type() != MessageContentType::Text) {
    LOG(ERROR) << "Text message content has been already changed to " << m->content->get_type();
    return;
  }

  const FormattedText *old_message_text = get_message_content_text(m->content.get());
  CHECK(old_message_text != nullptr);
  FormattedText new_message_text = get_message_text(
      td_->contacts_manager_.get(), old_message_text->text, std::move(entities), true,
      m->forward_info ? m->forward_info->date : m->date, m->media_album_id != 0, "on_update_sent_text_message");
  auto new_content = get_message_content(td_, std::move(new_message_text), std::move(message_media), dialog_id,
                                         true /*likely ignored*/, UserId() /*likely ignored*/, nullptr /*ignored*/);
  if (new_content->get_type() != MessageContentType::Text) {
    LOG(ERROR) << "Text message content has changed to " << new_content->get_type();
    return;
  }

  bool need_update = false;
  bool is_content_changed = false;
  merge_message_contents(td_, m->content.get(), new_content.get(), need_message_changed_warning(m), dialog_id, false,
                         is_content_changed, need_update);

  if (is_content_changed || need_update) {
    reregister_message_content(td_, m->content.get(), new_content.get(), full_message_id,
                               "on_update_sent_text_message");
    m->content = std::move(new_content);
    m->is_content_secret = is_secret_message_content(m->ttl, MessageContentType::Text);
  }
  if (need_update) {
    send_update_message_content(dialog_id, m->message_id, m->content.get(), m->date, m->is_content_secret,
                                "on_update_sent_text_message");
  }
}

void MessagesManager::delete_pending_message_web_page(FullMessageId full_message_id) {
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  Message *m = get_message(d, full_message_id.get_message_id());
  CHECK(m != nullptr);

  MessageContent *content = m->content.get();
  CHECK(has_message_content_web_page(content));
  unregister_message_content(td_, content, full_message_id, "delete_pending_message_web_page");
  remove_message_content_web_page(content);
  register_message_content(td_, content, full_message_id, "delete_pending_message_web_page");

  // don't need to send an updateMessageContent, because the web page was pending

  on_message_changed(d, m, false, "delete_pending_message_web_page");
}

void MessagesManager::on_get_dialogs(FolderId folder_id, vector<tl_object_ptr<telegram_api::Dialog>> &&dialog_folders,
                                     int32 total_count, vector<tl_object_ptr<telegram_api::Message>> &&messages,
                                     Promise<Unit> &&promise) {
  if (td_->updates_manager_->running_get_difference()) {
    LOG(INFO) << "Postpone result of getDialogs";
    pending_on_get_dialogs_.push_back(PendingOnGetDialogs{folder_id, std::move(dialog_folders), total_count,
                                                          std::move(messages), std::move(promise)});
    return;
  }
  bool from_dialog_list = total_count >= 0;
  bool from_get_dialog = total_count == -1;
  bool from_pinned_dialog_list = total_count == -2;

  if (from_get_dialog && dialog_folders.size() == 1 && dialog_folders[0]->get_id() == telegram_api::dialog::ID) {
    DialogId dialog_id(static_cast<const telegram_api::dialog *>(dialog_folders[0].get())->peer_);
    if (running_get_channel_difference(dialog_id)) {
      LOG(INFO) << "Postpone result of channels getDialogs for " << dialog_id;
      pending_channel_on_get_dialogs_.emplace(
          dialog_id, PendingOnGetDialogs{folder_id, std::move(dialog_folders), total_count, std::move(messages),
                                         std::move(promise)});
      return;
    }
  }

  vector<tl_object_ptr<telegram_api::dialog>> dialogs;
  for (auto &dialog_folder : dialog_folders) {
    switch (dialog_folder->get_id()) {
      case telegram_api::dialog::ID:
        dialogs.push_back(telegram_api::move_object_as<telegram_api::dialog>(dialog_folder));
        break;
      case telegram_api::dialogFolder::ID: {
        auto folder = telegram_api::move_object_as<telegram_api::dialogFolder>(dialog_folder);
        if (from_pinned_dialog_list) {
          // TODO update unread_muted_peers_count:int unread_unmuted_peers_count:int
          // unread_muted_messages_count:int unread_unmuted_messages_count:int
          FolderId folder_folder_id(folder->folder_->id_);
          if (folder_folder_id == FolderId::archive()) {
            // archive is expected in pinned dialogs list
            break;
          }
        }
        LOG(ERROR) << "Receive unexpected " << to_string(folder);
        break;
      }
      default:
        UNREACHABLE();
    }
  }

  LOG(INFO) << "Receive " << dialogs.size() << " chats out of " << total_count << " in " << folder_id;
  std::unordered_map<FullMessageId, DialogDate, FullMessageIdHash> full_message_id_to_dialog_date;
  std::unordered_map<FullMessageId, tl_object_ptr<telegram_api::Message>, FullMessageIdHash> full_message_id_to_message;
  for (auto &message : messages) {
    auto full_message_id = get_full_message_id(message, false);
    if (from_dialog_list) {
      auto message_date = get_message_date(message);
      int64 order = get_dialog_order(full_message_id.get_message_id(), message_date);
      full_message_id_to_dialog_date.emplace(full_message_id, DialogDate(order, full_message_id.get_dialog_id()));
    }
    full_message_id_to_message[full_message_id] = std::move(message);
  }

  DialogDate max_dialog_date = MIN_DIALOG_DATE;
  for (auto &dialog : dialogs) {
    //    LOG(INFO) << to_string(dialog);
    DialogId dialog_id(dialog->peer_);
    bool has_pts = (dialog->flags_ & DIALOG_FLAG_HAS_PTS) != 0;

    if (!dialog_id.is_valid()) {
      LOG(ERROR) << "Receive wrong " << dialog_id;
      return promise.set_error(Status::Error(500, "Wrong query result returned: receive wrong chat identifier"));
    }
    switch (dialog_id.get_type()) {
      case DialogType::User:
      case DialogType::Chat:
        if (has_pts) {
          LOG(ERROR) << "Receive user or group " << dialog_id << " with pts";
          return promise.set_error(
              Status::Error(500, "Wrong query result returned: receive user or basic group chat with pts"));
        }
        break;
      case DialogType::Channel:
        if (!has_pts) {
          LOG(ERROR) << "Receive channel " << dialog_id << " without pts";
          return promise.set_error(
              Status::Error(500, "Wrong query result returned: receive supergroup chat without pts"));
        }
        break;
      case DialogType::SecretChat:
      case DialogType::None:
      default:
        UNREACHABLE();
        return promise.set_error(Status::Error(500, "UNREACHABLE"));
    }

    if (from_dialog_list) {
      MessageId last_message_id(ServerMessageId(dialog->top_message_));
      if (last_message_id.is_valid()) {
        FullMessageId full_message_id(dialog_id, last_message_id);
        auto it = full_message_id_to_dialog_date.find(full_message_id);
        if (it == full_message_id_to_dialog_date.end()) {
          LOG(ERROR) << "Last " << last_message_id << " in " << dialog_id << " not found";
          return promise.set_error(Status::Error(500, "Wrong query result returned: last message not found"));
        }
        FolderId dialog_folder_id((dialog->flags_ & DIALOG_FLAG_HAS_FOLDER_ID) != 0 ? dialog->folder_id_ : 0);
        if (dialog_folder_id != folder_id) {
          LOG(ERROR) << "Receive " << dialog_id << " in " << dialog_folder_id << " instead of " << folder_id;
          continue;
        }

        DialogDate dialog_date = it->second;
        CHECK(dialog_date.get_dialog_id() == dialog_id);

        if (max_dialog_date < dialog_date) {
          max_dialog_date = dialog_date;
        }
      } else {
        LOG(ERROR) << "Receive " << last_message_id << " as last chat message";
        continue;
      }
    }
  }

  bool need_recalc_unread_count = (from_dialog_list || from_pinned_dialog_list) &&
                                  get_dialog_folder(folder_id)->last_server_dialog_date_ == MIN_DIALOG_DATE;
  if (from_dialog_list && total_count < narrow_cast<int32>(dialogs.size())) {
    LOG(ERROR) << "Receive chat total_count = " << total_count << ", but " << dialogs.size() << " chats";
    total_count = narrow_cast<int32>(dialogs.size());
  }

  vector<DialogId> added_dialog_ids;
  for (auto &dialog : dialogs) {
    MessageId last_message_id(ServerMessageId(dialog->top_message_));
    if (!last_message_id.is_valid() && from_dialog_list) {
      // skip dialogs without messages
      total_count--;
      continue;
    }

    DialogId dialog_id(dialog->peer_);
    if (td::contains(added_dialog_ids, dialog_id)) {
      LOG(ERROR) << "Receive " << dialog_id << " twice in result of getChats with total_count = " << total_count;
      continue;
    }
    added_dialog_ids.push_back(dialog_id);
    Dialog *d = get_dialog_force(dialog_id);
    bool need_update_dialog_pos = false;
    being_added_dialog_id_ = dialog_id;
    if (d == nullptr) {
      d = add_dialog(dialog_id);
      need_update_dialog_pos = true;
    } else {
      LOG(INFO) << "Receive already created " << dialog_id;
      CHECK(d->dialog_id == dialog_id);
    }
    bool is_new = d->last_new_message_id == MessageId();
    auto positions = get_dialog_positions(d);

    set_dialog_folder_id(d, FolderId((dialog->flags_ & DIALOG_FLAG_HAS_FOLDER_ID) != 0 ? dialog->folder_id_ : 0));

    on_update_dialog_notify_settings(dialog_id, std::move(dialog->notify_settings_), "on_get_dialogs");
    if (!d->notification_settings.is_synchronized && !td_->auth_manager_->is_bot()) {
      LOG(ERROR) << "Failed to synchronize settings in " << dialog_id;
      d->notification_settings.is_synchronized = true;
      on_dialog_updated(dialog_id, "set notification_settings.is_synchronized");
    }

    if (dialog->unread_count_ < 0) {
      LOG(ERROR) << "Receive " << dialog->unread_count_ << " as number of unread messages in " << dialog_id;
      dialog->unread_count_ = 0;
    }
    MessageId read_inbox_max_message_id = MessageId(ServerMessageId(dialog->read_inbox_max_id_));
    if (!read_inbox_max_message_id.is_valid() && read_inbox_max_message_id != MessageId()) {
      LOG(ERROR) << "Receive " << read_inbox_max_message_id << " as last read inbox message in " << dialog_id;
      read_inbox_max_message_id = MessageId();
    }
    MessageId read_outbox_max_message_id = MessageId(ServerMessageId(dialog->read_outbox_max_id_));
    if (!read_outbox_max_message_id.is_valid() && read_outbox_max_message_id != MessageId()) {
      LOG(ERROR) << "Receive " << read_outbox_max_message_id << " as last read outbox message in " << dialog_id;
      read_outbox_max_message_id = MessageId();
    }
    if (dialog->unread_mentions_count_ < 0) {
      LOG(ERROR) << "Receive " << dialog->unread_mentions_count_ << " as number of unread mention messages in "
                 << dialog_id;
      dialog->unread_mentions_count_ = 0;
    }
    if (!d->is_is_blocked_inited && !td_->auth_manager_->is_bot()) {
      // asynchronously get is_blocked from the server
      // TODO add is_blocked to telegram_api::dialog
      get_dialog_info_full(dialog_id, Auto());
    }
    if (!d->is_last_pinned_message_id_inited && !td_->auth_manager_->is_bot()) {
      // asynchronously get dialog pinned message from the server
      get_dialog_pinned_message(dialog_id, Auto());
    }

    need_update_dialog_pos |= update_dialog_draft_message(
        d, get_draft_message(td_->contacts_manager_.get(), std::move(dialog->draft_)), true, false);
    if (is_new) {
      bool has_pts = (dialog->flags_ & DIALOG_FLAG_HAS_PTS) != 0;
      if (last_message_id.is_valid()) {
        FullMessageId full_message_id(dialog_id, last_message_id);
        auto last_message = std::move(full_message_id_to_message[full_message_id]);
        if (last_message == nullptr) {
          LOG(ERROR) << "Last " << full_message_id << " not found";
        } else {
          auto added_full_message_id =
              on_get_message(std::move(last_message), false, has_pts, false, false, false, "get chats");
          CHECK(d->last_new_message_id == MessageId());
          set_dialog_last_new_message_id(d, last_message_id, "on_get_dialogs");
          if (d->last_new_message_id > d->last_message_id && added_full_message_id.get_message_id().is_valid()) {
            CHECK(added_full_message_id.get_message_id() == d->last_new_message_id);
            set_dialog_last_message_id(d, d->last_new_message_id, "on_get_dialogs");
            send_update_chat_last_message(d, "on_get_dialogs");
          }
        }
      }

      if (has_pts && !running_get_channel_difference(dialog_id)) {
        int32 channel_pts = dialog->pts_;
        LOG_IF(ERROR, channel_pts < d->pts) << "In new " << dialog_id << " pts = " << d->pts
                                            << ", but pts = " << channel_pts << " received in GetChats";
        set_channel_pts(d, channel_pts, "get channel");
      }
    }
    bool is_marked_as_unread = (dialog->flags_ & telegram_api::dialog::UNREAD_MARK_MASK) != 0;
    if (is_marked_as_unread != d->is_marked_as_unread) {
      set_dialog_is_marked_as_unread(d, is_marked_as_unread);
    }

    if (need_update_dialog_pos) {
      update_dialog_pos(d, "on_get_dialogs");
    }

    if (!td_->auth_manager_->is_bot() && !from_pinned_dialog_list) {
      // set is_pinned only after updating dialog pos to ensure that order is initialized
      bool is_pinned = (dialog->flags_ & DIALOG_FLAG_IS_PINNED) != 0;
      bool was_pinned = get_dialog_pinned_order(DialogListId(d->folder_id), dialog_id) != DEFAULT_ORDER;
      if (is_pinned != was_pinned) {
        set_dialog_is_pinned(DialogListId(d->folder_id), d, is_pinned);
      }
    }

    if (!G()->parameters().use_message_db || is_new || !d->is_last_read_inbox_message_id_inited ||
        d->need_repair_server_unread_count) {
      if (d->last_read_inbox_message_id.is_valid() && !d->last_read_inbox_message_id.is_server() &&
          read_inbox_max_message_id == d->last_read_inbox_message_id.get_prev_server_message_id()) {
        read_inbox_max_message_id = d->last_read_inbox_message_id;
      }
      if (d->need_repair_server_unread_count &&
          (d->last_read_inbox_message_id <= read_inbox_max_message_id || !need_unread_counter(d->order) ||
           !have_input_peer(dialog_id, AccessRights::Read))) {
        LOG(INFO) << "Repaired server unread count in " << dialog_id << " from " << d->last_read_inbox_message_id << "/"
                  << d->server_unread_count << " to " << read_inbox_max_message_id << "/" << dialog->unread_count_;
        d->need_repair_server_unread_count = false;
        on_dialog_updated(dialog_id, "repaired dialog server unread count");
      }
      if (d->need_repair_server_unread_count) {
        auto &previous_message_id = previous_repaired_read_inbox_max_message_id_[dialog_id];
        if (previous_message_id >= read_inbox_max_message_id) {
          // protect from sending the request in a loop
          LOG(ERROR) << "Failed to repair server unread count in " << dialog_id
                     << ", because receive read_inbox_max_message_id = " << read_inbox_max_message_id << " after "
                     << previous_message_id << ", but messages are read up to " << d->last_read_inbox_message_id;
          d->need_repair_server_unread_count = false;
          on_dialog_updated(dialog_id, "failed to repair dialog server unread count");
        } else {
          LOG(INFO) << "Have last_read_inbox_message_id = " << d->last_read_inbox_message_id << ", but received only "
                    << read_inbox_max_message_id << " from the server, trying to repair server unread count again";
          previous_message_id = read_inbox_max_message_id;
          repair_server_unread_count(dialog_id, d->server_unread_count);
        }
      }
      if (!d->need_repair_server_unread_count) {
        previous_repaired_read_inbox_max_message_id_.erase(dialog_id);
      }
      if ((d->server_unread_count != dialog->unread_count_ &&
           d->last_read_inbox_message_id == read_inbox_max_message_id) ||
          d->last_read_inbox_message_id < read_inbox_max_message_id) {
        set_dialog_last_read_inbox_message_id(d, read_inbox_max_message_id, dialog->unread_count_,
                                              d->local_unread_count, true, "on_get_dialogs");
      }
      if (!d->is_last_read_inbox_message_id_inited) {
        d->is_last_read_inbox_message_id_inited = true;
        on_dialog_updated(dialog_id, "set is_last_read_inbox_message_id_inited");
      }
    }

    if (!G()->parameters().use_message_db || is_new || !d->is_last_read_outbox_message_id_inited) {
      if (d->last_read_outbox_message_id < read_outbox_max_message_id) {
        set_dialog_last_read_outbox_message_id(d, read_outbox_max_message_id);
      }
      if (!d->is_last_read_outbox_message_id_inited) {
        d->is_last_read_outbox_message_id_inited = true;
        on_dialog_updated(dialog_id, "set is_last_read_outbox_message_id_inited");
      }
    }

    if (!G()->parameters().use_message_db || is_new) {
      if (d->unread_mention_count != dialog->unread_mentions_count_) {
        set_dialog_unread_mention_count(d, dialog->unread_mentions_count_);
        update_dialog_mention_notification_count(d);
        send_update_chat_unread_mention_count(d);
      }
    }

    being_added_dialog_id_ = DialogId();

    update_dialog_lists(d, std::move(positions), true, false, "on_get_dialogs");
  }

  if (from_dialog_list) {
    CHECK(!td_->auth_manager_->is_bot());
    CHECK(total_count >= 0);

    auto &folder_list = add_dialog_list(DialogListId(folder_id));
    if (folder_list.server_dialog_total_count_ != total_count) {
      auto old_dialog_total_count = get_dialog_total_count(folder_list);
      folder_list.server_dialog_total_count_ = total_count;
      if (folder_list.is_dialog_unread_count_inited_) {
        if (old_dialog_total_count != get_dialog_total_count(folder_list)) {
          send_update_unread_chat_count(folder_list, DialogId(), true, "on_get_dialogs");
        } else {
          save_unread_chat_count(folder_list);
        }
      }
    }

    auto *folder = get_dialog_folder(folder_id);
    CHECK(folder != nullptr);
    if (dialogs.empty()) {
      // if there are no more dialogs on the server
      max_dialog_date = MAX_DIALOG_DATE;
    }
    if (folder->last_server_dialog_date_ < max_dialog_date) {
      folder->last_server_dialog_date_ = max_dialog_date;
      update_last_dialog_date(folder_id);

      if (max_dialog_date != MAX_DIALOG_DATE) {
        bool need_new_get_dialog_list = false;
        for (const auto &list_it : dialog_lists_) {
          auto &dialog_list = list_it.second;
          if (!dialog_list.load_list_queries_.empty() && has_dialogs_from_folder(dialog_list, *folder)) {
            LOG(INFO) << "Need to load more chats in " << folder_id << " for " << list_it.first;
            need_new_get_dialog_list = true;
          }
        }
        if (need_new_get_dialog_list) {
          LOG(INFO) << "Schedule chats list load in " << folder_id;
          auto &multipromise = folder->load_folder_dialog_list_multipromise_;
          multipromise.add_promise(PromiseCreator::lambda([actor_id = actor_id(this), folder_id](Result<Unit> result) {
            if (result.is_ok()) {
              LOG(INFO) << "Continue to load chat list in " << folder_id;
              send_closure_later(actor_id, &MessagesManager::load_folder_dialog_list, folder_id, int32{MAX_GET_DIALOGS},
                                 false, Promise<Unit>());
            }
          }));
        }
      }
    } else if (promise) {
      LOG(ERROR) << "Last server dialog date didn't increased from " << folder->last_server_dialog_date_ << " to "
                 << max_dialog_date << " after receiving " << dialogs.size() << " chats " << added_dialog_ids
                 << " from " << total_count << " in " << folder_id
                 << ". last_dialog_date = " << folder->folder_last_dialog_date_
                 << ", last_loaded_database_dialog_date = " << folder->last_loaded_database_dialog_date_;
    }
  }
  if (from_pinned_dialog_list) {
    CHECK(!td_->auth_manager_->is_bot());
    auto *folder_list = get_dialog_list(DialogListId(folder_id));
    CHECK(folder_list != nullptr);
    auto pinned_dialog_ids = remove_secret_chat_dialog_ids(get_pinned_dialog_ids(DialogListId(folder_id)));
    bool are_pinned_dialogs_saved = folder_list->are_pinned_dialogs_inited_;
    folder_list->are_pinned_dialogs_inited_ = true;
    if (pinned_dialog_ids != added_dialog_ids) {
      LOG(INFO) << "Update pinned chats order from " << format::as_array(pinned_dialog_ids) << " to "
                << format::as_array(added_dialog_ids);
      std::unordered_set<DialogId, DialogIdHash> old_pinned_dialog_ids(pinned_dialog_ids.begin(),
                                                                       pinned_dialog_ids.end());

      std::reverse(pinned_dialog_ids.begin(), pinned_dialog_ids.end());
      std::reverse(added_dialog_ids.begin(), added_dialog_ids.end());
      auto old_it = pinned_dialog_ids.begin();
      for (auto dialog_id : added_dialog_ids) {
        old_pinned_dialog_ids.erase(dialog_id);
        while (old_it < pinned_dialog_ids.end()) {
          if (*old_it == dialog_id) {
            break;
          }
          ++old_it;
        }
        if (old_it < pinned_dialog_ids.end()) {
          // leave dialog where it is
          ++old_it;
          continue;
        }
        if (set_dialog_is_pinned(dialog_id, true)) {
          are_pinned_dialogs_saved = true;
        }
      }
      for (auto dialog_id : old_pinned_dialog_ids) {
        if (set_dialog_is_pinned(dialog_id, false)) {
          are_pinned_dialogs_saved = true;
        }
      }
    } else {
      LOG(INFO) << "Pinned chats are not changed";
    }
    update_list_last_pinned_dialog_date(*folder_list);

    if (!are_pinned_dialogs_saved && G()->parameters().use_message_db) {
      LOG(INFO) << "Save empty pinned chat list in " << folder_id;
      G()->td_db()->get_binlog_pmc()->set(PSTRING() << "pinned_dialog_ids" << folder_id.get(), "");
    }
  }
  promise.set_value(Unit());

  if (need_recalc_unread_count) {
    recalc_unread_count(DialogListId(folder_id));
  }
}

void MessagesManager::dump_debug_message_op(const Dialog *d, int priority) {
  if (!is_debug_message_op_enabled()) {
    return;
  }
  if (d == nullptr) {
    LOG(ERROR) << "Chat not found";
    return;
  }
  static int last_dumped_priority = -1;
  if (priority <= last_dumped_priority) {
    LOG(ERROR) << "Skip dump " << d->dialog_id;
    return;
  }
  last_dumped_priority = priority;

  for (auto &op : d->debug_message_op) {
    switch (op.type) {
      case Dialog::MessageOp::Add: {
        LOG(ERROR) << "MessageOpAdd at " << op.date << " " << op.message_id << " " << op.content_type << " "
                   << op.from_update << " " << op.have_previous << " " << op.have_next << " " << op.source;
        break;
      }
      case Dialog::MessageOp::SetPts: {
        LOG(ERROR) << "MessageOpSetPts at " << op.date << " " << op.pts << " " << op.source;
        break;
      }
      case Dialog::MessageOp::Delete: {
        LOG(ERROR) << "MessageOpDelete at " << op.date << " " << op.message_id << " " << op.content_type << " "
                   << op.from_update << " " << op.have_previous << " " << op.have_next << " " << op.source;
        break;
      }
      case Dialog::MessageOp::DeleteAll: {
        LOG(ERROR) << "MessageOpDeleteAll at " << op.date << " " << op.from_update;
        break;
      }
      default:
        UNREACHABLE();
    }
  }
}

bool MessagesManager::is_message_unload_enabled() const {
  return G()->parameters().use_message_db || td_->auth_manager_->is_bot();
}

bool MessagesManager::can_unload_message(const Dialog *d, const Message *m) const {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  CHECK(m->message_id.is_valid());
  // don't want to unload messages from opened dialogs
  // don't want to unload messages to which there are replies in yet unsent messages
  // don't want to unload message with active reply markup
  // don't want to unload the newest pinned message
  // don't want to unload last edited message, because server can send updateEditChannelMessage again
  // can't unload from memory last dialog, last database messages, yet unsent messages, being edited media messages and active live locations
  // can't unload messages in dialog with active suffix load query
  FullMessageId full_message_id{d->dialog_id, m->message_id};
  return !d->is_opened && m->message_id != d->last_message_id && m->message_id != d->last_database_message_id &&
         !m->message_id.is_yet_unsent() && active_live_location_full_message_ids_.count(full_message_id) == 0 &&
         replied_by_yet_unsent_messages_.count(full_message_id) == 0 && m->edited_content == nullptr &&
         d->suffix_load_queries_.empty() && m->message_id != d->reply_markup_message_id &&
         m->message_id != d->last_pinned_message_id && m->message_id != d->last_edited_message_id;
}

void MessagesManager::unload_message(Dialog *d, MessageId message_id) {
  CHECK(d != nullptr);
  CHECK(message_id.is_valid());
  bool need_update_dialog_pos = false;
  auto m = do_delete_message(d, message_id, false, true, &need_update_dialog_pos, "unload_message");
  CHECK(!need_update_dialog_pos);
}

unique_ptr<MessagesManager::Message> MessagesManager::delete_message(Dialog *d, MessageId message_id,
                                                                     bool is_permanently_deleted,
                                                                     bool *need_update_dialog_pos, const char *source) {
  return do_delete_message(d, message_id, is_permanently_deleted, false, need_update_dialog_pos, source);
}

void MessagesManager::add_random_id_to_message_id_correspondence(Dialog *d, int64 random_id, MessageId message_id) {
  CHECK(d != nullptr);
  CHECK(d->dialog_id.get_type() == DialogType::SecretChat);
  CHECK(message_id.is_valid());
  auto it = d->random_id_to_message_id.find(random_id);
  if (it == d->random_id_to_message_id.end() || it->second < message_id) {
    LOG(INFO) << "Add correspondence from random_id " << random_id << " to " << message_id << " in " << d->dialog_id;
    d->random_id_to_message_id[random_id] = message_id;
  }
}

void MessagesManager::delete_random_id_to_message_id_correspondence(Dialog *d, int64 random_id, MessageId message_id) {
  CHECK(d != nullptr);
  CHECK(d->dialog_id.get_type() == DialogType::SecretChat);
  CHECK(message_id.is_valid());
  auto it = d->random_id_to_message_id.find(random_id);
  if (it != d->random_id_to_message_id.end() && it->second == message_id) {
    LOG(INFO) << "Delete correspondence from random_id " << random_id << " to " << message_id << " in " << d->dialog_id;
    d->random_id_to_message_id.erase(it);
  }
}

void MessagesManager::add_notification_id_to_message_id_correspondence(Dialog *d, NotificationId notification_id,
                                                                       MessageId message_id) {
  CHECK(d != nullptr);
  CHECK(notification_id.is_valid());
  CHECK(message_id.is_valid());
  auto it = d->notification_id_to_message_id.find(notification_id);
  if (it == d->notification_id_to_message_id.end()) {
    VLOG(notifications) << "Add correspondence from " << notification_id << " to " << message_id << " in "
                        << d->dialog_id;
    d->notification_id_to_message_id.emplace(notification_id, message_id);
  } else if (it->second != message_id) {
    LOG(ERROR) << "Have duplicated " << notification_id << " in " << d->dialog_id << " in " << message_id << " and "
               << it->second;
    if (it->second < message_id) {
      it->second = message_id;
    }
  }
}

void MessagesManager::delete_notification_id_to_message_id_correspondence(Dialog *d, NotificationId notification_id,
                                                                          MessageId message_id) {
  CHECK(d != nullptr);
  CHECK(notification_id.is_valid());
  CHECK(message_id.is_valid());
  auto it = d->notification_id_to_message_id.find(notification_id);
  if (it != d->notification_id_to_message_id.end() && it->second == message_id) {
    VLOG(notifications) << "Delete correspondence from " << notification_id << " to " << message_id << " in "
                        << d->dialog_id;
    d->notification_id_to_message_id.erase(it);
  } else {
    LOG(ERROR) << "Can't find " << notification_id << " in " << d->dialog_id << " with " << message_id;
  }
}

void MessagesManager::remove_message_notification_id(Dialog *d, Message *m, bool is_permanent, bool force_update,
                                                     bool ignore_pinned_message_notification_removal) {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  CHECK(m->message_id.is_valid());
  if (!m->notification_id.is_valid()) {
    return;
  }

  auto from_mentions = is_from_mention_notification_group(d, m);
  auto &group_info = get_notification_group_info(d, m);
  if (!group_info.group_id.is_valid()) {
    return;
  }

  bool had_active_notification = is_message_notification_active(d, m);

  auto notification_id = m->notification_id;
  VLOG(notifications) << "Remove " << notification_id << " from " << m->message_id << " in " << group_info.group_id
                      << '/' << d->dialog_id << " from database, was_active = " << had_active_notification
                      << ", is_permanent = " << is_permanent;
  delete_notification_id_to_message_id_correspondence(d, notification_id, m->message_id);
  m->removed_notification_id = m->notification_id;
  m->notification_id = NotificationId();
  if (d->pinned_message_notification_message_id == m->message_id && is_permanent &&
      !ignore_pinned_message_notification_removal) {
    remove_dialog_pinned_message_notification(
        d, "remove_message_notification_id");  // must be called after notification_id is removed
  }
  if (group_info.last_notification_id == notification_id) {
    // last notification is deleted, need to find new last notification
    fix_dialog_last_notification_id(d, from_mentions, m->message_id);
  }

  if (is_permanent) {
    if (had_active_notification) {
      send_closure_later(G()->notification_manager(), &NotificationManager::remove_notification, group_info.group_id,
                         notification_id, is_permanent, force_update, Promise<Unit>(),
                         "remove_message_notification_id");
    }

    // on_message_changed will be called by the caller
    // don't need to call there to not save twice/or to save just deleted message
  } else {
    on_message_changed(d, m, false, "remove_message_notification_id");
  }
}

void MessagesManager::remove_new_secret_chat_notification(Dialog *d, bool is_permanent) {
  CHECK(d != nullptr);
  auto notification_id = d->new_secret_chat_notification_id;
  CHECK(notification_id.is_valid());
  VLOG(notifications) << "Remove " << notification_id << " about new secret " << d->dialog_id << " from "
                      << d->message_notification_group.group_id;
  d->new_secret_chat_notification_id = NotificationId();
  bool is_fixed = set_dialog_last_notification(d->dialog_id, d->message_notification_group, 0, NotificationId(),
                                               "remove_new_secret_chat_notification");
  CHECK(is_fixed);
  if (is_permanent) {
    CHECK(d->message_notification_group.group_id.is_valid());
    send_closure_later(G()->notification_manager(), &NotificationManager::remove_notification,
                       d->message_notification_group.group_id, notification_id, true, true, Promise<Unit>(),
                       "remove_new_secret_chat_notification");
  }
}

void MessagesManager::fix_dialog_last_notification_id(Dialog *d, bool from_mentions, MessageId message_id) {
  CHECK(d != nullptr);
  CHECK(!message_id.is_scheduled());
  MessagesConstIterator it(d, message_id);
  auto &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;
  VLOG(notifications) << "Trying to fix last notification id in " << group_info.group_id << " from " << d->dialog_id
                      << " from " << message_id << "/" << group_info.last_notification_id;
  if (*it != nullptr && ((*it)->message_id == message_id || (*it)->have_next)) {
    while (*it != nullptr) {
      const Message *m = *it;
      if (is_from_mention_notification_group(d, m) == from_mentions && m->notification_id.is_valid() &&
          is_message_notification_active(d, m) && m->message_id != message_id) {
        bool is_fixed = set_dialog_last_notification(d->dialog_id, group_info, m->date, m->notification_id,
                                                     "fix_dialog_last_notification_id");
        CHECK(is_fixed);
        return;
      }
      --it;
    }
  }
  if (G()->parameters().use_message_db) {
    get_message_notifications_from_database(
        d->dialog_id, group_info.group_id, group_info.last_notification_id, message_id, 1,
        PromiseCreator::lambda(
            [actor_id = actor_id(this), dialog_id = d->dialog_id, from_mentions,
             prev_last_notification_id = group_info.last_notification_id](Result<vector<Notification>> result) {
              send_closure(actor_id, &MessagesManager::do_fix_dialog_last_notification_id, dialog_id, from_mentions,
                           prev_last_notification_id, std::move(result));
            }));
  }
}

void MessagesManager::do_fix_dialog_last_notification_id(DialogId dialog_id, bool from_mentions,
                                                         NotificationId prev_last_notification_id,
                                                         Result<vector<Notification>> result) {
  if (result.is_error()) {
    return;
  }

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  auto &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;
  VLOG(notifications) << "Receive " << result.ok().size() << " message notifications in " << group_info.group_id << '/'
                      << dialog_id << " from " << prev_last_notification_id;
  if (group_info.last_notification_id != prev_last_notification_id) {
    // last_notification_id was changed
    return;
  }

  auto notifications = result.move_as_ok();
  CHECK(notifications.size() <= 1);

  int32 last_notification_date = 0;
  NotificationId last_notification_id;
  if (!notifications.empty()) {
    last_notification_date = notifications[0].date;
    last_notification_id = notifications[0].notification_id;
  }

  bool is_fixed = set_dialog_last_notification(dialog_id, group_info, last_notification_date, last_notification_id,
                                               "do_fix_dialog_last_notification_id");
  CHECK(is_fixed);
}

// DO NOT FORGET TO ADD ALL CHANGES OF THIS FUNCTION AS WELL TO do_delete_all_dialog_messages
unique_ptr<MessagesManager::Message> MessagesManager::do_delete_message(Dialog *d, MessageId message_id,
                                                                        bool is_permanently_deleted,
                                                                        bool only_from_memory,
                                                                        bool *need_update_dialog_pos,
                                                                        const char *source) {
  CHECK(d != nullptr);
  if (!message_id.is_valid()) {
    if (message_id.is_valid_scheduled()) {
      return do_delete_scheduled_message(d, message_id, is_permanently_deleted, source);
    }

    LOG(ERROR) << "Trying to delete " << message_id << " in " << d->dialog_id << " from " << source;
    return nullptr;
  }

  FullMessageId full_message_id(d->dialog_id, message_id);
  unique_ptr<Message> *v = treap_find_message(&d->messages, message_id);
  if (*v == nullptr) {
    LOG(INFO) << message_id << " is not found in " << d->dialog_id << " to be deleted from " << source;
    if (only_from_memory) {
      return nullptr;
    }

    if (get_message_force(d, message_id, "do_delete_message") == nullptr) {
      // currently there may be a race between add_message_to_database and get_message_force,
      // so delete a message from database just in case
      delete_message_from_database(d, message_id, nullptr, is_permanently_deleted);

      if (is_permanently_deleted && d->last_clear_history_message_id == message_id) {
        set_dialog_last_clear_history_date(d, 0, MessageId(), "do_delete_message");
        *need_update_dialog_pos = true;
      }

      /*
      can't do this because the message may be never received in the dialog, unread count will became negative
      // if last_read_inbox_message_id is not known, we can't be sure whether unread_count should be decreased or not
      if (message_id.is_valid() && !message_id.is_yet_unsent() && d->is_last_read_inbox_message_id_inited &&
          message_id > d->last_read_inbox_message_id && !td_->auth_manager_->is_bot()) {
        int32 server_unread_count = d->server_unread_count;
        int32 local_unread_count = d->local_unread_count;
        int32 &unread_count = message_id.is_server() ? server_unread_count : local_unread_count;
        if (unread_count == 0) {
          LOG(ERROR) << "Unread count became negative in " << d->dialog_id << " after deletion of " << message_id
                     << ". Last read is " << d->last_read_inbox_message_id;
          dump_debug_message_op(d, 3);
        } else {
          unread_count--;
          set_dialog_last_read_inbox_message_id(d, MessageId::min(), server_unread_count, local_unread_count, false,
                                                source);
        }
      }
      */
      return nullptr;
    }
    v = treap_find_message(&d->messages, message_id);
    CHECK(*v != nullptr);
  }

  const Message *m = v->get();
  CHECK(m->message_id == message_id);

  if (only_from_memory && !can_unload_message(d, m)) {
    return nullptr;
  }

  LOG_CHECK(!d->being_deleted_message_id.is_valid())
      << d->being_deleted_message_id << " " << message_id << " " << source;
  d->being_deleted_message_id = message_id;

  if (is_debug_message_op_enabled()) {
    d->debug_message_op.emplace_back(Dialog::MessageOp::Delete, m->message_id, m->content->get_type(), false,
                                     m->have_previous, m->have_next, source);
  }

  bool need_get_history = false;
  if (!only_from_memory) {
    LOG(INFO) << "Deleting " << full_message_id << " with have_previous = " << m->have_previous
              << " and have_next = " << m->have_next << " from " << source;

    delete_message_from_database(d, message_id, m, is_permanently_deleted);

    delete_active_live_location(d->dialog_id, m);
    remove_message_file_sources(d->dialog_id, m);

    if (message_id == d->last_message_id) {
      MessagesConstIterator it(d, message_id);
      CHECK(*it == m);
      if ((*it)->have_previous) {
        --it;
        if (*it != nullptr) {
          set_dialog_last_message_id(d, (*it)->message_id, "do_delete_message");
        } else {
          LOG(ERROR) << "Have have_previous is true, but there is no previous for " << full_message_id << " from "
                     << source;
          dump_debug_message_op(d);
          set_dialog_last_message_id(d, MessageId(), "do_delete_message");
        }
      } else {
        need_get_history = true;
        set_dialog_last_message_id(d, MessageId(), "do_delete_message");
        d->delete_last_message_date = m->date;
        d->deleted_last_message_id = message_id;
        d->is_last_message_deleted_locally = Slice(source) == Slice(DELETE_MESSAGE_USER_REQUEST_SOURCE);
        on_dialog_updated(d->dialog_id, "do delete last message");
      }
      *need_update_dialog_pos = true;
    }

    if (message_id == d->last_database_message_id) {
      MessagesConstIterator it(d, message_id);
      CHECK(*it == m);
      while ((*it)->have_previous) {
        --it;
        if (*it == nullptr || !(*it)->message_id.is_yet_unsent()) {
          break;
        }
      }

      if (*it != nullptr) {
        if (!(*it)->message_id.is_yet_unsent() && (*it)->message_id != d->last_database_message_id) {
          if ((*it)->message_id < d->first_database_message_id && d->dialog_id.get_type() == DialogType::Channel) {
            // possible if messages was deleted from database, but not from memory after updateChannelTooLong
            set_dialog_last_database_message_id(d, MessageId(), "do_delete_message");
          } else {
            set_dialog_last_database_message_id(d, (*it)->message_id, "do_delete_message");
            if (d->last_database_message_id < d->first_database_message_id) {
              LOG(ERROR) << "Last database " << d->last_database_message_id << " became less than first database "
                         << d->first_database_message_id << " after deletion of " << full_message_id;
              set_dialog_first_database_message_id(d, d->last_database_message_id, "do_delete_message 2");
            }
          }
        } else {
          need_get_history = true;
        }
      } else {
        LOG(ERROR) << "Have have_previous is true, but there is no previous";
        dump_debug_message_op(d);
      }
    }
    if (d->last_database_message_id.is_valid()) {
      CHECK(d->first_database_message_id.is_valid());
    } else {
      set_dialog_first_database_message_id(d, MessageId(), "do_delete_message");
    }

    if (message_id == d->suffix_load_first_message_id_) {
      MessagesConstIterator it(d, message_id);
      CHECK(*it == m);
      if ((*it)->have_previous) {
        --it;
        if (*it != nullptr) {
          d->suffix_load_first_message_id_ = (*it)->message_id;
        } else {
          LOG(ERROR) << "Have have_previous is true, but there is no previous for " << full_message_id << " from "
                     << source;
          dump_debug_message_op(d);
          d->suffix_load_first_message_id_ = MessageId();
          d->suffix_load_done_ = false;
        }
      } else {
        d->suffix_load_first_message_id_ = MessageId();
        d->suffix_load_done_ = false;
      }
    }
  }
  if (only_from_memory && message_id >= d->suffix_load_first_message_id_) {
    d->suffix_load_first_message_id_ = MessageId();
    d->suffix_load_done_ = false;
  }

  if (m->have_previous && (only_from_memory || !m->have_next)) {
    MessagesIterator it(d, message_id);
    CHECK(*it == m);
    --it;
    Message *prev_m = *it;
    if (prev_m != nullptr) {
      prev_m->have_next = false;
    } else {
      LOG(ERROR) << "Have have_previous is true, but there is no previous for " << full_message_id << " from "
                 << source;
      dump_debug_message_op(d);
    }
  }
  if ((*v)->have_next && (only_from_memory || !(*v)->have_previous)) {
    MessagesIterator it(d, message_id);
    CHECK(*it == m);
    ++it;
    Message *next_m = *it;
    if (next_m != nullptr) {
      next_m->have_previous = false;
    } else {
      LOG(ERROR) << "Have have_next is true, but there is no next for " << full_message_id << " from " << source;
      dump_debug_message_op(d);
    }
  }

  auto result = treap_delete_message(v);

  d->being_deleted_message_id = MessageId();

  if (!only_from_memory) {
    if (need_get_history && !td_->auth_manager_->is_bot() && have_input_peer(d->dialog_id, AccessRights::Read)) {
      get_history_from_the_end(d->dialog_id, true, false, Auto());
    }

    if (d->reply_markup_message_id == message_id) {
      set_dialog_reply_markup(d, MessageId());
    }
    // if last_read_inbox_message_id is not known, we can't be sure whether unread_count should be decreased or not
    if (has_incoming_notification(d->dialog_id, result.get()) && message_id > d->last_read_inbox_message_id &&
        d->is_last_read_inbox_message_id_inited && !td_->auth_manager_->is_bot()) {
      int32 server_unread_count = d->server_unread_count;
      int32 local_unread_count = d->local_unread_count;
      int32 &unread_count = message_id.is_server() ? server_unread_count : local_unread_count;
      if (unread_count == 0) {
        if (need_unread_counter(d->order)) {
          LOG(ERROR) << "Unread count became negative in " << d->dialog_id << " after deletion of " << message_id
                     << ". Last read is " << d->last_read_inbox_message_id;
          dump_debug_message_op(d, 3);
        }
      } else {
        unread_count--;
        set_dialog_last_read_inbox_message_id(d, MessageId::min(), server_unread_count, local_unread_count, false,
                                              source);
      }
    }
    if (result->contains_unread_mention) {
      if (d->unread_mention_count == 0) {
        if (is_dialog_inited(d)) {
          LOG(ERROR) << "Unread mention count became negative in " << d->dialog_id << " after deletion of "
                     << message_id;
        }
      } else {
        set_dialog_unread_mention_count(d, d->unread_mention_count - 1);
        send_update_chat_unread_mention_count(d);
      }
    }

    update_message_count_by_index(d, -1, result.get());
    update_reply_count_by_message(d, -1, result.get());
  }

  on_message_deleted(d, result.get(), is_permanently_deleted, source);

  return result;
}

void MessagesManager::on_message_deleted(Dialog *d, Message *m, bool is_permanently_deleted, const char *source) {
  // also called for unloaded messages

  if (m->message_id.is_yet_unsent() && m->top_thread_message_id.is_valid()) {
    auto it = d->yet_unsent_thread_message_ids.find(m->top_thread_message_id);
    CHECK(it != d->yet_unsent_thread_message_ids.end());
    auto is_deleted = it->second.erase(m->message_id) > 0;
    CHECK(is_deleted);
    if (it->second.empty()) {
      d->yet_unsent_thread_message_ids.erase(it);
    }
  }

  cancel_send_deleted_message(d->dialog_id, m, is_permanently_deleted);

  CHECK(m->message_id.is_valid());
  switch (d->dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
      if (m->message_id.is_server()) {
        message_id_to_dialog_id_.erase(m->message_id);
      }
      break;
    case DialogType::Channel:
      // nothing to do
      break;
    case DialogType::SecretChat:
      delete_random_id_to_message_id_correspondence(d, m->random_id, m->message_id);
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }
  ttl_unregister_message(d->dialog_id, m, source);
  ttl_period_unregister_message(d->dialog_id, m);
  unregister_message_content(td_, m->content.get(), {d->dialog_id, m->message_id}, "on_message_deleted");
  if (m->notification_id.is_valid()) {
    delete_notification_id_to_message_id_correspondence(d, m->notification_id, m->message_id);
  }
}

unique_ptr<MessagesManager::Message> MessagesManager::do_delete_scheduled_message(Dialog *d, MessageId message_id,
                                                                                  bool is_permanently_deleted,
                                                                                  const char *source) {
  CHECK(d != nullptr);
  CHECK(message_id.is_valid_scheduled());

  unique_ptr<Message> *v = treap_find_message(&d->scheduled_messages, message_id);
  if (*v == nullptr) {
    LOG(INFO) << message_id << " is not found in " << d->dialog_id << " to be deleted from " << source;
    auto message = get_message_force(d, message_id, "do_delete_scheduled_message");
    if (message == nullptr) {
      // currently there may be a race between add_message_to_database and get_message_force,
      // so delete a message from database just in case
      delete_message_from_database(d, message_id, nullptr, is_permanently_deleted);
      return nullptr;
    }

    message_id = message->message_id;
    v = treap_find_message(&d->scheduled_messages, message_id);
    CHECK(*v != nullptr);
  }

  const Message *m = v->get();
  CHECK(m->message_id == message_id);

  LOG(INFO) << "Deleting " << FullMessageId{d->dialog_id, message_id} << " from " << source;

  delete_message_from_database(d, message_id, m, is_permanently_deleted);

  remove_message_file_sources(d->dialog_id, m);

  auto result = treap_delete_message(v);

  if (message_id.is_scheduled_server()) {
    size_t erased_count = d->scheduled_message_date.erase(message_id.get_scheduled_server_message_id());
    CHECK(erased_count != 0);
  }

  cancel_send_deleted_message(d->dialog_id, result.get(), is_permanently_deleted);

  unregister_message_content(td_, result->content.get(), {d->dialog_id, message_id}, "do_delete_scheduled_message");

  return result;
}

void MessagesManager::do_delete_all_dialog_messages(Dialog *d, unique_ptr<Message> &message,
                                                    bool is_permanently_deleted, vector<int64> &deleted_message_ids) {
  if (message == nullptr) {
    return;
  }
  const Message *m = message.get();
  MessageId message_id = m->message_id;

  if (is_debug_message_op_enabled()) {
    d->debug_message_op.emplace_back(Dialog::MessageOp::Delete, m->message_id, m->content->get_type(), false,
                                     m->have_previous, m->have_next, "delete all messages");
  }

  LOG(INFO) << "Delete " << message_id;
  deleted_message_ids.push_back(message_id.get());

  do_delete_all_dialog_messages(d, message->right, is_permanently_deleted, deleted_message_ids);
  do_delete_all_dialog_messages(d, message->left, is_permanently_deleted, deleted_message_ids);

  delete_active_live_location(d->dialog_id, m);
  remove_message_file_sources(d->dialog_id, m);

  on_message_deleted(d, message.get(), is_permanently_deleted, "do_delete_all_dialog_messages");

  message = nullptr;
}

bool MessagesManager::have_dialog(DialogId dialog_id) const {
  return dialogs_.count(dialog_id) > 0;
}

void MessagesManager::load_dialogs(vector<DialogId> dialog_ids, Promise<Unit> &&promise) {
  LOG(INFO) << "Load chats " << format::as_array(dialog_ids);

  Dependencies dependencies;
  for (auto dialog_id : dialog_ids) {
    if (dialog_id.is_valid() && !have_dialog(dialog_id)) {
      add_dialog_dependencies(dependencies, dialog_id);
    }
  }
  resolve_dependencies_force(td_, dependencies, "load_dialogs");

  for (auto dialog_id : dialog_ids) {
    if (dialog_id.is_valid()) {
      force_create_dialog(dialog_id, "load_dialogs");
    }
  }

  promise.set_value(Unit());
}

bool MessagesManager::load_dialog(DialogId dialog_id, int left_tries, Promise<Unit> &&promise) {
  if (!dialog_id.is_valid()) {
    promise.set_error(Status::Error(6, "Invalid chat identifier specified"));
    return false;
  }

  if (!have_dialog_force(dialog_id)) {  // TODO remove _force
    if (G()->parameters().use_message_db) {
      //      TODO load dialog from database, DialogLoader
      //      send_closure_later(actor_id(this), &MessagesManager::load_dialog_from_database, dialog_id,
      //      std::move(promise));
      //      return false;
    }
    if (td_->auth_manager_->is_bot()) {
      switch (dialog_id.get_type()) {
        case DialogType::User: {
          auto user_id = dialog_id.get_user_id();
          auto have_user = td_->contacts_manager_->get_user(user_id, left_tries, std::move(promise));
          if (!have_user) {
            return false;
          }
          break;
        }
        case DialogType::Chat: {
          auto have_chat = td_->contacts_manager_->get_chat(dialog_id.get_chat_id(), left_tries, std::move(promise));
          if (!have_chat) {
            return false;
          }
          break;
        }
        case DialogType::Channel: {
          auto have_channel =
              td_->contacts_manager_->get_channel(dialog_id.get_channel_id(), left_tries, std::move(promise));
          if (!have_channel) {
            return false;
          }
          break;
        }
        case DialogType::SecretChat:
          promise.set_error(Status::Error(6, "Chat not found"));
          return false;
        case DialogType::None:
        default:
          UNREACHABLE();
      }
      if (!have_input_peer(dialog_id, AccessRights::Read)) {
        return false;
      }

      add_dialog(dialog_id);
      return true;
    }

    promise.set_error(Status::Error(6, "Chat not found"));
    return false;
  }

  promise.set_value(Unit());
  return true;
}

void MessagesManager::load_dialog_filter(DialogFilterId dialog_filter_id, bool force, Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  if (!dialog_filter_id.is_valid()) {
    return promise.set_error(Status::Error(400, "Invalid chat filter identifier specified"));
  }

  auto filter = get_dialog_filter(dialog_filter_id);
  if (filter == nullptr) {
    return promise.set_value(Unit());
  }

  load_dialog_filter(filter, force, std::move(promise));
}

void MessagesManager::load_dialog_filter(const DialogFilter *filter, bool force, Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  vector<InputDialogId> needed_dialog_ids;
  for (auto input_dialog_ids :
       {&filter->pinned_dialog_ids, &filter->excluded_dialog_ids, &filter->included_dialog_ids}) {
    for (auto input_dialog_id : *input_dialog_ids) {
      if (!have_dialog(input_dialog_id.get_dialog_id())) {
        needed_dialog_ids.push_back(input_dialog_id);
      }
    }
  }

  vector<InputDialogId> input_dialog_ids;
  for (auto &input_dialog_id : needed_dialog_ids) {
    auto dialog_id = input_dialog_id.get_dialog_id();
    // TODO load dialogs asynchronously
    if (!have_dialog_force(dialog_id)) {
      if (dialog_id.get_type() == DialogType::SecretChat) {
        if (have_dialog_info_force(dialog_id)) {
          force_create_dialog(dialog_id, "load_dialog_filter");
        }
      } else {
        input_dialog_ids.push_back(input_dialog_id);
      }
    }
  }

  if (!input_dialog_ids.empty() && !force) {
    const size_t MAX_SLICE_SIZE = 100;
    MultiPromiseActorSafe mpas{"GetFilterDialogsFromServerMultiPromiseActor"};
    mpas.add_promise(std::move(promise));
    mpas.set_ignore_errors(true);
    auto lock = mpas.get_promise();

    for (size_t i = 0; i < input_dialog_ids.size(); i += MAX_SLICE_SIZE) {
      auto end_i = i + MAX_SLICE_SIZE;
      auto end = end_i < input_dialog_ids.size() ? input_dialog_ids.begin() + end_i : input_dialog_ids.end();
      td_->create_handler<GetDialogsQuery>(mpas.get_promise())->send({input_dialog_ids.begin() + i, end});
    }

    lock.set_value(Unit());
    return;
  }

  promise.set_value(Unit());
}

void MessagesManager::get_recommended_dialog_filters(
    Promise<td_api::object_ptr<td_api::recommendedChatFilters>> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  auto query_promise =
      PromiseCreator::lambda([actor_id = actor_id(this), promise = std::move(promise)](
                                 Result<vector<tl_object_ptr<telegram_api::dialogFilterSuggested>>> result) mutable {
        send_closure(actor_id, &MessagesManager::on_get_recommended_dialog_filters, std::move(result),
                     std::move(promise));
      });
  td_->create_handler<GetSuggestedDialogFiltersQuery>(std::move(query_promise))->send();
}

void MessagesManager::on_get_recommended_dialog_filters(
    Result<vector<tl_object_ptr<telegram_api::dialogFilterSuggested>>> result,
    Promise<td_api::object_ptr<td_api::recommendedChatFilters>> &&promise) {
  if (result.is_error()) {
    return promise.set_error(result.move_as_error());
  }
  CHECK(!td_->auth_manager_->is_bot());
  auto suggested_filters = result.move_as_ok();

  MultiPromiseActorSafe mpas{"LoadRecommendedFiltersMultiPromiseActor"};
  mpas.add_promise(Promise<Unit>());
  auto lock = mpas.get_promise();

  vector<RecommendedDialogFilter> filters;
  for (auto &suggested_filter : suggested_filters) {
    RecommendedDialogFilter filter;
    filter.dialog_filter = DialogFilter::get_dialog_filter(std::move(suggested_filter->filter_), false);
    CHECK(filter.dialog_filter != nullptr);
    filter.dialog_filter->dialog_filter_id = DialogFilterId();  // just in case
    load_dialog_filter(filter.dialog_filter.get(), false, mpas.get_promise());

    filter.description = std::move(suggested_filter->description_);
    filters.push_back(std::move(filter));
  }

  mpas.add_promise(PromiseCreator::lambda([actor_id = actor_id(this), filters = std::move(filters),
                                           promise = std::move(promise)](Result<Unit> &&result) mutable {
    send_closure(actor_id, &MessagesManager::on_load_recommended_dialog_filters, std::move(result), std::move(filters),
                 std::move(promise));
  }));
  lock.set_value(Unit());
}

void MessagesManager::on_load_recommended_dialog_filters(
    Result<Unit> &&result, vector<RecommendedDialogFilter> &&filters,
    Promise<td_api::object_ptr<td_api::recommendedChatFilters>> &&promise) {
  if (result.is_error()) {
    return promise.set_error(result.move_as_error());
  }
  CHECK(!td_->auth_manager_->is_bot());

  auto chat_filters = transform(filters, [this](const RecommendedDialogFilter &filter) {
    return td_api::make_object<td_api::recommendedChatFilter>(get_chat_filter_object(filter.dialog_filter.get()),
                                                              filter.description);
  });
  recommended_dialog_filters_ = std::move(filters);
  promise.set_value(td_api::make_object<td_api::recommendedChatFilters>(std::move(chat_filters)));
}

std::pair<int32, vector<DialogId>> MessagesManager::get_dialogs(DialogListId dialog_list_id, DialogDate offset,
                                                                int32 limit, bool force, Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());

  auto *list_ptr = get_dialog_list(dialog_list_id);
  if (list_ptr == nullptr) {
    promise.set_error(Status::Error(3, "Chat list not found"));
    return {};
  }
  auto &list = *list_ptr;

  LOG(INFO) << "Get chats in " << dialog_list_id << " with offset " << offset << " and limit " << limit
            << ". last_dialog_date = " << list.list_last_dialog_date_
            << ", last_pinned_dialog_date_ = " << list.last_pinned_dialog_date_
            << ", are_pinned_dialogs_inited_ = " << list.are_pinned_dialogs_inited_;

  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit in getChats must be positive"));
    return {};
  }

  if (limit > MAX_GET_DIALOGS + 2) {
    limit = MAX_GET_DIALOGS + 2;
  }

  vector<DialogId> result;
  if (dialog_list_id == DialogListId(FolderId::main()) && sponsored_dialog_id_.is_valid()) {
    auto d = get_dialog(sponsored_dialog_id_);
    CHECK(d != nullptr);
    if (is_dialog_sponsored(d)) {
      DialogDate date(get_dialog_private_order(&list, d), d->dialog_id);
      if (offset < date) {
        result.push_back(sponsored_dialog_id_);
        offset = date;
        limit--;
      }
    }
  }

  if (!list.are_pinned_dialogs_inited_) {
    if (limit == 0 || force) {
      promise.set_value(Unit());
      return {get_dialog_total_count(list), std::move(result)};
    } else {
      if (dialog_list_id.is_folder()) {
        auto &folder = *get_dialog_folder(dialog_list_id.get_folder_id());
        if (folder.last_loaded_database_dialog_date_ == folder.last_database_server_dialog_date_ &&
            folder.folder_last_dialog_date_ != MAX_DIALOG_DATE) {
          load_dialog_list(list, limit, std::move(promise));
          return {};
        }
      }
      reload_pinned_dialogs(dialog_list_id, std::move(promise));
      return {};
    }
  }
  if (dialog_list_id.is_filter()) {
    auto *filter = get_dialog_filter(dialog_list_id.get_filter_id());
    CHECK(filter != nullptr);
    vector<InputDialogId> input_dialog_ids;
    for (auto &input_dialog_id : filter->pinned_dialog_ids) {
      auto dialog_id = input_dialog_id.get_dialog_id();
      if (!have_dialog_force(dialog_id)) {
        if (dialog_id.get_type() == DialogType::SecretChat) {
          if (have_dialog_info_force(dialog_id)) {
            force_create_dialog(dialog_id, "get_dialogs");
          }
        } else {
          input_dialog_ids.push_back(input_dialog_id);
        }
      }
    }

    if (!input_dialog_ids.empty()) {
      if (limit == 0 || force) {
        promise.set_value(Unit());
        return {get_dialog_total_count(list), std::move(result)};
      } else {
        td_->create_handler<GetDialogsQuery>(std::move(promise))->send(std::move(input_dialog_ids));
        return {};
      }
    }
  }

  bool need_reload_pinned_dialogs = false;
  if (!list.pinned_dialogs_.empty() && offset < list.pinned_dialogs_.back() && limit > 0) {
    for (auto &pinned_dialog : list.pinned_dialogs_) {
      if (offset < pinned_dialog) {
        auto dialog_id = pinned_dialog.get_dialog_id();
        auto d = get_dialog_force(dialog_id);
        if (d == nullptr) {
          LOG(ERROR) << "Failed to load pinned " << dialog_id << " from " << dialog_list_id;
          if (dialog_id.get_type() != DialogType::SecretChat) {
            need_reload_pinned_dialogs = true;
          }
          continue;
        }
        if (d->order == DEFAULT_ORDER) {
          LOG(INFO) << "Loaded pinned " << dialog_id << " with default order in " << dialog_list_id;
          continue;
        }
        result.push_back(dialog_id);
        offset = pinned_dialog;
        limit--;
        if (limit == 0) {
          break;
        }
      }
    }
  }
  if (need_reload_pinned_dialogs) {
    reload_pinned_dialogs(dialog_list_id, Auto());
  }
  update_list_last_pinned_dialog_date(list);

  vector<const DialogFolder *> folders;
  vector<std::set<DialogDate>::const_iterator> folder_iterators;
  for (auto folder_id : get_dialog_list_folder_ids(list)) {
    folders.push_back(get_dialog_folder(folder_id));
    folder_iterators.push_back(folders.back()->ordered_dialogs_.upper_bound(offset));
  }
  while (limit > 0) {
    size_t best_pos = 0;
    DialogDate best_dialog_date = MAX_DIALOG_DATE;
    for (size_t i = 0; i < folders.size(); i++) {
      while (folder_iterators[i] != folders[i]->ordered_dialogs_.end() &&
             *folder_iterators[i] <= list.list_last_dialog_date_ &&
             (!is_dialog_in_list(get_dialog(folder_iterators[i]->get_dialog_id()), dialog_list_id) ||
              get_dialog_pinned_order(&list, folder_iterators[i]->get_dialog_id()) != DEFAULT_ORDER)) {
        ++folder_iterators[i];
      }
      if (folder_iterators[i] != folders[i]->ordered_dialogs_.end() &&
          *folder_iterators[i] <= list.list_last_dialog_date_ && *folder_iterators[i] < best_dialog_date) {
        best_pos = i;
        best_dialog_date = *folder_iterators[i];
      }
    }
    if (best_dialog_date == MAX_DIALOG_DATE || best_dialog_date.get_order() == DEFAULT_ORDER) {
      break;
    }

    limit--;
    result.push_back(folder_iterators[best_pos]->get_dialog_id());
    ++folder_iterators[best_pos];
  }

  if (!result.empty() || force || list.list_last_dialog_date_ == MAX_DIALOG_DATE) {
    if (limit > 0 && list.list_last_dialog_date_ != MAX_DIALOG_DATE) {
      load_dialog_list(list, limit, Promise<Unit>());
    }

    promise.set_value(Unit());
    return {get_dialog_total_count(list), std::move(result)};
  } else {
    load_dialog_list(list, limit, std::move(promise));
    return {};
  }
}

void MessagesManager::load_dialog_list(DialogList &list, int32 limit, Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  bool is_request_sent = false;
  for (auto folder_id : get_dialog_list_folder_ids(list)) {
    const auto &folder = *get_dialog_folder(folder_id);
    if (folder.folder_last_dialog_date_ != MAX_DIALOG_DATE) {
      load_folder_dialog_list(folder_id, limit, false, Auto());
      is_request_sent = true;
    }
  }
  if (is_request_sent) {
    list.load_list_queries_.push_back(std::move(promise));
  } else {
    LOG(ERROR) << "There is nothing to load for " << list.dialog_list_id << " with folders "
               << get_dialog_list_folder_ids(list);
    promise.set_value(Unit());
  }
}

// TODO remove the promise
void MessagesManager::load_folder_dialog_list(FolderId folder_id, int32 limit, bool only_local,
                                              Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  auto &folder = *get_dialog_folder(folder_id);
  if (folder.folder_last_dialog_date_ == MAX_DIALOG_DATE) {
    return promise.set_value(Unit());
  }

  bool use_database = G()->parameters().use_message_db &&
                      folder.last_loaded_database_dialog_date_ < folder.last_database_server_dialog_date_;
  if (only_local && !use_database) {
    return promise.set_value(Unit());
  }

  LOG(INFO) << "Load dialog list in " << folder_id << " with limit " << limit;
  auto &multipromise = folder.load_folder_dialog_list_multipromise_;
  multipromise.add_promise(std::move(promise));
  multipromise.add_promise(PromiseCreator::lambda([actor_id = actor_id(this), folder_id](Result<Unit> result) {
    if (result.is_error() && !G()->close_flag()) {
      send_closure(actor_id, &MessagesManager::on_load_folder_dialog_list_fail, folder_id, result.move_as_error());
    }
  }));
  if (multipromise.promise_count() != 2) {
    // queries have already been sent, just wait for the result
    if (use_database && folder.load_dialog_list_limit_max_ != 0) {
      folder.load_dialog_list_limit_max_ = max(folder.load_dialog_list_limit_max_, limit);
    }
    return;
  }

  bool is_query_sent = false;
  if (use_database) {
    load_folder_dialog_list_from_database(folder_id, limit, multipromise.get_promise());
    is_query_sent = true;
  } else {
    LOG(INFO) << "Get chats from " << folder.last_server_dialog_date_;
    reload_pinned_dialogs(DialogListId(folder_id), multipromise.get_promise());
    if (folder.folder_last_dialog_date_ == folder.last_server_dialog_date_) {
      send_closure(
          td_->create_net_actor<GetDialogListActor>(multipromise.get_promise()), &GetDialogListActor::send, folder_id,
          folder.last_server_dialog_date_.get_date(),
          folder.last_server_dialog_date_.get_message_id().get_next_server_message_id().get_server_message_id(),
          folder.last_server_dialog_date_.get_dialog_id(), int32{MAX_GET_DIALOGS},
          get_sequence_dispatcher_id(DialogId(), MessageContentType::None));
      is_query_sent = true;
    }
    if (folder_id == FolderId::main() && folder.last_server_dialog_date_ == MIN_DIALOG_DATE) {
      // do not pass promise to not wait for drafts before showing chat list
      td_->create_handler<GetAllDraftsQuery>()->send();
    }
  }
  CHECK(is_query_sent);
}

void MessagesManager::on_load_folder_dialog_list_fail(FolderId folder_id, Status error) {
  LOG(WARNING) << "Failed to load chats in " << folder_id << ": " << error;
  CHECK(!td_->auth_manager_->is_bot());
  const auto &folder = *get_dialog_folder(folder_id);
  vector<Promise<Unit>> promises;
  for (auto &list_it : dialog_lists_) {
    auto &list = list_it.second;
    if (!list.load_list_queries_.empty() && has_dialogs_from_folder(list, folder)) {
      append(promises, std::move(list.load_list_queries_));
      list.load_list_queries_.clear();
    }
  }

  for (auto &promise : promises) {
    promise.set_error(error.clone());
  }
}

void MessagesManager::load_folder_dialog_list_from_database(FolderId folder_id, int32 limit, Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  auto &folder = *get_dialog_folder(folder_id);
  LOG(INFO) << "Load " << limit << " chats in " << folder_id << " from database from "
            << folder.last_loaded_database_dialog_date_
            << ", last database server dialog date = " << folder.last_database_server_dialog_date_;

  CHECK(folder.load_dialog_list_limit_max_ == 0);
  folder.load_dialog_list_limit_max_ = limit;
  G()->td_db()->get_dialog_db_async()->get_dialogs(
      folder_id, folder.last_loaded_database_dialog_date_.get_order(),
      folder.last_loaded_database_dialog_date_.get_dialog_id(), limit,
      PromiseCreator::lambda([actor_id = actor_id(this), folder_id, limit,
                              promise = std::move(promise)](DialogDbGetDialogsResult result) mutable {
        send_closure(actor_id, &MessagesManager::on_get_dialogs_from_database, folder_id, limit, std::move(result),
                     std::move(promise));
      }));
}

void MessagesManager::on_get_dialogs_from_database(FolderId folder_id, int32 limit, DialogDbGetDialogsResult &&dialogs,
                                                   Promise<Unit> &&promise) {
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  CHECK(!td_->auth_manager_->is_bot());
  auto &folder = *get_dialog_folder(folder_id);
  LOG(INFO) << "Receive " << dialogs.dialogs.size() << " from expected " << limit << " chats in " << folder_id
            << " in from database with next order " << dialogs.next_order << " and next " << dialogs.next_dialog_id;
  int32 new_get_dialogs_limit = 0;
  int32 have_more_dialogs_in_database = (limit == static_cast<int32>(dialogs.dialogs.size()));
  if (have_more_dialogs_in_database && limit < folder.load_dialog_list_limit_max_) {
    new_get_dialogs_limit = folder.load_dialog_list_limit_max_ - limit;
  }
  folder.load_dialog_list_limit_max_ = 0;

  size_t dialogs_skipped = 0;
  for (auto &dialog : dialogs.dialogs) {
    Dialog *d = on_load_dialog_from_database(DialogId(), std::move(dialog));
    if (d == nullptr) {
      dialogs_skipped++;
      continue;
    }
    if (d->folder_id != folder_id) {
      LOG(WARNING) << "Skip " << d->dialog_id << " received from database, because it is in " << d->folder_id
                   << " instead of " << folder_id;
      dialogs_skipped++;
      continue;
    }

    LOG(INFO) << "Loaded from database " << d->dialog_id << " with order " << d->order;
  }

  DialogDate max_dialog_date(dialogs.next_order, dialogs.next_dialog_id);
  if (!have_more_dialogs_in_database) {
    folder.last_loaded_database_dialog_date_ = MAX_DIALOG_DATE;
    LOG(INFO) << "Set last loaded database dialog date to " << folder.last_loaded_database_dialog_date_;
    folder.last_server_dialog_date_ = max(folder.last_server_dialog_date_, folder.last_database_server_dialog_date_);
    LOG(INFO) << "Set last server dialog date to " << folder.last_server_dialog_date_;
    update_last_dialog_date(folder_id);
  } else if (folder.last_loaded_database_dialog_date_ < max_dialog_date) {
    folder.last_loaded_database_dialog_date_ = min(max_dialog_date, folder.last_database_server_dialog_date_);
    LOG(INFO) << "Set last loaded database dialog date to " << folder.last_loaded_database_dialog_date_;
    folder.last_server_dialog_date_ = max(folder.last_server_dialog_date_, folder.last_loaded_database_dialog_date_);
    LOG(INFO) << "Set last server dialog date to " << folder.last_server_dialog_date_;
    update_last_dialog_date(folder_id);

    for (const auto &list_it : dialog_lists_) {
      auto &list = list_it.second;
      if (!list.load_list_queries_.empty() && has_dialogs_from_folder(list, folder) && new_get_dialogs_limit < limit) {
        new_get_dialogs_limit = limit;
      }
    }
  } else {
    LOG(ERROR) << "Last loaded database dialog date didn't increased, skipped " << dialogs_skipped << " chats out of "
               << dialogs.dialogs.size();
  }

  if (!(folder.last_loaded_database_dialog_date_ < folder.last_database_server_dialog_date_)) {
    // have_more_dialogs_in_database = false;
    new_get_dialogs_limit = 0;
  }

  if (new_get_dialogs_limit == 0) {
    preload_folder_dialog_list_timeout_.add_timeout_in(folder_id.get(), 0.2);
    promise.set_value(Unit());
  } else {
    load_folder_dialog_list_from_database(folder_id, new_get_dialogs_limit, std::move(promise));
  }
}

void MessagesManager::preload_folder_dialog_list(FolderId folder_id) {
  if (G()->close_flag()) {
    LOG(INFO) << "Skip chat list preload in " << folder_id << " because of closing";
    return;
  }
  CHECK(!td_->auth_manager_->is_bot());

  auto &folder = *get_dialog_folder(folder_id);
  CHECK(G()->parameters().use_message_db);
  if (folder.load_folder_dialog_list_multipromise_.promise_count() != 0) {
    LOG(INFO) << "Skip chat list preload in " << folder_id << ", because there is a pending load chat list request";
    return;
  }

  if (folder.last_loaded_database_dialog_date_ < folder.last_database_server_dialog_date_) {
    // if there are some dialogs in database, preload some of them
    load_folder_dialog_list(folder_id, 20, true, Auto());
  } else if (folder.folder_last_dialog_date_ != MAX_DIALOG_DATE) {
    // otherwise load more dialogs from the server
    load_folder_dialog_list(folder_id, MAX_GET_DIALOGS, false,
                            PromiseCreator::lambda([actor_id = actor_id(this), folder_id](Result<Unit> result) {
                              if (result.is_ok()) {
                                send_closure(actor_id, &MessagesManager::recalc_unread_count, DialogListId(folder_id),
                                             -1);
                              }
                            }));
  } else {
    recalc_unread_count(DialogListId(folder_id));
  }
}

vector<DialogId> MessagesManager::get_pinned_dialog_ids(DialogListId dialog_list_id) const {
  CHECK(!td_->auth_manager_->is_bot());
  auto *list = get_dialog_list(dialog_list_id);
  if (list == nullptr || !list->are_pinned_dialogs_inited_) {
    return {};
  }
  return transform(list->pinned_dialogs_, [](auto &pinned_dialog) { return pinned_dialog.get_dialog_id(); });
}

void MessagesManager::reload_pinned_dialogs(DialogListId dialog_list_id, Promise<Unit> &&promise) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  if (dialog_list_id.is_folder()) {
    send_closure(td_->create_net_actor<GetPinnedDialogsActor>(std::move(promise)), &GetPinnedDialogsActor::send,
                 dialog_list_id.get_folder_id(), get_sequence_dispatcher_id(DialogId(), MessageContentType::None));
  }
  if (dialog_list_id.is_filter()) {
    schedule_dialog_filters_reload(0.0);
    dialog_filter_reload_queries_.push_back(std::move(promise));
  }
}

double MessagesManager::get_dialog_filters_cache_time() const {
  return DIALOG_FILTERS_CACHE_TIME * 0.0001 * Random::fast(9000, 11000);
}

void MessagesManager::schedule_dialog_filters_reload(double timeout) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }
  if (timeout <= 0) {
    timeout = 0.0;
    if (dialog_filters_updated_date_ != 0) {
      dialog_filters_updated_date_ = 0;
      save_dialog_filters();
    }
  }
  LOG(INFO) << "Schedule reload of chat filters in " << timeout;
  reload_dialog_filters_timeout_.set_callback(std::move(MessagesManager::on_reload_dialog_filters_timeout));
  reload_dialog_filters_timeout_.set_callback_data(static_cast<void *>(this));
  reload_dialog_filters_timeout_.set_timeout_in(timeout);
}

void MessagesManager::on_reload_dialog_filters_timeout(void *messages_manager_ptr) {
  if (G()->close_flag()) {
    return;
  }
  auto messages_manager = static_cast<MessagesManager *>(messages_manager_ptr);
  send_closure_later(messages_manager->actor_id(messages_manager), &MessagesManager::reload_dialog_filters);
}

void MessagesManager::reload_dialog_filters() {
  if (G()->close_flag()) {
    return;
  }
  CHECK(!td_->auth_manager_->is_bot());
  if (are_dialog_filters_being_synchronized_ || are_dialog_filters_being_reloaded_) {
    need_dialog_filters_reload_ = true;
    return;
  }
  LOG(INFO) << "Reload chat filters from server";
  are_dialog_filters_being_reloaded_ = true;
  need_dialog_filters_reload_ = false;
  auto promise = PromiseCreator::lambda(
      [actor_id = actor_id(this)](Result<vector<tl_object_ptr<telegram_api::dialogFilter>>> r_filters) {
        send_closure(actor_id, &MessagesManager::on_get_dialog_filters, std::move(r_filters), false);
      });
  td_->create_handler<GetDialogFiltersQuery>(std::move(promise))->send();
}

void MessagesManager::on_get_dialog_filters(Result<vector<tl_object_ptr<telegram_api::dialogFilter>>> r_filters,
                                            bool dummy) {
  are_dialog_filters_being_reloaded_ = false;
  if (G()->close_flag()) {
    return;
  }
  CHECK(!td_->auth_manager_->is_bot());
  auto promises = std::move(dialog_filter_reload_queries_);
  dialog_filter_reload_queries_.clear();
  if (r_filters.is_error()) {
    for (auto &promise : promises) {
      promise.set_error(r_filters.error().clone());
    }
    LOG(WARNING) << "Receive error " << r_filters.error() << " for GetDialogFiltersQuery";
    need_dialog_filters_reload_ = false;
    schedule_dialog_filters_reload(Random::fast(60, 5 * 60));
    return;
  }

  auto filters = r_filters.move_as_ok();
  vector<unique_ptr<DialogFilter>> new_server_dialog_filters;
  LOG(INFO) << "Receive " << filters.size() << " chat filters from server";
  std::unordered_set<DialogFilterId, DialogFilterIdHash> new_dialog_filter_ids;
  for (auto &filter : filters) {
    auto dialog_filter = DialogFilter::get_dialog_filter(std::move(filter), true);
    if (dialog_filter == nullptr) {
      continue;
    }
    if (!new_dialog_filter_ids.insert(dialog_filter->dialog_filter_id).second) {
      LOG(ERROR) << "Receive duplicate " << dialog_filter->dialog_filter_id;
      continue;
    }

    sort_dialog_filter_input_dialog_ids(dialog_filter.get());
    new_server_dialog_filters.push_back(std::move(dialog_filter));
  }

  bool is_changed = false;
  dialog_filters_updated_date_ = G()->unix_time();
  if (server_dialog_filters_ != new_server_dialog_filters) {
    LOG(INFO) << "Change server chat filters from " << get_dialog_filter_ids(server_dialog_filters_) << " to "
              << get_dialog_filter_ids(new_server_dialog_filters);
    std::unordered_map<DialogFilterId, const DialogFilter *, DialogFilterIdHash> old_server_dialog_filters;
    for (const auto &filter : server_dialog_filters_) {
      old_server_dialog_filters.emplace(filter->dialog_filter_id, filter.get());
    }
    for (const auto &new_server_filter : new_server_dialog_filters) {
      auto dialog_filter_id = new_server_filter->dialog_filter_id;
      auto old_filter = get_dialog_filter(dialog_filter_id);
      auto it = old_server_dialog_filters.find(dialog_filter_id);
      if (it != old_server_dialog_filters.end()) {
        auto old_server_filter = it->second;
        if (*new_server_filter != *old_server_filter) {
          if (old_filter == nullptr) {
            // the filter was deleted, don't need to edit it
          } else {
            if (DialogFilter::are_equivalent(*old_filter, *new_server_filter)) {  // fast path
              // the filter was edited from this client, nothing to do
            } else {
              auto new_filter =
                  DialogFilter::merge_dialog_filter_changes(old_filter, old_server_filter, new_server_filter.get());
              LOG(INFO) << "Old  local filter: " << *old_filter;
              LOG(INFO) << "Old server filter: " << *old_server_filter;
              LOG(INFO) << "New server filter: " << *new_server_filter;
              LOG(INFO) << "New  local filter: " << *new_filter;
              sort_dialog_filter_input_dialog_ids(new_filter.get());
              if (*new_filter != *old_filter) {
                is_changed = true;
                edit_dialog_filter(std::move(new_filter), "on_get_dialog_filters");
              }
            }
          }
        }
        old_server_dialog_filters.erase(it);
      } else {
        if (old_filter == nullptr) {
          // the filter was added from another client
          is_changed = true;
          add_dialog_filter(make_unique<DialogFilter>(*new_server_filter), false, "on_get_dialog_filters");
        } else {
          // the filter was added from this client
          // after that it could be added from another client, or edited from this client, or edited from another client
          // prefer local value, so do nothing
          // effectively, ignore edits from other clients, if didn't receive UpdateDialogFilterQuery response
        }
      }
    }
    vector<DialogFilterId> left_old_server_dialog_filter_ids;
    for (const auto &filter : server_dialog_filters_) {
      if (old_server_dialog_filters.count(filter->dialog_filter_id) == 0) {
        left_old_server_dialog_filter_ids.push_back(filter->dialog_filter_id);
      }
    }
    LOG(INFO) << "Still existing server chat filters: " << left_old_server_dialog_filter_ids;
    for (auto &old_server_filter : old_server_dialog_filters) {
      auto dialog_filter_id = old_server_filter.first;
      // deleted filter
      auto old_filter = get_dialog_filter(dialog_filter_id);
      if (old_filter == nullptr) {
        // the filter was deleted from this client, nothing to do
      } else {
        // the filter was deleted from another client
        // ignore edits done from the current client and just delete the filter
        is_changed = true;
        delete_dialog_filter(dialog_filter_id, "on_get_dialog_filters");
      }
    }
    bool is_order_changed = [&] {
      vector<DialogFilterId> new_server_dialog_filter_ids = get_dialog_filter_ids(new_server_dialog_filters);
      CHECK(new_server_dialog_filter_ids.size() >= left_old_server_dialog_filter_ids.size());
      new_server_dialog_filter_ids.resize(left_old_server_dialog_filter_ids.size());
      return new_server_dialog_filter_ids != left_old_server_dialog_filter_ids;
    }();
    if (is_order_changed) {  // if order is changed from this and other clients, prefer order from another client
      vector<DialogFilterId> new_dialog_filter_order;
      for (const auto &new_server_filter : new_server_dialog_filters) {
        auto dialog_filter_id = new_server_filter->dialog_filter_id;
        if (get_dialog_filter(dialog_filter_id) != nullptr) {
          new_dialog_filter_order.push_back(dialog_filter_id);
        }
      }
      is_changed = true;
      set_dialog_filters_order(dialog_filters_, new_dialog_filter_order);
    }

    server_dialog_filters_ = std::move(new_server_dialog_filters);
  }
  if (is_changed || !is_update_chat_filters_sent_) {
    send_update_chat_filters();
  }
  schedule_dialog_filters_reload(get_dialog_filters_cache_time());
  save_dialog_filters();

  if (need_synchronize_dialog_filters()) {
    synchronize_dialog_filters();
  }
  for (auto &promise : promises) {
    promise.set_value(Unit());
  }
}

bool MessagesManager::need_synchronize_dialog_filters() const {
  CHECK(!td_->auth_manager_->is_bot());
  size_t server_dialog_filter_count = 0;
  vector<DialogFilterId> dialog_filter_ids;
  for (const auto &dialog_filter : dialog_filters_) {
    if (dialog_filter->is_empty(true)) {
      continue;
    }

    server_dialog_filter_count++;
    auto server_dialog_filter = get_server_dialog_filter(dialog_filter->dialog_filter_id);
    if (server_dialog_filter == nullptr || !DialogFilter::are_equivalent(*server_dialog_filter, *dialog_filter)) {
      // need update dialog filter on server
      return true;
    }
    dialog_filter_ids.push_back(dialog_filter->dialog_filter_id);
  }
  if (server_dialog_filter_count != server_dialog_filters_.size()) {
    // need delete dialog filter on server
    return true;
  }
  if (dialog_filter_ids != get_dialog_filter_ids(server_dialog_filters_)) {
    // need reorder dialog filters on server
    return true;
  }
  return false;
}

void MessagesManager::synchronize_dialog_filters() {
  if (G()->close_flag()) {
    return;
  }
  CHECK(!td_->auth_manager_->is_bot());
  if (are_dialog_filters_being_synchronized_ || are_dialog_filters_being_reloaded_) {
    return;
  }
  if (need_dialog_filters_reload_) {
    return reload_dialog_filters();
  }
  if (!need_synchronize_dialog_filters()) {
    // reload filters to repair their order if the server added new filter to the beginning of the list
    return reload_dialog_filters();
  }

  LOG(INFO) << "Synchronize chat filter changes with server having local " << get_dialog_filter_ids(dialog_filters_)
            << " and server " << get_dialog_filter_ids(server_dialog_filters_);
  for (const auto &server_dialog_filter : server_dialog_filters_) {
    if (get_dialog_filter(server_dialog_filter->dialog_filter_id) == nullptr) {
      return delete_dialog_filter_on_server(server_dialog_filter->dialog_filter_id);
    }
  }

  vector<DialogFilterId> dialog_filter_ids;
  for (const auto &dialog_filter : dialog_filters_) {
    if (dialog_filter->is_empty(true)) {
      continue;
    }

    auto server_dialog_filter = get_server_dialog_filter(dialog_filter->dialog_filter_id);
    if (server_dialog_filter == nullptr || !DialogFilter::are_equivalent(*server_dialog_filter, *dialog_filter)) {
      return update_dialog_filter_on_server(make_unique<DialogFilter>(*dialog_filter));
    }
    dialog_filter_ids.push_back(dialog_filter->dialog_filter_id);
  }

  if (dialog_filter_ids != get_dialog_filter_ids(server_dialog_filters_)) {
    return reorder_dialog_filters_on_server(std::move(dialog_filter_ids));
  }

  UNREACHABLE();
}

vector<DialogId> MessagesManager::search_public_dialogs(const string &query, Promise<Unit> &&promise) {
  LOG(INFO) << "Search public chats with query = \"" << query << '"';

  if (utf8_length(query) < MIN_SEARCH_PUBLIC_DIALOG_PREFIX_LEN) {
    string username = clean_username(query);
    if (username[0] == '@') {
      username = username.substr(1);
    }

    for (auto &short_username : get_valid_short_usernames()) {
      if (2 * username.size() > short_username.size() && begins_with(short_username, username)) {
        username = short_username.str();
        auto it = resolved_usernames_.find(username);
        if (it == resolved_usernames_.end()) {
          td_->create_handler<ResolveUsernameQuery>(std::move(promise))->send(username);
          return {};
        }

        if (it->second.expires_at < Time::now()) {
          td_->create_handler<ResolveUsernameQuery>(Promise<>())->send(username);
        }

        auto dialog_id = it->second.dialog_id;
        force_create_dialog(dialog_id, "public dialogs search");
        promise.set_value(Unit());
        return {dialog_id};
      }
    }
    promise.set_value(Unit());
    return {};
  }

  auto it = found_public_dialogs_.find(query);
  if (it != found_public_dialogs_.end()) {
    promise.set_value(Unit());
    return it->second;
  }

  send_search_public_dialogs_query(query, std::move(promise));
  return {};
}

void MessagesManager::send_search_public_dialogs_query(const string &query, Promise<Unit> &&promise) {
  auto &promises = search_public_dialogs_queries_[query];
  promises.push_back(std::move(promise));
  if (promises.size() != 1) {
    // query has already been sent, just wait for the result
    return;
  }

  td_->create_handler<SearchPublicDialogsQuery>()->send(query);
}

std::pair<int32, vector<DialogId>> MessagesManager::search_dialogs(const string &query, int32 limit,
                                                                   Promise<Unit> &&promise) {
  LOG(INFO) << "Search chats with query \"" << query << "\" and limit " << limit;
  CHECK(!td_->auth_manager_->is_bot());

  if (limit < 0) {
    promise.set_error(Status::Error(400, "Limit must be non-negative"));
    return {};
  }
  if (query.empty()) {
    if (!load_recently_found_dialogs(promise)) {
      return {};
    }

    promise.set_value(Unit());

    update_recently_found_dialogs();

    size_t result_size = min(static_cast<size_t>(limit), recently_found_dialog_ids_.size());
    return {narrow_cast<int32>(recently_found_dialog_ids_.size()),
            vector<DialogId>(recently_found_dialog_ids_.begin(), recently_found_dialog_ids_.begin() + result_size)};
  }

  auto result = dialogs_hints_.search(query, limit);
  vector<DialogId> dialog_ids;
  dialog_ids.reserve(result.second.size());
  for (auto key : result.second) {
    dialog_ids.push_back(DialogId(-key));
  }

  promise.set_value(Unit());
  return {narrow_cast<int32>(result.first), std::move(dialog_ids)};
}

vector<DialogId> MessagesManager::sort_dialogs_by_order(const vector<DialogId> &dialog_ids, int32 limit) const {
  CHECK(!td_->auth_manager_->is_bot());
  int64 fake_order = static_cast<int64>(dialog_ids.size()) + 1;
  auto dialog_dates = transform(dialog_ids, [this, &fake_order](DialogId dialog_id) {
    const Dialog *d = get_dialog(dialog_id);
    CHECK(d != nullptr);
    auto order = get_dialog_base_order(d);
    if (is_dialog_inited(d) || order != DEFAULT_ORDER) {
      return DialogDate(order, dialog_id);
    }
    // if the dialog is not inited yet, we need to assume that server knows better and the dialog needs to be returned
    return DialogDate(fake_order--, dialog_id);
  });
  if (static_cast<size_t>(limit) >= dialog_dates.size()) {
    std::sort(dialog_dates.begin(), dialog_dates.end());
  } else {
    std::partial_sort(dialog_dates.begin(), dialog_dates.begin() + limit, dialog_dates.end());
    dialog_dates.resize(limit, MAX_DIALOG_DATE);
  }
  while (!dialog_dates.empty() && dialog_dates.back().get_order() == DEFAULT_ORDER) {
    dialog_dates.pop_back();
  }
  return transform(dialog_dates, [](auto dialog_date) { return dialog_date.get_dialog_id(); });
}

vector<DialogId> MessagesManager::search_dialogs_on_server(const string &query, int32 limit, Promise<Unit> &&promise) {
  LOG(INFO) << "Search chats on server with query \"" << query << "\" and limit " << limit;

  if (limit < 0) {
    promise.set_error(Status::Error(400, "Limit must be non-negative"));
    return {};
  }
  if (limit > MAX_GET_DIALOGS) {
    limit = MAX_GET_DIALOGS;
  }

  if (query.empty()) {
    promise.set_value(Unit());
    return {};
  }

  auto it = found_on_server_dialogs_.find(query);
  if (it != found_on_server_dialogs_.end()) {
    promise.set_value(Unit());
    return sort_dialogs_by_order(it->second, limit);
  }

  send_search_public_dialogs_query(query, std::move(promise));
  return {};
}

void MessagesManager::drop_common_dialogs_cache(UserId user_id) {
  auto it = found_common_dialogs_.find(user_id);
  if (it != found_common_dialogs_.end()) {
    it->second.is_outdated = true;
  }
}

std::pair<int32, vector<DialogId>> MessagesManager::get_common_dialogs(UserId user_id, DialogId offset_dialog_id,
                                                                       int32 limit, bool force,
                                                                       Promise<Unit> &&promise) {
  if (!td_->contacts_manager_->have_input_user(user_id)) {
    promise.set_error(Status::Error(6, "Have no access to the user"));
    return {};
  }

  if (user_id == td_->contacts_manager_->get_my_id()) {
    promise.set_error(Status::Error(6, "Can't get common chats with self"));
    return {};
  }
  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit must be positive"));
    return {};
  }
  if (limit > MAX_GET_DIALOGS) {
    limit = MAX_GET_DIALOGS;
  }

  int32 offset_chat_id = 0;
  switch (offset_dialog_id.get_type()) {
    case DialogType::Chat:
      offset_chat_id = offset_dialog_id.get_chat_id().get();
      break;
    case DialogType::Channel:
      offset_chat_id = offset_dialog_id.get_channel_id().get();
      break;
    case DialogType::None:
      if (offset_dialog_id == DialogId()) {
        break;
      }
    // fallthrough
    case DialogType::User:
    case DialogType::SecretChat:
      promise.set_error(Status::Error(6, "Wrong offset_chat_id"));
      return {};
    default:
      UNREACHABLE();
      break;
  }

  auto it = found_common_dialogs_.find(user_id);
  if (it != found_common_dialogs_.end() && !it->second.dialog_ids.empty()) {
    int32 total_count = it->second.total_count;
    vector<DialogId> &common_dialog_ids = it->second.dialog_ids;
    bool use_cache = (!it->second.is_outdated && it->second.received_date >= Time::now() - 3600) || force ||
                     offset_chat_id != 0 || common_dialog_ids.size() >= static_cast<size_t>(MAX_GET_DIALOGS);
    // use cache if it is up-to-date, or we required to use it or we can't update it
    if (use_cache) {
      auto offset_it = common_dialog_ids.begin();
      if (offset_dialog_id != DialogId()) {
        offset_it = std::find(common_dialog_ids.begin(), common_dialog_ids.end(), offset_dialog_id);
        if (offset_it == common_dialog_ids.end()) {
          promise.set_error(Status::Error(6, "Wrong offset_chat_id"));
          return {};
        }
        ++offset_it;
      }
      vector<DialogId> result;
      while (result.size() < static_cast<size_t>(limit)) {
        if (offset_it == common_dialog_ids.end()) {
          break;
        }
        auto dialog_id = *offset_it++;
        if (dialog_id == DialogId()) {  // end of the list
          promise.set_value(Unit());
          return {total_count, std::move(result)};
        }
        result.push_back(dialog_id);
      }
      if (result.size() == static_cast<size_t>(limit) || force) {
        promise.set_value(Unit());
        return {total_count, std::move(result)};
      }
    }
  }

  td_->create_handler<GetCommonDialogsQuery>(std::move(promise))->send(user_id, offset_chat_id, MAX_GET_DIALOGS);
  return {};
}

void MessagesManager::on_get_common_dialogs(UserId user_id, int32 offset_chat_id,
                                            vector<tl_object_ptr<telegram_api::Chat>> &&chats, int32 total_count) {
  td_->contacts_manager_->on_update_user_common_chat_count(user_id, total_count);

  auto &common_dialogs = found_common_dialogs_[user_id];
  if (common_dialogs.is_outdated && offset_chat_id == 0 &&
      common_dialogs.dialog_ids.size() < static_cast<size_t>(MAX_GET_DIALOGS)) {
    // drop outdated cache if possible
    common_dialogs = CommonDialogs();
  }
  if (common_dialogs.received_date == 0) {
    common_dialogs.received_date = Time::now();
  }
  common_dialogs.is_outdated = false;
  auto &result = common_dialogs.dialog_ids;
  if (!result.empty() && result.back() == DialogId()) {
    return;
  }
  bool is_last = chats.empty() && offset_chat_id == 0;
  for (auto &chat : chats) {
    DialogId dialog_id;
    switch (chat->get_id()) {
      case telegram_api::chatEmpty::ID: {
        auto c = static_cast<const telegram_api::chatEmpty *>(chat.get());
        ChatId chat_id(c->id_);
        if (!chat_id.is_valid()) {
          LOG(ERROR) << "Receive invalid " << chat_id;
          continue;
        }
        dialog_id = DialogId(chat_id);
        break;
      }
      case telegram_api::chat::ID: {
        auto c = static_cast<const telegram_api::chat *>(chat.get());
        ChatId chat_id(c->id_);
        if (!chat_id.is_valid()) {
          LOG(ERROR) << "Receive invalid " << chat_id;
          continue;
        }
        dialog_id = DialogId(chat_id);
        break;
      }
      case telegram_api::chatForbidden::ID: {
        auto c = static_cast<const telegram_api::chatForbidden *>(chat.get());
        ChatId chat_id(c->id_);
        if (!chat_id.is_valid()) {
          LOG(ERROR) << "Receive invalid " << chat_id;
          continue;
        }
        dialog_id = DialogId(chat_id);
        break;
      }
      case telegram_api::channel::ID: {
        auto c = static_cast<const telegram_api::channel *>(chat.get());
        ChannelId channel_id(c->id_);
        if (!channel_id.is_valid()) {
          LOG(ERROR) << "Receive invalid " << channel_id;
          continue;
        }
        dialog_id = DialogId(channel_id);
        break;
      }
      case telegram_api::channelForbidden::ID: {
        auto c = static_cast<const telegram_api::channelForbidden *>(chat.get());
        ChannelId channel_id(c->id_);
        if (!channel_id.is_valid()) {
          LOG(ERROR) << "Receive invalid " << channel_id;
          continue;
        }
        dialog_id = DialogId(channel_id);
        break;
      }
      default:
        UNREACHABLE();
    }
    CHECK(dialog_id.is_valid());
    td_->contacts_manager_->on_get_chat(std::move(chat), "on_get_common_dialogs");

    if (!td::contains(result, dialog_id)) {
      force_create_dialog(dialog_id, "get common dialogs");
      result.push_back(dialog_id);
    }
  }
  if (result.size() >= static_cast<size_t>(total_count) || is_last) {
    if (result.size() != static_cast<size_t>(total_count)) {
      LOG(ERROR) << "Fix total count of common groups with " << user_id << " from " << total_count << " to "
                 << result.size();
      total_count = narrow_cast<int32>(result.size());
      td_->contacts_manager_->on_update_user_common_chat_count(user_id, total_count);
    }

    result.push_back(DialogId());
  }
  common_dialogs.total_count = total_count;
}

void MessagesManager::block_message_sender_from_replies(MessageId message_id, bool delete_message,
                                                        bool delete_all_messages, bool report_spam,
                                                        Promise<Unit> &&promise) {
  auto dialog_id = DialogId(ContactsManager::get_replies_bot_user_id());
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(400, "Chat not found"));
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_error(Status::Error(400, "Not enough rights"));
  }

  auto *m = get_message_force(d, message_id, "block_message_sender_from_replies");
  if (m == nullptr) {
    return promise.set_error(Status::Error(400, "Message not found"));
  }
  if (m->is_outgoing || m->message_id.is_scheduled() || !m->message_id.is_server()) {
    return promise.set_error(Status::Error(400, "Wrong message specified"));
  }

  UserId sender_user_id;
  if (m->forward_info != nullptr) {
    sender_user_id = m->forward_info->sender_user_id;
  }
  bool need_update_dialog_pos = false;
  vector<int64> deleted_message_ids;
  if (delete_message) {
    auto p = this->delete_message(d, message_id, true, &need_update_dialog_pos, "block_message_sender_from_replies");
    CHECK(p.get() == m);
    deleted_message_ids.push_back(p->message_id.get());
  }
  if (delete_all_messages && sender_user_id.is_valid()) {
    vector<MessageId> message_ids;
    find_messages(d->messages.get(), message_ids, [sender_user_id](const Message *m) {
      return !m->is_outgoing && m->forward_info != nullptr && m->forward_info->sender_user_id == sender_user_id;
    });

    for (auto user_message_id : message_ids) {
      auto p = this->delete_message(d, user_message_id, true, &need_update_dialog_pos,
                                    "block_message_sender_from_replies 2");
      deleted_message_ids.push_back(p->message_id.get());
    }
  }

  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "block_message_sender_from_replies");
  }

  send_update_delete_messages(dialog_id, std::move(deleted_message_ids), true, false);

  block_message_sender_from_replies_on_server(message_id, delete_message, delete_all_messages, report_spam, 0,
                                              std::move(promise));
}

class MessagesManager::BlockMessageSenderFromRepliesOnServerLogEvent {
 public:
  MessageId message_id_;
  bool delete_message_;
  bool delete_all_messages_;
  bool report_spam_;

  template <class StorerT>
  void store(StorerT &storer) const {
    BEGIN_STORE_FLAGS();
    STORE_FLAG(delete_message_);
    STORE_FLAG(delete_all_messages_);
    STORE_FLAG(report_spam_);
    END_STORE_FLAGS();

    td::store(message_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(delete_message_);
    PARSE_FLAG(delete_all_messages_);
    PARSE_FLAG(report_spam_);
    END_PARSE_FLAGS();

    td::parse(message_id_, parser);
  }
};

uint64 MessagesManager::save_block_message_sender_from_replies_on_server_log_event(MessageId message_id,
                                                                                   bool delete_message,
                                                                                   bool delete_all_messages,
                                                                                   bool report_spam) {
  BlockMessageSenderFromRepliesOnServerLogEvent log_event{message_id, delete_message, delete_all_messages, report_spam};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::BlockMessageSenderFromRepliesOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::block_message_sender_from_replies_on_server(MessageId message_id, bool delete_message,
                                                                  bool delete_all_messages, bool report_spam,
                                                                  uint64 log_event_id, Promise<Unit> &&promise) {
  if (log_event_id == 0) {
    log_event_id = save_block_message_sender_from_replies_on_server_log_event(message_id, delete_message,
                                                                              delete_all_messages, report_spam);
  }

  td_->create_handler<BlockFromRepliesQuery>(get_erase_log_event_promise(log_event_id, std::move(promise)))
      ->send(message_id, delete_message, delete_all_messages, report_spam);
}

std::pair<int32, vector<DialogId>> MessagesManager::get_blocked_dialogs(int32 offset, int32 limit, int64 &random_id,
                                                                        Promise<Unit> &&promise) {
  LOG(INFO) << "Get blocked chats with offset = " << offset << " and limit = " << limit;

  if (random_id != 0) {
    // request has already been sent before
    auto it = found_blocked_dialogs_.find(random_id);
    CHECK(it != found_blocked_dialogs_.end());
    auto result = std::move(it->second);
    found_blocked_dialogs_.erase(it);

    promise.set_value(Unit());
    return result;
  }

  if (offset < 0) {
    promise.set_error(Status::Error(3, "Parameter offset must be non-negative"));
    return {};
  }

  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit must be positive"));
    return {};
  }

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || found_blocked_dialogs_.find(random_id) != found_blocked_dialogs_.end());
  found_blocked_dialogs_[random_id];  // reserve place for result

  td_->create_handler<GetBlockedDialogsQuery>(std::move(promise))->send(offset, limit, random_id);
  return {};
}

void MessagesManager::on_get_blocked_dialogs(int32 offset, int32 limit, int64 random_id, int32 total_count,
                                             vector<tl_object_ptr<telegram_api::peerBlocked>> &&blocked_peers) {
  LOG(INFO) << "Receive " << blocked_peers.size() << " blocked chats from offset " << offset << " out of "
            << total_count;
  auto it = found_blocked_dialogs_.find(random_id);
  CHECK(it != found_blocked_dialogs_.end());

  auto &result = it->second.second;
  CHECK(result.empty());
  for (auto &blocked_peer : blocked_peers) {
    CHECK(blocked_peer != nullptr);
    DialogId dialog_id(blocked_peer->peer_id_);
    if (dialog_id.get_type() == DialogType::User) {
      if (td_->contacts_manager_->have_user(dialog_id.get_user_id())) {
        result.push_back(dialog_id);
      } else {
        LOG(ERROR) << "Have no info about " << dialog_id.get_user_id();
      }
    } else {
      force_create_dialog(dialog_id, "on_get_blocked_dialogs");
      if (have_dialog(dialog_id)) {
        result.push_back(dialog_id);
      } else {
        LOG(ERROR) << "Have no info about " << dialog_id;
      }
    }
  }
  if (!result.empty() && offset + result.size() > static_cast<size_t>(total_count)) {
    LOG(ERROR) << "Fix total count of blocked chats from " << total_count << " to " << offset + result.size();
    total_count = offset + narrow_cast<int32>(result.size());
  }
  it->second.first = total_count;
}

void MessagesManager::on_failed_get_blocked_dialogs(int64 random_id) {
  auto it = found_blocked_dialogs_.find(random_id);
  CHECK(it != found_blocked_dialogs_.end());
  found_blocked_dialogs_.erase(it);
}

bool MessagesManager::have_message_force(FullMessageId full_message_id, const char *source) {
  return get_message_force(full_message_id, source) != nullptr;
}

MessagesManager::Message *MessagesManager::get_message(FullMessageId full_message_id) {
  Dialog *d = get_dialog(full_message_id.get_dialog_id());
  if (d == nullptr) {
    return nullptr;
  }

  return get_message(d, full_message_id.get_message_id());
}

const MessagesManager::Message *MessagesManager::get_message(FullMessageId full_message_id) const {
  const Dialog *d = get_dialog(full_message_id.get_dialog_id());
  if (d == nullptr) {
    return nullptr;
  }

  return get_message(d, full_message_id.get_message_id());
}

MessagesManager::Message *MessagesManager::get_message_force(FullMessageId full_message_id, const char *source) {
  Dialog *d = get_dialog_force(full_message_id.get_dialog_id());
  if (d == nullptr) {
    return nullptr;
  }

  return get_message_force(d, full_message_id.get_message_id(), source);
}

FullMessageId MessagesManager::get_replied_message_id(DialogId dialog_id, const Message *m) {
  auto message_id = get_message_content_replied_message_id(m->content.get());
  if (message_id.is_valid()) {
    CHECK(!m->reply_to_message_id.is_valid());
    return {dialog_id, message_id};
  }
  if (!m->reply_to_message_id.is_valid()) {
    return {};
  }
  return {m->reply_in_dialog_id.is_valid() ? m->reply_in_dialog_id : dialog_id, m->reply_to_message_id};
}

void MessagesManager::get_message_force_from_server(Dialog *d, MessageId message_id, Promise<Unit> &&promise,
                                                    tl_object_ptr<telegram_api::InputMessage> input_message) {
  LOG(INFO) << "Get " << message_id << " in " << d->dialog_id << " using " << to_string(input_message);
  auto dialog_type = d->dialog_id.get_type();
  auto m = get_message_force(d, message_id, "get_message_force_from_server");
  if (m == nullptr) {
    if (message_id.is_valid() && message_id.is_server()) {
      if (d->last_new_message_id != MessageId() && message_id > d->last_new_message_id &&
          dialog_type != DialogType::Channel) {
        // message will not be added to the dialog anyway
        return promise.set_value(Unit());
      }

      if (d->deleted_message_ids.count(message_id) == 0 && dialog_type != DialogType::SecretChat) {
        return get_message_from_server({d->dialog_id, message_id}, std::move(promise), std::move(input_message));
      }
    } else if (message_id.is_valid_scheduled() && message_id.is_scheduled_server()) {
      if (d->deleted_scheduled_server_message_ids.count(message_id.get_scheduled_server_message_id()) == 0 &&
          dialog_type != DialogType::SecretChat && input_message == nullptr) {
        return get_message_from_server({d->dialog_id, message_id}, std::move(promise));
      }
    }
  }

  promise.set_value(Unit());
}

void MessagesManager::get_message(FullMessageId full_message_id, Promise<Unit> &&promise) {
  Dialog *d = get_dialog_force(full_message_id.get_dialog_id());
  if (d == nullptr) {
    return promise.set_error(Status::Error(6, "Chat not found"));
  }

  get_message_force_from_server(d, full_message_id.get_message_id(), std::move(promise));
}

FullMessageId MessagesManager::get_replied_message(DialogId dialog_id, MessageId message_id, bool force,
                                                   Promise<Unit> &&promise) {
  LOG(INFO) << "Get replied message to " << message_id << " in " << dialog_id;
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(6, "Chat not found"));
    return FullMessageId();
  }

  message_id = get_persistent_message_id(d, message_id);
  auto m = get_message_force(d, message_id, "get_replied_message");
  if (m == nullptr) {
    if (force) {
      promise.set_value(Unit());
    } else {
      get_message_force_from_server(d, message_id, std::move(promise));
    }
    return FullMessageId();
  }

  tl_object_ptr<telegram_api::InputMessage> input_message;
  auto replied_message_id = get_replied_message_id(dialog_id, m);
  if (replied_message_id.get_dialog_id() != dialog_id) {
    dialog_id = replied_message_id.get_dialog_id();
    if (!have_dialog_info_force(dialog_id)) {
      promise.set_value(Unit());
      return {};
    }
    if (!have_input_peer(dialog_id, AccessRights::Read)) {
      promise.set_value(Unit());
      return {};
    }

    force_create_dialog(dialog_id, "get_replied_message");
    d = get_dialog_force(dialog_id);
    if (d == nullptr) {
      promise.set_error(Status::Error(500, "Chat with replied message not found"));
      return {};
    }
  } else if (m->message_id.is_valid() && m->message_id.is_server()) {
    input_message = make_tl_object<telegram_api::inputMessageReplyTo>(m->message_id.get_server_message_id().get());
  }
  get_message_force_from_server(d, replied_message_id.get_message_id(), std::move(promise), std::move(input_message));

  return replied_message_id;
}

Result<FullMessageId> MessagesManager::get_top_thread_full_message_id(DialogId dialog_id, const Message *m) const {
  CHECK(m != nullptr);
  if (m->message_id.is_scheduled()) {
    return Status::Error(400, "Message is scheduled");
  }
  if (dialog_id.get_type() != DialogType::Channel) {
    return Status::Error(400, "Chat can't have message threads");
  }
  if (!m->reply_info.is_empty() && m->reply_info.is_comment) {
    if (!is_visible_message_reply_info(dialog_id, m)) {
      return Status::Error(400, "Message has no comments");
    }
    if (m->message_id.is_yet_unsent()) {
      return Status::Error(400, "Message is not sent yet");
    }
    return FullMessageId{DialogId(m->reply_info.channel_id), m->linked_top_thread_message_id};
  } else {
    if (!m->top_thread_message_id.is_valid()) {
      return Status::Error(400, "Message has no thread");
    }
    if (!m->message_id.is_server()) {
      return Status::Error(400, "Message thread is unavailable for the message");
    }
    if (m->top_thread_message_id != m->message_id &&
        !td_->contacts_manager_->get_channel_has_linked_channel(dialog_id.get_channel_id())) {
      return Status::Error(400, "Root message must be used to get the message thread");
    }
    return FullMessageId{dialog_id, m->top_thread_message_id};
  }
}

void MessagesManager::get_message_thread(DialogId dialog_id, MessageId message_id,
                                         Promise<MessageThreadInfo> &&promise) {
  LOG(INFO) << "Get message thread from " << message_id << " in " << dialog_id;
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(400, "Chat not found"));
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_error(Status::Error(400, "Can't access the chat"));
  }
  if (dialog_id.get_type() != DialogType::Channel) {
    return promise.set_error(Status::Error(400, "Chat is not a supergroup or a channel"));
  }
  if (message_id.is_scheduled()) {
    return promise.set_error(Status::Error(400, "Scheduled messages can't have message threads"));
  }

  auto m = get_message_force(d, message_id, "get_message_thread");
  if (m == nullptr) {
    return promise.set_error(Status::Error(400, "Message not found"));
  }

  TRY_RESULT_PROMISE(promise, top_thread_full_message_id, get_top_thread_full_message_id(dialog_id, m));

  auto query_promise =
      PromiseCreator::lambda([actor_id = actor_id(this), dialog_id, message_id,
                              promise = std::move(promise)](Result<vector<FullMessageId>> result) mutable {
        if (result.is_error()) {
          return promise.set_error(result.move_as_error());
        }
        send_closure(actor_id, &MessagesManager::on_get_discussion_message, dialog_id, message_id, result.move_as_ok(),
                     std::move(promise));
      });

  td_->create_handler<GetDiscussionMessageQuery>(std::move(query_promise))
      ->send(dialog_id, message_id, top_thread_full_message_id.get_dialog_id(),
             top_thread_full_message_id.get_message_id());
}

void MessagesManager::process_discussion_message(
    telegram_api::object_ptr<telegram_api::messages_discussionMessage> &&result, DialogId dialog_id,
    MessageId message_id, DialogId expected_dialog_id, MessageId expected_message_id,
    Promise<vector<FullMessageId>> promise) {
  LOG(INFO) << "Receive discussion message for " << message_id << " in " << dialog_id << ": " << to_string(result);
  td_->contacts_manager_->on_get_users(std::move(result->users_), "process_discussion_message");
  td_->contacts_manager_->on_get_chats(std::move(result->chats_), "process_discussion_message");

  for (auto &message : result->messages_) {
    auto message_dialog_id = get_message_dialog_id(message);
    if (message_dialog_id != expected_dialog_id) {
      return promise.set_error(Status::Error(500, "Expected messages in a different chat"));
    }
  }

  for (auto &message : result->messages_) {
    if (need_channel_difference_to_add_message(expected_dialog_id, message)) {
      return run_after_channel_difference(
          expected_dialog_id, PromiseCreator::lambda([actor_id = actor_id(this), result = std::move(result), dialog_id,
                                                      message_id, expected_dialog_id, expected_message_id,
                                                      promise = std::move(promise)](Unit ignored) mutable {
            send_closure(actor_id, &MessagesManager::process_discussion_message_impl, std::move(result), dialog_id,
                         message_id, expected_dialog_id, expected_message_id, std::move(promise));
          }));
    }
  }

  process_discussion_message_impl(std::move(result), dialog_id, message_id, expected_dialog_id, expected_message_id,
                                  std::move(promise));
}

void MessagesManager::process_discussion_message_impl(
    telegram_api::object_ptr<telegram_api::messages_discussionMessage> &&result, DialogId dialog_id,
    MessageId message_id, DialogId expected_dialog_id, MessageId expected_message_id,
    Promise<vector<FullMessageId>> promise) {
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }

  MessageId max_message_id;
  MessageId last_read_inbox_message_id;
  MessageId last_read_outbox_message_id;
  if ((result->flags_ & telegram_api::messages_discussionMessage::MAX_ID_MASK) != 0) {
    max_message_id = MessageId(ServerMessageId(result->max_id_));
  }
  if ((result->flags_ & telegram_api::messages_discussionMessage::READ_INBOX_MAX_ID_MASK) != 0) {
    last_read_inbox_message_id = MessageId(ServerMessageId(result->read_inbox_max_id_));
  }
  if ((result->flags_ & telegram_api::messages_discussionMessage::READ_OUTBOX_MAX_ID_MASK) != 0) {
    last_read_outbox_message_id = MessageId(ServerMessageId(result->read_outbox_max_id_));
  }

  vector<FullMessageId> full_message_ids;
  MessageId top_message_id;
  for (auto &message : result->messages_) {
    auto full_message_id =
        on_get_message(std::move(message), false, true, false, false, false, "process_discussion_message");
    if (full_message_id.get_message_id().is_valid()) {
      full_message_ids.push_back(full_message_id);
      if (full_message_id.get_message_id() == expected_message_id) {
        top_message_id = expected_message_id;
      }
    }
  }
  if (!full_message_ids.empty() && !top_message_id.is_valid()) {
    top_message_id = full_message_ids.back().get_message_id();
  }
  if (top_message_id.is_valid()) {
    on_update_read_message_comments(expected_dialog_id, top_message_id, max_message_id, last_read_inbox_message_id,
                                    last_read_outbox_message_id);
  }
  if (expected_dialog_id != dialog_id) {
    on_update_read_message_comments(dialog_id, message_id, max_message_id, last_read_inbox_message_id,
                                    last_read_outbox_message_id);
  }
  promise.set_value(std::move(full_message_ids));
}

void MessagesManager::on_get_discussion_message(DialogId dialog_id, MessageId message_id,
                                                vector<FullMessageId> full_message_ids,
                                                Promise<MessageThreadInfo> &&promise) {
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  Dialog *d = get_dialog_force(dialog_id);
  CHECK(d != nullptr);

  auto m = get_message_force(d, message_id, "on_get_discussion_message");
  if (m == nullptr) {
    return promise.set_error(Status::Error(400, "Message not found"));
  }
  if (full_message_ids.empty()) {
    return promise.set_error(Status::Error(400, "Message has no thread"));
  }

  DialogId expected_dialog_id;
  if (m->reply_info.is_comment) {
    if (!is_active_message_reply_info(dialog_id, m->reply_info)) {
      return promise.set_error(Status::Error(400, "Message has no comments"));
    }
    expected_dialog_id = DialogId(m->reply_info.channel_id);
  } else {
    if (!m->top_thread_message_id.is_valid()) {
      return promise.set_error(Status::Error(400, "Message has no thread"));
    }
    expected_dialog_id = dialog_id;
  }

  MessageThreadInfo result;
  for (auto full_message_id : full_message_ids) {
    if (full_message_id.get_dialog_id() != expected_dialog_id) {
      return promise.set_error(Status::Error(500, "Expected messages in a different chat"));
    }
    result.message_ids.push_back(full_message_id.get_message_id());
  }
  if (expected_dialog_id != dialog_id && m->reply_info.is_comment && !result.message_ids.empty() &&
      m->linked_top_thread_message_id != result.message_ids.back()) {
    auto linked_d = get_dialog_force(expected_dialog_id);
    CHECK(linked_d != nullptr);
    auto linked_message_id = result.message_ids.back();
    Message *linked_m = get_message_force(linked_d, linked_message_id, "on_get_discussion_message");
    CHECK(linked_m != nullptr && linked_m->message_id.is_server());
    if (linked_m->top_thread_message_id == linked_m->message_id &&
        is_active_message_reply_info(expected_dialog_id, linked_m->reply_info)) {
      if (m->linked_top_thread_message_id.is_valid()) {
        LOG(ERROR) << "Comment message identifier for " << message_id << " in " << dialog_id << " changed from "
                   << m->linked_top_thread_message_id << " to " << linked_message_id;
      }
      m->linked_top_thread_message_id = linked_message_id;
      on_dialog_updated(dialog_id, "on_get_discussion_message");
    }
  }
  result.dialog_id = expected_dialog_id;
  promise.set_value(std::move(result));
}

td_api::object_ptr<td_api::messageThreadInfo> MessagesManager::get_message_thread_info_object(
    const MessageThreadInfo &info) {
  if (info.message_ids.empty()) {
    return nullptr;
  }

  Dialog *d = get_dialog(info.dialog_id);
  CHECK(d != nullptr);
  td_api::object_ptr<td_api::messageReplyInfo> reply_info;
  vector<td_api::object_ptr<td_api::message>> messages;
  messages.reserve(info.message_ids.size());
  for (auto message_id : info.message_ids) {
    const Message *m = get_message_force(d, message_id, "get_message_thread_info_object");
    auto message = get_message_object(d->dialog_id, m);
    if (message != nullptr) {
      if (message->interaction_info_ != nullptr && message->interaction_info_->reply_info_ != nullptr) {
        reply_info = m->reply_info.get_message_reply_info_object(td_->contacts_manager_.get(), this);
        CHECK(reply_info != nullptr);
      }
      messages.push_back(std::move(message));
    }
  }
  if (reply_info == nullptr) {
    return nullptr;
  }

  MessageId top_thread_message_id;
  td_api::object_ptr<td_api::draftMessage> draft_message;
  if (!info.message_ids.empty()) {
    top_thread_message_id = info.message_ids.back();
    if (can_send_message(d->dialog_id).is_ok()) {
      const Message *m = get_message_force(d, top_thread_message_id, "get_message_thread_info_object 2");
      if (m != nullptr && !m->reply_info.is_comment && is_active_message_reply_info(d->dialog_id, m->reply_info)) {
        draft_message = get_draft_message_object(m->thread_draft_message);
      }
    }
  }
  return td_api::make_object<td_api::messageThreadInfo>(d->dialog_id.get(), top_thread_message_id.get(),
                                                        std::move(reply_info), std::move(messages),
                                                        std::move(draft_message));
}

void MessagesManager::get_dialog_info_full(DialogId dialog_id, Promise<Unit> &&promise) {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      send_closure_later(G()->contacts_manager(), &ContactsManager::load_user_full, dialog_id.get_user_id(), false,
                         std::move(promise));
      return;
    case DialogType::Chat:
      send_closure_later(G()->contacts_manager(), &ContactsManager::load_chat_full, dialog_id.get_chat_id(), false,
                         std::move(promise), "get_dialog_info_full");
      return;
    case DialogType::Channel:
      send_closure_later(G()->contacts_manager(), &ContactsManager::load_channel_full, dialog_id.get_channel_id(),
                         false, std::move(promise));
      return;
    case DialogType::SecretChat:
      return promise.set_value(Unit());
    case DialogType::None:
    default:
      UNREACHABLE();
      return promise.set_error(Status::Error(500, "Wrong chat type"));
  }
}

void MessagesManager::reload_dialog_info_full(DialogId dialog_id) {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      send_closure_later(G()->contacts_manager(), &ContactsManager::reload_user_full, dialog_id.get_user_id());
      return;
    case DialogType::Chat:
      send_closure_later(G()->contacts_manager(), &ContactsManager::reload_chat_full, dialog_id.get_chat_id(),
                         Promise<Unit>());
      return;
    case DialogType::Channel:
      send_closure_later(G()->contacts_manager(), &ContactsManager::reload_channel_full, dialog_id.get_channel_id(),
                         Promise<Unit>(), "reload_dialog_info_full");
      return;
    case DialogType::SecretChat:
      return;
    case DialogType::None:
    default:
      UNREACHABLE();
      return;
  }
}

MessageId MessagesManager::get_dialog_pinned_message(DialogId dialog_id, Promise<Unit> &&promise) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(6, "Chat not found"));
    return MessageId();
  }

  LOG(INFO) << "Get pinned message in " << dialog_id << " with "
            << (d->is_last_pinned_message_id_inited ? "inited" : "unknown") << " pinned " << d->last_pinned_message_id;

  if (!d->is_last_pinned_message_id_inited) {
    get_dialog_info_full(dialog_id, std::move(promise));
    return MessageId();
  }

  get_dialog_info_full(dialog_id, Auto());

  if (d->last_pinned_message_id.is_valid()) {
    tl_object_ptr<telegram_api::InputMessage> input_message;
    if (dialog_id.get_type() == DialogType::Channel) {
      input_message = make_tl_object<telegram_api::inputMessagePinned>();
    }
    get_message_force_from_server(d, d->last_pinned_message_id, std::move(promise), std::move(input_message));
  } else {
    promise.set_value(Unit());
  }

  return d->last_pinned_message_id;
}

void MessagesManager::get_callback_query_message(DialogId dialog_id, MessageId message_id, int64 callback_query_id,
                                                 Promise<Unit> &&promise) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(6, "Chat not found"));
  }
  if (!message_id.is_valid() || !message_id.is_server()) {
    return promise.set_error(Status::Error(6, "Invalid message identifier specified"));
  }

  LOG(INFO) << "Get callback query " << message_id << " in " << dialog_id << " for query " << callback_query_id;

  auto input_message = make_tl_object<telegram_api::inputMessageCallbackQuery>(message_id.get_server_message_id().get(),
                                                                               callback_query_id);
  get_message_force_from_server(d, message_id, std::move(promise), std::move(input_message));
}

bool MessagesManager::get_messages(DialogId dialog_id, const vector<MessageId> &message_ids, Promise<Unit> &&promise) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(6, "Chat not found"));
    return false;
  }

  bool is_secret = dialog_id.get_type() == DialogType::SecretChat;
  vector<FullMessageId> missed_message_ids;
  for (auto message_id : message_ids) {
    if (!message_id.is_valid() && !message_id.is_valid_scheduled()) {
      promise.set_error(Status::Error(6, "Invalid message identifier"));
      return false;
    }

    auto *m = get_message_force(d, message_id, "get_messages");
    if (m == nullptr && message_id.is_any_server() && !is_secret) {
      missed_message_ids.emplace_back(dialog_id, message_id);
      continue;
    }
  }

  if (!missed_message_ids.empty()) {
    get_messages_from_server(std::move(missed_message_ids), std::move(promise));
    return false;
  }

  promise.set_value(Unit());
  return true;
}

void MessagesManager::get_message_from_server(FullMessageId full_message_id, Promise<Unit> &&promise,
                                              tl_object_ptr<telegram_api::InputMessage> input_message) {
  get_messages_from_server({full_message_id}, std::move(promise), std::move(input_message));
}

void MessagesManager::get_messages_from_server(vector<FullMessageId> &&message_ids, Promise<Unit> &&promise,
                                               tl_object_ptr<telegram_api::InputMessage> input_message) {
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  if (message_ids.empty()) {
    LOG(ERROR) << "Empty message_ids";
    return promise.set_error(Status::Error(500, "There are no messages specified to fetch"));
  }

  if (input_message != nullptr) {
    CHECK(message_ids.size() == 1);
  }

  vector<tl_object_ptr<telegram_api::InputMessage>> ordinary_message_ids;
  std::unordered_map<ChannelId, vector<tl_object_ptr<telegram_api::InputMessage>>, ChannelIdHash> channel_message_ids;
  std::unordered_map<DialogId, vector<int32>, DialogIdHash> scheduled_message_ids;
  for (auto &full_message_id : message_ids) {
    auto dialog_id = full_message_id.get_dialog_id();
    auto message_id = full_message_id.get_message_id();
    if (!message_id.is_valid() || !message_id.is_server()) {
      if (message_id.is_valid_scheduled() && message_id.is_scheduled_server()) {
        scheduled_message_ids[dialog_id].push_back(message_id.get_scheduled_server_message_id().get());
      }
      continue;
    }

    if (input_message == nullptr) {
      input_message = make_tl_object<telegram_api::inputMessageID>(message_id.get_server_message_id().get());
    }

    switch (dialog_id.get_type()) {
      case DialogType::User:
      case DialogType::Chat:
        ordinary_message_ids.push_back(std::move(input_message));
        break;
      case DialogType::Channel:
        channel_message_ids[dialog_id.get_channel_id()].push_back(std::move(input_message));
        break;
      case DialogType::SecretChat:
        LOG(ERROR) << "Can't get secret chat message from server";
        break;
      case DialogType::None:
      default:
        UNREACHABLE();
        break;
    }
  }

  MultiPromiseActorSafe mpas{"GetMessagesFromServerMultiPromiseActor"};
  mpas.add_promise(std::move(promise));
  auto lock = mpas.get_promise();

  if (!ordinary_message_ids.empty()) {
    td_->create_handler<GetMessagesQuery>(mpas.get_promise())->send(std::move(ordinary_message_ids));
  }

  for (auto &it : scheduled_message_ids) {
    auto dialog_id = it.first;
    have_dialog_force(dialog_id);
    auto input_peer = get_input_peer(dialog_id, AccessRights::Read);
    if (input_peer == nullptr) {
      LOG(ERROR) << "Can't find info about " << dialog_id << " to get a message from it";
      mpas.get_promise().set_error(Status::Error(6, "Can't access the chat"));
      continue;
    }
    td_->create_handler<GetScheduledMessagesQuery>(mpas.get_promise())
        ->send(dialog_id, std::move(input_peer), std::move(it.second));
  }

  for (auto &it : channel_message_ids) {
    td_->contacts_manager_->have_channel_force(it.first);
    auto input_channel = td_->contacts_manager_->get_input_channel(it.first);
    if (input_channel == nullptr) {
      LOG(ERROR) << "Can't find info about " << it.first << " to get a message from it";
      mpas.get_promise().set_error(Status::Error(6, "Can't access the chat"));
      continue;
    }
    td_->create_handler<GetChannelMessagesQuery>(mpas.get_promise())
        ->send(it.first, std::move(input_channel), std::move(it.second));
  }
  lock.set_value(Unit());
}

bool MessagesManager::is_message_edited_recently(FullMessageId full_message_id, int32 seconds) {
  if (seconds < 0) {
    return false;
  }
  if (!full_message_id.get_message_id().is_valid()) {
    return false;
  }

  auto m = get_message_force(full_message_id, "is_message_edited_recently");
  if (m == nullptr) {
    return true;
  }

  return m->edit_date >= G()->unix_time() - seconds;
}

Result<std::pair<string, bool>> MessagesManager::get_message_link(FullMessageId full_message_id, bool for_group,
                                                                  bool for_comment) {
  auto dialog_id = full_message_id.get_dialog_id();
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(400, "Chat not found");
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return Status::Error(400, "Can't access the chat");
  }
  if (dialog_id.get_type() != DialogType::Channel) {
    return Status::Error(400, "Public message links are available only for messages in supergroups and channel chats");
  }

  auto *m = get_message_force(d, full_message_id.get_message_id(), "get_message_link");
  if (m == nullptr) {
    return Status::Error(400, "Message not found");
  }
  if (m->message_id.is_yet_unsent()) {
    return Status::Error(400, "Message is not sent yet");
  }
  if (m->message_id.is_scheduled()) {
    return Status::Error(400, "Message is scheduled");
  }
  if (!m->message_id.is_server()) {
    return Status::Error(400, "Message is local");
  }

  if (m->media_album_id == 0) {
    for_group = true;  // default is true
  }

  if (!m->top_thread_message_id.is_valid() || !m->top_thread_message_id.is_server()) {
    for_comment = false;
  }
  if (d->deleted_message_ids.count(m->top_thread_message_id) != 0) {
    for_comment = false;
  }
  if (for_comment && is_broadcast_channel(dialog_id)) {
    for_comment = false;
  }

  td_->create_handler<ExportChannelMessageLinkQuery>(Promise<Unit>())
      ->send(dialog_id.get_channel_id(), m->message_id, for_group, true);

  auto t_me = G()->shared_config().get_option_string("t_me_url", "https://t.me/");
  if (for_comment) {
    auto *top_m = get_message_force(d, m->top_thread_message_id, "get_public_message_link");
    if (is_discussion_message(dialog_id, top_m) && is_active_message_reply_info(dialog_id, top_m->reply_info)) {
      auto linked_dialog_id = top_m->forward_info->from_dialog_id;
      auto linked_message_id = top_m->forward_info->from_message_id;
      auto linked_d = get_dialog(linked_dialog_id);
      CHECK(linked_d != nullptr);
      CHECK(linked_dialog_id.get_type() == DialogType::Channel);
      auto *linked_m = get_message_force(linked_d, linked_message_id, "get_public_message_link");
      auto channel_username = td_->contacts_manager_->get_channel_username(linked_dialog_id.get_channel_id());
      if (linked_m != nullptr && is_active_message_reply_info(linked_dialog_id, linked_m->reply_info) &&
          linked_message_id.is_server() && have_input_peer(linked_dialog_id, AccessRights::Read) &&
          !channel_username.empty()) {
        return std::make_pair(
            PSTRING() << t_me << channel_username << '/' << linked_message_id.get_server_message_id().get()
                      << "?comment=" << m->message_id.get_server_message_id().get() << (for_group ? "" : "&single"),
            true);
      }
    }
  }

  auto dialog_username = td_->contacts_manager_->get_channel_username(dialog_id.get_channel_id());
  if (m->content->get_type() == MessageContentType::VideoNote && is_broadcast_channel(dialog_id) &&
      !dialog_username.empty()) {
    return std::make_pair(
        PSTRING() << "https://telesco.pe/" << dialog_username << '/' << m->message_id.get_server_message_id().get(),
        true);
  }

  string args;
  if (for_comment) {
    args = PSTRING() << "?thread=" << m->top_thread_message_id.get_server_message_id().get();
  }
  if (!for_group) {
    args += args.empty() ? '?' : '&';
    args += "single";
  }

  bool is_public = !dialog_username.empty();
  if (!is_public) {
    dialog_username = PSTRING() << "c/" << dialog_id.get_channel_id().get();
  }
  return std::make_pair(PSTRING() << G()->shared_config().get_option_string("t_me_url", "https://t.me/")
                                  << dialog_username << '/' << m->message_id.get_server_message_id().get() << args,
                        is_public);
}

string MessagesManager::get_message_embedding_code(FullMessageId full_message_id, bool for_group,
                                                   Promise<Unit> &&promise) {
  auto dialog_id = full_message_id.get_dialog_id();
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(400, "Chat not found"));
    return {};
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    promise.set_error(Status::Error(400, "Can't access the chat"));
    return {};
  }
  if (dialog_id.get_type() != DialogType::Channel ||
      td_->contacts_manager_->get_channel_username(dialog_id.get_channel_id()).empty()) {
    promise.set_error(Status::Error(
        400, "Message embedding code is available only for messages in public supergroups and channel chats"));
    return {};
  }

  auto *m = get_message_force(d, full_message_id.get_message_id(), "get_message_embedding_code");
  if (m == nullptr) {
    promise.set_error(Status::Error(400, "Message not found"));
    return {};
  }
  if (m->message_id.is_yet_unsent()) {
    promise.set_error(Status::Error(400, "Message is not sent yet"));
    return {};
  }
  if (m->message_id.is_scheduled()) {
    promise.set_error(Status::Error(400, "Message is scheduled"));
    return {};
  }
  if (!m->message_id.is_server()) {
    promise.set_error(Status::Error(400, "Message is local"));
    return {};
  }

  if (m->media_album_id == 0) {
    for_group = true;  // default is true
  }

  auto &links = public_message_links_[for_group][dialog_id].links_;
  auto it = links.find(m->message_id);
  if (it == links.end()) {
    td_->create_handler<ExportChannelMessageLinkQuery>(std::move(promise))
        ->send(dialog_id.get_channel_id(), m->message_id, for_group, false);
    return {};
  }

  promise.set_value(Unit());
  return it->second.second;
}

void MessagesManager::on_get_public_message_link(FullMessageId full_message_id, bool for_group, string url,
                                                 string html) {
  LOG_IF(ERROR, url.empty() && html.empty()) << "Receive empty public link for " << full_message_id;
  public_message_links_[for_group][full_message_id.get_dialog_id()].links_[full_message_id.get_message_id()] = {
      std::move(url), std::move(html)};
}

Result<MessagesManager::MessageLinkInfo> MessagesManager::get_message_link_info(Slice url) {
  if (url.empty()) {
    return Status::Error("URL must be non-empty");
  }

  url.truncate(url.find('#'));

  string lower_cased_url = to_lower(url);
  url = lower_cased_url;

  Slice username;
  Slice channel_id_slice;
  Slice message_id_slice;
  Slice comment_message_id_slice = "0";
  bool is_single = false;
  bool for_comment = false;
  if (begins_with(url, "tg:")) {
    url = url.substr(3);
    if (begins_with(url, "//")) {
      url = url.substr(2);
    }

    // resolve?domain=username&post=12345&single
    // privatepost?channel=123456789&msg_id=12345

    bool is_resolve = false;
    if (begins_with(url, "resolve")) {
      url = url.substr(7);
      is_resolve = true;
    } else if (begins_with(url, "privatepost")) {
      url = url.substr(11);
    } else {
      return Status::Error("Wrong message link URL");
    }

    if (begins_with(url, "/")) {
      url = url.substr(1);
    }
    if (!begins_with(url, "?")) {
      return Status::Error("Wrong message link URL");
    }
    url = url.substr(1);

    auto args = full_split(url, '&');
    for (auto arg : args) {
      auto key_value = split(arg, '=');
      if (is_resolve) {
        if (key_value.first == "domain") {
          username = key_value.second;
        }
        if (key_value.first == "post") {
          message_id_slice = key_value.second;
        }
      } else {
        if (key_value.first == "channel") {
          channel_id_slice = key_value.second;
        }
        if (key_value.first == "msg_id") {
          message_id_slice = key_value.second;
        }
      }
      if (key_value.first == "single") {
        is_single = true;
      }
      if (key_value.first == "comment") {
        comment_message_id_slice = key_value.second;
      }
      if (key_value.first == "thread") {
        for_comment = true;
      }
    }
  } else {
    if (begins_with(url, "http://") || begins_with(url, "https://")) {
      url = url.substr(url[4] == 's' ? 8 : 7);
    }

    // t.me/c/123456789/12345
    // t.me/username/12345?single

    vector<Slice> t_me_urls{Slice("t.me/"), Slice("telegram.me/"), Slice("telegram.dog/")};
    string cur_t_me_url = G()->shared_config().get_option_string("t_me_url");
    if (begins_with(cur_t_me_url, "http://") || begins_with(cur_t_me_url, "https://")) {
      Slice t_me_url = cur_t_me_url;
      t_me_url = t_me_url.substr(url[4] == 's' ? 8 : 7);
      if (!td::contains(t_me_urls, t_me_url)) {
        t_me_urls.push_back(t_me_url);
      }
    }

    for (auto t_me_url : t_me_urls) {
      if (begins_with(url, t_me_url)) {
        url = url.substr(t_me_url.size());
        auto username_end_pos = url.find('/');
        if (username_end_pos == Slice::npos) {
          return Status::Error("Wrong message link URL");
        }
        username = url.substr(0, username_end_pos);
        url = url.substr(username_end_pos + 1);
        if (username == "c") {
          username = Slice();
          auto channel_id_end_pos = url.find('/');
          if (channel_id_end_pos == Slice::npos) {
            return Status::Error("Wrong message link URL");
          }
          channel_id_slice = url.substr(0, channel_id_end_pos);
          url = url.substr(channel_id_end_pos + 1);
        }

        auto query_pos = url.find('?');
        message_id_slice = url.substr(0, query_pos);
        if (query_pos != Slice::npos) {
          auto args = full_split(url.substr(query_pos + 1), '&');
          for (auto arg : args) {
            auto key_value = split(arg, '=');
            if (key_value.first == "single") {
              is_single = true;
            }
            if (key_value.first == "comment") {
              comment_message_id_slice = key_value.second;
            }
            if (key_value.first == "thread") {
              for_comment = true;
            }
          }
        }
        break;
      }
    }
  }

  ChannelId channel_id;
  if (username.empty()) {
    auto r_channel_id = to_integer_safe<int32>(channel_id_slice);
    if (r_channel_id.is_error() || !ChannelId(r_channel_id.ok()).is_valid()) {
      return Status::Error("Wrong channel ID");
    }
    channel_id = ChannelId(r_channel_id.ok());
  }

  auto r_message_id = to_integer_safe<int32>(message_id_slice);
  if (r_message_id.is_error() || !ServerMessageId(r_message_id.ok()).is_valid()) {
    return Status::Error("Wrong message ID");
  }

  auto r_comment_message_id = to_integer_safe<int32>(comment_message_id_slice);
  if (r_comment_message_id.is_error() ||
      !(r_comment_message_id.ok() == 0 || ServerMessageId(r_comment_message_id.ok()).is_valid())) {
    return Status::Error("Wrong comment message ID");
  }

  MessageLinkInfo info;
  info.username = username.str();
  info.channel_id = channel_id;
  info.message_id = MessageId(ServerMessageId(r_message_id.ok()));
  info.comment_message_id = MessageId(ServerMessageId(r_comment_message_id.ok()));
  info.is_single = is_single;
  info.for_comment = for_comment;
  LOG(INFO) << "Have link to " << info.message_id << " in chat @" << info.username << "/" << channel_id.get();
  return std::move(info);
}

void MessagesManager::get_message_link_info(Slice url, Promise<MessageLinkInfo> &&promise) {
  auto r_message_link_info = get_message_link_info(url);
  if (r_message_link_info.is_error()) {
    return promise.set_error(Status::Error(400, r_message_link_info.error().message()));
  }

  auto info = r_message_link_info.move_as_ok();
  CHECK(info.username.empty() == info.channel_id.is_valid());

  bool have_dialog = info.username.empty() ? td_->contacts_manager_->have_channel_force(info.channel_id)
                                           : resolve_dialog_username(info.username).is_valid();
  if (!have_dialog) {
    auto query_promise = PromiseCreator::lambda(
        [actor_id = actor_id(this), info, promise = std::move(promise)](Result<Unit> &&result) mutable {
          if (result.is_error()) {
            return promise.set_value(std::move(info));
          }
          send_closure(actor_id, &MessagesManager::on_get_message_link_dialog, std::move(info), std::move(promise));
        });
    if (info.username.empty()) {
      td_->contacts_manager_->reload_channel(info.channel_id, std::move(query_promise));
    } else {
      td_->create_handler<ResolveUsernameQuery>(std::move(query_promise))->send(info.username);
    }
    return;
  }

  return on_get_message_link_dialog(std::move(info), std::move(promise));
}

void MessagesManager::on_get_message_link_dialog(MessageLinkInfo &&info, Promise<MessageLinkInfo> &&promise) {
  DialogId dialog_id;
  if (info.username.empty()) {
    if (!td_->contacts_manager_->have_channel(info.channel_id)) {
      return promise.set_error(Status::Error(500, "Chat info not found"));
    }

    dialog_id = DialogId(info.channel_id);
    force_create_dialog(dialog_id, "on_get_message_link_dialog");
  } else {
    dialog_id = resolve_dialog_username(info.username);
    if (dialog_id.is_valid()) {
      force_create_dialog(dialog_id, "on_get_message_link_dialog", true);
    }
  }
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(500, "Chat not found"));
  }

  get_message_force_from_server(d, info.message_id,
                                PromiseCreator::lambda([actor_id = actor_id(this), info = std::move(info), dialog_id,
                                                        promise = std::move(promise)](Result<Unit> &&result) mutable {
                                  if (result.is_error()) {
                                    return promise.set_value(std::move(info));
                                  }
                                  send_closure(actor_id, &MessagesManager::on_get_message_link_message, std::move(info),
                                               dialog_id, std::move(promise));
                                }));
}

void MessagesManager::on_get_message_link_message(MessageLinkInfo &&info, DialogId dialog_id,
                                                  Promise<MessageLinkInfo> &&promise) {
  Message *m = get_message_force({dialog_id, info.message_id}, "on_get_message_link_message");
  if (info.comment_message_id == MessageId() || m == nullptr || !is_broadcast_channel(dialog_id) ||
      !m->reply_info.is_comment || !is_active_message_reply_info(dialog_id, m->reply_info)) {
    return promise.set_value(std::move(info));
  }

  if (td_->contacts_manager_->have_channel_force(m->reply_info.channel_id)) {
    force_create_dialog(DialogId(m->reply_info.channel_id), "on_get_message_link_message");
    on_get_message_link_discussion_message(std::move(info), DialogId(m->reply_info.channel_id), std::move(promise));
    return;
  }

  auto query_promise =
      PromiseCreator::lambda([actor_id = actor_id(this), info = std::move(info),
                              promise = std::move(promise)](Result<vector<FullMessageId>> result) mutable {
        if (result.is_error() || result.ok().empty()) {
          return promise.set_value(std::move(info));
        }
        send_closure(actor_id, &MessagesManager::on_get_message_link_discussion_message, std::move(info),
                     result.ok()[0].get_dialog_id(), std::move(promise));
      });

  td_->create_handler<GetDiscussionMessageQuery>(std::move(query_promise))
      ->send(dialog_id, info.message_id, DialogId(m->reply_info.channel_id), MessageId());
}

void MessagesManager::on_get_message_link_discussion_message(MessageLinkInfo &&info, DialogId comment_dialog_id,
                                                             Promise<MessageLinkInfo> &&promise) {
  CHECK(comment_dialog_id.is_valid());
  info.comment_dialog_id = comment_dialog_id;

  Dialog *d = get_dialog_force(comment_dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(500, "Chat not found"));
  }

  get_message_force_from_server(
      d, info.comment_message_id,
      PromiseCreator::lambda([info = std::move(info), promise = std::move(promise)](Result<Unit> &&result) mutable {
        return promise.set_value(std::move(info));
      }));
}

td_api::object_ptr<td_api::messageLinkInfo> MessagesManager::get_message_link_info_object(
    const MessageLinkInfo &info) const {
  CHECK(info.username.empty() == info.channel_id.is_valid());

  bool is_public = !info.username.empty();
  DialogId dialog_id = info.comment_dialog_id.is_valid()
                           ? info.comment_dialog_id
                           : (is_public ? resolve_dialog_username(info.username) : DialogId(info.channel_id));
  MessageId message_id = info.comment_dialog_id.is_valid() ? info.comment_message_id : info.message_id;
  td_api::object_ptr<td_api::message> message;
  bool for_album = false;
  bool for_comment = false;

  const Dialog *d = get_dialog(dialog_id);
  if (d == nullptr) {
    dialog_id = DialogId();
  } else {
    const Message *m = get_message(d, message_id);
    if (m != nullptr) {
      message = get_message_object(dialog_id, m);
      for_album = !info.is_single && m->media_album_id != 0;
      for_comment = (info.comment_dialog_id.is_valid() || info.for_comment) && m->top_thread_message_id.is_valid();
    }
  }

  return td_api::make_object<td_api::messageLinkInfo>(is_public, dialog_id.get(), std::move(message), for_album,
                                                      for_comment);
}

InputDialogId MessagesManager::get_input_dialog_id(DialogId dialog_id) const {
  auto input_peer = get_input_peer(dialog_id, AccessRights::Read);
  if (input_peer == nullptr || input_peer->get_id() == telegram_api::inputPeerSelf::ID) {
    return InputDialogId(dialog_id);
  } else {
    return InputDialogId(input_peer);
  }
}

void MessagesManager::sort_dialog_filter_input_dialog_ids(DialogFilter *dialog_filter) const {
  auto sort_input_dialog_ids = [contacts_manager =
                                    td_->contacts_manager_.get()](vector<InputDialogId> &input_dialog_ids) {
    std::sort(input_dialog_ids.begin(), input_dialog_ids.end(),
              [contacts_manager](InputDialogId lhs, InputDialogId rhs) {
                auto get_order = [contacts_manager](InputDialogId input_dialog_id) {
                  auto dialog_id = input_dialog_id.get_dialog_id();
                  if (dialog_id.get_type() != DialogType::SecretChat) {
                    return dialog_id.get() * 10;
                  }
                  auto user_id = contacts_manager->get_secret_chat_user_id(dialog_id.get_secret_chat_id());
                  return DialogId(user_id).get() * 10 + 1;
                };
                return get_order(lhs) < get_order(rhs);
              });
  };

  if (!dialog_filter->include_contacts && !dialog_filter->include_non_contacts && !dialog_filter->include_bots &&
      !dialog_filter->include_groups && !dialog_filter->include_channels) {
    dialog_filter->excluded_dialog_ids.clear();
  }

  sort_input_dialog_ids(dialog_filter->excluded_dialog_ids);
  sort_input_dialog_ids(dialog_filter->included_dialog_ids);

  std::unordered_set<DialogId, DialogIdHash> all_dialog_ids;
  for (auto input_dialog_ids :
       {&dialog_filter->pinned_dialog_ids, &dialog_filter->excluded_dialog_ids, &dialog_filter->included_dialog_ids}) {
    for (auto input_dialog_id : *input_dialog_ids) {
      CHECK(all_dialog_ids.insert(input_dialog_id.get_dialog_id()).second);
    }
  }
}

Result<unique_ptr<DialogFilter>> MessagesManager::create_dialog_filter(DialogFilterId dialog_filter_id,
                                                                       td_api::object_ptr<td_api::chatFilter> filter) {
  CHECK(filter != nullptr);
  for (auto chat_ids : {&filter->pinned_chat_ids_, &filter->excluded_chat_ids_, &filter->included_chat_ids_}) {
    for (auto chat_id : *chat_ids) {
      DialogId dialog_id(chat_id);
      if (!dialog_id.is_valid()) {
        return Status::Error(400, "Invalid chat identifier specified");
      }
      const Dialog *d = get_dialog_force(dialog_id);
      if (d == nullptr) {
        return Status::Error(400, "Chat not found");
      }
      if (!have_input_peer(dialog_id, AccessRights::Read)) {
        return Status::Error(6, "Can't access the chat");
      }
      if (d->order == DEFAULT_ORDER) {
        return Status::Error(400, "Chat is not in the chat list");
      }
    }
  }

  auto dialog_filter = make_unique<DialogFilter>();
  dialog_filter->dialog_filter_id = dialog_filter_id;

  std::unordered_set<int64> added_dialog_ids;
  auto add_chats = [this, &added_dialog_ids](vector<InputDialogId> &input_dialog_ids, const vector<int64> &chat_ids) {
    for (auto &chat_id : chat_ids) {
      if (!added_dialog_ids.insert(chat_id).second) {
        // do not allow duplicate chat_ids
        continue;
      }

      input_dialog_ids.push_back(get_input_dialog_id(DialogId(chat_id)));
    }
  };
  add_chats(dialog_filter->pinned_dialog_ids, filter->pinned_chat_ids_);
  add_chats(dialog_filter->included_dialog_ids, filter->included_chat_ids_);
  add_chats(dialog_filter->excluded_dialog_ids, filter->excluded_chat_ids_);

  dialog_filter->title = clean_name(std::move(filter->title_), MAX_DIALOG_FILTER_TITLE_LENGTH);
  if (dialog_filter->title.empty()) {
    return Status::Error(400, "Title must be non-empty");
  }
  dialog_filter->emoji = DialogFilter::get_emoji_by_icon_name(filter->icon_name_);
  if (dialog_filter->emoji.empty() && !filter->icon_name_.empty()) {
    return Status::Error(400, "Invalid icon name specified");
  }
  dialog_filter->exclude_muted = filter->exclude_muted_;
  dialog_filter->exclude_read = filter->exclude_read_;
  dialog_filter->exclude_archived = filter->exclude_archived_;
  dialog_filter->include_contacts = filter->include_contacts_;
  dialog_filter->include_non_contacts = filter->include_non_contacts_;
  dialog_filter->include_bots = filter->include_bots_;
  dialog_filter->include_groups = filter->include_groups_;
  dialog_filter->include_channels = filter->include_channels_;

  TRY_STATUS(dialog_filter->check_limits());
  sort_dialog_filter_input_dialog_ids(dialog_filter.get());

  return std::move(dialog_filter);
}

void MessagesManager::create_dialog_filter(td_api::object_ptr<td_api::chatFilter> filter,
                                           Promise<td_api::object_ptr<td_api::chatFilterInfo>> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  if (dialog_filters_.size() >= MAX_DIALOG_FILTERS) {
    return promise.set_error(Status::Error(400, "Maximum number of chat folders exceeded"));
  }
  if (!is_update_chat_filters_sent_) {
    return promise.set_error(Status::Error(400, "Chat folders are not synchronized yet"));
  }

  DialogFilterId dialog_filter_id;
  do {
    auto min_id = static_cast<int>(DialogFilterId::min().get());
    auto max_id = static_cast<int>(DialogFilterId::max().get());
    dialog_filter_id = DialogFilterId(static_cast<int32>(Random::fast(min_id, max_id)));
  } while (get_dialog_filter(dialog_filter_id) != nullptr || get_server_dialog_filter(dialog_filter_id) != nullptr);

  auto r_dialog_filter = create_dialog_filter(dialog_filter_id, std::move(filter));
  if (r_dialog_filter.is_error()) {
    return promise.set_error(r_dialog_filter.move_as_error());
  }
  auto dialog_filter = r_dialog_filter.move_as_ok();
  CHECK(dialog_filter != nullptr);
  auto chat_filter_info = dialog_filter->get_chat_filter_info_object();

  bool at_beginning = false;
  for (auto &recommended_dialog_filter : recommended_dialog_filters_) {
    if (DialogFilter::are_similar(*recommended_dialog_filter.dialog_filter, *dialog_filter)) {
      at_beginning = true;
    }
  }

  add_dialog_filter(std::move(dialog_filter), at_beginning, "create_dialog_filter");
  save_dialog_filters();
  send_update_chat_filters();

  synchronize_dialog_filters();
  promise.set_value(std::move(chat_filter_info));
}

void MessagesManager::edit_dialog_filter(DialogFilterId dialog_filter_id, td_api::object_ptr<td_api::chatFilter> filter,
                                         Promise<td_api::object_ptr<td_api::chatFilterInfo>> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  auto old_dialog_filter = get_dialog_filter(dialog_filter_id);
  if (old_dialog_filter == nullptr) {
    return promise.set_error(Status::Error(400, "Chat filter not found"));
  }
  CHECK(is_update_chat_filters_sent_);

  auto r_dialog_filter = create_dialog_filter(dialog_filter_id, std::move(filter));
  if (r_dialog_filter.is_error()) {
    return promise.set_error(r_dialog_filter.move_as_error());
  }
  auto new_dialog_filter = r_dialog_filter.move_as_ok();
  CHECK(new_dialog_filter != nullptr);
  auto chat_filter_info = new_dialog_filter->get_chat_filter_info_object();

  if (*new_dialog_filter == *old_dialog_filter) {
    return promise.set_value(std::move(chat_filter_info));
  }

  edit_dialog_filter(std::move(new_dialog_filter), "edit_dialog_filter");
  save_dialog_filters();
  send_update_chat_filters();

  synchronize_dialog_filters();
  promise.set_value(std::move(chat_filter_info));
}

void MessagesManager::update_dialog_filter_on_server(unique_ptr<DialogFilter> &&dialog_filter) {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(dialog_filter != nullptr);
  are_dialog_filters_being_synchronized_ = true;
  dialog_filter->remove_secret_chat_dialog_ids();
  auto dialog_filter_id = dialog_filter->dialog_filter_id;
  auto input_dialog_filter = dialog_filter->get_input_dialog_filter();

  auto promise = PromiseCreator::lambda(
      [actor_id = actor_id(this), dialog_filter = std::move(dialog_filter)](Result<Unit> result) mutable {
        send_closure(actor_id, &MessagesManager::on_update_dialog_filter, std::move(dialog_filter),
                     result.is_error() ? result.move_as_error() : Status::OK());
      });
  td_->create_handler<UpdateDialogFilterQuery>(std::move(promise))
      ->send(dialog_filter_id, std::move(input_dialog_filter));
}

void MessagesManager::on_update_dialog_filter(unique_ptr<DialogFilter> dialog_filter, Status result) {
  CHECK(!td_->auth_manager_->is_bot());
  if (result.is_error()) {
    // TODO rollback dialog_filters_ changes if error isn't 429
  } else {
    bool is_edited = false;
    for (auto &filter : server_dialog_filters_) {
      if (filter->dialog_filter_id == dialog_filter->dialog_filter_id) {
        if (*filter != *dialog_filter) {
          filter = std::move(dialog_filter);
        }
        is_edited = true;
        break;
      }
    }

    if (!is_edited) {
      server_dialog_filters_.push_back(std::move(dialog_filter));
    }
    save_dialog_filters();
  }

  are_dialog_filters_being_synchronized_ = false;
  synchronize_dialog_filters();
}

void MessagesManager::delete_dialog_filter(DialogFilterId dialog_filter_id, Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  auto dialog_filter = get_dialog_filter(dialog_filter_id);
  if (dialog_filter == nullptr) {
    return promise.set_value(Unit());
  }

  delete_dialog_filter(dialog_filter_id, "delete_dialog_filter");
  save_dialog_filters();
  send_update_chat_filters();

  synchronize_dialog_filters();
  promise.set_value(Unit());
}

void MessagesManager::delete_dialog_filter_on_server(DialogFilterId dialog_filter_id) {
  CHECK(!td_->auth_manager_->is_bot());
  are_dialog_filters_being_synchronized_ = true;
  auto promise = PromiseCreator::lambda([actor_id = actor_id(this), dialog_filter_id](Result<Unit> result) {
    send_closure(actor_id, &MessagesManager::on_delete_dialog_filter, dialog_filter_id,
                 result.is_error() ? result.move_as_error() : Status::OK());
  });
  td_->create_handler<UpdateDialogFilterQuery>(std::move(promise))->send(dialog_filter_id, nullptr);
}

void MessagesManager::on_delete_dialog_filter(DialogFilterId dialog_filter_id, Status result) {
  CHECK(!td_->auth_manager_->is_bot());
  if (result.is_error()) {
    // TODO rollback dialog_filters_ changes if error isn't 429
  } else {
    for (auto it = server_dialog_filters_.begin(); it != server_dialog_filters_.end(); ++it) {
      if ((*it)->dialog_filter_id == dialog_filter_id) {
        server_dialog_filters_.erase(it);
        save_dialog_filters();
        break;
      }
    }
  }

  are_dialog_filters_being_synchronized_ = false;
  synchronize_dialog_filters();
}

void MessagesManager::reorder_dialog_filters(vector<DialogFilterId> dialog_filter_ids, Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());

  for (auto dialog_filter_id : dialog_filter_ids) {
    auto dialog_filter = get_dialog_filter(dialog_filter_id);
    if (dialog_filter == nullptr) {
      return promise.set_error(Status::Error(6, "Chat filter not found"));
    }
  }
  std::unordered_set<DialogFilterId, DialogFilterIdHash> new_dialog_filter_ids_set(dialog_filter_ids.begin(),
                                                                                   dialog_filter_ids.end());
  if (new_dialog_filter_ids_set.size() != dialog_filter_ids.size()) {
    return promise.set_error(Status::Error(400, "Duplicate chat filters in the new list"));
  }

  if (set_dialog_filters_order(dialog_filters_, dialog_filter_ids)) {
    save_dialog_filters();
    send_update_chat_filters();

    synchronize_dialog_filters();
  }
  promise.set_value(Unit());
}

void MessagesManager::reorder_dialog_filters_on_server(vector<DialogFilterId> dialog_filter_ids) {
  CHECK(!td_->auth_manager_->is_bot());
  are_dialog_filters_being_synchronized_ = true;
  auto promise = PromiseCreator::lambda([actor_id = actor_id(this), dialog_filter_ids](Result<Unit> result) mutable {
    send_closure(actor_id, &MessagesManager::on_reorder_dialog_filters, std::move(dialog_filter_ids),
                 result.is_error() ? result.move_as_error() : Status::OK());
  });
  td_->create_handler<UpdateDialogFiltersOrderQuery>(std::move(promise))->send(std::move(dialog_filter_ids));
}

void MessagesManager::on_reorder_dialog_filters(vector<DialogFilterId> dialog_filter_ids, Status result) {
  CHECK(!td_->auth_manager_->is_bot());
  if (result.is_error()) {
    // TODO rollback dialog_filters_ changes if error isn't 429
  } else {
    if (set_dialog_filters_order(server_dialog_filters_, dialog_filter_ids)) {
      save_dialog_filters();
    }
  }

  are_dialog_filters_being_synchronized_ = false;
  synchronize_dialog_filters();
}

bool MessagesManager::set_dialog_filters_order(vector<unique_ptr<DialogFilter>> &dialog_filters,
                                               vector<DialogFilterId> dialog_filter_ids) {
  auto old_dialog_filter_ids = get_dialog_filter_ids(dialog_filters);
  if (old_dialog_filter_ids == dialog_filter_ids) {
    return false;
  }
  LOG(INFO) << "Reorder chat filters from " << old_dialog_filter_ids << " to " << dialog_filter_ids;

  if (dialog_filter_ids.size() != old_dialog_filter_ids.size()) {
    for (auto dialog_filter_id : old_dialog_filter_ids) {
      if (!td::contains(dialog_filter_ids, dialog_filter_id)) {
        dialog_filter_ids.push_back(dialog_filter_id);
      }
    }
    CHECK(dialog_filter_ids.size() == old_dialog_filter_ids.size());
  }
  if (old_dialog_filter_ids == dialog_filter_ids) {
    return false;
  }

  CHECK(dialog_filter_ids.size() == dialog_filters.size());
  for (size_t i = 0; i < dialog_filters.size(); i++) {
    for (size_t j = i; j < dialog_filters.size(); j++) {
      if (dialog_filters[j]->dialog_filter_id == dialog_filter_ids[i]) {
        if (i != j) {
          std::swap(dialog_filters[i], dialog_filters[j]);
        }
        break;
      }
    }
    CHECK(dialog_filters[i]->dialog_filter_id == dialog_filter_ids[i]);
  }
  return true;
}

void MessagesManager::add_dialog_filter(unique_ptr<DialogFilter> dialog_filter, bool at_beginning, const char *source) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  CHECK(dialog_filter != nullptr);
  auto dialog_filter_id = dialog_filter->dialog_filter_id;
  LOG(INFO) << "Add " << dialog_filter_id << " from " << source;
  CHECK(get_dialog_filter(dialog_filter_id) == nullptr);
  if (at_beginning) {
    dialog_filters_.insert(dialog_filters_.begin(), std::move(dialog_filter));
  } else {
    dialog_filters_.push_back(std::move(dialog_filter));
  }

  auto dialog_list_id = DialogListId(dialog_filter_id);
  CHECK(dialog_lists_.find(dialog_list_id) == dialog_lists_.end());

  auto &list = add_dialog_list(dialog_list_id);
  auto folder_ids = get_dialog_list_folder_ids(list);
  CHECK(!folder_ids.empty());

  for (auto folder_id : folder_ids) {
    auto *folder = get_dialog_folder(folder_id);
    CHECK(folder != nullptr);
    for (const auto &dialog_date : folder->ordered_dialogs_) {
      if (dialog_date.get_order() == DEFAULT_ORDER) {
        break;
      }

      auto dialog_id = dialog_date.get_dialog_id();
      Dialog *d = get_dialog(dialog_id);
      CHECK(d != nullptr);

      if (need_dialog_in_list(d, list)) {
        list.in_memory_dialog_total_count_++;

        add_dialog_to_list(d, dialog_list_id);
      }
    }
  }

  for (auto &input_dialog_id : reversed(dialog_filters_.back()->pinned_dialog_ids)) {
    auto dialog_id = input_dialog_id.get_dialog_id();
    auto order = get_next_pinned_dialog_order();
    list.pinned_dialogs_.emplace_back(order, dialog_id);
    list.pinned_dialog_id_orders_.emplace(dialog_id, order);
  }
  std::reverse(list.pinned_dialogs_.begin(), list.pinned_dialogs_.end());
  list.are_pinned_dialogs_inited_ = true;

  update_list_last_pinned_dialog_date(list);
  update_list_last_dialog_date(list);
}

void MessagesManager::edit_dialog_filter(unique_ptr<DialogFilter> new_dialog_filter, const char *source) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  CHECK(new_dialog_filter != nullptr);
  LOG(INFO) << "Edit " << new_dialog_filter->dialog_filter_id << " from " << source;
  for (auto &old_dialog_filter : dialog_filters_) {
    if (old_dialog_filter->dialog_filter_id == new_dialog_filter->dialog_filter_id) {
      CHECK(*old_dialog_filter != *new_dialog_filter);

      auto dialog_list_id = DialogListId(old_dialog_filter->dialog_filter_id);
      auto *old_list_ptr = get_dialog_list(dialog_list_id);
      CHECK(old_list_ptr != nullptr);
      auto &old_list = *old_list_ptr;

      disable_get_dialog_filter_ = true;  // to ensure crash if get_dialog_filter is called

      auto folder_ids = get_dialog_filter_folder_ids(old_dialog_filter.get());
      CHECK(!folder_ids.empty());
      for (auto folder_id : get_dialog_filter_folder_ids(new_dialog_filter.get())) {
        if (!td::contains(folder_ids, folder_id)) {
          folder_ids.push_back(folder_id);
        }
      }

      DialogList new_list;
      new_list.dialog_list_id = dialog_list_id;

      auto old_it = old_list.pinned_dialogs_.rbegin();
      for (auto &input_dialog_id : reversed(new_dialog_filter->pinned_dialog_ids)) {
        auto dialog_id = input_dialog_id.get_dialog_id();
        while (old_it < old_list.pinned_dialogs_.rend()) {
          if (old_it->get_dialog_id() == dialog_id) {
            break;
          }
          ++old_it;
        }

        int64 order;
        if (old_it < old_list.pinned_dialogs_.rend()) {
          order = old_it->get_order();
          ++old_it;
        } else {
          order = get_next_pinned_dialog_order();
        }
        new_list.pinned_dialogs_.emplace_back(order, dialog_id);
        new_list.pinned_dialog_id_orders_.emplace(dialog_id, order);
      }
      std::reverse(new_list.pinned_dialogs_.begin(), new_list.pinned_dialogs_.end());
      new_list.are_pinned_dialogs_inited_ = true;

      do_update_list_last_pinned_dialog_date(new_list);
      do_update_list_last_dialog_date(new_list, get_dialog_filter_folder_ids(new_dialog_filter.get()));

      new_list.server_dialog_total_count_ = 0;
      new_list.secret_chat_total_count_ = 0;

      std::map<DialogDate, const Dialog *> updated_position_dialogs;
      for (auto folder_id : folder_ids) {
        auto *folder = get_dialog_folder(folder_id);
        CHECK(folder != nullptr);
        for (const auto &dialog_date : folder->ordered_dialogs_) {
          if (dialog_date.get_order() == DEFAULT_ORDER) {
            break;
          }

          auto dialog_id = dialog_date.get_dialog_id();
          Dialog *d = get_dialog(dialog_id);
          CHECK(d != nullptr);

          const DialogPositionInList old_position = get_dialog_position_in_list(old_list_ptr, d);
          // can't use get_dialog_position_in_list, because need_dialog_in_list calls get_dialog_filter
          DialogPositionInList new_position;
          if (need_dialog_in_filter(d, new_dialog_filter.get())) {
            new_position.private_order = get_dialog_private_order(&new_list, d);
            if (new_position.private_order != 0) {
              new_position.public_order =
                  DialogDate(new_position.private_order, dialog_id) <= new_list.list_last_dialog_date_
                      ? new_position.private_order
                      : 0;
              new_position.is_pinned = get_dialog_pinned_order(&new_list, dialog_id) != DEFAULT_ORDER;
              new_position.is_sponsored = is_dialog_sponsored(d);
            }
          }

          if (need_send_update_chat_position(old_position, new_position)) {
            updated_position_dialogs.emplace(DialogDate(new_position.public_order, dialog_id), d);
          }

          bool was_in_list = old_position.private_order != 0;
          bool is_in_list = new_position.private_order != 0;
          if (is_in_list) {
            if (!was_in_list) {
              add_dialog_to_list(d, dialog_list_id);
            }

            new_list.in_memory_dialog_total_count_++;
            if (dialog_id.get_type() == DialogType::SecretChat) {
              new_list.secret_chat_total_count_++;
            } else {
              new_list.server_dialog_total_count_++;
            }

            auto unread_count = d->server_unread_count + d->local_unread_count;
            if (unread_count != 0) {
              new_list.unread_message_total_count_ += unread_count;
              if (is_dialog_muted(d)) {
                new_list.unread_message_muted_count_ += unread_count;
              }
            }
            if (unread_count != 0 || d->is_marked_as_unread) {
              new_list.unread_dialog_total_count_++;
              if (unread_count == 0 && d->is_marked_as_unread) {
                new_list.unread_dialog_marked_count_++;
              }
              if (is_dialog_muted(d)) {
                new_list.unread_dialog_muted_count_++;
                if (unread_count == 0 && d->is_marked_as_unread) {
                  new_list.unread_dialog_muted_marked_count_++;
                }
              }
            }
          } else {
            if (was_in_list) {
              remove_dialog_from_list(d, dialog_list_id);
            }
          }
        }
      }

      if (new_list.list_last_dialog_date_ == MAX_DIALOG_DATE) {
        new_list.is_message_unread_count_inited_ = true;
        new_list.is_dialog_unread_count_inited_ = true;
        new_list.need_unread_count_recalc_ = false;
      } else {
        if (old_list.is_message_unread_count_inited_) {  // can't stop sending updates
          new_list.is_message_unread_count_inited_ = true;
        }
        if (old_list.is_dialog_unread_count_inited_) {  // can't stop sending updates
          new_list.is_dialog_unread_count_inited_ = true;
        }
        new_list.server_dialog_total_count_ = -1;
        new_list.secret_chat_total_count_ = -1;
      }

      bool need_update_unread_message_count =
          new_list.is_message_unread_count_inited_ &&
          (old_list.unread_message_total_count_ != new_list.unread_message_total_count_ ||
           old_list.unread_message_muted_count_ != new_list.unread_message_muted_count_ ||
           !old_list.is_message_unread_count_inited_);
      bool need_update_unread_chat_count =
          new_list.is_dialog_unread_count_inited_ &&
          (old_list.unread_dialog_total_count_ != new_list.unread_dialog_total_count_ ||
           old_list.unread_dialog_muted_count_ != new_list.unread_dialog_muted_count_ ||
           old_list.unread_dialog_marked_count_ != new_list.unread_dialog_marked_count_ ||
           old_list.unread_dialog_muted_marked_count_ != new_list.unread_dialog_muted_marked_count_ ||
           get_dialog_total_count(old_list) != get_dialog_total_count(new_list) ||
           !old_list.is_dialog_unread_count_inited_);
      bool need_save_unread_chat_count = new_list.is_dialog_unread_count_inited_ &&
                                         (old_list.server_dialog_total_count_ != new_list.server_dialog_total_count_ ||
                                          old_list.secret_chat_total_count_ != new_list.secret_chat_total_count_);

      auto load_list_promises = std::move(old_list.load_list_queries_);

      disable_get_dialog_filter_ = false;

      old_list = std::move(new_list);
      old_dialog_filter = std::move(new_dialog_filter);

      if (need_update_unread_message_count) {
        send_update_unread_message_count(old_list, DialogId(), true, source);
      }
      if (need_update_unread_chat_count) {
        send_update_unread_chat_count(old_list, DialogId(), true, source);
      } else if (need_save_unread_chat_count) {
        save_unread_chat_count(old_list);
      }

      for (auto it : updated_position_dialogs) {
        send_update_chat_position(dialog_list_id, it.second, source);
      }

      if (old_list.need_unread_count_recalc_) {
        // repair unread count
        get_dialogs(dialog_list_id, MIN_DIALOG_DATE, static_cast<int32>(old_list.pinned_dialogs_.size() + 2), false,
                    Promise<Unit>());
      }

      for (auto &promise : load_list_promises) {
        promise.set_value(Unit());  // try again
      }
      return;
    }
  }
  UNREACHABLE();
}

void MessagesManager::delete_dialog_filter(DialogFilterId dialog_filter_id, const char *source) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  LOG(INFO) << "Delete " << dialog_filter_id << " from " << source;
  for (auto it = dialog_filters_.begin(); it != dialog_filters_.end(); ++it) {
    if ((*it)->dialog_filter_id == dialog_filter_id) {
      auto dialog_list_id = DialogListId(dialog_filter_id);
      auto *list = get_dialog_list(dialog_list_id);
      CHECK(list != nullptr);
      auto folder_ids = get_dialog_list_folder_ids(*list);
      CHECK(!folder_ids.empty());

      for (auto folder_id : folder_ids) {
        auto *folder = get_dialog_folder(folder_id);
        CHECK(folder != nullptr);
        for (const auto &dialog_date : folder->ordered_dialogs_) {
          if (dialog_date.get_order() == DEFAULT_ORDER) {
            break;
          }

          auto dialog_id = dialog_date.get_dialog_id();
          Dialog *d = get_dialog(dialog_id);
          CHECK(d != nullptr);

          const DialogPositionInList old_position = get_dialog_position_in_list(list, d);

          if (is_dialog_in_list(d, dialog_list_id)) {
            remove_dialog_from_list(d, dialog_list_id);

            if (old_position.public_order != 0) {
              send_update_chat_position(dialog_list_id, d, source);
            }
          }
        }
      }

      if (G()->parameters().use_message_db) {
        postponed_unread_message_count_updates_.erase(dialog_list_id);
        postponed_unread_chat_count_updates_.erase(dialog_list_id);

        if (list->is_message_unread_count_inited_) {
          list->unread_message_total_count_ = 0;
          list->unread_message_muted_count_ = 0;
          send_update_unread_message_count(*list, DialogId(), true, source, true);
          G()->td_db()->get_binlog_pmc()->erase(PSTRING() << "unread_message_count" << dialog_list_id.get());
        }
        if (list->is_dialog_unread_count_inited_) {
          list->unread_dialog_total_count_ = 0;
          list->unread_dialog_muted_count_ = 0;
          list->unread_dialog_marked_count_ = 0;
          list->unread_dialog_muted_marked_count_ = 0;
          list->in_memory_dialog_total_count_ = 0;
          list->server_dialog_total_count_ = 0;
          list->secret_chat_total_count_ = 0;
          send_update_unread_chat_count(*list, DialogId(), true, source, true);
          G()->td_db()->get_binlog_pmc()->erase(PSTRING() << "unread_dialog_count" << dialog_list_id.get());
        }
      }

      auto promises = std::move(list->load_list_queries_);
      for (auto &promise : promises) {
        promise.set_error(Status::Error(400, "Chat list not found"));
      }

      dialog_lists_.erase(dialog_list_id);
      dialog_filters_.erase(it);
      return;
    }
  }
  UNREACHABLE();
}

Status MessagesManager::delete_dialog_reply_markup(DialogId dialog_id, MessageId message_id) {
  if (td_->auth_manager_->is_bot()) {
    return Status::Error(6, "Bots can't delete chat reply markup");
  }
  if (message_id.is_scheduled()) {
    return Status::Error(6, "Wrong message identifier specified");
  }
  if (!message_id.is_valid()) {
    return Status::Error(6, "Invalid message identifier specified");
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(6, "Chat not found");
  }
  if (d->reply_markup_message_id != message_id) {
    return Status::OK();
  }

  Message *m = get_message_force(d, message_id, "delete_dialog_reply_markup");
  CHECK(m != nullptr);
  CHECK(m->reply_markup != nullptr);

  if (m->reply_markup->type == ReplyMarkup::Type::ForceReply) {
    set_dialog_reply_markup(d, MessageId());
  } else if (m->reply_markup->type == ReplyMarkup::Type::ShowKeyboard) {
    if (!m->reply_markup->is_one_time_keyboard) {
      return Status::Error(6, "Do not need to delete non one-time keyboard");
    }
    if (m->reply_markup->is_personal) {
      m->reply_markup->is_personal = false;
      set_dialog_reply_markup(d, message_id);

      on_message_changed(d, m, true, "delete_dialog_reply_markup");
    }
  } else {
    // non-bots can't have messages with RemoveKeyboard
    UNREACHABLE();
  }
  return Status::OK();
}

class MessagesManager::SaveDialogDraftMessageOnServerLogEvent {
 public:
  DialogId dialog_id_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
  }
};

Status MessagesManager::set_dialog_draft_message(DialogId dialog_id, MessageId top_thread_message_id,
                                                 tl_object_ptr<td_api::draftMessage> &&draft_message) {
  if (td_->auth_manager_->is_bot()) {
    return Status::Error(6, "Bots can't change chat draft message");
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(6, "Chat not found");
  }
  TRY_STATUS(can_send_message(dialog_id));

  unique_ptr<DraftMessage> new_draft_message;
  if (draft_message != nullptr) {
    new_draft_message = make_unique<DraftMessage>();
    new_draft_message->date = G()->unix_time();
    new_draft_message->reply_to_message_id =
        get_reply_to_message_id(d, top_thread_message_id, MessageId(draft_message->reply_to_message_id_), true);

    auto input_message_content = std::move(draft_message->input_message_text_);
    if (input_message_content != nullptr) {
      int32 draft_message_content_type = input_message_content->get_id();
      if (draft_message_content_type != td_api::inputMessageText::ID) {
        return Status::Error(5, "Input message content type must be InputMessageText");
      }
      TRY_RESULT(message_content, process_input_message_text(td_->contacts_manager_.get(), dialog_id,
                                                             std::move(input_message_content), false, true));
      new_draft_message->input_message_text = std::move(message_content);
    }

    if (!new_draft_message->reply_to_message_id.is_valid() && new_draft_message->input_message_text.text.text.empty()) {
      new_draft_message = nullptr;
    }
  }

  if (top_thread_message_id != MessageId()) {
    if (!top_thread_message_id.is_valid()) {
      return Status::Error(6, "Invalid message thread specified");
    }

    auto m = get_message_force(d, top_thread_message_id, "set_dialog_draft_message");
    if (m == nullptr || m->message_id.is_scheduled() || m->reply_info.is_comment ||
        !is_active_message_reply_info(dialog_id, m->reply_info)) {
      return Status::OK();
    }

    auto &old_draft_message = m->thread_draft_message;
    if (((new_draft_message == nullptr) != (old_draft_message == nullptr)) ||
        (new_draft_message != nullptr &&
         (old_draft_message->reply_to_message_id != new_draft_message->reply_to_message_id ||
          old_draft_message->input_message_text != new_draft_message->input_message_text))) {
      old_draft_message = std::move(new_draft_message);
      on_message_changed(d, m, false, "set_dialog_draft_message");
    }
    return Status::OK();
  }

  if (update_dialog_draft_message(d, std::move(new_draft_message), false, true)) {
    if (dialog_id.get_type() != DialogType::SecretChat) {
      if (G()->parameters().use_message_db) {
        SaveDialogDraftMessageOnServerLogEvent log_event;
        log_event.dialog_id_ = dialog_id;
        add_log_event(d->save_draft_message_log_event_id, get_log_event_storer(log_event),
                      LogEvent::HandlerType::SaveDialogDraftMessageOnServer, "draft");
      }

      pending_draft_message_timeout_.set_timeout_in(dialog_id.get(), d->is_opened ? MIN_SAVE_DRAFT_DELAY : 0);
    }
  }
  return Status::OK();
}

void MessagesManager::save_dialog_draft_message_on_server(DialogId dialog_id) {
  if (G()->close_flag()) {
    return;
  }

  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  Promise<> promise;
  if (d->save_draft_message_log_event_id.log_event_id != 0) {
    d->save_draft_message_log_event_id.generation++;
    promise = PromiseCreator::lambda([actor_id = actor_id(this), dialog_id,
                                      generation = d->save_draft_message_log_event_id.generation](Result<Unit> result) {
      if (!G()->close_flag()) {
        send_closure(actor_id, &MessagesManager::on_saved_dialog_draft_message, dialog_id, generation);
      }
    });
  }

  // TODO do not send two queries simultaneously or use SequenceDispatcher
  td_->create_handler<SaveDraftMessageQuery>(std::move(promise))->send(dialog_id, d->draft_message);
}

void MessagesManager::on_saved_dialog_draft_message(DialogId dialog_id, uint64 generation) {
  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  delete_log_event(d->save_draft_message_log_event_id, generation, "draft");
}

void MessagesManager::clear_all_draft_messages(bool exclude_secret_chats, Promise<Unit> &&promise) {
  if (!exclude_secret_chats) {
    for (auto &dialog : dialogs_) {
      Dialog *d = dialog.second.get();
      if (d->dialog_id.get_type() == DialogType::SecretChat) {
        update_dialog_draft_message(d, nullptr, false, true);
      }
    }
  }
  td_->create_handler<ClearAllDraftsQuery>(std::move(promise))->send();
}

int32 MessagesManager::get_pinned_dialogs_limit(DialogListId dialog_list_id) {
  if (dialog_list_id.is_filter()) {
    return DialogFilter::MAX_INCLUDED_FILTER_DIALOGS;
  }

  Slice key{"pinned_chat_count_max"};
  int32 default_limit = 5;
  if (!dialog_list_id.is_folder() || dialog_list_id.get_folder_id() != FolderId::main()) {
    key = Slice("pinned_archived_chat_count_max");
    default_limit = 100;
  }
  int32 limit = clamp(narrow_cast<int32>(G()->shared_config().get_option_integer(key)), 0, 1000);
  if (limit <= 0) {
    return default_limit;
  }
  return limit;
}

vector<DialogId> MessagesManager::remove_secret_chat_dialog_ids(vector<DialogId> dialog_ids) {
  td::remove_if(dialog_ids, [](DialogId dialog_id) { return dialog_id.get_type() == DialogType::SecretChat; });
  return dialog_ids;
}

Status MessagesManager::toggle_dialog_is_pinned(DialogListId dialog_list_id, DialogId dialog_id, bool is_pinned) {
  if (td_->auth_manager_->is_bot()) {
    return Status::Error(6, "Bots can't change chat pin state");
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(6, "Chat not found");
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return Status::Error(6, "Can't access the chat");
  }
  if (d->order == DEFAULT_ORDER && is_pinned) {
    return Status::Error(6, "The chat can't be pinned");
  }

  auto *list = get_dialog_list(dialog_list_id);
  if (list == nullptr) {
    return Status::Error(6, "Chat list not found");
  }
  if (!list->are_pinned_dialogs_inited_) {
    return Status::Error(6, "Pinned chats must be loaded first");
  }

  bool was_pinned = get_dialog_pinned_order(dialog_list_id, dialog_id) != DEFAULT_ORDER;
  if (is_pinned == was_pinned) {
    return Status::OK();
  }

  if (dialog_list_id.is_filter()) {
    CHECK(is_update_chat_filters_sent_);
    auto dialog_filter_id = dialog_list_id.get_filter_id();
    auto old_dialog_filter = get_dialog_filter(dialog_filter_id);
    CHECK(old_dialog_filter != nullptr);
    auto new_dialog_filter = make_unique<DialogFilter>(*old_dialog_filter);
    auto is_changed_dialog = [dialog_id](InputDialogId input_dialog_id) {
      return dialog_id == input_dialog_id.get_dialog_id();
    };
    if (is_pinned) {
      new_dialog_filter->pinned_dialog_ids.insert(new_dialog_filter->pinned_dialog_ids.begin(),
                                                  get_input_dialog_id(dialog_id));
      td::remove_if(new_dialog_filter->included_dialog_ids, is_changed_dialog);
      td::remove_if(new_dialog_filter->excluded_dialog_ids, is_changed_dialog);
    } else {
      td::remove_if(new_dialog_filter->pinned_dialog_ids, is_changed_dialog);
      new_dialog_filter->included_dialog_ids.push_back(get_input_dialog_id(dialog_id));
    }

    TRY_STATUS(new_dialog_filter->check_limits());
    sort_dialog_filter_input_dialog_ids(new_dialog_filter.get());

    edit_dialog_filter(std::move(new_dialog_filter), "toggle_dialog_is_pinned");
    save_dialog_filters();
    send_update_chat_filters();

    if (dialog_id.get_type() != DialogType::SecretChat) {
      synchronize_dialog_filters();
    }

    return Status::OK();
  }

  CHECK(dialog_list_id.is_folder());
  auto folder_id = dialog_list_id.get_folder_id();
  if (is_pinned) {
    if (d->folder_id != folder_id) {
      return Status::Error(400, "Chat not in the list");
    }

    auto pinned_dialog_ids = get_pinned_dialog_ids(dialog_list_id);
    auto pinned_dialog_count = pinned_dialog_ids.size();
    auto secret_pinned_dialog_count =
        std::count_if(pinned_dialog_ids.begin(), pinned_dialog_ids.end(),
                      [](DialogId dialog_id) { return dialog_id.get_type() == DialogType::SecretChat; });
    size_t dialog_count = dialog_id.get_type() == DialogType::SecretChat
                              ? secret_pinned_dialog_count
                              : pinned_dialog_count - secret_pinned_dialog_count;

    if (dialog_count >= static_cast<size_t>(get_pinned_dialogs_limit(dialog_list_id))) {
      return Status::Error(400, "Maximum number of pinned chats exceeded");
    }
  }

  if (set_dialog_is_pinned(dialog_list_id, d, is_pinned)) {
    toggle_dialog_is_pinned_on_server(dialog_id, is_pinned, 0);
  }
  return Status::OK();
}

class MessagesManager::ToggleDialogIsPinnedOnServerLogEvent {
 public:
  DialogId dialog_id_;
  bool is_pinned_;

  template <class StorerT>
  void store(StorerT &storer) const {
    BEGIN_STORE_FLAGS();
    STORE_FLAG(is_pinned_);
    END_STORE_FLAGS();

    td::store(dialog_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(is_pinned_);
    END_PARSE_FLAGS();

    td::parse(dialog_id_, parser);
  }
};

uint64 MessagesManager::save_toggle_dialog_is_pinned_on_server_log_event(DialogId dialog_id, bool is_pinned) {
  ToggleDialogIsPinnedOnServerLogEvent log_event{dialog_id, is_pinned};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::ToggleDialogIsPinnedOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::toggle_dialog_is_pinned_on_server(DialogId dialog_id, bool is_pinned, uint64 log_event_id) {
  CHECK(!td_->auth_manager_->is_bot());
  if (log_event_id == 0 && dialog_id.get_type() == DialogType::SecretChat) {
    // don't even create new binlog events
    return;
  }

  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_toggle_dialog_is_pinned_on_server_log_event(dialog_id, is_pinned);
  }

  td_->create_handler<ToggleDialogPinQuery>(get_erase_log_event_promise(log_event_id))->send(dialog_id, is_pinned);
}

Status MessagesManager::set_pinned_dialogs(DialogListId dialog_list_id, vector<DialogId> dialog_ids) {
  if (td_->auth_manager_->is_bot()) {
    return Status::Error(6, "Bots can't reorder pinned chats");
  }

  int32 dialog_count = 0;
  int32 secret_dialog_count = 0;
  auto dialog_count_limit = get_pinned_dialogs_limit(dialog_list_id);
  for (auto dialog_id : dialog_ids) {
    Dialog *d = get_dialog_force(dialog_id);
    if (d == nullptr) {
      return Status::Error(6, "Chat not found");
    }
    if (!have_input_peer(dialog_id, AccessRights::Read)) {
      return Status::Error(6, "Can't access the chat");
    }
    if (d->order == DEFAULT_ORDER) {
      return Status::Error(6, "The chat can't be pinned");
    }
    if (dialog_list_id.is_folder() && d->folder_id != dialog_list_id.get_folder_id()) {
      return Status::Error(400, "Chat not in the list");
    }
    if (dialog_id.get_type() == DialogType::SecretChat) {
      secret_dialog_count++;
    } else {
      dialog_count++;
    }

    if (dialog_count > dialog_count_limit || secret_dialog_count > dialog_count_limit) {
      return Status::Error(400, "Maximum number of pinned chats exceeded");
    }
  }
  std::unordered_set<DialogId, DialogIdHash> new_pinned_dialog_ids(dialog_ids.begin(), dialog_ids.end());
  if (new_pinned_dialog_ids.size() != dialog_ids.size()) {
    return Status::Error(400, "Duplicate chats in the list of pinned chats");
  }

  auto *list = get_dialog_list(dialog_list_id);
  if (list == nullptr) {
    return Status::Error(6, "Chat list not found");
  }
  if (!list->are_pinned_dialogs_inited_) {
    return Status::Error(6, "Pinned chats must be loaded first");
  }

  auto pinned_dialog_ids = get_pinned_dialog_ids(dialog_list_id);
  if (pinned_dialog_ids == dialog_ids) {
    return Status::OK();
  }
  LOG(INFO) << "Reorder pinned chats in " << dialog_list_id << " from " << pinned_dialog_ids << " to " << dialog_ids;

  auto server_old_dialog_ids = remove_secret_chat_dialog_ids(pinned_dialog_ids);
  auto server_new_dialog_ids = remove_secret_chat_dialog_ids(dialog_ids);

  if (dialog_list_id.is_filter()) {
    CHECK(is_update_chat_filters_sent_);
    auto dialog_filter_id = dialog_list_id.get_filter_id();
    auto old_dialog_filter = get_dialog_filter(dialog_filter_id);
    CHECK(old_dialog_filter != nullptr);
    auto new_dialog_filter = make_unique<DialogFilter>(*old_dialog_filter);
    auto old_pinned_dialog_ids = std::move(new_dialog_filter->pinned_dialog_ids);
    new_dialog_filter->pinned_dialog_ids =
        transform(dialog_ids, [this](DialogId dialog_id) { return get_input_dialog_id(dialog_id); });
    auto is_new_pinned = [&new_pinned_dialog_ids](InputDialogId input_dialog_id) {
      return new_pinned_dialog_ids.count(input_dialog_id.get_dialog_id()) > 0;
    };
    td::remove_if(old_pinned_dialog_ids, is_new_pinned);
    td::remove_if(new_dialog_filter->included_dialog_ids, is_new_pinned);
    td::remove_if(new_dialog_filter->excluded_dialog_ids, is_new_pinned);
    append(new_dialog_filter->included_dialog_ids, old_pinned_dialog_ids);

    TRY_STATUS(new_dialog_filter->check_limits());
    sort_dialog_filter_input_dialog_ids(new_dialog_filter.get());

    edit_dialog_filter(std::move(new_dialog_filter), "set_pinned_dialogs");
    save_dialog_filters();
    send_update_chat_filters();

    if (server_old_dialog_ids != server_new_dialog_ids) {
      synchronize_dialog_filters();
    }

    return Status::OK();
  }

  CHECK(dialog_list_id.is_folder());

  std::reverse(pinned_dialog_ids.begin(), pinned_dialog_ids.end());
  std::reverse(dialog_ids.begin(), dialog_ids.end());

  std::unordered_set<DialogId, DialogIdHash> old_pinned_dialog_ids(pinned_dialog_ids.begin(), pinned_dialog_ids.end());
  auto old_it = pinned_dialog_ids.begin();
  for (auto dialog_id : dialog_ids) {
    old_pinned_dialog_ids.erase(dialog_id);
    while (old_it < pinned_dialog_ids.end()) {
      if (*old_it == dialog_id) {
        break;
      }
      ++old_it;
    }
    if (old_it < pinned_dialog_ids.end()) {
      // leave dialog where it is
      ++old_it;
      continue;
    }
    set_dialog_is_pinned(dialog_id, true);
  }
  for (auto dialog_id : old_pinned_dialog_ids) {
    set_dialog_is_pinned(dialog_id, false);
  }

  if (server_old_dialog_ids != server_new_dialog_ids) {
    reorder_pinned_dialogs_on_server(dialog_list_id.get_folder_id(), server_new_dialog_ids, 0);
  }
  return Status::OK();
}

class MessagesManager::ReorderPinnedDialogsOnServerLogEvent {
 public:
  FolderId folder_id_;
  vector<DialogId> dialog_ids_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(folder_id_, storer);
    td::store(dialog_ids_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    if (parser.version() >= static_cast<int32>(Version::AddFolders)) {
      td::parse(folder_id_, parser);
    } else {
      folder_id_ = FolderId();
    }
    td::parse(dialog_ids_, parser);
  }
};

uint64 MessagesManager::save_reorder_pinned_dialogs_on_server_log_event(FolderId folder_id,
                                                                        const vector<DialogId> &dialog_ids) {
  ReorderPinnedDialogsOnServerLogEvent log_event{folder_id, dialog_ids};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::ReorderPinnedDialogsOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::reorder_pinned_dialogs_on_server(FolderId folder_id, const vector<DialogId> &dialog_ids,
                                                       uint64 log_event_id) {
  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_reorder_pinned_dialogs_on_server_log_event(folder_id, dialog_ids);
  }

  td_->create_handler<ReorderPinnedDialogsQuery>(get_erase_log_event_promise(log_event_id))
      ->send(folder_id, dialog_ids);
}

Status MessagesManager::toggle_dialog_is_marked_as_unread(DialogId dialog_id, bool is_marked_as_unread) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(6, "Chat not found");
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return Status::Error(6, "Can't access the chat");
  }

  if (is_marked_as_unread == d->is_marked_as_unread) {
    return Status::OK();
  }

  set_dialog_is_marked_as_unread(d, is_marked_as_unread);

  toggle_dialog_is_marked_as_unread_on_server(dialog_id, is_marked_as_unread, 0);
  return Status::OK();
}

class MessagesManager::ToggleDialogIsMarkedAsUnreadOnServerLogEvent {
 public:
  DialogId dialog_id_;
  bool is_marked_as_unread_;

  template <class StorerT>
  void store(StorerT &storer) const {
    BEGIN_STORE_FLAGS();
    STORE_FLAG(is_marked_as_unread_);
    END_STORE_FLAGS();

    td::store(dialog_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(is_marked_as_unread_);
    END_PARSE_FLAGS();

    td::parse(dialog_id_, parser);
  }
};

uint64 MessagesManager::save_toggle_dialog_is_marked_as_unread_on_server_log_event(DialogId dialog_id,
                                                                                   bool is_marked_as_unread) {
  ToggleDialogIsMarkedAsUnreadOnServerLogEvent log_event{dialog_id, is_marked_as_unread};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::ToggleDialogIsMarkedAsUnreadOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::toggle_dialog_is_marked_as_unread_on_server(DialogId dialog_id, bool is_marked_as_unread,
                                                                  uint64 log_event_id) {
  if (log_event_id == 0 && dialog_id.get_type() == DialogType::SecretChat) {
    // don't even create new binlog events
    return;
  }

  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_toggle_dialog_is_marked_as_unread_on_server_log_event(dialog_id, is_marked_as_unread);
  }

  td_->create_handler<ToggleDialogUnreadMarkQuery>(get_erase_log_event_promise(log_event_id))
      ->send(dialog_id, is_marked_as_unread);
}

Status MessagesManager::toggle_message_sender_is_blocked(const td_api::object_ptr<td_api::MessageSender> &sender,
                                                         bool is_blocked) {
  if (sender == nullptr) {
    return Status::Error(400, "Message sender must be non-empty");
  }

  UserId sender_user_id;
  DialogId dialog_id;
  switch (sender->get_id()) {
    case td_api::messageSenderUser::ID:
      sender_user_id = UserId(static_cast<const td_api::messageSenderUser *>(sender.get())->user_id_);
      break;
    case td_api::messageSenderChat::ID: {
      auto sender_dialog_id = DialogId(static_cast<const td_api::messageSenderChat *>(sender.get())->chat_id_);
      if (!have_dialog_force(sender_dialog_id)) {
        return Status::Error(400, "Sender chat not found");
      }

      switch (sender_dialog_id.get_type()) {
        case DialogType::User:
          sender_user_id = sender_dialog_id.get_user_id();
          break;
        case DialogType::Chat:
          return Status::Error(400, "Basic group chats can't be blocked");
        case DialogType::Channel:
          dialog_id = sender_dialog_id;
          break;
        case DialogType::SecretChat:
          sender_user_id = td_->contacts_manager_->get_secret_chat_user_id(sender_dialog_id.get_secret_chat_id());
          break;
        case DialogType::None:
        default:
          UNREACHABLE();
      }
      break;
    }
    default:
      UNREACHABLE();
  }
  if (!dialog_id.is_valid()) {
    if (!td_->contacts_manager_->have_user_force(sender_user_id)) {
      return Status::Error(400, "Sender user not found");
    }
    dialog_id = DialogId(sender_user_id);
  }
  if (dialog_id == get_my_dialog_id()) {
    return Status::Error(5, is_blocked ? Slice("Can't block self") : Slice("Can't unblock self"));
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d != nullptr) {
    if (is_blocked == d->is_blocked) {
      return Status::OK();
    }
    set_dialog_is_blocked(d, is_blocked);
  } else {
    CHECK(dialog_id.get_type() == DialogType::User);
    td_->contacts_manager_->on_update_user_is_blocked(dialog_id.get_user_id(), is_blocked);
  }

  toggle_dialog_is_blocked_on_server(dialog_id, is_blocked, 0);
  return Status::OK();
}

class MessagesManager::ToggleDialogIsBlockedOnServerLogEvent {
 public:
  DialogId dialog_id_;
  bool is_blocked_;

  template <class StorerT>
  void store(StorerT &storer) const {
    BEGIN_STORE_FLAGS();
    STORE_FLAG(is_blocked_);
    END_STORE_FLAGS();

    td::store(dialog_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(is_blocked_);
    END_PARSE_FLAGS();

    td::parse(dialog_id_, parser);
  }
};

uint64 MessagesManager::save_toggle_dialog_is_blocked_on_server_log_event(DialogId dialog_id, bool is_blocked) {
  ToggleDialogIsBlockedOnServerLogEvent log_event{dialog_id, is_blocked};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::ToggleDialogIsBlockedOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::toggle_dialog_is_blocked_on_server(DialogId dialog_id, bool is_blocked, uint64 log_event_id) {
  if (log_event_id == 0 && dialog_id.get_type() == DialogType::SecretChat) {
    // don't even create new binlog events
    return;
  }

  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_toggle_dialog_is_blocked_on_server_log_event(dialog_id, is_blocked);
  }

  td_->create_handler<ToggleDialogIsBlockedQuery>(get_erase_log_event_promise(log_event_id))
      ->send(dialog_id, is_blocked);
}

Status MessagesManager::toggle_dialog_silent_send_message(DialogId dialog_id, bool silent_send_message) {
  CHECK(!td_->auth_manager_->is_bot());

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(6, "Chat not found");
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return Status::Error(6, "Can't access the chat");
  }

  if (update_dialog_silent_send_message(d, silent_send_message)) {
    update_dialog_notification_settings_on_server(dialog_id, false);
  }

  return Status::OK();
}

class MessagesManager::UpdateDialogNotificationSettingsOnServerLogEvent {
 public:
  DialogId dialog_id_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
  }
};

void MessagesManager::update_dialog_notification_settings_on_server(DialogId dialog_id, bool from_binlog) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  if (!from_binlog && get_input_notify_peer(dialog_id) == nullptr) {
    // don't even create new binlog events
    return;
  }

  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  if (!from_binlog && G()->parameters().use_message_db) {
    UpdateDialogNotificationSettingsOnServerLogEvent log_event;
    log_event.dialog_id_ = dialog_id;
    add_log_event(d->save_notification_settings_log_event_id, get_log_event_storer(log_event),
                  LogEvent::HandlerType::UpdateDialogNotificationSettingsOnServer, "notification settings");
  }

  Promise<> promise;
  if (d->save_notification_settings_log_event_id.log_event_id != 0) {
    d->save_notification_settings_log_event_id.generation++;
    promise = PromiseCreator::lambda(
        [actor_id = actor_id(this), dialog_id,
         generation = d->save_notification_settings_log_event_id.generation](Result<Unit> result) {
          if (!G()->close_flag()) {
            send_closure(actor_id, &MessagesManager::on_updated_dialog_notification_settings, dialog_id, generation);
          }
        });
  }

  send_update_dialog_notification_settings_query(d, std::move(promise));
}

void MessagesManager::send_update_dialog_notification_settings_query(const Dialog *d, Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(d != nullptr);
  // TODO do not send two queries simultaneously or use SequenceDispatcher
  td_->create_handler<UpdateDialogNotifySettingsQuery>(std::move(promise))
      ->send(d->dialog_id, d->notification_settings);
}

void MessagesManager::on_updated_dialog_notification_settings(DialogId dialog_id, uint64 generation) {
  CHECK(!td_->auth_manager_->is_bot());
  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  delete_log_event(d->save_notification_settings_log_event_id, generation, "notification settings");
}

Status MessagesManager::set_dialog_client_data(DialogId dialog_id, string &&client_data) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(6, "Chat not found");
  }

  d->client_data = std::move(client_data);
  on_dialog_updated(d->dialog_id, "set_dialog_client_data");
  return Status::OK();
}

bool MessagesManager::is_dialog_inited(const Dialog *d) {
  return d != nullptr && d->notification_settings.is_synchronized && d->is_last_read_inbox_message_id_inited &&
         d->is_last_read_outbox_message_id_inited;
}

int32 MessagesManager::get_dialog_mute_until(const Dialog *d) const {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(d != nullptr);
  return d->notification_settings.use_default_mute_until ? get_scope_mute_until(d->dialog_id)
                                                         : d->notification_settings.mute_until;
}

bool MessagesManager::is_dialog_muted(const Dialog *d) const {
  return get_dialog_mute_until(d) != 0;
}

bool MessagesManager::is_dialog_pinned_message_notifications_disabled(const Dialog *d) const {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(d != nullptr);
  if (d->notification_settings.use_default_disable_pinned_message_notifications) {
    auto scope = get_dialog_notification_setting_scope(d->dialog_id);
    return get_scope_notification_settings(scope)->disable_pinned_message_notifications;
  }

  return d->notification_settings.disable_pinned_message_notifications;
}

bool MessagesManager::is_dialog_mention_notifications_disabled(const Dialog *d) const {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(d != nullptr);
  if (d->notification_settings.use_default_disable_mention_notifications) {
    auto scope = get_dialog_notification_setting_scope(d->dialog_id);
    return get_scope_notification_settings(scope)->disable_mention_notifications;
  }

  return d->notification_settings.disable_mention_notifications;
}

void MessagesManager::create_dialog(DialogId dialog_id, bool force, Promise<Unit> &&promise) {
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    if (!have_dialog_info_force(dialog_id)) {
      return promise.set_error(Status::Error(6, "Chat info not found"));
    }
    if (!have_input_peer(dialog_id, AccessRights::Read)) {
      return promise.set_error(Status::Error(6, "Can't access the chat"));
    }
  }

  if (force || td_->auth_manager_->is_bot() || dialog_id.get_type() == DialogType::SecretChat) {
    force_create_dialog(dialog_id, "create dialog");
  } else {
    const Dialog *d = get_dialog_force(dialog_id);
    if (!is_dialog_inited(d)) {
      return send_get_dialog_query(dialog_id, std::move(promise), 0, "create_dialog");
    }
  }

  promise.set_value(Unit());
}

DialogId MessagesManager::create_new_group_chat(const vector<UserId> &user_ids, const string &title, int64 &random_id,
                                                Promise<Unit> &&promise) {
  LOG(INFO) << "Trying to create group chat \"" << title << "\" with members " << format::as_array(user_ids);

  if (random_id != 0) {
    // request has already been sent before
    auto it = created_dialogs_.find(random_id);
    CHECK(it != created_dialogs_.end());
    auto dialog_id = it->second;
    CHECK(dialog_id.get_type() == DialogType::Chat);
    CHECK(have_dialog(dialog_id));

    created_dialogs_.erase(it);

    // set default notification settings to newly created chat
    on_update_dialog_notify_settings(
        dialog_id, make_tl_object<telegram_api::peerNotifySettings>(0, false, false, 0, ""), "create_new_group_chat");

    promise.set_value(Unit());
    return dialog_id;
  }

  if (user_ids.empty()) {
    promise.set_error(Status::Error(3, "Too few users to create basic group chat"));
    return DialogId();
  }

  auto new_title = clean_name(title, MAX_TITLE_LENGTH);
  if (new_title.empty()) {
    promise.set_error(Status::Error(3, "Title can't be empty"));
    return DialogId();
  }

  vector<tl_object_ptr<telegram_api::InputUser>> input_users;
  for (auto user_id : user_ids) {
    auto input_user = td_->contacts_manager_->get_input_user(user_id);
    if (input_user == nullptr) {
      promise.set_error(Status::Error(3, "User not found"));
      return DialogId();
    }
    input_users.push_back(std::move(input_user));
  }

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || created_dialogs_.find(random_id) != created_dialogs_.end());
  created_dialogs_[random_id];  // reserve place for result

  td_->create_handler<CreateChatQuery>(std::move(promise))->send(std::move(input_users), new_title, random_id);
  return DialogId();
}

DialogId MessagesManager::create_new_channel_chat(const string &title, bool is_megagroup, const string &description,
                                                  const DialogLocation &location, bool for_import, int64 &random_id,
                                                  Promise<Unit> &&promise) {
  LOG(INFO) << "Trying to create " << (is_megagroup ? "supergroup" : "broadcast") << " with title \"" << title
            << "\", description \"" << description << "\" and " << location;

  if (random_id != 0) {
    // request has already been sent before
    auto it = created_dialogs_.find(random_id);
    CHECK(it != created_dialogs_.end());
    auto dialog_id = it->second;
    CHECK(dialog_id.get_type() == DialogType::Channel);
    CHECK(have_dialog(dialog_id));

    created_dialogs_.erase(it);

    // set default notification settings to newly created chat
    on_update_dialog_notify_settings(
        dialog_id, make_tl_object<telegram_api::peerNotifySettings>(0, false, false, 0, ""), "create_new_channel_chat");

    promise.set_value(Unit());
    return dialog_id;
  }

  auto new_title = clean_name(title, MAX_TITLE_LENGTH);
  if (new_title.empty()) {
    promise.set_error(Status::Error(3, "Title can't be empty"));
    return DialogId();
  }

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || created_dialogs_.find(random_id) != created_dialogs_.end());
  created_dialogs_[random_id];  // reserve place for result

  td_->create_handler<CreateChannelQuery>(std::move(promise))
      ->send(new_title, is_megagroup, strip_empty_characters(description, MAX_DESCRIPTION_LENGTH), location, for_import,
             random_id);
  return DialogId();
}

void MessagesManager::create_new_secret_chat(UserId user_id, Promise<SecretChatId> &&promise) {
  auto user_base = td_->contacts_manager_->get_input_user(user_id);
  if (user_base == nullptr || user_base->get_id() != telegram_api::inputUser::ID) {
    return promise.set_error(Status::Error(6, "User not found"));
  }
  auto user = move_tl_object_as<telegram_api::inputUser>(user_base);

  send_closure(G()->secret_chats_manager(), &SecretChatsManager::create_chat, user->user_id_, user->access_hash_,
               std::move(promise));
}

DialogId MessagesManager::migrate_dialog_to_megagroup(DialogId dialog_id, Promise<Unit> &&promise) {
  LOG(INFO) << "Trying to convert " << dialog_id << " to supergroup";

  if (dialog_id.get_type() != DialogType::Chat) {
    promise.set_error(Status::Error(3, "Only basic group chats can be converted to supergroup"));
    return DialogId();
  }

  auto channel_id = td_->contacts_manager_->migrate_chat_to_megagroup(dialog_id.get_chat_id(), promise);
  if (!channel_id.is_valid()) {
    return DialogId();
  }

  if (!td_->contacts_manager_->have_channel(channel_id)) {
    LOG(ERROR) << "Can't find info about supergroup to which the group has migrated";
    promise.set_error(Status::Error(6, "Supergroup is not found"));
    return DialogId();
  }

  auto new_dialog_id = DialogId(channel_id);
  Dialog *d = get_dialog_force(new_dialog_id);
  if (d == nullptr) {
    d = add_dialog(new_dialog_id);
    if (d->pts == 0) {
      d->pts = 1;
      if (is_debug_message_op_enabled()) {
        d->debug_message_op.emplace_back(Dialog::MessageOp::SetPts, d->pts, "migrate");
      }
    }
    update_dialog_pos(d, "migrate_dialog_to_megagroup");
  }

  promise.set_value(Unit());
  return new_dialog_id;
}

Status MessagesManager::open_dialog(DialogId dialog_id) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(3, "Chat not found");
  }

  open_dialog(d);
  return Status::OK();
}

Status MessagesManager::close_dialog(DialogId dialog_id) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(3, "Chat not found");
  }

  close_dialog(d);
  return Status::OK();
}

DialogId MessagesManager::get_my_dialog_id() const {
  return DialogId(td_->contacts_manager_->get_my_id());
}

Status MessagesManager::view_messages(DialogId dialog_id, MessageId top_thread_message_id,
                                      const vector<MessageId> &message_ids, bool force_read) {
  CHECK(!td_->auth_manager_->is_bot());

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(3, "Chat not found");
  }
  for (auto message_id : message_ids) {
    if (!message_id.is_valid() && !message_id.is_valid_scheduled()) {
      return Status::Error(3, "Invalid message identifier");
    }
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return Status::Error(5, "Can't access the chat");
  }

  if (top_thread_message_id != MessageId()) {
    if (!top_thread_message_id.is_valid() || !top_thread_message_id.is_server()) {
      return Status::Error(400, "Invalid message thread ID specified");
    }
    if (dialog_id.get_type() != DialogType::Channel || is_broadcast_channel(dialog_id)) {
      return Status::Error(400, "There is no message threads in the chat");
    }
  }

  bool need_read = force_read || d->is_opened;
  MessageId max_message_id;  // max server or local viewed message_id
  vector<MessageId> read_content_message_ids;
  for (auto message_id : message_ids) {
    if (!message_id.is_valid()) {
      continue;
    }

    auto *m = get_message_force(d, message_id, "view_messages");
    if (m != nullptr) {
      if (m->message_id.is_server() && m->view_count > 0) {
        d->pending_viewed_message_ids.insert(m->message_id);
      }

      if (!m->message_id.is_yet_unsent() && m->message_id > max_message_id) {
        max_message_id = m->message_id;
      }

      auto message_content_type = m->content->get_type();
      if (message_content_type == MessageContentType::LiveLocation) {
        on_message_live_location_viewed(d, m);
      }

      if (need_read && message_content_type != MessageContentType::VoiceNote &&
          message_content_type != MessageContentType::VideoNote &&
          update_message_contains_unread_mention(d, m, false, "view_messages")) {
        CHECK(m->message_id.is_server());
        read_content_message_ids.push_back(m->message_id);
        on_message_changed(d, m, true, "view_messages");
      }
    } else if (!message_id.is_yet_unsent() && message_id > max_message_id &&
               message_id <= d->max_notification_message_id) {
      max_message_id = message_id;
    }
  }
  if (!d->pending_viewed_message_ids.empty()) {
    pending_message_views_timeout_.add_timeout_in(dialog_id.get(), MAX_MESSAGE_VIEW_DELAY);
    d->increment_view_counter |= d->is_opened;
  }
  if (!read_content_message_ids.empty()) {
    read_message_contents_on_server(dialog_id, std::move(read_content_message_ids), 0, Auto());
  }

  if (!need_read) {
    return Status::OK();
  }

  if (top_thread_message_id.is_valid()) {
    MessageId prev_last_read_inbox_message_id;
    MessageId max_thread_message_id;
    Message *top_m = get_message_force(d, top_thread_message_id, "view_messages 2");
    if (top_m != nullptr && is_active_message_reply_info(dialog_id, top_m->reply_info)) {
      prev_last_read_inbox_message_id = top_m->reply_info.last_read_inbox_message_id;
      if (top_m->reply_info.update_max_message_ids(MessageId(), max_message_id, MessageId())) {
        on_message_reply_info_changed(dialog_id, top_m);
        on_message_changed(d, top_m, true, "view_messages 3");
      }
      max_thread_message_id = top_m->reply_info.max_message_id;

      if (is_discussion_message(dialog_id, top_m)) {
        auto linked_dialog_id = top_m->forward_info->from_dialog_id;
        auto linked_d = get_dialog(linked_dialog_id);
        CHECK(linked_d != nullptr);
        CHECK(linked_dialog_id.get_type() == DialogType::Channel);
        auto *linked_m = get_message_force(linked_d, top_m->forward_info->from_message_id, "view_messages 4");
        if (linked_m != nullptr && is_active_message_reply_info(linked_dialog_id, linked_m->reply_info)) {
          if (linked_m->reply_info.last_read_inbox_message_id < prev_last_read_inbox_message_id) {
            prev_last_read_inbox_message_id = linked_m->reply_info.last_read_inbox_message_id;
          }
          if (linked_m->reply_info.update_max_message_ids(MessageId(), max_message_id, MessageId())) {
            on_message_reply_info_changed(linked_dialog_id, linked_m);
            on_message_changed(linked_d, linked_m, true, "view_messages 5");
          }
          if (linked_m->reply_info.max_message_id > max_thread_message_id) {
            max_thread_message_id = linked_m->reply_info.max_message_id;
          }
        }
      }
    }

    if (max_message_id.get_prev_server_message_id().get() >
        prev_last_read_inbox_message_id.get_prev_server_message_id().get()) {
      read_message_thread_history_on_server(d, top_thread_message_id, max_message_id.get_prev_server_message_id(),
                                            max_thread_message_id.get_prev_server_message_id());
    }

    return Status::OK();
  }

  if (max_message_id > d->last_read_inbox_message_id) {
    const MessageId last_read_message_id = max_message_id;
    const MessageId prev_last_read_inbox_message_id = d->last_read_inbox_message_id;
    MessageId read_history_on_server_message_id;
    if (dialog_id.get_type() != DialogType::SecretChat) {
      if (last_read_message_id.get_prev_server_message_id().get() >
          prev_last_read_inbox_message_id.get_prev_server_message_id().get()) {
        read_history_on_server_message_id = last_read_message_id.get_prev_server_message_id();
      }
    } else {
      if (last_read_message_id > prev_last_read_inbox_message_id) {
        read_history_on_server_message_id = last_read_message_id;
      }
    }

    if (read_history_on_server_message_id.is_valid()) {
      // add dummy timeout to not try to repair unread_count in read_history_inbox before server request succeeds
      // the timeout will be overwritten in the read_history_on_server call
      pending_read_history_timeout_.add_timeout_in(dialog_id.get(), 0);
    }
    read_history_inbox(d->dialog_id, last_read_message_id, -1, "view_messages");
    if (read_history_on_server_message_id.is_valid()) {
      // call read_history_on_server after read_history_inbox to not have delay before request if all messages are read
      read_history_on_server(d, read_history_on_server_message_id);
    }
  }
  if (d->is_marked_as_unread) {
    set_dialog_is_marked_as_unread(d, false);
  }

  return Status::OK();
}

Status MessagesManager::open_message_content(FullMessageId full_message_id) {
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(3, "Chat not found");
  }

  auto *m = get_message_force(d, full_message_id.get_message_id(), "open_message_content");
  if (m == nullptr) {
    return Status::Error(4, "Message not found");
  }

  if (m->message_id.is_scheduled() || m->message_id.is_yet_unsent() || m->is_outgoing) {
    return Status::OK();
  }

  if (read_message_content(d, m, true, "open_message_content") &&
      (m->message_id.is_server() || dialog_id.get_type() == DialogType::SecretChat)) {
    read_message_contents_on_server(dialog_id, {m->message_id}, 0, Auto());
  }

  if (m->content->get_type() == MessageContentType::LiveLocation) {
    on_message_live_location_viewed(d, m);
  }

  return Status::OK();
}

class MessagesManager::ReadMessageContentsOnServerLogEvent {
 public:
  DialogId dialog_id_;
  vector<MessageId> message_ids_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
    td::store(message_ids_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
    td::parse(message_ids_, parser);
  }
};

uint64 MessagesManager::save_read_message_contents_on_server_log_event(DialogId dialog_id,
                                                                       const vector<MessageId> &message_ids) {
  ReadMessageContentsOnServerLogEvent log_event{dialog_id, message_ids};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::ReadMessageContentsOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::read_message_contents_on_server(DialogId dialog_id, vector<MessageId> message_ids,
                                                      uint64 log_event_id, Promise<Unit> &&promise,
                                                      bool skip_log_event) {
  CHECK(!message_ids.empty());

  LOG(INFO) << "Read contents of " << format::as_array(message_ids) << " in " << dialog_id << " on server";

  if (log_event_id == 0 && G()->parameters().use_message_db && !skip_log_event) {
    log_event_id = save_read_message_contents_on_server_log_event(dialog_id, message_ids);
  }

  auto new_promise = get_erase_log_event_promise(log_event_id, std::move(promise));
  promise = std::move(new_promise);  // to prevent self-move

  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
      td_->create_handler<ReadMessagesContentsQuery>(std::move(promise))->send(std::move(message_ids));
      break;
    case DialogType::Channel:
      td_->create_handler<ReadChannelMessagesContentsQuery>(std::move(promise))
          ->send(dialog_id.get_channel_id(), std::move(message_ids));
      break;
    case DialogType::SecretChat: {
      CHECK(message_ids.size() == 1);
      auto m = get_message_force({dialog_id, message_ids[0]}, "read_message_contents_on_server");
      if (m != nullptr) {
        send_closure(G()->secret_chats_manager(), &SecretChatsManager::send_open_message,
                     dialog_id.get_secret_chat_id(), m->random_id, std::move(promise));
      } else {
        promise.set_error(Status::Error(400, "Message not found"));
      }
      break;
    }
    case DialogType::None:
    default:
      UNREACHABLE();
  }
}

void MessagesManager::open_dialog(Dialog *d) {
  DialogId dialog_id = d->dialog_id;
  if (d->is_opened || !have_input_peer(dialog_id, AccessRights::Read)) {
    return;
  }
  d->is_opened = true;

  auto min_message_id = MessageId(ServerMessageId(1));
  if (d->last_message_id == MessageId() && d->last_read_outbox_message_id < min_message_id && d->messages != nullptr &&
      d->messages->message_id < min_message_id) {
    Message *m = d->messages.get();
    while (m->right != nullptr) {
      m = m->right.get();
    }
    if (m->message_id < min_message_id) {
      read_history_inbox(dialog_id, m->message_id, -1, "open_dialog");
    }
  }

  if (d->has_unload_timeout) {
    LOG(INFO) << "Cancel unload timeout for " << dialog_id;
    pending_unload_dialog_timeout_.cancel_timeout(dialog_id.get());
    d->has_unload_timeout = false;
  }

  if (d->new_secret_chat_notification_id.is_valid()) {
    remove_new_secret_chat_notification(d, true);
  }

  get_dialog_pinned_message(dialog_id, Auto());

  if (d->active_group_call_id.is_valid()) {
    td_->group_call_manager_->reload_group_call(d->active_group_call_id, Auto());
  }

  switch (dialog_id.get_type()) {
    case DialogType::User:
      break;
    case DialogType::Chat:
      td_->contacts_manager_->repair_chat_participants(dialog_id.get_chat_id());
      reget_dialog_action_bar(dialog_id, "open_dialog");
      break;
    case DialogType::Channel:
      if (!is_broadcast_channel(dialog_id)) {
        auto participant_count = td_->contacts_manager_->get_channel_participant_count(dialog_id.get_channel_id());
        if (participant_count < 195) {  // include unknown participant_count
          td_->contacts_manager_->get_channel_participants(dialog_id.get_channel_id(),
                                                           td_api::make_object<td_api::supergroupMembersFilterRecent>(),
                                                           string(), 0, 200, 200, true, Auto());
        }
      }
      get_channel_difference(dialog_id, d->pts, true, "open_dialog");
      reget_dialog_action_bar(dialog_id, "open_dialog");
      break;
    case DialogType::SecretChat: {
      // to repair dialog action bar
      auto user_id = td_->contacts_manager_->get_secret_chat_user_id(dialog_id.get_secret_chat_id());
      if (user_id.is_valid()) {
        td_->contacts_manager_->reload_user_full(user_id);
      }
      break;
    }
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  if (!td_->auth_manager_->is_bot()) {
    auto online_count_it = dialog_online_member_counts_.find(dialog_id);
    if (online_count_it != dialog_online_member_counts_.end()) {
      auto &info = online_count_it->second;
      CHECK(!info.is_update_sent);
      if (Time::now() - info.updated_time < ONLINE_MEMBER_COUNT_CACHE_EXPIRE_TIME) {
        info.is_update_sent = true;
        send_update_chat_online_member_count(dialog_id, info.online_member_count);
      }
    }

    if (d->has_scheduled_database_messages && !d->is_has_scheduled_database_messages_checked) {
      CHECK(G()->parameters().use_message_db);

      LOG(INFO) << "Send check has_scheduled_database_messages request";
      d->is_has_scheduled_database_messages_checked = true;
      G()->td_db()->get_messages_db_async()->get_scheduled_messages(
          dialog_id, 1,
          PromiseCreator::lambda([dialog_id, actor_id = actor_id(this)](std::vector<BufferSlice> messages) {
            if (messages.empty()) {
              send_closure(actor_id, &MessagesManager::set_dialog_has_scheduled_database_messages, dialog_id, false);
            }
          }));
    }
  }
}

void MessagesManager::close_dialog(Dialog *d) {
  if (!d->is_opened) {
    return;
  }
  d->is_opened = false;

  auto dialog_id = d->dialog_id;
  if (have_input_peer(dialog_id, AccessRights::Write)) {
    if (pending_draft_message_timeout_.has_timeout(dialog_id.get())) {
      pending_draft_message_timeout_.set_timeout_in(dialog_id.get(), 0.0);
    }
  } else {
    pending_draft_message_timeout_.cancel_timeout(dialog_id.get());
  }

  if (have_input_peer(dialog_id, AccessRights::Read)) {
    if (pending_message_views_timeout_.has_timeout(dialog_id.get())) {
      pending_message_views_timeout_.set_timeout_in(dialog_id.get(), 0.0);
    }
    if (pending_read_history_timeout_.has_timeout(dialog_id.get())) {
      pending_read_history_timeout_.set_timeout_in(dialog_id.get(), 0.0);
    }
  } else {
    pending_message_views_timeout_.cancel_timeout(dialog_id.get());
    d->pending_viewed_message_ids.clear();
    d->increment_view_counter = false;

    pending_read_history_timeout_.cancel_timeout(dialog_id.get());
  }

  if (is_message_unload_enabled()) {
    CHECK(!d->has_unload_timeout);
    d->has_unload_timeout = true;
    pending_unload_dialog_timeout_.set_timeout_in(dialog_id.get(), get_unload_dialog_delay());
  }

  for (auto &it : d->pending_viewed_live_locations) {
    auto live_location_task_id = it.second;
    auto erased_count = viewed_live_location_tasks_.erase(live_location_task_id);
    CHECK(erased_count > 0);
  }
  d->pending_viewed_live_locations.clear();

  switch (dialog_id.get_type()) {
    case DialogType::User:
      break;
    case DialogType::Chat:
      break;
    case DialogType::Channel:
      channel_get_difference_timeout_.cancel_timeout(dialog_id.get());
      break;
    case DialogType::SecretChat:
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  if (!td_->auth_manager_->is_bot()) {
    auto online_count_it = dialog_online_member_counts_.find(dialog_id);
    if (online_count_it != dialog_online_member_counts_.end()) {
      auto &info = online_count_it->second;
      info.is_update_sent = false;
    }
    update_dialog_online_member_count_timeout_.set_timeout_in(dialog_id.get(), ONLINE_MEMBER_COUNT_CACHE_EXPIRE_TIME);
  }
}

td_api::object_ptr<td_api::ChatType> MessagesManager::get_chat_type_object(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      return td_api::make_object<td_api::chatTypePrivate>(
          td_->contacts_manager_->get_user_id_object(dialog_id.get_user_id(), "chatTypePrivate"));
    case DialogType::Chat:
      return td_api::make_object<td_api::chatTypeBasicGroup>(
          td_->contacts_manager_->get_basic_group_id_object(dialog_id.get_chat_id(), "chatTypeBasicGroup"));
    case DialogType::Channel: {
      auto channel_id = dialog_id.get_channel_id();
      auto channel_type = td_->contacts_manager_->get_channel_type(channel_id);
      return td_api::make_object<td_api::chatTypeSupergroup>(
          td_->contacts_manager_->get_supergroup_id_object(channel_id, "chatTypeSupergroup"),
          channel_type != ChannelType::Megagroup);
    }
    case DialogType::SecretChat: {
      auto secret_chat_id = dialog_id.get_secret_chat_id();
      auto user_id = td_->contacts_manager_->get_secret_chat_user_id(secret_chat_id);
      return td_api::make_object<td_api::chatTypeSecret>(
          td_->contacts_manager_->get_secret_chat_id_object(secret_chat_id, "chatTypeSecret"),
          td_->contacts_manager_->get_user_id_object(user_id, "chatTypeSecret"));
    }
    case DialogType::None:
    default:
      UNREACHABLE();
      return nullptr;
  }
}

td_api::object_ptr<td_api::ChatActionBar> MessagesManager::get_chat_action_bar_object(const Dialog *d,
                                                                                      bool hide_unarchive) const {
  CHECK(d != nullptr);
  if (d->dialog_id.get_type() == DialogType::SecretChat) {
    auto user_id = td_->contacts_manager_->get_secret_chat_user_id(d->dialog_id.get_secret_chat_id());
    if (!user_id.is_valid()) {
      return nullptr;
    }
    const Dialog *user_d = get_dialog(DialogId(user_id));
    if (user_d == nullptr) {
      return nullptr;
    }
    return get_chat_action_bar_object(user_d, d->folder_id != FolderId::archive());
  }

  if (!d->know_action_bar) {
    if (d->know_can_report_spam && d->dialog_id.get_type() != DialogType::SecretChat && d->can_report_spam) {
      return td_api::make_object<td_api::chatActionBarReportSpam>(false);
    }
    return nullptr;
  }

  if (d->can_report_location) {
    CHECK(d->dialog_id.get_type() == DialogType::Channel);
    CHECK(!d->can_share_phone_number && !d->can_block_user && !d->can_add_contact && !d->can_report_spam &&
          !d->can_invite_members);
    return td_api::make_object<td_api::chatActionBarReportUnrelatedLocation>();
  }
  if (d->can_invite_members) {
    CHECK(!d->can_share_phone_number && !d->can_block_user && !d->can_add_contact && !d->can_report_spam);
    return td_api::make_object<td_api::chatActionBarInviteMembers>();
  }
  if (d->can_share_phone_number) {
    CHECK(d->dialog_id.get_type() == DialogType::User);
    CHECK(!d->can_block_user && !d->can_add_contact && !d->can_report_spam);
    return td_api::make_object<td_api::chatActionBarSharePhoneNumber>();
  }
  if (hide_unarchive) {
    if (d->can_add_contact) {
      return td_api::make_object<td_api::chatActionBarAddContact>();
    } else {
      return nullptr;
    }
  }
  if (d->can_block_user) {
    CHECK(d->dialog_id.get_type() == DialogType::User);
    CHECK(d->can_report_spam && d->can_add_contact);
    auto distance = d->hide_distance ? -1 : d->distance;
    return td_api::make_object<td_api::chatActionBarReportAddBlock>(d->can_unarchive, distance);
  }
  if (d->can_add_contact) {
    CHECK(d->dialog_id.get_type() == DialogType::User);
    CHECK(!d->can_report_spam);
    return td_api::make_object<td_api::chatActionBarAddContact>();
  }
  if (d->can_report_spam) {
    return td_api::make_object<td_api::chatActionBarReportSpam>(d->can_unarchive);
  }
  return nullptr;
}

td_api::object_ptr<td_api::chat> MessagesManager::get_chat_object(const Dialog *d) const {
  CHECK(d != nullptr);

  auto chat_source = is_dialog_sponsored(d) ? sponsored_dialog_source_.get_chat_source_object() : nullptr;

  bool can_delete_for_self = false;
  bool can_delete_for_all_users = false;
  if (chat_source != nullptr) {
    switch (chat_source->get_id()) {
      case td_api::chatSourcePublicServiceAnnouncement::ID:
        // can delete for self (but only while removing from dialog list)
        can_delete_for_self = true;
        break;
      default:
        // can't delete
        break;
    }
  } else if (!td_->auth_manager_->is_bot() && have_input_peer(d->dialog_id, AccessRights::Read)) {
    switch (d->dialog_id.get_type()) {
      case DialogType::User:
        can_delete_for_self = true;
        can_delete_for_all_users = G()->shared_config().get_option_boolean("revoke_pm_inbox", true);
        if (d->dialog_id == get_my_dialog_id() || td_->contacts_manager_->is_user_deleted(d->dialog_id.get_user_id()) ||
            td_->contacts_manager_->is_user_bot(d->dialog_id.get_user_id())) {
          can_delete_for_all_users = false;
        }
        break;
      case DialogType::Chat:
        // chats can't be deleted only for self with deleteChatHistory
        can_delete_for_self = true;
        break;
      case DialogType::Channel:
        if (is_broadcast_channel(d->dialog_id) ||
            td_->contacts_manager_->is_channel_public(d->dialog_id.get_channel_id())) {
          // deleteChatHistory can't be used in channels and public supergroups
        } else {
          // private supergroups can be deleted for self
          can_delete_for_self = true;
        }
        break;
      case DialogType::SecretChat:
        if (td_->contacts_manager_->get_secret_chat_state(d->dialog_id.get_secret_chat_id()) ==
            SecretChatState::Closed) {
          // in a closed secret chats there is no way to delete messages for both users
          can_delete_for_self = true;
        } else {
          // active secret chats can be deleted only for both users
          can_delete_for_all_users = true;
        }
        break;
      case DialogType::None:
      default:
        UNREACHABLE();
    }
  }

  // TODO hide/show draft message when can_send_message(dialog_id) changes
  auto draft_message = can_send_message(d->dialog_id).is_ok() ? get_draft_message_object(d->draft_message) : nullptr;

  auto active_group_call_id = td_->group_call_manager_->get_group_call_id(d->active_group_call_id, d->dialog_id);

  return make_tl_object<td_api::chat>(
      d->dialog_id.get(), get_chat_type_object(d->dialog_id), get_dialog_title(d->dialog_id),
      get_chat_photo_info_object(td_->file_manager_.get(), get_dialog_photo(d->dialog_id)),
      get_dialog_permissions(d->dialog_id).get_chat_permissions_object(),
      get_message_object(d->dialog_id, get_message(d, d->last_message_id)), get_chat_positions_object(d),
      d->is_marked_as_unread, d->is_blocked, get_dialog_has_scheduled_messages(d), can_delete_for_self,
      can_delete_for_all_users, can_report_dialog(d->dialog_id), d->notification_settings.silent_send_message,
      d->server_unread_count + d->local_unread_count, d->last_read_inbox_message_id.get(),
      d->last_read_outbox_message_id.get(), d->unread_mention_count,
      get_chat_notification_settings_object(&d->notification_settings),
      d->message_ttl_setting.get_message_ttl_setting_object(), get_chat_action_bar_object(d),
      active_group_call_id.get(), active_group_call_id.is_valid() ? d->is_group_call_empty : true,
      d->reply_markup_message_id.get(), std::move(draft_message), d->client_data);
}

tl_object_ptr<td_api::chat> MessagesManager::get_chat_object(DialogId dialog_id) const {
  return get_chat_object(get_dialog(dialog_id));
}

tl_object_ptr<td_api::chats> MessagesManager::get_chats_object(int32 total_count, const vector<DialogId> &dialog_ids) {
  if (total_count == -1) {
    total_count = narrow_cast<int32>(dialog_ids.size());
  }
  return td_api::make_object<td_api::chats>(total_count,
                                            transform(dialog_ids, [](DialogId dialog_id) { return dialog_id.get(); }));
}

tl_object_ptr<td_api::chats> MessagesManager::get_chats_object(const std::pair<int32, vector<DialogId>> &dialog_ids) {
  return get_chats_object(dialog_ids.first, dialog_ids.second);
}

td_api::object_ptr<td_api::chatFilter> MessagesManager::get_chat_filter_object(DialogFilterId dialog_filter_id) const {
  CHECK(!td_->auth_manager_->is_bot());
  auto filter = get_dialog_filter(dialog_filter_id);
  if (filter == nullptr) {
    return nullptr;
  }

  return get_chat_filter_object(filter);
}

td_api::object_ptr<td_api::chatFilter> MessagesManager::get_chat_filter_object(const DialogFilter *filter) const {
  auto get_chat_ids = [this,
                       dialog_filter_id = filter->dialog_filter_id](const vector<InputDialogId> &input_dialog_ids) {
    vector<int64> chat_ids;
    chat_ids.reserve(input_dialog_ids.size());
    for (auto &input_dialog_id : input_dialog_ids) {
      auto dialog_id = input_dialog_id.get_dialog_id();
      const Dialog *d = get_dialog(dialog_id);
      if (d != nullptr) {
        if (d->order != DEFAULT_ORDER) {
          chat_ids.push_back(dialog_id.get());
        } else {
          LOG(INFO) << "Skip nonjoined " << dialog_id << " from " << dialog_filter_id;
        }
      } else {
        LOG(ERROR) << "Can't find " << dialog_id << " from " << dialog_filter_id;
      }
    }
    return chat_ids;
  };
  return td_api::make_object<td_api::chatFilter>(
      filter->title, filter->get_icon_name(), get_chat_ids(filter->pinned_dialog_ids),
      get_chat_ids(filter->included_dialog_ids), get_chat_ids(filter->excluded_dialog_ids), filter->exclude_muted,
      filter->exclude_read, filter->exclude_archived, filter->include_contacts, filter->include_non_contacts,
      filter->include_bots, filter->include_groups, filter->include_channels);
}

td_api::object_ptr<td_api::updateScopeNotificationSettings>
MessagesManager::get_update_scope_notification_settings_object(NotificationSettingsScope scope) const {
  auto notification_settings = get_scope_notification_settings(scope);
  CHECK(notification_settings != nullptr);
  return td_api::make_object<td_api::updateScopeNotificationSettings>(
      get_notification_settings_scope_object(scope), get_scope_notification_settings_object(notification_settings));
}

std::pair<bool, int32> MessagesManager::get_dialog_mute_until(DialogId dialog_id, const Dialog *d) const {
  CHECK(!td_->auth_manager_->is_bot());
  if (d == nullptr || !d->notification_settings.is_synchronized) {
    return {false, get_scope_mute_until(dialog_id)};
  }

  return {d->notification_settings.is_use_default_fixed, get_dialog_mute_until(d)};
}

NotificationSettingsScope MessagesManager::get_dialog_notification_setting_scope(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::SecretChat:
      return NotificationSettingsScope::Private;
    case DialogType::Chat:
      return NotificationSettingsScope::Group;
    case DialogType::Channel:
      return is_broadcast_channel(dialog_id) ? NotificationSettingsScope::Channel : NotificationSettingsScope::Group;
    case DialogType::None:
    default:
      UNREACHABLE();
      return NotificationSettingsScope::Private;
  }
}

int32 MessagesManager::get_scope_mute_until(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::SecretChat:
      return users_notification_settings_.mute_until;
    case DialogType::Chat:
      return chats_notification_settings_.mute_until;
    case DialogType::Channel:
      return is_broadcast_channel(dialog_id) ? channels_notification_settings_.mute_until
                                             : chats_notification_settings_.mute_until;
    case DialogType::None:
    default:
      UNREACHABLE();
      return 0;
  }
}

vector<DialogId> MessagesManager::get_dialog_notification_settings_exceptions(NotificationSettingsScope scope,
                                                                              bool filter_scope, bool compare_sound,
                                                                              bool force, Promise<Unit> &&promise) {
  CHECK(!td_->auth_manager_->is_bot());
  bool have_all_dialogs = true;
  for (const auto &list : dialog_folders_) {
    if (list.second.folder_last_dialog_date_ != MAX_DIALOG_DATE) {
      have_all_dialogs = false;
    }
  }

  if (have_all_dialogs || force) {
    vector<DialogDate> ordered_dialogs;
    auto my_dialog_id = get_my_dialog_id();
    for (const auto &list : dialog_folders_) {
      for (const auto &it : list.second.ordered_dialogs_) {
        auto dialog_id = it.get_dialog_id();
        if (filter_scope && get_dialog_notification_setting_scope(dialog_id) != scope) {
          continue;
        }
        if (dialog_id == my_dialog_id) {
          continue;
        }

        const Dialog *d = get_dialog(dialog_id);
        CHECK(d != nullptr);
        if (d->order == DEFAULT_ORDER) {
          break;
        }
        if (are_default_dialog_notification_settings(d->notification_settings, compare_sound)) {
          continue;
        }
        if (is_dialog_message_notification_disabled(dialog_id, std::numeric_limits<int32>::max())) {
          continue;
        }
        ordered_dialogs.push_back(DialogDate(get_dialog_base_order(d), dialog_id));
      }
    }
    std::sort(ordered_dialogs.begin(), ordered_dialogs.end());

    vector<DialogId> result;
    for (auto &it : ordered_dialogs) {
      CHECK(result.empty() || result.back() != it.get_dialog_id());
      result.push_back(it.get_dialog_id());
    }
    promise.set_value(Unit());
    return result;
  }

  for (const auto &folder : dialog_folders_) {
    load_folder_dialog_list(folder.first, MAX_GET_DIALOGS, true, Auto());
  }

  td_->create_handler<GetNotifySettingsExceptionsQuery>(std::move(promise))->send(scope, filter_scope, compare_sound);
  return {};
}

const ScopeNotificationSettings *MessagesManager::get_scope_notification_settings(NotificationSettingsScope scope,
                                                                                  Promise<Unit> &&promise) {
  const ScopeNotificationSettings *notification_settings = get_scope_notification_settings(scope);
  CHECK(notification_settings != nullptr);
  if (!notification_settings->is_synchronized && !td_->auth_manager_->is_bot()) {
    send_get_scope_notification_settings_query(scope, std::move(promise));
    return nullptr;
  }

  promise.set_value(Unit());
  return notification_settings;
}

DialogNotificationSettings *MessagesManager::get_dialog_notification_settings(DialogId dialog_id, bool force) {
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return nullptr;
  }
  if (!force && !have_input_peer(dialog_id, AccessRights::Read)) {
    return nullptr;
  }
  return &d->notification_settings;
}

ScopeNotificationSettings *MessagesManager::get_scope_notification_settings(NotificationSettingsScope scope) {
  switch (scope) {
    case NotificationSettingsScope::Private:
      return &users_notification_settings_;
    case NotificationSettingsScope::Group:
      return &chats_notification_settings_;
    case NotificationSettingsScope::Channel:
      return &channels_notification_settings_;
    default:
      UNREACHABLE();
      return nullptr;
  }
}

const ScopeNotificationSettings *MessagesManager::get_scope_notification_settings(
    NotificationSettingsScope scope) const {
  switch (scope) {
    case NotificationSettingsScope::Private:
      return &users_notification_settings_;
    case NotificationSettingsScope::Group:
      return &chats_notification_settings_;
    case NotificationSettingsScope::Channel:
      return &channels_notification_settings_;
    default:
      UNREACHABLE();
      return nullptr;
  }
}

tl_object_ptr<telegram_api::InputNotifyPeer> MessagesManager::get_input_notify_peer(DialogId dialog_id) const {
  if (get_dialog(dialog_id) == nullptr) {
    return nullptr;
  }
  auto input_peer = get_input_peer(dialog_id, AccessRights::Read);
  if (input_peer == nullptr) {
    return nullptr;
  }
  return make_tl_object<telegram_api::inputNotifyPeer>(std::move(input_peer));
}

Status MessagesManager::set_dialog_notification_settings(
    DialogId dialog_id, tl_object_ptr<td_api::chatNotificationSettings> &&notification_settings) {
  CHECK(!td_->auth_manager_->is_bot());
  auto current_settings = get_dialog_notification_settings(dialog_id, false);
  if (current_settings == nullptr) {
    return Status::Error(6, "Wrong chat identifier specified");
  }
  if (dialog_id == get_my_dialog_id()) {
    return Status::Error(6, "Notification settings of the Saved Messages chat can't be changed");
  }

  TRY_RESULT(new_settings, ::td::get_dialog_notification_settings(std::move(notification_settings),
                                                                  current_settings->silent_send_message));
  if (update_dialog_notification_settings(dialog_id, current_settings, new_settings)) {
    update_dialog_notification_settings_on_server(dialog_id, false);
  }
  return Status::OK();
}

Status MessagesManager::set_scope_notification_settings(
    NotificationSettingsScope scope, tl_object_ptr<td_api::scopeNotificationSettings> &&notification_settings) {
  CHECK(!td_->auth_manager_->is_bot());
  TRY_RESULT(new_settings, ::td::get_scope_notification_settings(std::move(notification_settings)));
  if (update_scope_notification_settings(scope, get_scope_notification_settings(scope), new_settings)) {
    update_scope_notification_settings_on_server(scope, 0);
  }
  return Status::OK();
}

class MessagesManager::UpdateScopeNotificationSettingsOnServerLogEvent {
 public:
  NotificationSettingsScope scope_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(scope_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(scope_, parser);
  }
};

uint64 MessagesManager::save_update_scope_notification_settings_on_server_log_event(NotificationSettingsScope scope) {
  UpdateScopeNotificationSettingsOnServerLogEvent log_event{scope};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::UpdateScopeNotificationSettingsOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::update_scope_notification_settings_on_server(NotificationSettingsScope scope,
                                                                   uint64 log_event_id) {
  CHECK(!td_->auth_manager_->is_bot());
  if (log_event_id == 0) {
    log_event_id = save_update_scope_notification_settings_on_server_log_event(scope);
  }

  LOG(INFO) << "Update " << scope << " notification settings on server with log_event " << log_event_id;
  td_->create_handler<UpdateScopeNotifySettingsQuery>(get_erase_log_event_promise(log_event_id))
      ->send(scope, *get_scope_notification_settings(scope));
}

void MessagesManager::reset_all_notification_settings() {
  CHECK(!td_->auth_manager_->is_bot());
  DialogNotificationSettings new_dialog_settings;
  ScopeNotificationSettings new_scope_settings;
  new_dialog_settings.is_synchronized = true;
  new_scope_settings.is_synchronized = true;

  update_scope_notification_settings(NotificationSettingsScope::Private, &users_notification_settings_,
                                     new_scope_settings);
  update_scope_notification_settings(NotificationSettingsScope::Group, &chats_notification_settings_,
                                     new_scope_settings);
  update_scope_notification_settings(NotificationSettingsScope::Channel, &channels_notification_settings_,
                                     new_scope_settings);

  for (auto &dialog : dialogs_) {
    Dialog *d = dialog.second.get();
    update_dialog_notification_settings(d->dialog_id, &d->notification_settings, new_dialog_settings);
  }
  reset_all_notification_settings_on_server(0);
}

class MessagesManager::ResetAllNotificationSettingsOnServerLogEvent {
 public:
  template <class StorerT>
  void store(StorerT &storer) const {
  }

  template <class ParserT>
  void parse(ParserT &parser) {
  }
};

uint64 MessagesManager::save_reset_all_notification_settings_on_server_log_event() {
  ResetAllNotificationSettingsOnServerLogEvent log_event;
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::ResetAllNotificationSettingsOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::reset_all_notification_settings_on_server(uint64 log_event_id) {
  CHECK(!td_->auth_manager_->is_bot());
  if (log_event_id == 0) {
    log_event_id = save_reset_all_notification_settings_on_server_log_event();
  }

  LOG(INFO) << "Reset all notification settings";
  td_->create_handler<ResetNotifySettingsQuery>(get_erase_log_event_promise(log_event_id))->send();
}

tl_object_ptr<td_api::messages> MessagesManager::get_dialog_history(DialogId dialog_id, MessageId from_message_id,
                                                                    int32 offset, int32 limit, int left_tries,
                                                                    bool only_local, Promise<Unit> &&promise) {
  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit must be positive"));
    return nullptr;
  }
  if (limit > MAX_GET_HISTORY) {
    limit = MAX_GET_HISTORY;
  }
  if (offset > 0) {
    promise.set_error(Status::Error(5, "Parameter offset must be non-positive"));
    return nullptr;
  }
  if (offset <= -MAX_GET_HISTORY) {
    promise.set_error(Status::Error(5, "Parameter offset must be greater than -100"));
    return nullptr;
  }
  if (offset < -limit) {
    promise.set_error(Status::Error(5, "Parameter offset must be greater than or equal to -limit"));
    return nullptr;
  }
  bool is_limit_increased = false;
  if (limit == -offset) {
    limit++;
    is_limit_increased = true;
  }
  CHECK(0 < limit && limit <= MAX_GET_HISTORY);
  CHECK(-limit < offset && offset <= 0);

  if (from_message_id == MessageId() || from_message_id.get() > MessageId::max().get()) {
    from_message_id = MessageId::max();
  }
  if (!from_message_id.is_valid()) {
    promise.set_error(Status::Error(3, "Invalid value of parameter from_message_id specified"));
    return nullptr;
  }

  const Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(6, "Chat not found"));
    return nullptr;
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    promise.set_error(Status::Error(5, "Can't access the chat"));
    return nullptr;
  }

  LOG(INFO) << "Get " << (only_local ? "local " : "") << "history in " << dialog_id << " from " << from_message_id
            << " with offset " << offset << " and limit " << limit << ", " << left_tries
            << " tries left. Last read inbox message is " << d->last_read_inbox_message_id
            << ", last read outbox message is " << d->last_read_outbox_message_id
            << ", have_full_history = " << d->have_full_history;

  MessagesConstIterator p(d, from_message_id);
  LOG(DEBUG) << "Iterator points to " << (*p ? (*p)->message_id : MessageId());
  bool from_the_end = (d->last_message_id != MessageId() && from_message_id > d->last_message_id) ||
                      from_message_id >= MessageId::max();

  if (from_the_end) {
    limit += offset;
    offset = 0;
    if (d->last_message_id == MessageId()) {
      p = MessagesConstIterator();
    }
  } else {
    bool have_a_gap = false;
    if (*p == nullptr) {
      // there is no gap if from_message_id is less than first message in the dialog
      if (left_tries == 0 && d->messages != nullptr && offset < 0) {
        const Message *cur = d->messages.get();
        while (cur->left != nullptr) {
          cur = cur->left.get();
        }
        CHECK(cur->message_id > from_message_id);
        from_message_id = cur->message_id;
        p = MessagesConstIterator(d, from_message_id);
      } else {
        have_a_gap = true;
      }
    } else if ((*p)->message_id != from_message_id) {
      CHECK((*p)->message_id < from_message_id);
      if (!(*p)->have_next && (d->last_message_id == MessageId() || (*p)->message_id < d->last_message_id)) {
        have_a_gap = true;
      }
    }

    if (have_a_gap) {
      LOG(INFO) << "Have a gap near message to get chat history from";
      p = MessagesConstIterator();
    }
    if (*p != nullptr && (*p)->message_id == from_message_id) {
      if (offset < 0) {
        offset++;
      } else {
        --p;
      }
    }

    while (*p != nullptr && offset < 0) {
      ++p;
      if (*p) {
        ++offset;
        from_message_id = (*p)->message_id;
      }
    }

    if (offset < 0 && ((d->last_message_id != MessageId() && from_message_id >= d->last_message_id) ||
                       (!have_a_gap && left_tries == 0))) {
      CHECK(!have_a_gap);
      limit += offset;
      offset = 0;
      p = MessagesConstIterator(d, from_message_id);
    }

    if (!have_a_gap && offset < 0) {
      offset--;
    }
  }

  LOG(INFO) << "Iterator after applying offset points to " << (*p ? (*p)->message_id : MessageId())
            << ", offset = " << offset << ", limit = " << limit << ", from_the_end = " << from_the_end;
  vector<tl_object_ptr<td_api::message>> messages;
  if (*p != nullptr && offset == 0) {
    while (*p != nullptr && messages.size() < static_cast<size_t>(limit)) {
      messages.push_back(get_message_object(dialog_id, *p));
      from_message_id = (*p)->message_id;
      --p;
    }
  }

  if (messages.size()) {
    // maybe need some messages
    CHECK(offset == 0);
    preload_newer_messages(d, MessageId(messages[0]->id_));
    preload_older_messages(d, MessageId(messages.back()->id_));
  } else if (messages.size() < static_cast<size_t>(limit) && left_tries != 0 &&
             !(d->is_empty && d->have_full_history && left_tries < 3)) {
    // there can be more messages in the database or on the server, need to load them
    if (from_the_end) {
      from_message_id = MessageId();
    }
    send_closure_later(actor_id(this), &MessagesManager::load_messages, d->dialog_id, from_message_id, offset,
                       limit - static_cast<int32>(messages.size()), left_tries, only_local, std::move(promise));
    return nullptr;
  }

  LOG(INFO) << "Have " << messages.size() << " messages out of requested "
            << (is_limit_increased ? "increased " : "exact ") << limit;
  if (is_limit_increased && static_cast<size_t>(limit) == messages.size()) {
    messages.pop_back();
  }

  LOG(INFO) << "Return " << messages.size() << " messages in result to getChatHistory";
  promise.set_value(Unit());                                   // can return some messages
  return get_messages_object(-1, std::move(messages), false);  // TODO return real total_count of messages in the dialog
}

class MessagesManager::ReadHistoryOnServerLogEvent {
 public:
  DialogId dialog_id_;
  MessageId max_message_id_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
    td::store(max_message_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
    td::parse(max_message_id_, parser);
  }
};

class MessagesManager::ReadHistoryInSecretChatLogEvent {
 public:
  DialogId dialog_id_;
  int32 max_date_ = 0;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
    td::store(max_date_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
    td::parse(max_date_, parser);
  }
};

class MessagesManager::ReadMessageThreadHistoryOnServerLogEvent {
 public:
  DialogId dialog_id_;
  MessageId top_thread_message_id_;
  MessageId max_message_id_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
    td::store(top_thread_message_id_, storer);
    td::store(max_message_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
    td::parse(top_thread_message_id_, parser);
    td::parse(max_message_id_, parser);
  }
};

void MessagesManager::read_history_on_server(Dialog *d, MessageId max_message_id) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  CHECK(!max_message_id.is_scheduled());

  auto dialog_id = d->dialog_id;
  LOG(INFO) << "Read history in " << dialog_id << " on server up to " << max_message_id;

  bool is_secret = dialog_id.get_type() == DialogType::SecretChat;
  if (is_secret) {
    auto *m = get_message_force(d, max_message_id, "read_history_on_server");
    if (m == nullptr) {
      LOG(ERROR) << "Failed to read history in " << dialog_id << " up to " << max_message_id;
      return;
    }

    ReadHistoryInSecretChatLogEvent log_event;
    log_event.dialog_id_ = dialog_id;
    log_event.max_date_ = m->date;
    add_log_event(d->read_history_log_event_ids[0], get_log_event_storer(log_event),
                  LogEvent::HandlerType::ReadHistoryInSecretChat, "read history");

    d->last_read_inbox_message_date = m->date;
  } else if (G()->parameters().use_message_db) {
    ReadHistoryOnServerLogEvent log_event;
    log_event.dialog_id_ = dialog_id;
    log_event.max_message_id_ = max_message_id;
    add_log_event(d->read_history_log_event_ids[0], get_log_event_storer(log_event),
                  LogEvent::HandlerType::ReadHistoryOnServer, "read history");
  }

  d->updated_read_history_message_ids.insert(MessageId());

  bool need_delay = d->is_opened && !is_secret && d->server_unread_count > 0;
  pending_read_history_timeout_.set_timeout_in(dialog_id.get(), need_delay ? MIN_READ_HISTORY_DELAY : 0);
}

void MessagesManager::read_message_thread_history_on_server(Dialog *d, MessageId top_thread_message_id,
                                                            MessageId max_message_id, MessageId last_message_id) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  CHECK(top_thread_message_id.is_valid());
  CHECK(top_thread_message_id.is_server());
  CHECK(max_message_id.is_server());

  auto dialog_id = d->dialog_id;
  LOG(INFO) << "Read history in thread of " << top_thread_message_id << " in " << dialog_id << " on server up to "
            << max_message_id;

  if (G()->parameters().use_message_db) {
    ReadMessageThreadHistoryOnServerLogEvent log_event;
    log_event.dialog_id_ = dialog_id;
    log_event.top_thread_message_id_ = top_thread_message_id;
    log_event.max_message_id_ = max_message_id;
    add_log_event(d->read_history_log_event_ids[top_thread_message_id.get()], get_log_event_storer(log_event),
                  LogEvent::HandlerType::ReadMessageThreadHistoryOnServer, "read history");
  }

  d->updated_read_history_message_ids.insert(top_thread_message_id);

  bool need_delay = d->is_opened && last_message_id.is_valid() && max_message_id != last_message_id;
  pending_read_history_timeout_.set_timeout_in(dialog_id.get(), need_delay ? MIN_READ_HISTORY_DELAY : 0);
}

void MessagesManager::do_read_history_on_server(DialogId dialog_id) {
  if (G()->close_flag()) {
    return;
  }

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  for (auto top_thread_message_id : d->updated_read_history_message_ids) {
    if (!top_thread_message_id.is_valid()) {
      read_history_on_server_impl(d, MessageId());
    } else {
      read_message_thread_history_on_server_impl(d, top_thread_message_id, MessageId());
    }
  }
  reset_to_empty(d->updated_read_history_message_ids);
}

void MessagesManager::read_history_on_server_impl(Dialog *d, MessageId max_message_id) {
  CHECK(d != nullptr);
  auto dialog_id = d->dialog_id;

  {
    auto message_id = d->last_read_inbox_message_id;
    if (dialog_id.get_type() != DialogType::SecretChat) {
      message_id = message_id.get_prev_server_message_id();
    }
    if (message_id > max_message_id) {
      max_message_id = message_id;
    }
  }

  Promise<> promise;
  if (d->read_history_log_event_ids[0].log_event_id != 0) {
    d->read_history_log_event_ids[0].generation++;
    promise = PromiseCreator::lambda([actor_id = actor_id(this), dialog_id,
                                      generation = d->read_history_log_event_ids[0].generation](Result<Unit> result) {
      if (!G()->close_flag()) {
        send_closure(actor_id, &MessagesManager::on_read_history_finished, dialog_id, MessageId(), generation);
      }
    });
  }
  if (d->need_repair_server_unread_count && need_unread_counter(d->order)) {
    repair_server_unread_count(dialog_id, d->server_unread_count);
  }

  if (!max_message_id.is_valid() || !have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_value(Unit());
  }

  LOG(INFO) << "Send read history request in " << dialog_id << " up to " << max_message_id;
  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
      td_->create_handler<ReadHistoryQuery>(std::move(promise))->send(dialog_id, max_message_id);
      break;
    case DialogType::Channel: {
      auto channel_id = dialog_id.get_channel_id();
      td_->create_handler<ReadChannelHistoryQuery>(std::move(promise))->send(channel_id, max_message_id);
      break;
    }
    case DialogType::SecretChat: {
      auto secret_chat_id = dialog_id.get_secret_chat_id();
      auto date = d->last_read_inbox_message_date;
      auto *m = get_message_force(d, max_message_id, "read_history_on_server_impl");
      if (m != nullptr && m->date > date) {
        date = m->date;
      }
      if (date == 0) {
        LOG(ERROR) << "Don't know last read inbox message date in " << dialog_id;
        return promise.set_value(Unit());
      }
      send_closure(G()->secret_chats_manager(), &SecretChatsManager::send_read_history, secret_chat_id, date,
                   std::move(promise));
      break;
    }
    case DialogType::None:
    default:
      UNREACHABLE();
  }
}

void MessagesManager::read_message_thread_history_on_server_impl(Dialog *d, MessageId top_thread_message_id,
                                                                 MessageId max_message_id) {
  CHECK(d != nullptr);
  auto dialog_id = d->dialog_id;
  CHECK(dialog_id.get_type() == DialogType::Channel);

  const Message *m = get_message_force(d, top_thread_message_id, "read_message_thread_history_on_server_impl");
  if (m != nullptr) {
    auto message_id = m->reply_info.last_read_inbox_message_id.get_prev_server_message_id();
    if (message_id > max_message_id) {
      max_message_id = message_id;
    }
  }

  Promise<> promise;
  if (d->read_history_log_event_ids[top_thread_message_id.get()].log_event_id != 0) {
    d->read_history_log_event_ids[top_thread_message_id.get()].generation++;
    promise = PromiseCreator::lambda(
        [actor_id = actor_id(this), dialog_id, top_thread_message_id,
         generation = d->read_history_log_event_ids[top_thread_message_id.get()].generation](Result<Unit> result) {
          if (!G()->close_flag()) {
            send_closure(actor_id, &MessagesManager::on_read_history_finished, dialog_id, top_thread_message_id,
                         generation);
          }
        });
  }

  if (!max_message_id.is_valid() || !have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_value(Unit());
  }

  LOG(INFO) << "Send read history request in thread of " << top_thread_message_id << " in " << dialog_id << " up to "
            << max_message_id;
  td_->create_handler<ReadDiscussionQuery>(std::move(promise))->send(dialog_id, top_thread_message_id, max_message_id);
}

void MessagesManager::on_read_history_finished(DialogId dialog_id, MessageId top_thread_message_id, uint64 generation) {
  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  auto it = d->read_history_log_event_ids.find(top_thread_message_id.get());
  if (it == d->read_history_log_event_ids.end()) {
    return;
  }
  delete_log_event(it->second, generation, "read history");
  if (it->second.log_event_id == 0) {
    d->read_history_log_event_ids.erase(it);
  }
}

template <class T, class It>
vector<MessageId> MessagesManager::get_message_history_slice(const T &begin, It it, const T &end,
                                                             MessageId from_message_id, int32 offset, int32 limit) {
  int32 left_offset = -offset;
  int32 left_limit = limit + offset;
  while (left_offset > 0 && it != end) {
    ++it;
    left_offset--;
    left_limit++;
  }

  vector<MessageId> message_ids;
  while (left_limit > 0 && it != begin) {
    --it;
    left_limit--;
    message_ids.push_back(*it);
  }
  return message_ids;
}

std::pair<DialogId, vector<MessageId>> MessagesManager::get_message_thread_history(
    DialogId dialog_id, MessageId message_id, MessageId from_message_id, int32 offset, int32 limit, int64 &random_id,
    Promise<Unit> &&promise) {
  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit must be positive"));
    return {};
  }
  if (limit > MAX_GET_HISTORY) {
    limit = MAX_GET_HISTORY;
  }
  if (offset > 0) {
    promise.set_error(Status::Error(5, "Parameter offset must be non-positive"));
    return {};
  }
  if (offset <= -MAX_GET_HISTORY) {
    promise.set_error(Status::Error(5, "Parameter offset must be greater than -100"));
    return {};
  }
  if (offset < -limit) {
    promise.set_error(Status::Error(5, "Parameter offset must be greater than or equal to -limit"));
    return {};
  }
  bool is_limit_increased = false;
  if (limit == -offset) {
    limit++;
    is_limit_increased = true;
  }
  CHECK(0 < limit && limit <= MAX_GET_HISTORY);
  CHECK(-limit < offset && offset <= 0);

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(6, "Chat not found"));
    return {};
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    promise.set_error(Status::Error(5, "Can't access the chat"));
    return {};
  }
  if (dialog_id.get_type() != DialogType::Channel) {
    promise.set_error(Status::Error(400, "Can't get message thread history in the chat"));
    return {};
  }

  if (from_message_id == MessageId() || from_message_id.get() > MessageId::max().get()) {
    from_message_id = MessageId::max();
  }
  if (!from_message_id.is_valid()) {
    promise.set_error(Status::Error(3, "Parameter from_message_id must be identifier of the chat message or 0"));
    return {};
  }

  FullMessageId top_thread_full_message_id;
  {
    Message *m = get_message_force(d, message_id, "get_message_thread_history 1");
    if (m == nullptr) {
      promise.set_error(Status::Error(400, "Message not found"));
      return {};
    }

    auto r_top_thread_full_message_id = get_top_thread_full_message_id(dialog_id, m);
    if (r_top_thread_full_message_id.is_error()) {
      promise.set_error(r_top_thread_full_message_id.move_as_error());
      return {};
    }
    top_thread_full_message_id = r_top_thread_full_message_id.move_as_ok();

    if (!top_thread_full_message_id.get_message_id().is_valid()) {
      CHECK(m->reply_info.is_comment);
      get_message_thread(
          dialog_id, message_id,
          PromiseCreator::lambda([promise = std::move(promise)](Result<MessageThreadInfo> &&result) mutable {
            if (result.is_error()) {
              promise.set_error(result.move_as_error());
            } else {
              promise.set_value(Unit());
            }
          }));
      return {};
    }
  }

  if (random_id != 0) {
    // request has already been sent before
    auto it = found_dialog_messages_.find(random_id);
    CHECK(it != found_dialog_messages_.end());
    auto result = std::move(it->second.second);
    found_dialog_messages_.erase(it);

    auto dialog_id_it = found_dialog_messages_dialog_id_.find(random_id);
    if (dialog_id_it != found_dialog_messages_dialog_id_.end()) {
      dialog_id = dialog_id_it->second;
      found_dialog_messages_dialog_id_.erase(dialog_id_it);

      d = get_dialog(dialog_id);
      CHECK(d != nullptr);
    }
    if (dialog_id != top_thread_full_message_id.get_dialog_id()) {
      promise.set_error(Status::Error(500, "Receive messages in an unexpected chat"));
      return {};
    }

    auto yet_unsent_it = d->yet_unsent_thread_message_ids.find(top_thread_full_message_id.get_message_id());
    if (yet_unsent_it != d->yet_unsent_thread_message_ids.end()) {
      const std::set<MessageId> &message_ids = yet_unsent_it->second;
      auto merge_message_ids = get_message_history_slice(message_ids.begin(), message_ids.lower_bound(from_message_id),
                                                         message_ids.end(), from_message_id, offset, limit);
      vector<MessageId> new_result(result.size() + merge_message_ids.size());
      std::merge(result.begin(), result.end(), merge_message_ids.begin(), merge_message_ids.end(), new_result.begin(),
                 std::greater<>());
      result = std::move(new_result);
    }

    Message *top_m = get_message_force(d, top_thread_full_message_id.get_message_id(), "get_message_thread_history 2");
    if (top_m != nullptr && !top_m->local_thread_message_ids.empty()) {
      vector<MessageId> &message_ids = top_m->local_thread_message_ids;
      vector<MessageId> merge_message_ids;
      while (true) {
        merge_message_ids = get_message_history_slice(
            message_ids.begin(), std::lower_bound(message_ids.begin(), message_ids.end(), from_message_id),
            message_ids.end(), from_message_id, offset, limit);
        bool found_deleted = false;
        for (auto local_message_id : merge_message_ids) {
          Message *local_m = get_message_force(d, local_message_id, "get_message_thread_history 3");
          if (local_m == nullptr) {
            auto local_it = std::lower_bound(message_ids.begin(), message_ids.end(), local_message_id);
            CHECK(local_it != message_ids.end() && *local_it == local_message_id);
            message_ids.erase(local_it);
            found_deleted = true;
          }
        }
        if (!found_deleted) {
          break;
        }
        on_message_changed(d, top_m, false, "get_message_thread_history");
      }
      vector<MessageId> new_result(result.size() + merge_message_ids.size());
      std::merge(result.begin(), result.end(), merge_message_ids.begin(), merge_message_ids.end(), new_result.begin(),
                 std::greater<>());
      result = std::move(new_result);
    }

    if (is_limit_increased) {
      limit--;
    }

    std::reverse(result.begin(), result.end());
    result = get_message_history_slice(result.begin(), std::lower_bound(result.begin(), result.end(), from_message_id),
                                       result.end(), from_message_id, offset, limit);

    LOG(INFO) << "Return " << result.size() << " messages in result to getMessageThreadHistory";

    promise.set_value(Unit());
    return {dialog_id, std::move(result)};
  }

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || found_dialog_messages_.find(random_id) != found_dialog_messages_.end());
  found_dialog_messages_[random_id];  // reserve place for result

  td_->create_handler<SearchMessagesQuery>(std::move(promise))
      ->send(dialog_id, string(), DialogId(), from_message_id.get_next_server_message_id(), offset, limit,
             MessageSearchFilter::Empty, message_id, random_id);
  return {};
}

std::pair<int32, vector<MessageId>> MessagesManager::search_dialog_messages(
    DialogId dialog_id, const string &query, const td_api::object_ptr<td_api::MessageSender> &sender,
    MessageId from_message_id, int32 offset, int32 limit, MessageSearchFilter filter, MessageId top_thread_message_id,
    int64 &random_id, bool use_db, Promise<Unit> &&promise) {
  if (random_id != 0) {
    // request has already been sent before
    auto it = found_dialog_messages_.find(random_id);
    if (it != found_dialog_messages_.end()) {
      CHECK(found_dialog_messages_dialog_id_.count(random_id) == 0);
      auto result = std::move(it->second);
      found_dialog_messages_.erase(it);
      promise.set_value(Unit());
      return result;
    }
    random_id = 0;
  }
  LOG(INFO) << "Search messages with query \"" << query << "\" in " << dialog_id << " sent by "
            << oneline(to_string(sender)) << " in thread of " << top_thread_message_id << " filtered by " << filter
            << " from " << from_message_id << " with offset " << offset << " and limit " << limit;

  std::pair<int32, vector<MessageId>> result;
  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit must be positive"));
    return result;
  }
  if (limit > MAX_SEARCH_MESSAGES) {
    limit = MAX_SEARCH_MESSAGES;
  }
  if (limit <= -offset) {
    promise.set_error(Status::Error(5, "Parameter limit must be greater than -offset"));
    return result;
  }
  if (offset > 0) {
    promise.set_error(Status::Error(5, "Parameter offset must be non-positive"));
    return result;
  }

  if (from_message_id.get() > MessageId::max().get()) {
    from_message_id = MessageId::max();
  }

  if (!from_message_id.is_valid() && from_message_id != MessageId()) {
    promise.set_error(Status::Error(3, "Parameter from_message_id must be identifier of the chat message or 0"));
    return result;
  }
  from_message_id = from_message_id.get_next_server_message_id();

  const Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(6, "Chat not found"));
    return result;
  }

  DialogId sender_dialog_id;
  if (sender != nullptr) {
    switch (sender->get_id()) {
      case td_api::messageSenderUser::ID:
        sender_dialog_id = DialogId(UserId(static_cast<const td_api::messageSenderUser *>(sender.get())->user_id_));
        break;
      case td_api::messageSenderChat::ID:
        sender_dialog_id = DialogId(static_cast<const td_api::messageSenderChat *>(sender.get())->chat_id_);
        switch (sender_dialog_id.get_type()) {
          case DialogType::User:
          case DialogType::Chat:
          case DialogType::Channel:
            // ok
            break;
          case DialogType::SecretChat:
            promise.set_value(Unit());
            return result;
          case DialogType::None:
            if (sender_dialog_id == DialogId()) {
              break;
            }
            promise.set_error(Status::Error(6, "Invalid sender chat identifier specified"));
            return result;
          default:
            UNREACHABLE();
            return result;
        }
        break;
      default:
        UNREACHABLE();
    }
    if (sender_dialog_id != DialogId() && !have_input_peer(sender_dialog_id, AccessRights::Read)) {
      promise.set_error(Status::Error(6, "Invalid message sender specified"));
      return result;
    }
  }
  if (sender_dialog_id == dialog_id && is_broadcast_channel(dialog_id)) {
    sender_dialog_id = DialogId();
  }

  if (filter == MessageSearchFilter::FailedToSend && sender_dialog_id.is_valid()) {
    if (sender_dialog_id != get_my_dialog_id()) {
      promise.set_value(Unit());
      return result;
    }
    sender_dialog_id = DialogId();
  }

  if (top_thread_message_id != MessageId()) {
    if (!top_thread_message_id.is_valid() || !top_thread_message_id.is_server()) {
      promise.set_error(Status::Error(400, "Invalid message thread ID specified"));
      return result;
    }
    if (dialog_id.get_type() != DialogType::Channel || is_broadcast_channel(dialog_id)) {
      promise.set_error(Status::Error(400, "Can't filter by message thread ID in the chat"));
      return result;
    }
  }

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || found_dialog_messages_.find(random_id) != found_dialog_messages_.end());
  found_dialog_messages_[random_id];  // reserve place for result

  if (filter == MessageSearchFilter::UnreadMention) {
    if (!query.empty()) {
      promise.set_error(Status::Error(6, "Non-empty query is unsupported with the specified filter"));
      return result;
    }
    if (sender_dialog_id.is_valid()) {
      promise.set_error(Status::Error(6, "Filtering by sender is unsupported with the specified filter"));
      return result;
    }
    if (top_thread_message_id != MessageId()) {
      promise.set_error(Status::Error(6, "Filtering by message thread is unsupported with the specified filter"));
      return result;
    }
  }

  // Trying to use database
  if (use_db && query.empty() && G()->parameters().use_message_db && filter != MessageSearchFilter::Empty &&
      !sender_dialog_id.is_valid() && top_thread_message_id == MessageId()) {
    MessageId first_db_message_id = get_first_database_message_id_by_index(d, filter);
    int32 message_count = d->message_count_by_index[message_search_filter_index(filter)];
    auto fixed_from_message_id = from_message_id;
    if (fixed_from_message_id == MessageId()) {
      fixed_from_message_id = MessageId::max();
    }
    LOG(INFO) << "Search messages in " << dialog_id << " from " << fixed_from_message_id << ", have up to "
              << first_db_message_id << ", message_count = " << message_count;
    if ((first_db_message_id < fixed_from_message_id || (first_db_message_id == fixed_from_message_id && offset < 0)) &&
        message_count != -1) {
      LOG(INFO) << "Search messages in database in " << dialog_id << " from " << fixed_from_message_id
                << " and with limit " << limit;
      auto new_promise = PromiseCreator::lambda(
          [random_id, dialog_id, fixed_from_message_id, first_db_message_id, filter, offset, limit,
           promise = std::move(promise)](Result<std::vector<BufferSlice>> r_messages) mutable {
            send_closure(G()->messages_manager(), &MessagesManager::on_search_dialog_messages_db_result, random_id,
                         dialog_id, fixed_from_message_id, first_db_message_id, filter, offset, limit,
                         std::move(r_messages), std::move(promise));
          });
      MessagesDbMessagesQuery db_query;
      db_query.dialog_id = dialog_id;
      db_query.index_mask = message_search_filter_index_mask(filter);
      db_query.from_message_id = fixed_from_message_id;
      db_query.offset = offset;
      db_query.limit = limit;
      G()->td_db()->get_messages_db_async()->get_messages(db_query, std::move(new_promise));
      return result;
    }
  }
  if (filter == MessageSearchFilter::FailedToSend) {
    promise.set_value(Unit());
    return result;
  }

  LOG(DEBUG) << "Search messages on server in " << dialog_id << " with query \"" << query << "\" from "
             << sender_dialog_id << " in thread of " << top_thread_message_id << " from " << from_message_id
             << " and with limit " << limit;

  switch (dialog_id.get_type()) {
    case DialogType::None:
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::Channel:
      td_->create_handler<SearchMessagesQuery>(std::move(promise))
          ->send(dialog_id, query, sender_dialog_id, from_message_id, offset, limit, filter, top_thread_message_id,
                 random_id);
      break;
    case DialogType::SecretChat:
      if (filter == MessageSearchFilter::UnreadMention || filter == MessageSearchFilter::Pinned) {
        promise.set_value(Unit());
      } else {
        promise.set_error(Status::Error(500, "Search messages in secret chats is not supported"));
      }
      break;
    default:
      UNREACHABLE();
      promise.set_error(Status::Error(500, "Search messages is not supported"));
  }
  return result;
}

std::pair<int32, vector<FullMessageId>> MessagesManager::search_call_messages(MessageId from_message_id, int32 limit,
                                                                              bool only_missed, int64 &random_id,
                                                                              bool use_db, Promise<Unit> &&promise) {
  if (random_id != 0) {
    // request has already been sent before
    auto it = found_call_messages_.find(random_id);
    if (it != found_call_messages_.end()) {
      auto result = std::move(it->second);
      found_call_messages_.erase(it);
      promise.set_value(Unit());
      return result;
    }
    random_id = 0;
  }
  LOG(INFO) << "Search call messages from " << from_message_id << " with limit " << limit;

  std::pair<int32, vector<FullMessageId>> result;
  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit must be positive"));
    return result;
  }
  if (limit > MAX_SEARCH_MESSAGES) {
    limit = MAX_SEARCH_MESSAGES;
  }

  if (from_message_id.get() > MessageId::max().get()) {
    from_message_id = MessageId::max();
  }

  if (!from_message_id.is_valid() && from_message_id != MessageId()) {
    promise.set_error(Status::Error(3, "Parameter from_message_id must be identifier of the chat message or 0"));
    return result;
  }
  from_message_id = from_message_id.get_next_server_message_id();

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || found_call_messages_.find(random_id) != found_call_messages_.end());
  found_call_messages_[random_id];  // reserve place for result

  auto filter = only_missed ? MessageSearchFilter::MissedCall : MessageSearchFilter::Call;

  if (use_db && G()->parameters().use_message_db) {
    // try to use database
    MessageId first_db_message_id =
        calls_db_state_.first_calls_database_message_id_by_index[call_message_search_filter_index(filter)];
    int32 message_count = calls_db_state_.message_count_by_index[call_message_search_filter_index(filter)];
    auto fixed_from_message_id = from_message_id;
    if (fixed_from_message_id == MessageId()) {
      fixed_from_message_id = MessageId::max();
    }
    CHECK(fixed_from_message_id.is_valid() && fixed_from_message_id.is_server());
    LOG(INFO) << "Search call messages from " << fixed_from_message_id << ", have up to " << first_db_message_id
              << ", message_count = " << message_count;
    if (first_db_message_id < fixed_from_message_id && message_count != -1) {
      LOG(INFO) << "Search messages in database from " << fixed_from_message_id << " and with limit " << limit;

      MessagesDbCallsQuery db_query;
      db_query.index_mask = message_search_filter_index_mask(filter);
      db_query.from_unique_message_id = fixed_from_message_id.get_server_message_id().get();
      db_query.limit = limit;
      G()->td_db()->get_messages_db_async()->get_calls(
          db_query, PromiseCreator::lambda([random_id, first_db_message_id, filter, promise = std::move(promise)](
                                               Result<MessagesDbCallsResult> calls_result) mutable {
            send_closure(G()->messages_manager(), &MessagesManager::on_messages_db_calls_result,
                         std::move(calls_result), random_id, first_db_message_id, filter, std::move(promise));
          }));
      return result;
    }
  }

  LOG(DEBUG) << "Search call messages on server from " << from_message_id << " and with limit " << limit;
  td_->create_handler<SearchMessagesQuery>(std::move(promise))
      ->send(DialogId(), "", DialogId(), from_message_id, 0, limit, filter, MessageId(), random_id);
  return result;
}

std::pair<int32, vector<MessageId>> MessagesManager::search_dialog_recent_location_messages(DialogId dialog_id,
                                                                                            int32 limit,
                                                                                            int64 &random_id,
                                                                                            Promise<Unit> &&promise) {
  if (random_id != 0) {
    // request has already been sent before
    auto it = found_dialog_recent_location_messages_.find(random_id);
    CHECK(it != found_dialog_recent_location_messages_.end());
    auto result = std::move(it->second);
    found_dialog_recent_location_messages_.erase(it);
    promise.set_value(Unit());
    return result;
  }
  LOG(INFO) << "Search recent location messages in " << dialog_id << " with limit " << limit;

  std::pair<int32, vector<MessageId>> result;
  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit must be positive"));
    return result;
  }
  if (limit > MAX_SEARCH_MESSAGES) {
    limit = MAX_SEARCH_MESSAGES;
  }

  const Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(6, "Chat not found"));
    return result;
  }

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 ||
           found_dialog_recent_location_messages_.find(random_id) != found_dialog_recent_location_messages_.end());
  found_dialog_recent_location_messages_[random_id];  // reserve place for result

  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::Channel:
      td_->create_handler<GetRecentLocationsQuery>(std::move(promise))->send(dialog_id, limit, random_id);
      break;
    case DialogType::SecretChat:
      promise.set_value(Unit());
      break;
    default:
      UNREACHABLE();
      promise.set_error(Status::Error(500, "Search messages is not supported"));
  }
  return result;
}

vector<FullMessageId> MessagesManager::get_active_live_location_messages(Promise<Unit> &&promise) {
  if (!G()->parameters().use_message_db) {
    are_active_live_location_messages_loaded_ = true;
  }

  if (!are_active_live_location_messages_loaded_) {
    load_active_live_location_messages_queries_.push_back(std::move(promise));
    if (load_active_live_location_messages_queries_.size() == 1u) {
      LOG(INFO) << "Trying to load active live location messages from database";
      G()->td_db()->get_sqlite_pmc()->get(
          "di_active_live_location_messages", PromiseCreator::lambda([](string value) {
            send_closure(G()->messages_manager(),
                         &MessagesManager::on_load_active_live_location_full_message_ids_from_database,
                         std::move(value));
          }));
    }
    return {};
  }

  promise.set_value(Unit());
  vector<FullMessageId> result;
  for (auto &full_message_id : active_live_location_full_message_ids_) {
    auto m = get_message(full_message_id);
    CHECK(m != nullptr);
    CHECK(m->content->get_type() == MessageContentType::LiveLocation);
    CHECK(!m->message_id.is_scheduled());

    if (m->is_failed_to_send) {
      continue;
    }

    auto live_period = get_message_content_live_location_period(m->content.get());
    if (live_period <= G()->unix_time() - m->date) {  // bool is_expired flag?
      // live location is expired
      continue;
    }
    result.push_back(full_message_id);
  }

  return result;
}

void MessagesManager::on_load_active_live_location_full_message_ids_from_database(string value) {
  if (G()->close_flag()) {
    return;
  }
  if (value.empty()) {
    LOG(INFO) << "Active live location messages aren't found in the database";
    on_load_active_live_location_messages_finished();

    if (!active_live_location_full_message_ids_.empty()) {
      save_active_live_locations();
    }
    return;
  }

  LOG(INFO) << "Successfully loaded active live location messages list of size " << value.size() << " from database";

  auto new_full_message_ids = std::move(active_live_location_full_message_ids_);
  vector<FullMessageId> old_full_message_ids;
  log_event_parse(old_full_message_ids, value).ensure();

  // TODO asynchronously load messages from database
  active_live_location_full_message_ids_.clear();
  for (auto full_message_id : old_full_message_ids) {
    Message *m = get_message_force(full_message_id, "on_load_active_live_location_full_message_ids_from_database");
    if (m != nullptr) {
      try_add_active_live_location(full_message_id.get_dialog_id(), m);
    }
  }

  for (auto full_message_id : new_full_message_ids) {
    add_active_live_location(full_message_id);
  }

  on_load_active_live_location_messages_finished();

  if (!new_full_message_ids.empty() || old_full_message_ids.size() != active_live_location_full_message_ids_.size()) {
    save_active_live_locations();
  }
}

void MessagesManager::on_load_active_live_location_messages_finished() {
  are_active_live_location_messages_loaded_ = true;
  auto promises = std::move(load_active_live_location_messages_queries_);
  load_active_live_location_messages_queries_.clear();
  for (auto &promise : promises) {
    promise.set_value(Unit());
  }
}

void MessagesManager::try_add_active_live_location(DialogId dialog_id, const Message *m) {
  CHECK(m != nullptr);

  if (td_->auth_manager_->is_bot()) {
    return;
  }
  if (m->content->get_type() != MessageContentType::LiveLocation || m->message_id.is_scheduled() ||
      m->message_id.is_local() || m->via_bot_user_id.is_valid() || m->forward_info != nullptr) {
    return;
  }

  auto live_period = get_message_content_live_location_period(m->content.get());
  if (live_period <= G()->unix_time() - m->date + 1) {  // bool is_expired flag?
    // live location is expired
    return;
  }
  add_active_live_location({dialog_id, m->message_id});
}

void MessagesManager::add_active_live_location(FullMessageId full_message_id) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }
  if (!active_live_location_full_message_ids_.insert(full_message_id).second) {
    return;
  }

  // TODO add timer for live location expiration

  if (!G()->parameters().use_message_db) {
    return;
  }

  if (are_active_live_location_messages_loaded_) {
    save_active_live_locations();
  } else if (load_active_live_location_messages_queries_.empty()) {
    // load active live locations and save after that
    get_active_live_location_messages(Auto());
  }
}

bool MessagesManager::delete_active_live_location(DialogId dialog_id, const Message *m) {
  CHECK(m != nullptr);
  return active_live_location_full_message_ids_.erase(FullMessageId{dialog_id, m->message_id}) != 0;
}

void MessagesManager::save_active_live_locations() {
  CHECK(are_active_live_location_messages_loaded_);
  LOG(INFO) << "Save active live locations of size " << active_live_location_full_message_ids_.size() << " to database";
  if (G()->parameters().use_message_db) {
    G()->td_db()->get_sqlite_pmc()->set("di_active_live_location_messages",
                                        log_event_store(active_live_location_full_message_ids_).as_slice().str(),
                                        Auto());
  }
}

void MessagesManager::on_message_live_location_viewed(Dialog *d, const Message *m) {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  CHECK(m->content->get_type() == MessageContentType::LiveLocation);
  CHECK(!m->message_id.is_scheduled());

  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  switch (d->dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::Channel:
      // ok
      break;
    case DialogType::SecretChat:
      return;
    default:
      UNREACHABLE();
      return;
  }
  if (!d->is_opened) {
    return;
  }

  if (m->is_outgoing || !m->message_id.is_server() || m->via_bot_user_id.is_valid() || !m->sender_user_id.is_valid() ||
      td_->contacts_manager_->is_user_bot(m->sender_user_id) || m->forward_info != nullptr) {
    return;
  }

  auto live_period = get_message_content_live_location_period(m->content.get());
  if (live_period <= G()->unix_time() - m->date + 1) {
    // live location is expired
    return;
  }

  auto &live_location_task_id = d->pending_viewed_live_locations[m->message_id];
  if (live_location_task_id != 0) {
    return;
  }

  live_location_task_id = ++viewed_live_location_task_id_;
  auto &full_message_id = viewed_live_location_tasks_[live_location_task_id];
  full_message_id = FullMessageId(d->dialog_id, m->message_id);
  view_message_live_location_on_server_impl(live_location_task_id, full_message_id);
}

void MessagesManager::view_message_live_location_on_server(int64 task_id) {
  if (G()->close_flag()) {
    return;
  }

  auto it = viewed_live_location_tasks_.find(task_id);
  if (it == viewed_live_location_tasks_.end()) {
    return;
  }

  auto full_message_id = it->second;
  Dialog *d = get_dialog(full_message_id.get_dialog_id());
  const Message *m = get_message_force(d, full_message_id.get_message_id(), "view_message_live_location_on_server");
  if (m == nullptr || get_message_content_live_location_period(m->content.get()) <= G()->unix_time() - m->date + 1) {
    // the message was deleted or live location is expired
    viewed_live_location_tasks_.erase(it);
    auto erased_count = d->pending_viewed_live_locations.erase(full_message_id.get_message_id());
    CHECK(erased_count > 0);
    return;
  }

  view_message_live_location_on_server_impl(task_id, full_message_id);
}

void MessagesManager::view_message_live_location_on_server_impl(int64 task_id, FullMessageId full_message_id) {
  auto promise = PromiseCreator::lambda([actor_id = actor_id(this), task_id](Unit result) {
    send_closure(actor_id, &MessagesManager::on_message_live_location_viewed_on_server, task_id);
  });
  read_message_contents_on_server(full_message_id.get_dialog_id(), {full_message_id.get_message_id()}, 0,
                                  std::move(promise), true);
}

void MessagesManager::on_message_live_location_viewed_on_server(int64 task_id) {
  if (G()->close_flag()) {
    return;
  }

  auto it = viewed_live_location_tasks_.find(task_id);
  if (it == viewed_live_location_tasks_.end()) {
    return;
  }

  pending_message_live_location_view_timeout_.add_timeout_in(task_id, LIVE_LOCATION_VIEW_PERIOD);
}

FileSourceId MessagesManager::get_message_file_source_id(FullMessageId full_message_id) {
  if (td_->auth_manager_->is_bot()) {
    return FileSourceId();
  }

  auto dialog_id = full_message_id.get_dialog_id();
  auto message_id = full_message_id.get_message_id();
  if (!dialog_id.is_valid() || !(message_id.is_valid() || message_id.is_valid_scheduled()) ||
      dialog_id.get_type() == DialogType::SecretChat || !message_id.is_any_server()) {
    return FileSourceId();
  }

  auto &file_source_id = full_message_id_to_file_source_id_[full_message_id];
  if (!file_source_id.is_valid()) {
    file_source_id = td_->file_reference_manager_->create_message_file_source(full_message_id);
  }
  return file_source_id;
}

void MessagesManager::add_message_file_sources(DialogId dialog_id, const Message *m) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  if (dialog_id.get_type() != DialogType::SecretChat && m->is_content_secret) {
    // return;
  }

  auto file_ids = get_message_content_file_ids(m->content.get(), td_);
  if (file_ids.empty()) {
    return;
  }

  // do not create file_source_id for messages without file_ids
  auto file_source_id = get_message_file_source_id(FullMessageId(dialog_id, m->message_id));
  if (file_source_id.is_valid()) {
    for (auto file_id : file_ids) {
      td_->file_manager_->add_file_source(file_id, file_source_id);
    }
  }
}

void MessagesManager::remove_message_file_sources(DialogId dialog_id, const Message *m) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  auto file_ids = get_message_content_file_ids(m->content.get(), td_);
  if (file_ids.empty()) {
    return;
  }

  // do not create file_source_id for messages without file_ids
  auto file_source_id = get_message_file_source_id(FullMessageId(dialog_id, m->message_id));
  if (file_source_id.is_valid()) {
    for (auto file_id : file_ids) {
      td_->file_manager_->remove_file_source(file_id, file_source_id);
    }
  }
}

void MessagesManager::change_message_files(DialogId dialog_id, const Message *m, const vector<FileId> &old_file_ids) {
  if (dialog_id.get_type() != DialogType::SecretChat && m->is_content_secret) {
    // return;
  }

  auto new_file_ids = get_message_content_file_ids(m->content.get(), td_);
  if (new_file_ids == old_file_ids) {
    return;
  }

  FullMessageId full_message_id{dialog_id, m->message_id};
  if (need_delete_message_files(dialog_id, m)) {
    for (auto file_id : old_file_ids) {
      if (!td::contains(new_file_ids, file_id) && need_delete_file(full_message_id, file_id)) {
        send_closure(G()->file_manager(), &FileManager::delete_file, file_id, Promise<>(), "change_message_files");
      }
    }
  }

  auto file_source_id = get_message_file_source_id(full_message_id);
  if (file_source_id.is_valid()) {
    td_->file_manager_->change_files_source(file_source_id, old_file_ids, new_file_ids);
  }
}

MessageId MessagesManager::get_first_database_message_id_by_index(const Dialog *d, MessageSearchFilter filter) {
  CHECK(d != nullptr);
  auto message_id = filter == MessageSearchFilter::Empty
                        ? d->first_database_message_id
                        : d->first_database_message_id_by_index[message_search_filter_index(filter)];
  CHECK(!message_id.is_scheduled());
  if (!message_id.is_valid()) {
    if (d->dialog_id.get_type() == DialogType::SecretChat) {
      LOG(ERROR) << "Invalid first_database_message_id_by_index in " << d->dialog_id;
      return MessageId::min();
    }
    return MessageId::max();
  }
  return message_id;
}

void MessagesManager::on_search_dialog_messages_db_result(int64 random_id, DialogId dialog_id,
                                                          MessageId from_message_id, MessageId first_db_message_id,
                                                          MessageSearchFilter filter, int32 offset, int32 limit,
                                                          Result<std::vector<BufferSlice>> r_messages,
                                                          Promise<> promise) {
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  if (r_messages.is_error()) {
    LOG(ERROR) << "Failed to get messages from the database: " << r_messages.error();
    if (first_db_message_id != MessageId::min() && dialog_id.get_type() != DialogType::SecretChat &&
        filter != MessageSearchFilter::FailedToSend) {
      found_dialog_messages_.erase(random_id);
    }
    return promise.set_value(Unit());
  }
  CHECK(!from_message_id.is_scheduled());
  CHECK(!first_db_message_id.is_scheduled());

  auto messages = r_messages.move_as_ok();

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  auto it = found_dialog_messages_.find(random_id);
  CHECK(it != found_dialog_messages_.end());
  auto &res = it->second.second;

  res.reserve(messages.size());
  for (auto &message : messages) {
    auto m = on_get_message_from_database(dialog_id, d, message, false, "on_search_dialog_messages_db_result");
    if (m != nullptr && first_db_message_id <= m->message_id) {
      if (filter == MessageSearchFilter::UnreadMention && !m->contains_unread_mention) {
        // skip already read by d->last_read_all_mentions_message_id mentions
      } else {
        CHECK(!m->message_id.is_scheduled());
        res.push_back(m->message_id);
      }
    }
  }

  auto &message_count = d->message_count_by_index[message_search_filter_index(filter)];
  int32 result_size = narrow_cast<int32>(res.size());
  bool from_the_end =
      from_message_id == MessageId::max() || (offset < 0 && (result_size == 0 || res[0] < from_message_id));
  if ((message_count != -1 && message_count < result_size) ||
      (message_count > result_size && from_the_end && first_db_message_id == MessageId::min() &&
       result_size < limit + offset)) {
    LOG(INFO) << "Fix found message count in " << dialog_id << " from " << message_count << " to " << result_size;
    message_count = result_size;
    if (filter == MessageSearchFilter::UnreadMention) {
      d->unread_mention_count = message_count;
      update_dialog_mention_notification_count(d);
      send_update_chat_unread_mention_count(d);
    }
    on_dialog_updated(dialog_id, "on_search_dialog_messages_db_result");
  }
  it->second.first = message_count;
  if (res.empty() && first_db_message_id != MessageId::min() && dialog_id.get_type() != DialogType::SecretChat) {
    LOG(INFO) << "No messages in database found";
    found_dialog_messages_.erase(it);
  } else {
    LOG(INFO) << "Found " << res.size() << " messages out of " << message_count << " in database";
    if (from_the_end && filter == MessageSearchFilter::Pinned) {
      set_dialog_last_pinned_message_id(d, res.empty() ? MessageId() : res[0]);
    }
  }
  promise.set_value(Unit());
}

td_api::object_ptr<td_api::foundMessages> MessagesManager::get_found_messages_object(
    const FoundMessages &found_messages) {
  vector<tl_object_ptr<td_api::message>> result;
  result.reserve(found_messages.full_message_ids.size());
  for (auto full_message_id : found_messages.full_message_ids) {
    auto message = get_message_object(full_message_id);
    if (message != nullptr) {
      result.push_back(std::move(message));
    }
  }

  return td_api::make_object<td_api::foundMessages>(found_messages.total_count, std::move(result),
                                                    found_messages.next_offset);
}

MessagesManager::FoundMessages MessagesManager::offline_search_messages(DialogId dialog_id, const string &query,
                                                                        const string &offset, int32 limit,
                                                                        MessageSearchFilter filter, int64 &random_id,
                                                                        Promise<> &&promise) {
  if (!G()->parameters().use_message_db) {
    promise.set_error(Status::Error(400, "Message database is required to search messages in secret chats"));
    return {};
  }

  if (random_id != 0) {
    // request has already been sent before
    auto it = found_fts_messages_.find(random_id);
    CHECK(it != found_fts_messages_.end());
    auto result = std::move(it->second);
    found_fts_messages_.erase(it);
    promise.set_value(Unit());
    return result;
  }

  if (query.empty()) {
    promise.set_value(Unit());
    return {};
  }
  if (dialog_id != DialogId() && !have_dialog_force(dialog_id)) {
    promise.set_error(Status::Error(400, "Chat not found"));
    return {};
  }
  if (limit <= 0) {
    promise.set_error(Status::Error(400, "Limit must be positive"));
    return {};
  }
  if (limit > MAX_SEARCH_MESSAGES) {
    limit = MAX_SEARCH_MESSAGES;
  }

  MessagesDbFtsQuery fts_query;
  fts_query.query = query;
  fts_query.dialog_id = dialog_id;
  fts_query.index_mask = message_search_filter_index_mask(filter);
  if (!offset.empty()) {
    auto r_from_search_id = to_integer_safe<int64>(offset);
    if (r_from_search_id.is_error()) {
      promise.set_error(Status::Error(400, "Invalid offset specified"));
      return {};
    }
    fts_query.from_search_id = r_from_search_id.ok();
  }
  fts_query.limit = limit;

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || found_fts_messages_.find(random_id) != found_fts_messages_.end());
  found_fts_messages_[random_id];  // reserve place for result

  G()->td_db()->get_messages_db_async()->get_messages_fts(
      std::move(fts_query), PromiseCreator::lambda([random_id, offset, limit, promise = std::move(promise)](
                                                       Result<MessagesDbFtsResult> fts_result) mutable {
        send_closure(G()->messages_manager(), &MessagesManager::on_messages_db_fts_result, std::move(fts_result),
                     std::move(offset), limit, random_id, std::move(promise));
      }));

  return {};
}

void MessagesManager::on_messages_db_fts_result(Result<MessagesDbFtsResult> result, string offset, int32 limit,
                                                int64 random_id, Promise<Unit> &&promise) {
  if (G()->close_flag()) {
    result = Status::Error(500, "Request aborted");
  }
  if (result.is_error()) {
    found_fts_messages_.erase(random_id);
    return promise.set_error(result.move_as_error());
  }
  auto fts_result = result.move_as_ok();

  auto it = found_fts_messages_.find(random_id);
  CHECK(it != found_fts_messages_.end());
  auto &res = it->second.full_message_ids;

  res.reserve(fts_result.messages.size());
  for (auto &message : fts_result.messages) {
    auto m = on_get_message_from_database(message.dialog_id, get_dialog_force(message.dialog_id), message.data, false,
                                          "on_messages_db_fts_result");
    if (m != nullptr) {
      res.push_back(FullMessageId(message.dialog_id, m->message_id));
    }
  }

  it->second.next_offset = fts_result.next_search_id <= 1 ? string() : to_string(fts_result.next_search_id);
  it->second.total_count = offset.empty() && fts_result.messages.size() < static_cast<size_t>(limit)
                               ? static_cast<int32>(fts_result.messages.size())
                               : -1;

  promise.set_value(Unit());
}

void MessagesManager::on_messages_db_calls_result(Result<MessagesDbCallsResult> result, int64 random_id,
                                                  MessageId first_db_message_id, MessageSearchFilter filter,
                                                  Promise<> &&promise) {
  CHECK(!first_db_message_id.is_scheduled());
  if (G()->close_flag()) {
    result = Status::Error(500, "Request aborted");
  }
  if (result.is_error()) {
    found_call_messages_.erase(random_id);
    return promise.set_error(result.move_as_error());
  }
  auto calls_result = result.move_as_ok();

  auto it = found_call_messages_.find(random_id);
  CHECK(it != found_call_messages_.end());
  auto &res = it->second.second;

  res.reserve(calls_result.messages.size());
  for (auto &message : calls_result.messages) {
    auto m = on_get_message_from_database(message.dialog_id, get_dialog_force(message.dialog_id), message.data, false,
                                          "on_messages_db_calls_result");

    if (m != nullptr && first_db_message_id <= m->message_id) {
      res.push_back(FullMessageId(message.dialog_id, m->message_id));
    }
  }
  it->second.first = calls_db_state_.message_count_by_index[call_message_search_filter_index(filter)];

  if (res.empty() && first_db_message_id != MessageId::min()) {
    LOG(INFO) << "No messages in database found";
    found_call_messages_.erase(it);
  }

  promise.set_value(Unit());
}

std::pair<int32, vector<FullMessageId>> MessagesManager::search_messages(
    FolderId folder_id, bool ignore_folder_id, const string &query, int32 offset_date, DialogId offset_dialog_id,
    MessageId offset_message_id, int32 limit, MessageSearchFilter filter, int32 min_date, int32 max_date,
    int64 &random_id, Promise<Unit> &&promise) {
  if (random_id != 0) {
    // request has already been sent before
    auto it = found_messages_.find(random_id);
    CHECK(it != found_messages_.end());
    auto result = std::move(it->second);
    found_messages_.erase(it);
    promise.set_value(Unit());
    return result;
  }

  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit must be positive"));
    return {};
  }
  if (limit > MAX_SEARCH_MESSAGES) {
    limit = MAX_SEARCH_MESSAGES;
  }

  if (offset_date <= 0) {
    offset_date = std::numeric_limits<int32>::max();
  }
  if (!offset_message_id.is_valid()) {
    if (offset_message_id.is_valid_scheduled()) {
      promise.set_error(Status::Error(3, "Parameter offset_message_id can't be a scheduled message identifier"));
      return {};
    }
    offset_message_id = MessageId();
  }
  if (offset_message_id != MessageId() && !offset_message_id.is_server()) {
    promise.set_error(
        Status::Error(3, "Parameter offset_message_id must be identifier of the last found message or 0"));
    return {};
  }

  if (filter == MessageSearchFilter::Call || filter == MessageSearchFilter::MissedCall ||
      filter == MessageSearchFilter::Mention || filter == MessageSearchFilter::UnreadMention ||
      filter == MessageSearchFilter::FailedToSend || filter == MessageSearchFilter::Pinned) {
    promise.set_error(Status::Error(400, "The filter is not supported"));
    return {};
  }

  if (query.empty() && filter == MessageSearchFilter::Empty) {
    promise.set_value(Unit());
    return {};
  }

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || found_messages_.find(random_id) != found_messages_.end());
  found_messages_[random_id];  // reserve place for result

  LOG(DEBUG) << "Search all messages filtered by " << filter << " with query = \"" << query << "\" from date "
             << offset_date << ", " << offset_dialog_id << ", " << offset_message_id << " and limit " << limit;

  td_->create_handler<SearchMessagesGlobalQuery>(std::move(promise))
      ->send(folder_id, ignore_folder_id, query, offset_date, offset_dialog_id, offset_message_id, limit, filter,
             min_date, max_date, random_id);
  return {};
}

int64 MessagesManager::get_dialog_message_by_date(DialogId dialog_id, int32 date, Promise<Unit> &&promise) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(5, "Chat not found"));
    return 0;
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    promise.set_error(Status::Error(5, "Can't access the chat"));
    return 0;
  }

  if (date <= 0) {
    date = 1;
  }

  int64 random_id = 0;
  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 ||
           get_dialog_message_by_date_results_.find(random_id) != get_dialog_message_by_date_results_.end());
  get_dialog_message_by_date_results_[random_id];  // reserve place for result

  auto message_id = find_message_by_date(d->messages.get(), date);
  if (message_id.is_valid() && (message_id == d->last_message_id || get_message(d, message_id)->have_next)) {
    get_dialog_message_by_date_results_[random_id] = {dialog_id, message_id};
    promise.set_value(Unit());
    return random_id;
  }

  if (G()->parameters().use_message_db && d->last_database_message_id != MessageId()) {
    CHECK(d->first_database_message_id != MessageId());
    G()->td_db()->get_messages_db_async()->get_dialog_message_by_date(
        dialog_id, d->first_database_message_id, d->last_database_message_id, date,
        PromiseCreator::lambda([actor_id = actor_id(this), dialog_id, date, random_id,
                                promise = std::move(promise)](Result<BufferSlice> result) mutable {
          send_closure(actor_id, &MessagesManager::on_get_dialog_message_by_date_from_database, dialog_id, date,
                       random_id, std::move(result), std::move(promise));
        }));
  } else {
    get_dialog_message_by_date_from_server(d, date, random_id, false, std::move(promise));
  }
  return random_id;
}

MessageId MessagesManager::find_message_by_date(const Message *m, int32 date) {
  if (m == nullptr) {
    return MessageId();
  }

  if (m->date > date) {
    return find_message_by_date(m->left.get(), date);
  }

  auto message_id = find_message_by_date(m->right.get(), date);
  if (message_id.is_valid()) {
    return message_id;
  }

  return m->message_id;
}

void MessagesManager::on_get_dialog_message_by_date_from_database(DialogId dialog_id, int32 date, int64 random_id,
                                                                  Result<BufferSlice> result, Promise<Unit> promise) {
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  if (result.is_ok()) {
    Message *m =
        on_get_message_from_database(dialog_id, d, result.ok(), false, "on_get_dialog_message_by_date_from_database");
    if (m != nullptr) {
      auto message_id = find_message_by_date(d->messages.get(), date);
      if (!message_id.is_valid()) {
        LOG(ERROR) << "Failed to find " << m->message_id << " in " << dialog_id << " by date " << date;
        message_id = m->message_id;
      }
      get_dialog_message_by_date_results_[random_id] = {dialog_id, message_id};
      promise.set_value(Unit());
      return;
    }
    // TODO if m == nullptr, we need to just adjust it to the next non-nullptr message, not get from server
  }

  return get_dialog_message_by_date_from_server(d, date, random_id, true, std::move(promise));
}

void MessagesManager::get_dialog_message_by_date_from_server(const Dialog *d, int32 date, int64 random_id,
                                                             bool after_database_search, Promise<Unit> &&promise) {
  CHECK(d != nullptr);
  if (d->have_full_history) {
    // request can be always done locally/in memory. There is no need to send request to the server
    if (after_database_search) {
      return promise.set_value(Unit());
    }

    auto message_id = find_message_by_date(d->messages.get(), date);
    if (message_id.is_valid()) {
      get_dialog_message_by_date_results_[random_id] = {d->dialog_id, message_id};
    }
    promise.set_value(Unit());
    return;
  }
  if (d->dialog_id.get_type() == DialogType::SecretChat) {
    // there is no way to send request to the server
    return promise.set_value(Unit());
  }

  td_->create_handler<GetDialogMessageByDateQuery>(std::move(promise))->send(d->dialog_id, date, random_id);
}

void MessagesManager::on_get_dialog_message_by_date_success(DialogId dialog_id, int32 date, int64 random_id,
                                                            vector<tl_object_ptr<telegram_api::Message>> &&messages) {
  auto it = get_dialog_message_by_date_results_.find(random_id);
  CHECK(it != get_dialog_message_by_date_results_.end());
  auto &result = it->second;
  CHECK(result == FullMessageId());

  for (auto &message : messages) {
    auto message_date = get_message_date(message);
    auto message_dialog_id = get_message_dialog_id(message);
    if (message_dialog_id != dialog_id) {
      LOG(ERROR) << "Receive message in wrong " << message_dialog_id << " instead of " << dialog_id;
      continue;
    }
    if (message_date != 0 && message_date <= date) {
      result = on_get_message(std::move(message), false, dialog_id.get_type() == DialogType::Channel, false, false,
                              false, "on_get_dialog_message_by_date_success");
      if (result != FullMessageId()) {
        const Dialog *d = get_dialog(dialog_id);
        CHECK(d != nullptr);
        auto message_id = find_message_by_date(d->messages.get(), date);
        if (!message_id.is_valid()) {
          LOG(ERROR) << "Failed to find " << result.get_message_id() << " in " << dialog_id << " by date " << date;
          message_id = result.get_message_id();
        }
        get_dialog_message_by_date_results_[random_id] = {dialog_id, message_id};
        // TODO result must be adjusted by local messages
        return;
      }
    }
  }
}

void MessagesManager::on_get_dialog_message_by_date_fail(int64 random_id) {
  auto erased_count = get_dialog_message_by_date_results_.erase(random_id);
  CHECK(erased_count > 0);
}

tl_object_ptr<td_api::message> MessagesManager::get_dialog_message_by_date_object(int64 random_id) {
  auto it = get_dialog_message_by_date_results_.find(random_id);
  CHECK(it != get_dialog_message_by_date_results_.end());
  auto full_message_id = std::move(it->second);
  get_dialog_message_by_date_results_.erase(it);
  return get_message_object(full_message_id);
}

int32 MessagesManager::get_dialog_message_count(DialogId dialog_id, MessageSearchFilter filter, bool return_local,
                                                int64 &random_id, Promise<Unit> &&promise) {
  if (random_id != 0) {
    // request has already been sent before
    auto it = found_dialog_messages_.find(random_id);
    CHECK(it != found_dialog_messages_.end());
    auto result = std::move(it->second);
    found_dialog_messages_.erase(it);
    CHECK(found_dialog_messages_dialog_id_.count(random_id) == 0);
    promise.set_value(Unit());
    return result.first;
  }

  LOG(INFO) << "Get " << (return_local ? "local " : "") << "number of messages in " << dialog_id << " filtered by "
            << filter;

  const Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(6, "Chat not found"));
    return -1;
  }

  if (filter == MessageSearchFilter::Empty) {
    promise.set_error(Status::Error(6, "Can't use searchMessagesFilterEmpty"));
    return -1;
  }

  auto dialog_type = dialog_id.get_type();
  int32 message_count = d->message_count_by_index[message_search_filter_index(filter)];
  if (message_count == -1) {
    if (filter == MessageSearchFilter::UnreadMention) {
      message_count = d->unread_mention_count;
    }
  }
  if (message_count != -1 || return_local || dialog_type == DialogType::SecretChat ||
      filter == MessageSearchFilter::FailedToSend) {
    promise.set_value(Unit());
    return message_count;
  }

  LOG(INFO) << "Get number of messages in " << dialog_id << " filtered by " << filter << " from the server";

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || found_dialog_messages_.find(random_id) != found_dialog_messages_.end());
  found_dialog_messages_[random_id];  // reserve place for result

  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::Channel:
      td_->create_handler<SearchMessagesQuery>(std::move(promise))
          ->send(dialog_id, "", DialogId(), MessageId(), 0, 1, filter, MessageId(), random_id);
      break;
    case DialogType::None:
    case DialogType::SecretChat:
    default:
      UNREACHABLE();
  }
  return -1;
}

void MessagesManager::preload_newer_messages(const Dialog *d, MessageId max_message_id) {
  CHECK(d != nullptr);
  CHECK(max_message_id.is_valid());
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  MessagesConstIterator p(d, max_message_id);
  int32 limit = MAX_GET_HISTORY * 3 / 10;
  while (*p != nullptr && limit-- > 0) {
    ++p;
    if (*p) {
      max_message_id = (*p)->message_id;
    }
  }
  if (limit > 0 && (d->last_message_id == MessageId() || max_message_id < d->last_message_id)) {
    // need to preload some new messages
    LOG(INFO) << "Preloading newer after " << max_message_id;
    load_messages(d->dialog_id, max_message_id, -MAX_GET_HISTORY + 1, MAX_GET_HISTORY, 3, false, Promise<Unit>());
  }
}

void MessagesManager::preload_older_messages(const Dialog *d, MessageId min_message_id) {
  CHECK(d != nullptr);
  CHECK(min_message_id.is_valid());
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  /*
    if (d->first_remote_message_id == -1) {
      // nothing left to preload from server
      return;
    }
  */
  MessagesConstIterator p(d, min_message_id);
  int32 limit = MAX_GET_HISTORY * 3 / 10 + 1;
  while (*p != nullptr && limit-- > 0) {
    min_message_id = (*p)->message_id;
    --p;
  }
  if (limit > 0) {
    // need to preload some old messages
    LOG(INFO) << "Preloading older before " << min_message_id;
    load_messages(d->dialog_id, min_message_id, 0, MAX_GET_HISTORY / 2, 3, false, Promise<Unit>());
  }
}

unique_ptr<MessagesManager::Message> MessagesManager::parse_message(DialogId dialog_id, const BufferSlice &value,
                                                                    bool is_scheduled) {
  LOG(INFO) << "Loaded message of size " << value.size() << " from database";
  auto m = make_unique<Message>();

  auto status = log_event_parse(*m, value.as_slice());
  bool is_message_id_valid = is_scheduled ? m->message_id.is_valid_scheduled() : m->message_id.is_valid();
  if (status.is_error() || !is_message_id_valid) {
    // can't happen unless database is broken, but has been seen in the wild
    LOG(ERROR) << "Receive invalid message from database: " << m->message_id << ' ' << status << ' '
               << format::as_hex_dump<4>(value.as_slice());
    if (!is_scheduled && dialog_id.get_type() != DialogType::SecretChat && m->message_id.is_valid() &&
        m->message_id.is_server()) {
      // trying to repair the message
      get_message_from_server({dialog_id, m->message_id}, Auto());
    }
    return nullptr;
  }

  return m;
}

void MessagesManager::on_get_history_from_database(DialogId dialog_id, MessageId from_message_id, int32 offset,
                                                   int32 limit, bool from_the_end, bool only_local,
                                                   vector<BufferSlice> &&messages, Promise<Unit> &&promise) {
  CHECK(-limit < offset && offset <= 0);
  CHECK(offset < 0 || from_the_end);
  CHECK(!from_message_id.is_scheduled());

  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    LOG(WARNING) << "Ignore result of get_history_from_database in " << dialog_id;
    promise.set_value(Unit());
    return;
  }

  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  LOG(INFO) << "Receive " << messages.size() << " history messages from database "
            << (from_the_end ? "from the end " : "") << "in " << dialog_id << " from " << from_message_id
            << " with offset " << offset << " and limit " << limit << ". First database message is "
            << d->first_database_message_id << ", have_full_history = " << d->have_full_history;

  if (messages.empty() && from_the_end && d->messages == nullptr) {
    if (d->have_full_history) {
      set_dialog_is_empty(d, "on_get_history_from_database empty");
    } else if (d->last_database_message_id.is_valid()) {
      set_dialog_first_database_message_id(d, MessageId(), "on_get_history_from_database empty");
      set_dialog_last_database_message_id(d, MessageId(), "on_get_history_from_database empty");
    }
  }

  bool have_next = false;
  bool need_update = false;
  bool need_update_dialog_pos = false;
  bool added_new_message = false;
  MessageId first_added_message_id;
  MessageId last_added_message_id;
  Message *next_message = nullptr;
  Dependencies dependencies;
  bool is_first = true;
  bool had_full_history = d->have_full_history;
  auto debug_first_database_message_id = d->first_database_message_id;
  auto debug_last_message_id = d->last_message_id;
  auto debug_last_new_message_id = d->last_new_message_id;
  auto last_received_message_id = MessageId::max();
  size_t pos = 0;
  for (auto &message_slice : messages) {
    if (!d->first_database_message_id.is_valid() && !d->have_full_history) {
      break;
    }
    auto message = parse_message(dialog_id, std::move(message_slice), false);
    if (message == nullptr) {
      if (d->have_full_history) {
        d->have_full_history = false;
        on_dialog_updated(dialog_id, "drop have_full_history in on_get_history_from_database");
      }
      break;
    }
    if (message->message_id >= last_received_message_id) {
      // TODO move to ERROR
      LOG(FATAL) << "Receive " << message->message_id << " after " << last_received_message_id
                 << " from database in the history of " << dialog_id << " from " << from_message_id << " with offset "
                 << offset << ", limit " << limit << ", from_the_end = " << from_the_end;
      break;
    }
    last_received_message_id = message->message_id;

    if (message->message_id < d->first_database_message_id) {
      if (d->have_full_history) {
        LOG(ERROR) << "Have full history in the " << dialog_id << " and receive " << message->message_id
                   << " from database, but first database message is " << d->first_database_message_id;
      } else {
        break;
      }
    }
    if (!have_next && (from_the_end || (is_first && offset < -1 && message->message_id <= from_message_id)) &&
        message->message_id < d->last_message_id) {
      // last message in the dialog must be attached to the next local message
      have_next = true;
    }

    message->have_previous = false;
    message->have_next = have_next;
    message->from_database = true;

    auto old_message = get_message(d, message->message_id);
    Message *m = old_message ? old_message
                             : add_message_to_dialog(d, std::move(message), false, &need_update,
                                                     &need_update_dialog_pos, "on_get_history_from_database");
    if (m != nullptr) {
      first_added_message_id = m->message_id;
      if (!have_next) {
        last_added_message_id = m->message_id;
      }
      if (old_message == nullptr) {
        add_message_dependencies(dependencies, dialog_id, m);
        added_new_message = true;
      } else if (m->message_id != from_message_id) {
        added_new_message = true;
      }
      if (next_message != nullptr && !next_message->have_previous) {
        LOG_CHECK(m->message_id < next_message->message_id)
            << m->message_id << ' ' << next_message->message_id << ' ' << last_received_message_id << ' ' << dialog_id
            << ' ' << from_message_id << ' ' << offset << ' ' << limit << ' ' << from_the_end << ' ' << only_local
            << ' ' << messages.size() << ' ' << debug_first_database_message_id << ' ' << last_added_message_id << ' '
            << added_new_message << ' ' << pos << ' ' << m << ' ' << next_message << ' ' << old_message << ' '
            << to_string(get_message_object(dialog_id, m)) << to_string(get_message_object(dialog_id, next_message));
        LOG(INFO) << "Fix have_previous for " << next_message->message_id;
        next_message->have_previous = true;
        attach_message_to_previous(
            d, next_message->message_id,
            (PSLICE() << "on_get_history_from_database 1 " << m->message_id << ' ' << from_message_id << ' ' << offset
                      << ' ' << limit << ' ' << d->first_database_message_id << ' ' << d->have_full_history << ' '
                      << pos)
                .c_str());
      }

      have_next = true;
      next_message = m;
    }
    is_first = false;
    pos++;
  }
  resolve_dependencies_force(td_, dependencies, "get_history");

  if (from_the_end && !last_added_message_id.is_valid() && last_received_message_id < d->first_database_message_id &&
      !d->have_full_history) {
    // failed to load from database a message from first_database_message_id to last_database_message_id; drop them
    set_dialog_first_database_message_id(d, MessageId(), "on_get_history_from_database 8");
    set_dialog_last_database_message_id(d, MessageId(), "on_get_history_from_database 9");
  }

  if (!added_new_message && !only_local && dialog_id.get_type() != DialogType::SecretChat) {
    if (from_the_end) {
      from_message_id = MessageId();
    }
    load_messages(dialog_id, from_message_id, offset, limit, 1, false, std::move(promise));
    return;
  }

  if (from_the_end && last_added_message_id.is_valid()) {
    // CHECK(d->first_database_message_id.is_valid());
    // CHECK(last_added_message_id >= d->first_database_message_id);
    if ((had_full_history || d->have_full_history) && !d->last_new_message_id.is_valid() &&
        (last_added_message_id.is_server() || d->dialog_id.get_type() == DialogType::SecretChat)) {
      LOG(ERROR) << "Trying to hard fix " << d->dialog_id << " last new message to " << last_added_message_id
                 << " from on_get_history_from_database 2";
      d->last_new_message_id = last_added_message_id;
      on_dialog_updated(d->dialog_id, "on_get_history_from_database 3");
    }
    if (last_added_message_id > d->last_message_id && d->last_new_message_id.is_valid()) {
      set_dialog_last_message_id(d, last_added_message_id, "on_get_history_from_database 4");
      need_update_dialog_pos = true;
    }
    if (last_added_message_id != d->last_database_message_id && d->last_new_message_id.is_valid()) {
      auto debug_last_database_message_id = d->last_database_message_id;
      set_dialog_last_database_message_id(d, last_added_message_id, "on_get_history_from_database 5");
      if (last_added_message_id < d->first_database_message_id || !d->first_database_message_id.is_valid()) {
        CHECK(next_message != nullptr);
        LOG_CHECK(had_full_history || d->have_full_history)
            << had_full_history << ' ' << d->have_full_history << ' ' << next_message->message_id << ' '
            << last_added_message_id << ' ' << d->first_database_message_id << ' ' << debug_first_database_message_id
            << ' ' << d->last_database_message_id << ' ' << debug_last_database_message_id << ' ' << dialog_id << ' '
            << d->last_new_message_id << ' ' << debug_last_new_message_id << ' ' << d->last_message_id << ' '
            << debug_last_message_id;
        CHECK(next_message->message_id <= d->last_database_message_id);
        LOG(ERROR) << "Fix first database message in " << dialog_id << " from " << d->first_database_message_id
                   << " to " << next_message->message_id;
        set_dialog_first_database_message_id(d, next_message->message_id, "on_get_history_from_database 6");
      }
    }
  }
  if (first_added_message_id.is_valid() && first_added_message_id != d->first_database_message_id &&
      last_received_message_id < d->first_database_message_id && d->last_new_message_id.is_valid() &&
      !d->have_full_history) {
    CHECK(first_added_message_id > d->first_database_message_id);
    set_dialog_first_database_message_id(d, first_added_message_id, "on_get_history_from_database 10");
    if (d->last_database_message_id < d->first_database_message_id) {
      set_dialog_last_database_message_id(d, d->first_database_message_id, "on_get_history_from_database 11");
    }
  }

  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "on_get_history_from_database 7");
  }

  promise.set_value(Unit());
}

void MessagesManager::get_history_from_the_end(DialogId dialog_id, bool from_database, bool only_local,
                                               Promise<Unit> &&promise) {
  CHECK(dialog_id.is_valid());
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    // can't get history in dialogs without read access
    return promise.set_value(Unit());
  }
  int32 limit = MAX_GET_HISTORY;
  if (from_database && G()->parameters().use_message_db) {
    if (!promise) {
      // repair last database message ID
      limit = 10;
    }
    LOG(INFO) << "Get history from the end of " << dialog_id << " from database";
    MessagesDbMessagesQuery db_query;
    db_query.dialog_id = dialog_id;
    db_query.from_message_id = MessageId::max();
    db_query.limit = limit;
    G()->td_db()->get_messages_db_async()->get_messages(
        db_query, PromiseCreator::lambda([dialog_id, only_local, limit, actor_id = actor_id(this),
                                          promise = std::move(promise)](std::vector<BufferSlice> messages) mutable {
          send_closure(actor_id, &MessagesManager::on_get_history_from_database, dialog_id, MessageId::max(), 0, limit,
                       true, only_local, std::move(messages), std::move(promise));
        }));
  } else {
    if (only_local || dialog_id.get_type() == DialogType::SecretChat) {
      promise.set_value(Unit());
      return;
    }

    LOG(INFO) << "Get history from the end of " << dialog_id << " from server";
    td_->create_handler<GetHistoryQuery>(std::move(promise))->send_get_from_the_end(dialog_id, limit);
  }
}

void MessagesManager::get_history(DialogId dialog_id, MessageId from_message_id, int32 offset, int32 limit,
                                  bool from_database, bool only_local, Promise<Unit> &&promise) {
  CHECK(dialog_id.is_valid());
  CHECK(from_message_id.is_valid());
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    // can't get history in dialogs without read access
    return promise.set_value(Unit());
  }
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }
  if (from_database && G()->parameters().use_message_db) {
    LOG(INFO) << "Get history in " << dialog_id << " from " << from_message_id << " with offset " << offset
              << " and limit " << limit << " from database";
    MessagesDbMessagesQuery db_query;
    db_query.dialog_id = dialog_id;
    db_query.from_message_id = from_message_id;
    db_query.offset = offset;
    db_query.limit = limit;
    G()->td_db()->get_messages_db_async()->get_messages(
        db_query,
        PromiseCreator::lambda([dialog_id, from_message_id, offset, limit, only_local, actor_id = actor_id(this),
                                promise = std::move(promise)](std::vector<BufferSlice> messages) mutable {
          send_closure(actor_id, &MessagesManager::on_get_history_from_database, dialog_id, from_message_id, offset,
                       limit, false, only_local, std::move(messages), std::move(promise));
        }));
  } else {
    if (only_local || dialog_id.get_type() == DialogType::SecretChat) {
      return promise.set_value(Unit());
    }

    LOG(INFO) << "Get history in " << dialog_id << " from " << from_message_id << " with offset " << offset
              << " and limit " << limit << " from server";
    td_->create_handler<GetHistoryQuery>(std::move(promise))
        ->send(dialog_id, from_message_id.get_next_server_message_id(), offset, limit);
  }
}

void MessagesManager::load_messages(DialogId dialog_id, MessageId from_message_id, int32 offset, int32 limit,
                                    int left_tries, bool only_local, Promise<Unit> &&promise) {
  LOG(INFO) << "Load " << (only_local ? "local " : "") << "messages in " << dialog_id << " from " << from_message_id
            << " with offset = " << offset << " and limit = " << limit << ". " << left_tries << " tries left";
  CHECK(offset <= 0);
  CHECK(left_tries > 0);
  only_local |= dialog_id.get_type() == DialogType::SecretChat;
  if (!only_local) {
    Dialog *d = get_dialog(dialog_id);
    if (d != nullptr && d->have_full_history) {
      LOG(INFO) << "Have full history in " << dialog_id << ", so don't need to get chat history from server";
      only_local = true;
    }
  }
  bool from_database = (left_tries > 2 || only_local) && G()->parameters().use_message_db;
  // TODO do not send requests to database if (from_message_id < d->first_database_message_id ||
  // !d->first_database_message_id.is_valid()) && !d->have_full_history

  if (from_message_id == MessageId()) {
    get_history_from_the_end(dialog_id, from_database, only_local, std::move(promise));
    return;
  }
  if (offset >= -1) {
    // get history before some server or local message
    limit = min(max(limit + offset + 1, MAX_GET_HISTORY / 2), MAX_GET_HISTORY);
    offset = -1;
  } else {
    // get history around some server or local message
    int32 messages_to_load = max(MAX_GET_HISTORY, limit);
    int32 max_add = max(messages_to_load - limit - 2, 0);
    offset -= max_add;
    limit = MAX_GET_HISTORY;
  }
  get_history(dialog_id, from_message_id, offset, limit, from_database, only_local, std::move(promise));
}

vector<MessageId> MessagesManager::get_dialog_scheduled_messages(DialogId dialog_id, bool force, bool ignore_result,
                                                                 Promise<Unit> &&promise) {
  LOG(INFO) << "Get scheduled messages in " << dialog_id;
  if (G()->close_flag()) {
    promise.set_error(Status::Error(500, "Request aborted"));
    return {};
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(6, "Chat not found"));
    return {};
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    promise.set_error(Status::Error(5, "Can't access the chat"));
    return {};
  }
  if (is_broadcast_channel(dialog_id) &&
      !td_->contacts_manager_->get_channel_status(dialog_id.get_channel_id()).can_post_messages()) {
    promise.set_error(Status::Error(3, "Not enough rights to get scheduled messages"));
    return {};
  }

  if (!d->has_loaded_scheduled_messages_from_database) {
    load_dialog_scheduled_messages(dialog_id, true, 0, std::move(promise));
    return {};
  }

  vector<MessageId> message_ids;
  find_old_messages(d->scheduled_messages.get(),
                    MessageId(ScheduledServerMessageId(), std::numeric_limits<int32>::max(), true), message_ids);
  std::reverse(message_ids.begin(), message_ids.end());

  if (G()->parameters().use_message_db) {
    bool has_scheduled_database_messages = false;
    for (auto &message_id : message_ids) {
      CHECK(message_id.is_valid_scheduled());
      if (!message_id.is_yet_unsent()) {
        has_scheduled_database_messages = true;
        break;
      }
    }
    set_dialog_has_scheduled_database_messages(d->dialog_id, has_scheduled_database_messages);
  }

  if (d->scheduled_messages_sync_generation != scheduled_messages_sync_generation_) {
    vector<uint32> numbers;
    for (auto &message_id : message_ids) {
      if (!message_id.is_scheduled_server()) {
        continue;
      }

      numbers.push_back(message_id.get_scheduled_server_message_id().get());
      const Message *m = get_message(d, message_id);
      CHECK(m != nullptr);
      CHECK(m->message_id.get_scheduled_server_message_id() == message_id.get_scheduled_server_message_id());
      numbers.push_back(m->edit_date);
      numbers.push_back(m->date);
    }
    auto hash = get_vector_hash(numbers);

    if (!force && (d->has_scheduled_server_messages ||
                   (d->scheduled_messages_sync_generation == 0 && !G()->parameters().use_message_db))) {
      load_dialog_scheduled_messages(dialog_id, false, hash, std::move(promise));
      return {};
    }
    load_dialog_scheduled_messages(dialog_id, false, hash, Promise<Unit>());
  }

  if (!ignore_result) {
    d->sent_scheduled_messages = true;
  }

  promise.set_value(Unit());
  return message_ids;
}

void MessagesManager::load_dialog_scheduled_messages(DialogId dialog_id, bool from_database, int32 hash,
                                                     Promise<Unit> &&promise) {
  if (G()->parameters().use_message_db && from_database) {
    LOG(INFO) << "Load scheduled messages from database in " << dialog_id;
    auto &queries = load_scheduled_messages_from_database_queries_[dialog_id];
    queries.push_back(std::move(promise));
    if (queries.size() == 1) {
      G()->td_db()->get_messages_db_async()->get_scheduled_messages(
          dialog_id, 1000,
          PromiseCreator::lambda([dialog_id, actor_id = actor_id(this)](std::vector<BufferSlice> messages) {
            send_closure(actor_id, &MessagesManager::on_get_scheduled_messages_from_database, dialog_id,
                         std::move(messages));
          }));
    }
  } else {
    td_->create_handler<GetAllScheduledMessagesQuery>(std::move(promise))
        ->send(dialog_id, hash, scheduled_messages_sync_generation_);
  }
}

void MessagesManager::on_get_scheduled_messages_from_database(DialogId dialog_id, vector<BufferSlice> &&messages) {
  if (G()->close_flag()) {
    auto it = load_scheduled_messages_from_database_queries_.find(dialog_id);
    CHECK(it != load_scheduled_messages_from_database_queries_.end());
    CHECK(!it->second.empty());
    auto promises = std::move(it->second);
    load_scheduled_messages_from_database_queries_.erase(it);

    for (auto &promise : promises) {
      promise.set_error(Status::Error(500, "Request aborted"));
    }
    return;
  }
  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  d->has_loaded_scheduled_messages_from_database = true;

  LOG(INFO) << "Receive " << messages.size() << " scheduled messages from database in " << dialog_id;

  Dependencies dependencies;
  vector<MessageId> added_message_ids;
  for (auto &message_slice : messages) {
    auto message = parse_message(dialog_id, std::move(message_slice), true);
    if (message == nullptr) {
      continue;
    }
    message->from_database = true;

    if (get_message(d, message->message_id) != nullptr) {
      continue;
    }

    bool need_update = false;
    Message *m = add_scheduled_message_to_dialog(d, std::move(message), false, &need_update,
                                                 "on_get_scheduled_messages_from_database");
    if (m != nullptr) {
      add_message_dependencies(dependencies, dialog_id, m);
      added_message_ids.push_back(m->message_id);
    }
  }
  resolve_dependencies_force(td_, dependencies, "get_scheduled_messages");

  // for (auto message_id : added_message_ids) {
  //   send_update_new_message(d, get_message(d, message_id));
  // }
  send_update_chat_has_scheduled_messages(d, false);

  auto it = load_scheduled_messages_from_database_queries_.find(dialog_id);
  CHECK(it != load_scheduled_messages_from_database_queries_.end());
  CHECK(!it->second.empty());
  auto promises = std::move(it->second);
  load_scheduled_messages_from_database_queries_.erase(it);

  for (auto &promise : promises) {
    promise.set_value(Unit());
  }
}

MessagesManager::FoundMessages MessagesManager::get_message_public_forwards(FullMessageId full_message_id,
                                                                            const string &offset, int32 limit,
                                                                            int64 &random_id, Promise<Unit> &&promise) {
  if (random_id != 0) {
    // request has already been sent before
    auto it = found_message_public_forwards_.find(random_id);
    CHECK(it != found_message_public_forwards_.end());
    auto result = std::move(it->second);
    found_message_public_forwards_.erase(it);
    promise.set_value(Unit());
    return result;
  }

  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(5, "Chat not found"));
    return {};
  }

  const Message *m = get_message_force(d, full_message_id.get_message_id(), "get_message_public_forwards");
  if (m == nullptr) {
    promise.set_error(Status::Error(5, "Message not found"));
    return {};
  }

  if (m->view_count == 0 || m->forward_info != nullptr || m->had_forward_info || m->message_id.is_scheduled() ||
      !m->message_id.is_server()) {
    promise.set_error(Status::Error(5, "Message forwards are inaccessible"));
    return {};
  }

  FoundMessages result;
  if (limit <= 0) {
    promise.set_error(Status::Error(3, "Parameter limit must be positive"));
    return {};
  }
  if (limit > MAX_SEARCH_MESSAGES) {
    limit = MAX_SEARCH_MESSAGES;
  }

  int32 offset_date = std::numeric_limits<int32>::max();
  DialogId offset_dialog_id;
  ServerMessageId offset_message_id;

  if (!offset.empty()) {
    auto parts = full_split(offset, ',');
    if (parts.size() != 3) {
      promise.set_error(Status::Error(3, "Invalid offset specified"));
      return {};
    }
    auto r_offset_date = to_integer_safe<int32>(parts[0]);
    auto r_offset_dialog_id = to_integer_safe<int64>(parts[1]);
    auto r_offset_message_id = to_integer_safe<int32>(parts[2]);
    if (r_offset_date.is_error() || r_offset_dialog_id.is_error() || r_offset_message_id.is_error()) {
      promise.set_error(Status::Error(3, "Invalid offset specified"));
      return {};
    }

    offset_date = r_offset_date.ok();
    offset_dialog_id = DialogId(r_offset_dialog_id.ok());
    offset_message_id = ServerMessageId(r_offset_message_id.ok());
  }

  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || found_message_public_forwards_.find(random_id) != found_message_public_forwards_.end());
  found_message_public_forwards_[random_id];  // reserve place for result

  LOG(DEBUG) << "Get public message forwards from date " << offset_date << ", " << offset_dialog_id
             << ", server message " << offset_message_id.get() << " and with limit " << limit;

  td_->create_handler<GetMessagePublicForwardsQuery>(std::move(promise))
      ->send(full_message_id, offset_date, offset_dialog_id, offset_message_id, limit, random_id);
  return {};
}

Result<int32> MessagesManager::get_message_schedule_date(
    td_api::object_ptr<td_api::MessageSchedulingState> &&scheduling_state) {
  if (scheduling_state == nullptr) {
    return 0;
  }

  switch (scheduling_state->get_id()) {
    case td_api::messageSchedulingStateSendWhenOnline::ID: {
      auto send_date = SCHEDULE_WHEN_ONLINE_DATE;
      return send_date;
    }
    case td_api::messageSchedulingStateSendAtDate::ID: {
      auto send_at_date = td_api::move_object_as<td_api::messageSchedulingStateSendAtDate>(scheduling_state);
      auto send_date = send_at_date->send_date_;
      if (send_date <= 0) {
        return Status::Error(400, "Invalid send date specified");
      }
      if (send_date <= G()->unix_time() + 10) {
        return 0;
      }
      if (send_date - G()->unix_time() > 367 * 86400) {
        return Status::Error(400, "Send date is too far in the future");
      }
      return send_date;
    }
    default:
      UNREACHABLE();
      return 0;
  }
}

tl_object_ptr<td_api::MessageSendingState> MessagesManager::get_message_sending_state_object(const Message *m) const {
  CHECK(m != nullptr);
  if (m->message_id.is_yet_unsent()) {
    return td_api::make_object<td_api::messageSendingStatePending>();
  }
  if (m->is_failed_to_send) {
    return td_api::make_object<td_api::messageSendingStateFailed>(
        m->send_error_code, m->send_error_message, can_resend_message(m), max(m->try_resend_at - Time::now(), 0.0));
  }
  return nullptr;
}

tl_object_ptr<td_api::MessageSchedulingState> MessagesManager::get_message_scheduling_state_object(int32 send_date) {
  if (send_date == SCHEDULE_WHEN_ONLINE_DATE) {
    return td_api::make_object<td_api::messageSchedulingStateSendWhenOnline>();
  }
  return td_api::make_object<td_api::messageSchedulingStateSendAtDate>(send_date);
}

tl_object_ptr<td_api::message> MessagesManager::get_message_object(FullMessageId full_message_id) {
  return get_message_object(full_message_id.get_dialog_id(), get_message_force(full_message_id, "get_message_object"));
}

tl_object_ptr<td_api::message> MessagesManager::get_message_object(DialogId dialog_id, const Message *m,
                                                                   bool for_event_log) const {
  if (m == nullptr) {
    return nullptr;
  }

  auto sending_state = get_message_sending_state_object(m);

  if (for_event_log) {
    CHECK(m->message_id.is_server());
    CHECK(sending_state == nullptr);
  }

  bool can_delete = can_delete_message(dialog_id, m);
  bool is_scheduled = m->message_id.is_scheduled();
  DialogId my_dialog_id = get_my_dialog_id();
  bool can_delete_for_self = false;
  bool can_delete_for_all_users = can_delete && can_revoke_message(dialog_id, m);
  if (can_delete) {
    switch (dialog_id.get_type()) {
      case DialogType::User:
      case DialogType::Chat:
        // TODO allow to delete yet unsent message just for self
        can_delete_for_self = !m->message_id.is_yet_unsent() || dialog_id == my_dialog_id;
        break;
      case DialogType::Channel:
      case DialogType::SecretChat:
        can_delete_for_self = !can_delete_for_all_users;
        break;
      case DialogType::None:
      default:
        UNREACHABLE();
    }
  }
  if (for_event_log) {
    can_delete_for_self = false;
    can_delete_for_all_users = false;
  } else if (is_scheduled) {
    can_delete_for_self = (dialog_id == my_dialog_id);
    can_delete_for_all_users = !can_delete_for_self;
  }

  bool is_outgoing = m->is_outgoing;
  if (dialog_id == my_dialog_id) {
    // in Saved Messages all non-forwarded messages must be outgoing
    // a forwarded message is outgoing, only if it doesn't have from_dialog_id and its sender isn't hidden
    // i.e. a message is incoming only if it's a forwarded message with known from_dialog_id or with a hidden sender
    auto forward_info = m->forward_info.get();
    is_outgoing = is_scheduled || forward_info == nullptr ||
                  (!forward_info->from_dialog_id.is_valid() && !is_forward_info_sender_hidden(forward_info));
  }

  int32 ttl = m->ttl;
  double ttl_expires_in = 0;
  if (!for_event_log) {
    if (m->ttl_expires_at != 0) {
      ttl_expires_in = max(m->ttl_expires_at - Time::now(), 1e-3);
    } else {
      ttl_expires_in = m->ttl;
    }
    if (ttl == 0 && m->ttl_period != 0) {
      ttl = m->ttl_period;
      ttl_expires_in = max(m->date + m->ttl_period - G()->server_time(), 1e-3);
    }
  } else {
    ttl = 0;
  }
  auto scheduling_state = is_scheduled ? get_message_scheduling_state_object(m->date) : nullptr;
  bool can_be_edited = for_event_log ? false : can_edit_message(dialog_id, m, false, td_->auth_manager_->is_bot());
  bool can_be_forwarded = for_event_log ? false : can_forward_message(dialog_id, m);
  bool can_get_statistics = for_event_log ? false : can_get_message_statistics(dialog_id, m);
  bool can_get_message_thread = for_event_log ? false : get_top_thread_full_message_id(dialog_id, m).is_ok();
  auto via_bot_user_id = td_->contacts_manager_->get_user_id_object(m->via_bot_user_id, "via_bot_user_id");
  auto media_album_id = for_event_log ? static_cast<int64>(0) : m->media_album_id;
  auto reply_to_message_id = for_event_log ? static_cast<int64>(0) : m->reply_to_message_id.get();
  auto reply_in_dialog_id =
      reply_to_message_id == 0 ? DialogId() : (m->reply_in_dialog_id.is_valid() ? m->reply_in_dialog_id : dialog_id);
  auto top_thread_message_id = for_event_log || is_scheduled ? static_cast<int64>(0) : m->top_thread_message_id.get();
  bool contains_unread_mention = for_event_log ? false : m->contains_unread_mention;
  auto live_location_date = m->is_failed_to_send ? 0 : m->date;
  auto date = is_scheduled ? 0 : m->date;
  auto edit_date = m->hide_edit_date ? 0 : m->edit_date;
  auto is_pinned = for_event_log || is_scheduled ? false : m->is_pinned;
  return make_tl_object<td_api::message>(
      m->message_id.get(), get_message_sender_object_const(m->sender_user_id, m->sender_dialog_id), dialog_id.get(),
      std::move(sending_state), std::move(scheduling_state), is_outgoing, is_pinned, can_be_edited, can_be_forwarded,
      can_delete_for_self, can_delete_for_all_users, can_get_statistics, can_get_message_thread, m->is_channel_post,
      contains_unread_mention, date, edit_date, get_message_forward_info_object(m->forward_info),
      get_message_interaction_info_object(dialog_id, m), reply_in_dialog_id.get(), reply_to_message_id,
      top_thread_message_id, ttl, ttl_expires_in, via_bot_user_id, m->author_signature, media_album_id,
      get_restriction_reason_description(m->restriction_reasons),
      get_message_content_object(m->content.get(), td_, live_location_date, m->is_content_secret),
      get_reply_markup_object(m->reply_markup));
}

tl_object_ptr<td_api::messages> MessagesManager::get_messages_object(int32 total_count, DialogId dialog_id,
                                                                     const vector<MessageId> &message_ids,
                                                                     bool skip_not_found) {
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  auto message_objects = transform(message_ids, [this, dialog_id, d](MessageId message_id) {
    return get_message_object(dialog_id, get_message_force(d, message_id, "get_messages_object"));
  });
  return get_messages_object(total_count, std::move(message_objects), skip_not_found);
}

tl_object_ptr<td_api::messages> MessagesManager::get_messages_object(int32 total_count,
                                                                     const vector<FullMessageId> &full_message_ids,
                                                                     bool skip_not_found) {
  auto message_objects = transform(
      full_message_ids, [this](FullMessageId full_message_id) { return get_message_object(full_message_id); });
  return get_messages_object(total_count, std::move(message_objects), skip_not_found);
}

tl_object_ptr<td_api::messages> MessagesManager::get_messages_object(int32 total_count,
                                                                     vector<tl_object_ptr<td_api::message>> &&messages,
                                                                     bool skip_not_found) {
  auto message_count = narrow_cast<int32>(messages.size());
  if (total_count < message_count) {
    if (total_count != -1) {
      LOG(ERROR) << "Have wrong total_count = " << total_count << ", while having " << message_count << " messages";
    }
    total_count = message_count;
  }
  if (skip_not_found && td::remove(messages, nullptr)) {
    total_count -= message_count - static_cast<int32>(messages.size());
  }
  return td_api::make_object<td_api::messages>(total_count, std::move(messages));
}

bool MessagesManager::is_anonymous_administrator(DialogId dialog_id, string *author_signature) const {
  CHECK(dialog_id.is_valid());

  if (is_broadcast_channel(dialog_id)) {
    return true;
  }

  if (td_->auth_manager_->is_bot()) {
    return false;
  }

  if (dialog_id.get_type() != DialogType::Channel) {
    return false;
  }

  auto status = td_->contacts_manager_->get_channel_status(dialog_id.get_channel_id());
  if (!status.is_anonymous()) {
    return false;
  }

  if (author_signature != nullptr) {
    *author_signature = status.get_rank();
  }
  return true;
}

MessagesManager::Message *MessagesManager::get_message_to_send(
    Dialog *d, MessageId top_thread_message_id, MessageId reply_to_message_id, const MessageSendOptions &options,
    unique_ptr<MessageContent> &&content, bool *need_update_dialog_pos, bool suppress_reply_info,
    unique_ptr<MessageForwardInfo> forward_info, bool is_copy) {
  CHECK(d != nullptr);
  CHECK(!reply_to_message_id.is_scheduled());
  CHECK(content != nullptr);

  bool is_scheduled = options.schedule_date != 0;
  DialogId dialog_id = d->dialog_id;
  MessageId message_id = is_scheduled ? get_next_yet_unsent_scheduled_message_id(d, options.schedule_date)
                                      : get_next_yet_unsent_message_id(d);
  LOG(INFO) << "Create " << message_id << " in " << dialog_id;

  auto dialog_type = dialog_id.get_type();
  auto my_id = td_->contacts_manager_->get_my_id();

  auto m = make_unique<Message>();
  set_message_id(m, message_id);
  bool is_channel_post = is_broadcast_channel(dialog_id);
  if (is_channel_post) {
    // sender of the post can be hidden
    if (!is_scheduled && td_->contacts_manager_->get_channel_sign_messages(dialog_id.get_channel_id())) {
      m->author_signature = td_->contacts_manager_->get_user_title(my_id);
    }
    m->sender_dialog_id = d->dialog_id;
  } else {
    if (is_anonymous_administrator(d->dialog_id, &m->author_signature)) {
      m->sender_dialog_id = d->dialog_id;
    } else {
      m->sender_user_id = my_id;
    }
  }
  m->send_date = G()->unix_time();
  m->date = is_scheduled ? options.schedule_date : m->send_date;
  m->reply_to_message_id = reply_to_message_id;
  m->top_thread_message_id = top_thread_message_id;
  if (reply_to_message_id.is_valid()) {
    const Message *reply_m = get_message(d, reply_to_message_id);
    if (reply_m != nullptr && reply_m->top_thread_message_id.is_valid()) {
      m->top_thread_message_id = reply_m->top_thread_message_id;
    }
  }
  m->is_channel_post = is_channel_post;
  m->is_outgoing = is_scheduled || dialog_id != DialogId(my_id);
  m->from_background = options.from_background;
  m->view_count = is_channel_post && !is_scheduled ? 1 : 0;
  m->forward_count = 0;
  if ([&] {
        if (suppress_reply_info) {
          return false;
        }
        if (is_scheduled) {
          return false;
        }
        if (dialog_type != DialogType::Channel) {
          return false;
        }
        if (td_->auth_manager_->is_bot()) {
          return false;
        }
        if (is_channel_post) {
          return td_->contacts_manager_->get_channel_has_linked_channel(dialog_id.get_channel_id());
        }
        return !reply_to_message_id.is_valid();
      }()) {
    m->reply_info.reply_count = 0;
    if (is_channel_post) {
      auto linked_channel_id = td_->contacts_manager_->get_channel_linked_channel_id(dialog_id.get_channel_id());
      if (linked_channel_id.is_valid()) {
        m->reply_info.is_comment = true;
        m->reply_info.channel_id = linked_channel_id;
      }
    }
  }
  m->content = std::move(content);
  m->forward_info = std::move(forward_info);
  m->is_copy = is_copy || forward_info != nullptr;

  if (td_->auth_manager_->is_bot() || options.disable_notification ||
      G()->shared_config().get_option_boolean("ignore_default_disable_notification")) {
    m->disable_notification = options.disable_notification;
  } else {
    auto notification_settings = get_dialog_notification_settings(dialog_id, true);
    CHECK(notification_settings != nullptr);
    m->disable_notification = notification_settings->silent_send_message;
  }

  if (dialog_type == DialogType::SecretChat) {
    CHECK(!is_scheduled);
    m->ttl = td_->contacts_manager_->get_secret_chat_ttl(dialog_id.get_secret_chat_id());
    if (is_service_message_content(m->content->get_type())) {
      m->ttl = 0;
    }
    m->is_content_secret = is_secret_message_content(m->ttl, m->content->get_type());
    if (reply_to_message_id.is_valid()) {
      auto *reply_to_message = get_message_force(d, reply_to_message_id, "get_message_to_send");
      if (reply_to_message != nullptr) {
        m->reply_to_random_id = reply_to_message->random_id;
      } else {
        m->reply_to_message_id = MessageId();
      }
    }
  }

  m->have_previous = true;
  m->have_next = true;

  do {
    m->random_id = Random::secure_int64();
  } while (m->random_id == 0 || message_random_ids_.find(m->random_id) != message_random_ids_.end());
  message_random_ids_.insert(m->random_id);

  bool need_update = false;
  CHECK(have_input_peer(dialog_id, AccessRights::Read));
  auto result = add_message_to_dialog(d, std::move(m), true, &need_update, need_update_dialog_pos, "send message");
  LOG_CHECK(result != nullptr) << message_id << " " << debug_add_message_to_dialog_fail_reason_;
  if (result->message_id.is_scheduled()) {
    send_update_chat_has_scheduled_messages(d, false);
  }
  return result;
}

int64 MessagesManager::begin_send_message(DialogId dialog_id, const Message *m) {
  LOG(INFO) << "Begin to send " << FullMessageId(dialog_id, m->message_id) << " with random_id = " << m->random_id;
  CHECK(m->random_id != 0 && being_sent_messages_.find(m->random_id) == being_sent_messages_.end());
  CHECK(m->message_id.is_yet_unsent());
  being_sent_messages_[m->random_id] = FullMessageId(dialog_id, m->message_id);
  return m->random_id;
}

Status MessagesManager::can_send_message(DialogId dialog_id) const {
  if (!have_input_peer(dialog_id, AccessRights::Write)) {
    return Status::Error(400, "Have no write access to the chat");
  }

  if (dialog_id.get_type() == DialogType::Channel) {
    auto channel_id = dialog_id.get_channel_id();
    auto channel_type = td_->contacts_manager_->get_channel_type(channel_id);
    auto channel_status = td_->contacts_manager_->get_channel_permissions(channel_id);

    switch (channel_type) {
      case ChannelType::Unknown:
      case ChannelType::Megagroup:
        if (!channel_status.can_send_messages()) {
          return Status::Error(400, "Have no rights to send a message");
        }
        break;
      case ChannelType::Broadcast: {
        if (!channel_status.can_post_messages()) {
          return Status::Error(400, "Need administrator rights in the channel chat");
        }
        break;
      }
      default:
        UNREACHABLE();
    }
  }
  return Status::OK();
}

Status MessagesManager::can_send_message_content(DialogId dialog_id, const MessageContent *content,
                                                 bool is_forward) const {
  auto dialog_type = dialog_id.get_type();
  int32 secret_chat_layer = std::numeric_limits<int32>::max();
  if (dialog_type == DialogType::SecretChat) {
    auto secret_chat_id = dialog_id.get_secret_chat_id();
    secret_chat_layer = td_->contacts_manager_->get_secret_chat_layer(secret_chat_id);
  }

  bool can_send_messages = true;
  bool can_send_media = true;
  bool can_send_stickers = true;
  bool can_send_animations = true;
  bool can_send_games = true;
  bool can_send_polls = true;

  auto content_type = content->get_type();
  switch (dialog_type) {
    case DialogType::User:
      if (content_type == MessageContentType::Poll && !is_forward && !td_->auth_manager_->is_bot() &&
          !td_->contacts_manager_->is_user_bot(dialog_id.get_user_id())) {
        return Status::Error(400, "Polls can't be sent to the private chat");
      }
      break;
    case DialogType::Chat:
      // ok
      break;
    case DialogType::Channel: {
      auto channel_status = td_->contacts_manager_->get_channel_permissions(dialog_id.get_channel_id());
      can_send_messages = channel_status.can_send_messages();
      can_send_media = channel_status.can_send_media();
      can_send_stickers = channel_status.can_send_stickers();
      can_send_animations = channel_status.can_send_animations();
      can_send_games = channel_status.can_send_games();
      can_send_polls = channel_status.can_send_polls();
      break;
    }
    case DialogType::SecretChat:
      if (content_type == MessageContentType::Game) {
        return Status::Error(400, "Games can't be sent to secret chats");
      }
      if (content_type == MessageContentType::Poll) {
        return Status::Error(400, "Polls can't be sent to secret chats");
      }
      if (content_type == MessageContentType::Dice) {
        return Status::Error(400, "Dice can't be sent to secret chats");
      }
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  switch (content_type) {
    case MessageContentType::Animation:
      if (!can_send_animations) {
        return Status::Error(400, "Not enough rights to send animations to the chat");
      }
      break;
    case MessageContentType::Audio:
      if (!can_send_media) {
        return Status::Error(400, "Not enough rights to send audios to the chat");
      }
      break;
    case MessageContentType::Contact:
      if (!can_send_messages) {
        return Status::Error(400, "Not enough rights to send contacts to the chat");
      }
      break;
    case MessageContentType::Dice:
      if (!can_send_stickers) {
        return Status::Error(400, "Not enough rights to send dice to the chat");
      }
      break;
    case MessageContentType::Document:
      if (!can_send_media) {
        return Status::Error(400, "Not enough rights to send documents to the chat");
      }
      break;
    case MessageContentType::Game:
      if (is_broadcast_channel(dialog_id)) {
        // return Status::Error(400, "Games can't be sent to channel chats");
      }

      if (!can_send_games) {
        return Status::Error(400, "Not enough rights to send games to the chat");
      }
      break;
    case MessageContentType::Invoice:
      if (!is_forward) {
        switch (dialog_type) {
          case DialogType::User:
            // ok
            break;
          case DialogType::Chat:
          case DialogType::Channel:
          case DialogType::SecretChat:
            return Status::Error(400, "Invoices can be sent only to private chats");
          case DialogType::None:
          default:
            UNREACHABLE();
        }
      }
      break;
    case MessageContentType::LiveLocation:
      if (!can_send_messages) {
        return Status::Error(400, "Not enough rights to send live locations to the chat");
      }
      break;
    case MessageContentType::Location:
      if (!can_send_messages) {
        return Status::Error(400, "Not enough rights to send locations to the chat");
      }
      break;
    case MessageContentType::Photo:
      if (!can_send_media) {
        return Status::Error(400, "Not enough rights to send photos to the chat");
      }
      break;
    case MessageContentType::Poll:
      if (!can_send_polls) {
        return Status::Error(400, "Not enough rights to send polls to the chat");
      }
      if (!get_message_content_poll_is_anonymous(td_, content) && is_broadcast_channel(dialog_id)) {
        return Status::Error(400, "Non-anonymous polls can't be sent to channel chats");
      }
      break;
    case MessageContentType::Sticker:
      if (!can_send_stickers) {
        return Status::Error(400, "Not enough rights to send stickers to the chat");
      }
      break;
    case MessageContentType::Text:
      if (!can_send_messages) {
        return Status::Error(400, "Not enough rights to send text messages to the chat");
      }
      break;
    case MessageContentType::Venue:
      if (!can_send_messages) {
        return Status::Error(400, "Not enough rights to send venues to the chat");
      }
      break;
    case MessageContentType::Video:
      if (!can_send_media) {
        return Status::Error(400, "Not enough rights to send videos to the chat");
      }
      break;
    case MessageContentType::VideoNote:
      if (!can_send_media) {
        return Status::Error(400, "Not enough rights to send video notes to the chat");
      }
      if (secret_chat_layer < SecretChatActor::VIDEO_NOTES_LAYER) {
        return Status::Error(400, PSLICE()
                                      << "Video notes can't be sent to secret chat with layer " << secret_chat_layer);
      }
      break;
    case MessageContentType::VoiceNote:
      if (!can_send_media) {
        return Status::Error(400, "Not enough rights to send voice notes to the chat");
      }
      break;
    case MessageContentType::None:
    case MessageContentType::ChatCreate:
    case MessageContentType::ChatChangeTitle:
    case MessageContentType::ChatChangePhoto:
    case MessageContentType::ChatDeletePhoto:
    case MessageContentType::ChatDeleteHistory:
    case MessageContentType::ChatAddUsers:
    case MessageContentType::ChatJoinedByLink:
    case MessageContentType::ChatDeleteUser:
    case MessageContentType::ChatMigrateTo:
    case MessageContentType::ChannelCreate:
    case MessageContentType::ChannelMigrateFrom:
    case MessageContentType::PinMessage:
    case MessageContentType::GameScore:
    case MessageContentType::ScreenshotTaken:
    case MessageContentType::ChatSetTtl:
    case MessageContentType::Unsupported:
    case MessageContentType::Call:
    case MessageContentType::PaymentSuccessful:
    case MessageContentType::ContactRegistered:
    case MessageContentType::ExpiredPhoto:
    case MessageContentType::ExpiredVideo:
    case MessageContentType::CustomServiceAction:
    case MessageContentType::WebsiteConnected:
    case MessageContentType::PassportDataSent:
    case MessageContentType::PassportDataReceived:
    case MessageContentType::ProximityAlertTriggered:
    case MessageContentType::GroupCall:
    case MessageContentType::InviteToGroupCall:
      UNREACHABLE();
  }
  return Status::OK();
}

MessageId MessagesManager::get_persistent_message_id(const Dialog *d, MessageId message_id) const {
  if (!message_id.is_valid() && !message_id.is_valid_scheduled()) {
    return MessageId();
  }
  if (message_id.is_yet_unsent()) {
    // it is possible that user tries to do something with an already sent message by its temporary id
    // we need to use real message in this case and transparently replace message_id
    auto it = d->yet_unsent_message_id_to_persistent_message_id.find(message_id);
    if (it != d->yet_unsent_message_id_to_persistent_message_id.end()) {
      return it->second;
    }
  }

  return message_id;
}

MessageId MessagesManager::get_reply_to_message_id(Dialog *d, MessageId top_thread_message_id, MessageId message_id,
                                                   bool for_draft) {
  CHECK(d != nullptr);
  if (!message_id.is_valid()) {
    if (!for_draft && message_id == MessageId() && top_thread_message_id.is_valid() &&
        top_thread_message_id.is_server() &&
        get_message_force(d, top_thread_message_id, "get_reply_to_message_id 1") != nullptr) {
      return top_thread_message_id;
    }
    return MessageId();
  }
  message_id = get_persistent_message_id(d, message_id);
  const Message *m = get_message_force(d, message_id, "get_reply_to_message_id 2");
  if (m == nullptr || m->message_id.is_yet_unsent() ||
      (m->message_id.is_local() && d->dialog_id.get_type() != DialogType::SecretChat)) {
    if (message_id.is_server() && d->dialog_id.get_type() != DialogType::SecretChat &&
        message_id > d->last_new_message_id && message_id <= d->max_notification_message_id) {
      // allow to reply yet unreceived server message
      return message_id;
    }
    if (!for_draft && top_thread_message_id.is_valid() && top_thread_message_id.is_server() &&
        get_message_force(d, top_thread_message_id, "get_reply_to_message_id 3") != nullptr) {
      return top_thread_message_id;
    }

    // TODO local replies to local messages can be allowed
    // TODO replies to yet unsent messages can be allowed with special handling of them on application restart
    return MessageId();
  }
  return m->message_id;
}

void MessagesManager::fix_server_reply_to_message_id(DialogId dialog_id, MessageId message_id,
                                                     DialogId reply_in_dialog_id, MessageId &reply_to_message_id) {
  CHECK(!reply_to_message_id.is_scheduled());
  if (!reply_to_message_id.is_valid()) {
    if (reply_to_message_id != MessageId()) {
      LOG(ERROR) << "Receive reply to " << reply_to_message_id << " for " << message_id << " in " << dialog_id;
      reply_to_message_id = MessageId();
    }
    return;
  }

  if (!message_id.is_scheduled() && !reply_in_dialog_id.is_valid() && reply_to_message_id >= message_id) {
    if (reply_to_message_id.get() - message_id.get() <= MessageId(ServerMessageId(1000000)).get() ||
        dialog_id.get_type() == DialogType::Channel) {
      LOG(ERROR) << "Receive reply to wrong " << reply_to_message_id << " in " << message_id << " in " << dialog_id;
    }
    reply_to_message_id = MessageId();
  }
}

vector<FileId> MessagesManager::get_message_file_ids(const Message *m) const {
  CHECK(m != nullptr);
  return get_message_content_file_ids(m->content.get(), td_);
}

void MessagesManager::cancel_upload_message_content_files(const MessageContent *content) {
  auto file_id = get_message_content_upload_file_id(content);
  // always cancel file upload, it should be a no-op in the worst case
  if (being_uploaded_files_.erase(file_id) || file_id.is_valid()) {
    cancel_upload_file(file_id);
  }
  file_id = get_message_content_thumbnail_file_id(content, td_);
  if (being_uploaded_thumbnails_.erase(file_id) || file_id.is_valid()) {
    cancel_upload_file(file_id);
  }
}

void MessagesManager::cancel_upload_file(FileId file_id) {
  // send the request later so they doesn't interfere with other actions
  // for example merge, supposed to happen soon, can auto-cancel the upload
  LOG(INFO) << "Cancel upload of file " << file_id;
  send_closure_later(G()->file_manager(), &FileManager::cancel_upload, file_id);
}

void MessagesManager::cancel_send_message_query(DialogId dialog_id, Message *m) {
  CHECK(m != nullptr);
  CHECK(m->content != nullptr);
  CHECK(m->message_id.is_valid() || m->message_id.is_valid_scheduled());
  CHECK(m->message_id.is_yet_unsent());
  LOG(INFO) << "Cancel send message query for " << m->message_id;

  cancel_upload_message_content_files(m->content.get());

  CHECK(m->edited_content == nullptr);

  if (!m->send_query_ref.empty()) {
    LOG(INFO) << "Cancel send query for " << m->message_id;
    cancel_query(m->send_query_ref);
    m->send_query_ref = NetQueryRef();
  }

  if (m->send_message_log_event_id != 0) {
    LOG(INFO) << "Delete send message log event for " << m->message_id;
    binlog_erase(G()->td_db()->get_binlog(), m->send_message_log_event_id);
    m->send_message_log_event_id = 0;
  }

  if (m->reply_to_message_id.is_valid() && !m->reply_to_message_id.is_yet_unsent()) {
    auto it = replied_by_yet_unsent_messages_.find({dialog_id, m->reply_to_message_id});
    CHECK(it != replied_by_yet_unsent_messages_.end());
    it->second--;
    CHECK(it->second >= 0);
    if (it->second == 0) {
      replied_by_yet_unsent_messages_.erase(it);
    }
  }

  if (m->media_album_id != 0) {
    send_closure_later(actor_id(this), &MessagesManager::on_upload_message_media_finished, m->media_album_id, dialog_id,
                       m->message_id, Status::OK());
  }

  if (!m->message_id.is_scheduled() && G()->parameters().use_file_db &&
      !m->is_copy) {  // ResourceManager::Mode::Baseline
    auto queue_id = get_sequence_dispatcher_id(dialog_id, m->content->get_type());
    if (queue_id & 1) {
      auto queue_it = yet_unsent_media_queues_.find(queue_id);
      if (queue_it != yet_unsent_media_queues_.end()) {
        auto &queue = queue_it->second;
        LOG(INFO) << "Delete " << m->message_id << " from queue " << queue_id;
        if (queue.erase(m->message_id) != 0) {
          if (queue.empty()) {
            yet_unsent_media_queues_.erase(queue_it);
          } else {
            // send later, because do_delete_all_dialog_messages can be called right now
            send_closure_later(actor_id(this), &MessagesManager::on_yet_unsent_media_queue_updated, dialog_id);
          }
        }
      }
    }
  }
}

void MessagesManager::cancel_send_deleted_message(DialogId dialog_id, Message *m, bool is_permanently_deleted) {
  CHECK(m != nullptr);
  if (m->message_id.is_yet_unsent()) {
    cancel_send_message_query(dialog_id, m);
  } else if (is_permanently_deleted || !m->message_id.is_scheduled()) {
    cancel_edit_message_media(dialog_id, m, "Message was deleted");
  }
}

bool MessagesManager::is_message_auto_read(DialogId dialog_id, bool is_outgoing) const {
  switch (dialog_id.get_type()) {
    case DialogType::User: {
      auto user_id = dialog_id.get_user_id();
      if (user_id == td_->contacts_manager_->get_my_id()) {
        return true;
      }
      if (is_outgoing && td_->contacts_manager_->is_user_bot(user_id)) {
        return true;
      }
      return false;
    }
    case DialogType::Chat:
      // TODO auto_read message content and messages sent to group with bots only
      return false;
    case DialogType::Channel:
      return is_outgoing && is_broadcast_channel(dialog_id);
    case DialogType::SecretChat:
      return false;
    case DialogType::None:
      return false;
    default:
      UNREACHABLE();
      return false;
  }
}

void MessagesManager::add_message_dependencies(Dependencies &dependencies, DialogId dialog_id, const Message *m) {
  dependencies.user_ids.insert(m->sender_user_id);
  add_dialog_and_dependencies(dependencies, m->sender_dialog_id);
  add_dialog_and_dependencies(dependencies, m->reply_in_dialog_id);
  add_dialog_and_dependencies(dependencies, m->real_forward_from_dialog_id);
  dependencies.user_ids.insert(m->via_bot_user_id);
  if (m->forward_info != nullptr) {
    dependencies.user_ids.insert(m->forward_info->sender_user_id);
    add_dialog_and_dependencies(dependencies, m->forward_info->sender_dialog_id);
    add_dialog_and_dependencies(dependencies, m->forward_info->from_dialog_id);
  }
  for (auto recent_replier_dialog_id : m->reply_info.recent_replier_dialog_ids) {
    add_message_sender_dependencies(dependencies, recent_replier_dialog_id);
  }
  add_message_content_dependencies(dependencies, m->content.get());
}

class MessagesManager::SendMessageLogEvent {
 public:
  DialogId dialog_id;
  const Message *m_in;
  unique_ptr<Message> m_out;

  SendMessageLogEvent() : dialog_id(), m_in(nullptr) {
  }

  SendMessageLogEvent(DialogId dialog_id, const Message *m) : dialog_id(dialog_id), m_in(m) {
  }

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id, storer);
    td::store(*m_in, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id, parser);
    td::parse(m_out, parser);
  }
};

Result<MessageId> MessagesManager::send_message(DialogId dialog_id, MessageId top_thread_message_id,
                                                MessageId reply_to_message_id,
                                                tl_object_ptr<td_api::messageSendOptions> &&options,
                                                tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                                tl_object_ptr<td_api::InputMessageContent> &&input_message_content) {
  if (input_message_content == nullptr) {
    return Status::Error(5, "Can't send message without content");
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(5, "Chat not found");
  }

  LOG(INFO) << "Begin to send message to " << dialog_id << " in reply to " << reply_to_message_id;

  reply_to_message_id = get_reply_to_message_id(d, top_thread_message_id, reply_to_message_id, false);

  if (input_message_content->get_id() == td_api::inputMessageForwarded::ID) {
    auto input_message = td_api::move_object_as<td_api::inputMessageForwarded>(input_message_content);
    TRY_RESULT(copy_options, process_message_copy_options(dialog_id, std::move(input_message->copy_options_)));
    copy_options.top_thread_message_id = top_thread_message_id;
    copy_options.reply_to_message_id = reply_to_message_id;
    TRY_RESULT_ASSIGN(copy_options.reply_markup, get_dialog_reply_markup(dialog_id, std::move(reply_markup)));
    return forward_message(dialog_id, DialogId(input_message->from_chat_id_), MessageId(input_message->message_id_),
                           std::move(options), input_message->in_game_share_, std::move(copy_options));
  }

  TRY_STATUS(can_send_message(dialog_id));
  TRY_RESULT(message_reply_markup, get_dialog_reply_markup(dialog_id, std::move(reply_markup)));
  TRY_RESULT(message_content, process_input_message_content(dialog_id, std::move(input_message_content)));
  TRY_RESULT(message_send_options, process_message_send_options(dialog_id, std::move(options)));
  TRY_STATUS(can_use_message_send_options(message_send_options, message_content));
  TRY_STATUS(can_use_top_thread_message_id(d, top_thread_message_id, reply_to_message_id));

  // there must be no errors after get_message_to_send call

  bool need_update_dialog_pos = false;
  Message *m = get_message_to_send(d, top_thread_message_id, reply_to_message_id, message_send_options,
                                   dup_message_content(td_, dialog_id, message_content.content.get(),
                                                       MessageContentDupType::Send, MessageCopyOptions()),
                                   &need_update_dialog_pos, false, nullptr, message_content.via_bot_user_id.is_valid());
  m->reply_markup = std::move(message_reply_markup);
  m->via_bot_user_id = message_content.via_bot_user_id;
  m->disable_web_page_preview = message_content.disable_web_page_preview;
  m->clear_draft = message_content.clear_draft;
  if (message_content.ttl > 0) {
    m->ttl = message_content.ttl;
    m->is_content_secret = is_secret_message_content(m->ttl, m->content->get_type());
  }
  m->send_emoji = std::move(message_content.emoji);

  if (message_content.clear_draft) {
    if (top_thread_message_id.is_valid()) {
      set_dialog_draft_message(dialog_id, top_thread_message_id, nullptr).ignore();
    } else {
      update_dialog_draft_message(d, nullptr, false, !need_update_dialog_pos);
    }
  }

  save_send_message_log_event(dialog_id, m);
  do_send_message(dialog_id, m);

  send_update_new_message(d, m);
  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "send_message");
  }

  return m->message_id;
}

Result<InputMessageContent> MessagesManager::process_input_message_content(
    DialogId dialog_id, tl_object_ptr<td_api::InputMessageContent> &&input_message_content) {
  if (input_message_content == nullptr) {
    return Status::Error(400, "Can't send message without content");
  }

  if (input_message_content->get_id() == td_api::inputMessageForwarded::ID) {
    // for sendMessageAlbum/editMessageMedia/addLocalMessage
    auto input_message = td_api::move_object_as<td_api::inputMessageForwarded>(input_message_content);
    TRY_RESULT(copy_options, process_message_copy_options(dialog_id, std::move(input_message->copy_options_)));
    if (!copy_options.send_copy) {
      return Status::Error(400, "Can't use forwarded message");
    }

    DialogId from_dialog_id(input_message->from_chat_id_);
    Dialog *from_dialog = get_dialog_force(from_dialog_id);
    if (from_dialog == nullptr) {
      return Status::Error(400, "Chat to copy message from not found");
    }
    if (!have_input_peer(from_dialog_id, AccessRights::Read)) {
      return Status::Error(400, "Can't access the chat to copy message from");
    }
    if (from_dialog_id.get_type() == DialogType::SecretChat) {
      return Status::Error(400, "Can't copy message from secret chats");
    }
    MessageId message_id = get_persistent_message_id(from_dialog, MessageId(input_message->message_id_));

    const Message *copied_message = get_message_force(from_dialog, message_id, "process_input_message_content");
    if (copied_message == nullptr) {
      return Status::Error(400, "Can't find message to copy");
    }
    if (!can_forward_message(from_dialog_id, copied_message)) {
      return Status::Error(400, "Can't copy message");
    }

    unique_ptr<MessageContent> content = dup_message_content(td_, dialog_id, copied_message->content.get(),
                                                             MessageContentDupType::Copy, std::move(copy_options));
    if (content == nullptr) {
      return Status::Error(400, "Can't copy message content");
    }

    return InputMessageContent(std::move(content), get_message_disable_web_page_preview(copied_message), false, 0,
                               UserId(), copied_message->send_emoji);
  }

  TRY_RESULT(content, get_input_message_content(dialog_id, std::move(input_message_content), td_));

  if (content.ttl < 0 || content.ttl > MAX_PRIVATE_MESSAGE_TTL) {
    return Status::Error(10, "Invalid message content TTL specified");
  }
  if (content.ttl > 0 && dialog_id.get_type() != DialogType::User) {
    return Status::Error(10, "Message content TTL can be specified only in private chats");
  }

  if (dialog_id != DialogId()) {
    TRY_STATUS(can_send_message_content(dialog_id, content.content.get(), false));
  }

  return std::move(content);
}

Result<MessageCopyOptions> MessagesManager::process_message_copy_options(
    DialogId dialog_id, tl_object_ptr<td_api::messageCopyOptions> &&options) const {
  if (options == nullptr || !options->send_copy_) {
    return MessageCopyOptions();
  }
  MessageCopyOptions result;
  result.send_copy = true;
  result.replace_caption = options->replace_caption_;
  if (result.replace_caption) {
    TRY_RESULT_ASSIGN(result.new_caption,
                      process_input_caption(td_->contacts_manager_.get(), dialog_id, std::move(options->new_caption_),
                                            td_->auth_manager_->is_bot()));
  }
  return std::move(result);
}

Result<MessagesManager::MessageSendOptions> MessagesManager::process_message_send_options(
    DialogId dialog_id, tl_object_ptr<td_api::messageSendOptions> &&options) const {
  MessageSendOptions result;
  if (options != nullptr) {
    result.disable_notification = options->disable_notification_;
    result.from_background = options->from_background_;
    TRY_RESULT_ASSIGN(result.schedule_date, get_message_schedule_date(std::move(options->scheduling_state_)));
  }

  auto dialog_type = dialog_id.get_type();
  if (result.schedule_date != 0) {
    if (dialog_type == DialogType::SecretChat) {
      return Status::Error(400, "Can't schedule messages in secret chats");
    }
    if (td_->auth_manager_->is_bot()) {
      return Status::Error(400, "Bots can't send scheduled messages");
    }
  }
  if (result.schedule_date == SCHEDULE_WHEN_ONLINE_DATE) {
    if (dialog_type != DialogType::User) {
      return Status::Error(400, "Messages can be scheduled till online only in private chats");
    }
    if (dialog_id == get_my_dialog_id()) {
      return Status::Error(400, "Can't scheduled till online messages in chat with self");
    }
  }

  return result;
}

Status MessagesManager::can_use_message_send_options(const MessageSendOptions &options,
                                                     const unique_ptr<MessageContent> &content, int32 ttl) {
  if (options.schedule_date != 0) {
    if (ttl > 0) {
      return Status::Error(400, "Can't send scheduled self-destructing messages");
    }
    if (content->get_type() == MessageContentType::LiveLocation) {
      return Status::Error(400, "Can't send scheduled live location messages");
    }
  }

  return Status::OK();
}

Status MessagesManager::can_use_message_send_options(const MessageSendOptions &options,
                                                     const InputMessageContent &content) {
  return can_use_message_send_options(options, content.content, content.ttl);
}

Status MessagesManager::can_use_top_thread_message_id(Dialog *d, MessageId top_thread_message_id,
                                                      MessageId reply_to_message_id) {
  if (top_thread_message_id == MessageId()) {
    return Status::OK();
  }

  if (!top_thread_message_id.is_valid() || !top_thread_message_id.is_server()) {
    return Status::Error(400, "Invalid message thread ID specified");
  }
  if (d->dialog_id.get_type() != DialogType::Channel || is_broadcast_channel(d->dialog_id)) {
    return Status::Error(400, "Chat doesn't have threads");
  }
  if (reply_to_message_id.is_valid()) {
    const Message *reply_m = get_message_force(d, reply_to_message_id, "can_use_top_thread_message_id 1");
    if (reply_m != nullptr && top_thread_message_id != reply_m->top_thread_message_id) {
      if (reply_m->top_thread_message_id.is_valid() || reply_m->media_album_id == 0) {
        return Status::Error(400, "The message to reply is not in the specified message thread");
      }

      // if the message is in an album and not in the thread, it can be in the album of top_thread_message_id
      const Message *top_m = get_message_force(d, top_thread_message_id, "can_use_top_thread_message_id 2");
      if (top_m != nullptr &&
          (top_m->media_album_id != reply_m->media_album_id || top_m->top_thread_message_id != top_m->message_id)) {
        return Status::Error(400, "The message to reply is not in the specified message thread root album");
      }
    }
  }

  return Status::OK();
}

int64 MessagesManager::generate_new_media_album_id() {
  int64 media_album_id = 0;
  do {
    media_album_id = Random::secure_int64();
  } while (media_album_id >= 0 || pending_message_group_sends_.count(media_album_id) != 0);
  return media_album_id;
}

Result<vector<MessageId>> MessagesManager::send_message_group(
    DialogId dialog_id, MessageId top_thread_message_id, MessageId reply_to_message_id,
    tl_object_ptr<td_api::messageSendOptions> &&options,
    vector<tl_object_ptr<td_api::InputMessageContent>> &&input_message_contents) {
  if (input_message_contents.size() > MAX_GROUPED_MESSAGES) {
    return Status::Error(4, "Too much messages to send as an album");
  }
  if (input_message_contents.empty()) {
    return Status::Error(4, "There are no messages to send");
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(5, "Chat not found");
  }

  TRY_STATUS(can_send_message(dialog_id));
  TRY_RESULT(message_send_options, process_message_send_options(dialog_id, std::move(options)));

  vector<std::pair<unique_ptr<MessageContent>, int32>> message_contents;
  std::unordered_set<MessageContentType, MessageContentTypeHash> message_content_types;
  for (auto &input_message_content : input_message_contents) {
    TRY_RESULT(message_content, process_input_message_content(dialog_id, std::move(input_message_content)));
    TRY_STATUS(can_use_message_send_options(message_send_options, message_content));
    auto message_content_type = message_content.content->get_type();
    if (!is_allowed_media_group_content(message_content_type)) {
      return Status::Error(5, "Invalid message content type");
    }
    message_content_types.insert(message_content_type);

    message_contents.emplace_back(std::move(message_content.content), message_content.ttl);
  }
  if (message_content_types.size() > 1) {
    for (auto message_content_type : message_content_types) {
      if (is_homogenous_media_group_content(message_content_type)) {
        return Status::Error(400, PSLICE() << message_content_type << " can't be mixed with other media types");
      }
    }
  }

  reply_to_message_id = get_reply_to_message_id(d, top_thread_message_id, reply_to_message_id, false);
  TRY_STATUS(can_use_top_thread_message_id(d, top_thread_message_id, reply_to_message_id));

  int64 media_album_id = 0;
  if (message_contents.size() > 1) {
    media_album_id = generate_new_media_album_id();
  }

  // there must be no errors after get_message_to_send calls

  vector<MessageId> result;
  bool need_update_dialog_pos = false;
  for (size_t i = 0; i < message_contents.size(); i++) {
    auto &message_content = message_contents[i];
    Message *m = get_message_to_send(d, top_thread_message_id, reply_to_message_id, message_send_options,
                                     dup_message_content(td_, dialog_id, message_content.first.get(),
                                                         MessageContentDupType::Send, MessageCopyOptions()),
                                     &need_update_dialog_pos, i != 0);
    result.push_back(m->message_id);
    auto ttl = message_content.second;
    if (ttl > 0) {
      m->ttl = ttl;
      m->is_content_secret = is_secret_message_content(m->ttl, m->content->get_type());
    }
    m->media_album_id = media_album_id;

    save_send_message_log_event(dialog_id, m);
    do_send_message(dialog_id, m);

    send_update_new_message(d, m);
  }

  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "send_message_group");
  }

  return result;
}

void MessagesManager::save_send_message_log_event(DialogId dialog_id, const Message *m) {
  if (!G()->parameters().use_message_db) {
    return;
  }

  CHECK(m != nullptr);
  LOG(INFO) << "Save " << FullMessageId(dialog_id, m->message_id) << " to binlog";
  auto log_event = SendMessageLogEvent(dialog_id, m);
  CHECK(m->send_message_log_event_id == 0);
  m->send_message_log_event_id =
      binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::SendMessage, get_log_event_storer(log_event));
}

void MessagesManager::do_send_message(DialogId dialog_id, const Message *m, vector<int> bad_parts) {
  bool is_edit = m->message_id.is_any_server();
  LOG(INFO) << "Do " << (is_edit ? "edit" : "send") << ' ' << FullMessageId(dialog_id, m->message_id);
  bool is_secret = dialog_id.get_type() == DialogType::SecretChat;

  if (m->media_album_id != 0 && bad_parts.empty() && !is_secret && !is_edit) {
    auto &request = pending_message_group_sends_[m->media_album_id];
    request.dialog_id = dialog_id;
    request.message_ids.push_back(m->message_id);
    request.is_finished.push_back(false);

    request.results.push_back(Status::OK());
  }

  auto content = is_edit ? m->edited_content.get() : m->content.get();
  CHECK(content != nullptr);
  auto content_type = content->get_type();
  if (content_type == MessageContentType::Text) {
    CHECK(!is_edit);
    send_closure_later(actor_id(this), &MessagesManager::on_text_message_ready_to_send, dialog_id, m->message_id);
    return;
  }

  FileId file_id = get_message_content_any_file_id(content);  // any_file_id, because it could be a photo sent by ID
  FileView file_view = td_->file_manager_->get_file_view(file_id);
  FileId thumbnail_file_id = get_message_content_thumbnail_file_id(content, td_);
  LOG(DEBUG) << "Need to send file " << file_id << " with thumbnail " << thumbnail_file_id;
  if (is_secret) {
    CHECK(!is_edit);
    auto layer = td_->contacts_manager_->get_secret_chat_layer(dialog_id.get_secret_chat_id());
    auto secret_input_media = get_secret_input_media(content, td_, nullptr, BufferSlice(), layer);
    if (secret_input_media.empty()) {
      LOG(INFO) << "Ask to upload encrypted file " << file_id;
      CHECK(file_view.is_encrypted_secret());
      CHECK(file_id.is_valid());
      CHECK(being_uploaded_files_.find(file_id) == being_uploaded_files_.end());
      being_uploaded_files_[file_id] = {FullMessageId(dialog_id, m->message_id), thumbnail_file_id};
      // need to call resume_upload synchronously to make upload process consistent with being_uploaded_files_
      td_->file_manager_->resume_upload(file_id, std::move(bad_parts), upload_media_callback_, 1, m->message_id.get());
    } else {
      on_secret_message_media_uploaded(dialog_id, m, std::move(secret_input_media), file_id, thumbnail_file_id);
    }
  } else {
    auto input_media =
        get_input_media(content, td_, m->ttl, m->send_emoji, td_->auth_manager_->is_bot() && bad_parts.empty());
    if (input_media == nullptr) {
      if (content_type == MessageContentType::Game || content_type == MessageContentType::Poll) {
        return;
      }
      if (content_type == MessageContentType::Photo) {
        thumbnail_file_id = FileId();
      }

      LOG(INFO) << "Ask to upload file " << file_id << " with bad parts " << bad_parts;
      CHECK(file_id.is_valid());
      CHECK(being_uploaded_files_.find(file_id) == being_uploaded_files_.end());
      being_uploaded_files_[file_id] = {FullMessageId(dialog_id, m->message_id), thumbnail_file_id};
      // need to call resume_upload synchronously to make upload process consistent with being_uploaded_files_
      td_->file_manager_->resume_upload(file_id, std::move(bad_parts), upload_media_callback_, 1, m->message_id.get());
    } else {
      on_message_media_uploaded(dialog_id, m, std::move(input_media), file_id, thumbnail_file_id);
    }
  }
}

void MessagesManager::on_message_media_uploaded(DialogId dialog_id, const Message *m,
                                                tl_object_ptr<telegram_api::InputMedia> &&input_media, FileId file_id,
                                                FileId thumbnail_file_id) {
  CHECK(m != nullptr);
  CHECK(input_media != nullptr);

  auto message_id = m->message_id;
  if (message_id.is_any_server()) {
    const FormattedText *caption = get_message_content_caption(m->edited_content.get());
    auto input_reply_markup = get_input_reply_markup(m->edited_reply_markup);
    bool was_uploaded = FileManager::extract_was_uploaded(input_media);
    bool was_thumbnail_uploaded = FileManager::extract_was_thumbnail_uploaded(input_media);

    LOG(INFO) << "Edit media from " << message_id << " in " << dialog_id;
    auto schedule_date = get_message_schedule_date(m);
    auto promise = PromiseCreator::lambda(
        [actor_id = actor_id(this), dialog_id, message_id, file_id, thumbnail_file_id, schedule_date,
         generation = m->edit_generation, was_uploaded, was_thumbnail_uploaded,
         file_reference = FileManager::extract_file_reference(input_media)](Result<int32> result) mutable {
          send_closure(actor_id, &MessagesManager::on_message_media_edited, dialog_id, message_id, file_id,
                       thumbnail_file_id, was_uploaded, was_thumbnail_uploaded, std::move(file_reference),
                       schedule_date, generation, std::move(result));
        });
    send_closure(td_->create_net_actor<EditMessageActor>(std::move(promise)), &EditMessageActor::send, 1 << 11,
                 dialog_id, message_id, caption == nullptr ? "" : caption->text,
                 get_input_message_entities(td_->contacts_manager_.get(), caption, "edit_message_media"),
                 std::move(input_media), std::move(input_reply_markup), schedule_date,
                 get_sequence_dispatcher_id(dialog_id, MessageContentType::None));
    return;
  }

  if (m->media_album_id == 0) {
    send_closure_later(
        actor_id(this), &MessagesManager::on_media_message_ready_to_send, dialog_id, message_id,
        PromiseCreator::lambda([this, dialog_id, input_media = std::move(input_media), file_id,
                                thumbnail_file_id](Result<Message *> result) mutable {
          if (result.is_error() || G()->close_flag()) {
            return;
          }

          auto m = result.move_as_ok();
          CHECK(m != nullptr);
          CHECK(input_media != nullptr);

          const FormattedText *caption = get_message_content_caption(m->content.get());
          LOG(INFO) << "Send media from " << m->message_id << " in " << dialog_id << " in reply to "
                    << m->reply_to_message_id;
          int64 random_id = begin_send_message(dialog_id, m);
          send_closure(
              td_->create_net_actor<SendMediaActor>(), &SendMediaActor::send, file_id, thumbnail_file_id,
              get_message_flags(m), dialog_id, m->reply_to_message_id, get_message_schedule_date(m),
              get_input_reply_markup(m->reply_markup),
              get_input_message_entities(td_->contacts_manager_.get(), caption, "on_message_media_uploaded"),
              caption == nullptr ? "" : caption->text, std::move(input_media), random_id, &m->send_query_ref,
              get_sequence_dispatcher_id(dialog_id, m->is_copy ? MessageContentType::None : m->content->get_type()));
        }));
  } else {
    switch (input_media->get_id()) {
      case telegram_api::inputMediaUploadedDocument::ID:
        static_cast<telegram_api::inputMediaUploadedDocument *>(input_media.get())->flags_ |=
            telegram_api::inputMediaUploadedDocument::NOSOUND_VIDEO_MASK;
      // fallthrough
      case telegram_api::inputMediaUploadedPhoto::ID:
      case telegram_api::inputMediaDocumentExternal::ID:
      case telegram_api::inputMediaPhotoExternal::ID:
        LOG(INFO) << "Upload media from " << message_id << " in " << dialog_id;
        td_->create_handler<UploadMediaQuery>()->send(dialog_id, message_id, file_id, thumbnail_file_id,
                                                      std::move(input_media));
        break;
      case telegram_api::inputMediaDocument::ID:
      case telegram_api::inputMediaPhoto::ID:
        send_closure_later(actor_id(this), &MessagesManager::on_upload_message_media_finished, m->media_album_id,
                           dialog_id, message_id, Status::OK());
        break;
      default:
        LOG(ERROR) << "Have wrong input media " << to_string(input_media);
        send_closure_later(actor_id(this), &MessagesManager::on_upload_message_media_finished, m->media_album_id,
                           dialog_id, message_id, Status::Error(400, "Invalid input media"));
    }
  }
}

void MessagesManager::on_secret_message_media_uploaded(DialogId dialog_id, const Message *m,
                                                       SecretInputMedia &&secret_input_media, FileId file_id,
                                                       FileId thumbnail_file_id) {
  CHECK(m != nullptr);
  CHECK(m->message_id.is_valid());
  CHECK(!secret_input_media.empty());
  /*
  if (m->media_album_id != 0) {
    switch (secret_input_media->input_file_->get_id()) {
      case telegram_api::inputEncryptedFileUploaded::ID:
      case telegram_api::inputEncryptedFileBigUploaded::ID:
        LOG(INFO) << "Upload media from " << m->message_id << " in " << dialog_id;
        return td_->create_handler<UploadEncryptedMediaQuery>()->send(dialog_id, m->message_id, std::move(secret_input_media));
      case telegram_api::inputEncryptedFile::ID:
        return send_closure_later(actor_id(this), &MessagesManager::on_upload_message_media_finished, m->media_album_id,
                           dialog_id, m->message_id, Status::OK());
      default:
        LOG(ERROR) << "Have wrong secret input media " << to_string(secret_input_media->input_file_);
        return send_closure_later(actor_id(this), &MessagesManager::on_upload_message_media_finished, m->media_album_id,
                           dialog_id, m->message_id, Status::Error(400, "Invalid input media"));
  }
  */
  // TODO use file_id, thumbnail_file_id, was_uploaded, was_thumbnail_uploaded,
  // invalidate partial remote location for file_id in case of failed upload even message has already been deleted
  send_closure_later(
      actor_id(this), &MessagesManager::on_media_message_ready_to_send, dialog_id, m->message_id,
      PromiseCreator::lambda(
          [this, dialog_id, secret_input_media = std::move(secret_input_media)](Result<Message *> result) mutable {
            if (result.is_error() || G()->close_flag()) {
              return;
            }

            auto m = result.move_as_ok();
            CHECK(m != nullptr);
            CHECK(!secret_input_media.empty());
            LOG(INFO) << "Send secret media from " << m->message_id << " in " << dialog_id << " in reply to "
                      << m->reply_to_message_id;
            int64 random_id = begin_send_message(dialog_id, m);
            auto layer = td_->contacts_manager_->get_secret_chat_layer(dialog_id.get_secret_chat_id());
            auto caption = get_message_content_caption(m->content.get());
            vector<tl_object_ptr<secret_api::MessageEntity>> entities;
            if (caption != nullptr && !caption->entities.empty()) {
              entities = get_input_secret_message_entities(caption->entities, layer);
            }
            send_closure(td_->create_net_actor<SendSecretMessageActor>(), &SendSecretMessageActor::send, dialog_id,
                         m->reply_to_random_id, m->ttl, "", std::move(secret_input_media), std::move(entities),
                         m->via_bot_user_id, m->media_album_id, m->disable_notification, random_id);
          }));
}

void MessagesManager::on_upload_message_media_success(DialogId dialog_id, MessageId message_id,
                                                      tl_object_ptr<telegram_api::MessageMedia> &&media) {
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  CHECK(message_id.is_valid() || message_id.is_valid_scheduled());
  CHECK(message_id.is_yet_unsent());
  Message *m = get_message(d, message_id);
  if (m == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel
    // don't need to send error to the user, because the message has already been deleted
    // and there is nothing to be deleted from the server
    LOG(INFO) << "Fail to send already deleted by the user or sent to inaccessible chat "
              << FullMessageId{dialog_id, message_id};
    return;
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return;  // the message should be deleted soon
  }

  auto caption = get_message_content_caption(m->content.get());
  auto content = get_message_content(td_, caption == nullptr ? FormattedText() : *caption, std::move(media), dialog_id,
                                     false, UserId(), nullptr);

  update_message_content(dialog_id, m, std::move(content), true, true, true);

  auto input_media = get_input_media(m->content.get(), td_, m->ttl, m->send_emoji, true);
  Status result;
  if (input_media == nullptr) {
    result = Status::Error(400, "Failed to upload file");
  }

  send_closure_later(actor_id(this), &MessagesManager::on_upload_message_media_finished, m->media_album_id, dialog_id,
                     m->message_id, std::move(result));
}

void MessagesManager::on_upload_message_media_file_part_missing(DialogId dialog_id, MessageId message_id,
                                                                int bad_part) {
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  Message *m = get_message(d, message_id);
  if (m == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel
    // don't need to send error to the user, because the message has already been deleted
    // and there is nothing to be deleted from the server
    LOG(INFO) << "Fail to send already deleted by the user or sent to inaccessible chat "
              << FullMessageId{dialog_id, message_id};
    return;
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    // LOG(ERROR) << "Found " << m->message_id << " in inaccessible " << dialog_id;
    // dump_debug_message_op(get_dialog(dialog_id), 5);
    return;  // the message should be deleted soon
  }

  CHECK(dialog_id.get_type() != DialogType::SecretChat);

  do_send_message(dialog_id, m, {bad_part});
}

void MessagesManager::on_upload_message_media_fail(DialogId dialog_id, MessageId message_id, Status error) {
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  Message *m = get_message(d, message_id);
  if (m == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel
    // don't need to send error to the user, because the message has already been deleted
    // and there is nothing to be deleted from the server
    LOG(INFO) << "Fail to send already deleted by the user or sent to inaccessible chat "
              << FullMessageId{dialog_id, message_id};
    return;
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    // LOG(ERROR) << "Found " << m->message_id << " in inaccessible " << dialog_id;
    // dump_debug_message_op(get_dialog(dialog_id), 5);
    return;  // the message should be deleted soon
  }

  CHECK(dialog_id.get_type() != DialogType::SecretChat);

  send_closure_later(actor_id(this), &MessagesManager::on_upload_message_media_finished, m->media_album_id, dialog_id,
                     m->message_id, std::move(error));
}

void MessagesManager::on_upload_message_media_finished(int64 media_album_id, DialogId dialog_id, MessageId message_id,
                                                       Status result) {
  CHECK(media_album_id < 0);
  auto it = pending_message_group_sends_.find(media_album_id);
  if (it == pending_message_group_sends_.end()) {
    // the group may be already sent or failed to be sent
    return;
  }
  auto &request = it->second;
  CHECK(request.dialog_id == dialog_id);
  auto message_it = std::find(request.message_ids.begin(), request.message_ids.end(), message_id);
  if (message_it == request.message_ids.end()) {
    // the message may be already deleted and the album is recreated without it
    CHECK(message_id.is_yet_unsent());
    LOG_CHECK(get_message({dialog_id, message_id}) == nullptr)
        << dialog_id << ' ' << request.message_ids << ' ' << message_id << ' ' << request.finished_count << ' '
        << request.is_finished << ' ' << request.results;
    return;
  }
  auto pos = static_cast<size_t>(message_it - request.message_ids.begin());

  if (request.is_finished[pos]) {
    LOG(INFO) << "Upload media of " << message_id << " in " << dialog_id << " from group " << media_album_id
              << " at pos " << pos << " was already finished";
    return;
  }
  LOG(INFO) << "Finish to upload media of " << message_id << " in " << dialog_id << " from group " << media_album_id
            << " at pos " << pos << " with result " << result
            << " and previous finished_count = " << request.finished_count;

  request.results[pos] = std::move(result);
  request.is_finished[pos] = true;
  request.finished_count++;

  if (request.finished_count == request.message_ids.size() || request.results[pos].is_error()) {
    // must use send_closure_later if some messages may be being deleted now
    // but this function is called only through send_closure_later, so there should be no being deleted messages
    // we must use synchronous calls to keep the correct message order during copying of multiple messages
    // but "request" iterator can be invalidated by do_send_message_group, so it must not be used below
    auto message_ids = request.message_ids;
    for (auto request_message_id : message_ids) {
      LOG(INFO) << "Send on_media_message_ready_to_send for " << request_message_id << " in " << dialog_id;
      auto promise = PromiseCreator::lambda([this, media_album_id](Result<Message *> result) {
        if (result.is_error() || G()->close_flag()) {
          return;
        }

        auto m = result.move_as_ok();
        CHECK(m != nullptr);
        CHECK(m->media_album_id == media_album_id);
        do_send_message_group(media_album_id);
        // send_closure_later(actor_id, &MessagesManager::do_send_message_group, media_album_id);
      });
      // send_closure_later(actor_id(this), &MessagesManager::on_media_message_ready_to_send, dialog_id,
      //                   request_message_id, std::move(promise));
      on_media_message_ready_to_send(dialog_id, request_message_id, std::move(promise));
    }
  }
}

void MessagesManager::do_send_message_group(int64 media_album_id) {
  CHECK(media_album_id < 0);
  auto it = pending_message_group_sends_.find(media_album_id);
  if (it == pending_message_group_sends_.end()) {
    // the group may be already sent or failed to be sent
    return;
  }
  auto &request = it->second;

  auto dialog_id = request.dialog_id;
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  auto default_status = can_send_message(dialog_id);
  bool success = default_status.is_ok();
  vector<FileId> file_ids;
  vector<int64> random_ids;
  vector<tl_object_ptr<telegram_api::inputSingleMedia>> input_single_media;
  MessageId reply_to_message_id;
  int32 flags = 0;
  int32 schedule_date = 0;
  bool is_copy = false;
  for (size_t i = 0; i < request.message_ids.size(); i++) {
    auto *m = get_message(d, request.message_ids[i]);
    if (m == nullptr) {
      // skip deleted messages
      random_ids.push_back(0);
      continue;
    }

    reply_to_message_id = m->reply_to_message_id;
    flags = get_message_flags(m);
    schedule_date = get_message_schedule_date(m);
    is_copy = m->is_copy;

    file_ids.push_back(get_message_content_any_file_id(m->content.get()));
    random_ids.push_back(begin_send_message(dialog_id, m));

    LOG(INFO) << "Have file " << file_ids.back() << " in " << m->message_id << " with result " << request.results[i]
              << " and is_finished = " << static_cast<bool>(request.is_finished[i]);

    if (request.results[i].is_error() || !request.is_finished[i]) {
      success = false;
      continue;
    }

    const FormattedText *caption = get_message_content_caption(m->content.get());
    auto input_media = get_input_media(m->content.get(), td_, m->ttl, m->send_emoji, true);
    if (input_media == nullptr) {
      // TODO return CHECK
      auto file_id = get_message_content_any_file_id(m->content.get());
      auto file_view = td_->file_manager_->get_file_view(file_id);
      bool has_remote = file_view.has_remote_location();
      bool is_web = has_remote ? file_view.remote_location().is_web() : false;
      LOG(FATAL) << request.dialog_id << " " << request.finished_count << " " << i << " " << request.message_ids << " "
                 << request.is_finished << " " << request.results << " " << m->ttl << " " << has_remote << " "
                 << file_view.has_alive_remote_location() << " " << file_view.has_active_upload_remote_location() << " "
                 << file_view.has_active_download_remote_location() << " " << file_view.is_encrypted() << " " << is_web
                 << " " << file_view.has_url() << " "
                 << to_string(get_message_content_object(m->content.get(), td_, m->date, m->is_content_secret));
    }
    auto entities = get_input_message_entities(td_->contacts_manager_.get(), caption, "do_send_message_group");
    int32 input_single_media_flags = 0;
    if (!entities.empty()) {
      input_single_media_flags |= telegram_api::inputSingleMedia::ENTITIES_MASK;
    }

    input_single_media.push_back(make_tl_object<telegram_api::inputSingleMedia>(
        input_single_media_flags, std::move(input_media), random_ids.back(), caption == nullptr ? "" : caption->text,
        std::move(entities)));
  }

  if (!success) {
    if (default_status.is_ok()) {
      default_status = Status::Error(400, "Group send failed");
    }
    for (size_t i = 0; i < random_ids.size(); i++) {
      if (random_ids[i] != 0) {
        on_send_message_fail(random_ids[i],
                             request.results[i].is_error() ? std::move(request.results[i]) : default_status.clone());
      }
    }
    pending_message_group_sends_.erase(it);
    return;
  }
  LOG_CHECK(request.finished_count == request.message_ids.size())
      << request.finished_count << " " << request.message_ids.size();
  pending_message_group_sends_.erase(it);

  LOG(INFO) << "Begin to send media group " << media_album_id << " to " << dialog_id;

  if (input_single_media.empty()) {
    LOG(INFO) << "Media group " << media_album_id << " from " << dialog_id << " is empty";
  }
  send_closure(td_->create_net_actor<SendMultiMediaActor>(), &SendMultiMediaActor::send, flags, dialog_id,
               reply_to_message_id, schedule_date, std::move(file_ids), std::move(input_single_media),
               get_sequence_dispatcher_id(dialog_id, is_copy ? MessageContentType::None : MessageContentType::Photo));
}

void MessagesManager::on_text_message_ready_to_send(DialogId dialog_id, MessageId message_id) {
  LOG(INFO) << "Ready to send " << message_id << " to " << dialog_id;

  auto m = get_message({dialog_id, message_id});
  if (m == nullptr) {
    return;
  }

  CHECK(message_id.is_yet_unsent());

  auto content = m->content.get();
  CHECK(content != nullptr);
  auto content_type = content->get_type();

  const FormattedText *message_text = get_message_content_text(content);
  CHECK(message_text != nullptr);

  int64 random_id = begin_send_message(dialog_id, m);
  if (dialog_id.get_type() == DialogType::SecretChat) {
    CHECK(!message_id.is_scheduled());
    auto layer = td_->contacts_manager_->get_secret_chat_layer(dialog_id.get_secret_chat_id());
    send_closure(td_->create_net_actor<SendSecretMessageActor>(), &SendSecretMessageActor::send, dialog_id,
                 m->reply_to_random_id, m->ttl, message_text->text,
                 get_secret_input_media(content, td_, nullptr, BufferSlice(), layer),
                 get_input_secret_message_entities(message_text->entities, layer), m->via_bot_user_id,
                 m->media_album_id, m->disable_notification, random_id);
  } else {
    send_closure(td_->create_net_actor<SendMessageActor>(), &SendMessageActor::send, get_message_flags(m), dialog_id,
                 m->reply_to_message_id, get_message_schedule_date(m), get_input_reply_markup(m->reply_markup),
                 get_input_message_entities(td_->contacts_manager_.get(), message_text->entities, "do_send_message"),
                 message_text->text, random_id, &m->send_query_ref,
                 get_sequence_dispatcher_id(dialog_id, content_type));
  }
}

void MessagesManager::on_media_message_ready_to_send(DialogId dialog_id, MessageId message_id,
                                                     Promise<Message *> &&promise) {
  LOG(INFO) << "Ready to send " << message_id << " to " << dialog_id;
  CHECK(promise);
  if (!G()->parameters().use_file_db || message_id.is_scheduled()) {  // ResourceManager::Mode::Greedy
    auto m = get_message({dialog_id, message_id});
    if (m != nullptr) {
      promise.set_value(std::move(m));
    }
    return;
  }

  auto queue_id = get_sequence_dispatcher_id(dialog_id, MessageContentType::Photo);
  CHECK(queue_id & 1);
  auto &queue = yet_unsent_media_queues_[queue_id];
  auto it = queue.find(message_id);
  if (it == queue.end()) {
    if (queue.empty()) {
      yet_unsent_media_queues_.erase(queue_id);
    }

    LOG(INFO) << "Can't find " << message_id << " in the queue of " << dialog_id;
    auto m = get_message({dialog_id, message_id});
    if (m != nullptr) {
      promise.set_value(std::move(m));
    }
    return;
  }
  if (it->second) {
    promise.set_error(Status::Error(500, "Duplicate promise"));
    return;
  }
  it->second = std::move(promise);

  on_yet_unsent_media_queue_updated(dialog_id);
}

void MessagesManager::on_yet_unsent_media_queue_updated(DialogId dialog_id) {
  auto queue_id = get_sequence_dispatcher_id(dialog_id, MessageContentType::Photo);
  CHECK(queue_id & 1);
  while (true) {
    auto it = yet_unsent_media_queues_.find(queue_id);
    if (it == yet_unsent_media_queues_.end()) {
      return;
    }
    auto &queue = it->second;
    if (queue.empty()) {
      yet_unsent_media_queues_.erase(it);
      return;
    }
    auto first_it = queue.begin();
    if (!first_it->second) {
      return;
    }

    auto m = get_message({dialog_id, first_it->first});
    auto promise = std::move(first_it->second);
    queue.erase(first_it);
    LOG(INFO) << "Queue for " << dialog_id << " now has size " << queue.size();

    // don't use it/queue/first_it after promise is called
    if (m != nullptr) {
      LOG(INFO) << "Can send " << FullMessageId{dialog_id, m->message_id};
      promise.set_value(std::move(m));
    } else {
      promise.set_error(Status::Error(400, "Message not found"));
    }
  }
}

Result<MessageId> MessagesManager::send_bot_start_message(UserId bot_user_id, DialogId dialog_id,
                                                          const string &parameter) {
  LOG(INFO) << "Begin to send bot start message to " << dialog_id;
  if (td_->auth_manager_->is_bot()) {
    return Status::Error(5, "Bot can't send start message to another bot");
  }

  TRY_RESULT(bot_data, td_->contacts_manager_->get_bot_data(bot_user_id));

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(5, "Chat not found");
  }

  bool is_chat_with_bot = false;
  switch (dialog_id.get_type()) {
    case DialogType::User:
      if (dialog_id.get_user_id() != bot_user_id) {
        return Status::Error(5, "Can't send start message to a private chat other than chat with the bot");
      }
      is_chat_with_bot = true;
      break;
    case DialogType::Chat: {
      if (!bot_data.can_join_groups) {
        return Status::Error(5, "Bot can't join groups");
      }

      auto chat_id = dialog_id.get_chat_id();
      if (!td_->contacts_manager_->have_input_peer_chat(chat_id, AccessRights::Write)) {
        return Status::Error(3, "Can't access the chat");
      }
      auto status = td_->contacts_manager_->get_chat_permissions(chat_id);
      if (!status.can_invite_users()) {
        return Status::Error(3, "Need administrator rights to invite a bot to the group chat");
      }
      break;
    }
    case DialogType::Channel: {
      auto channel_id = dialog_id.get_channel_id();
      if (!td_->contacts_manager_->have_input_peer_channel(channel_id, AccessRights::Write)) {
        return Status::Error(3, "Can't access the chat");
      }
      switch (td_->contacts_manager_->get_channel_type(channel_id)) {
        case ChannelType::Megagroup:
          if (!bot_data.can_join_groups) {
            return Status::Error(5, "The bot can't join groups");
          }
          break;
        case ChannelType::Broadcast:
          return Status::Error(3, "Bots can't be invited to channel chats. Add them as administrators instead");
        case ChannelType::Unknown:
        default:
          UNREACHABLE();
      }
      auto status = td_->contacts_manager_->get_channel_permissions(channel_id);
      if (!status.can_invite_users()) {
        return Status::Error(3, "Need administrator rights to invite a bot to the supergroup chat");
      }
      break;
    }
    case DialogType::SecretChat:
      return Status::Error(5, "Can't send bot start message to a secret chat");
    case DialogType::None:
    default:
      UNREACHABLE();
  }
  string text = "/start";
  if (!is_chat_with_bot) {
    text += '@';
    text += bot_data.username;
  }

  vector<MessageEntity> text_entities;
  text_entities.emplace_back(MessageEntity::Type::BotCommand, 0, narrow_cast<int32>(text.size()));
  bool need_update_dialog_pos = false;
  Message *m = get_message_to_send(d, MessageId(), MessageId(), MessageSendOptions(),
                                   create_text_message_content(text, std::move(text_entities), WebPageId()),
                                   &need_update_dialog_pos);
  m->is_bot_start_message = true;

  send_update_new_message(d, m);
  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "send_bot_start_message");
  }

  if (parameter.empty() && is_chat_with_bot) {
    save_send_message_log_event(dialog_id, m);
    do_send_message(dialog_id, m);
  } else {
    save_send_bot_start_message_log_event(bot_user_id, dialog_id, parameter, m);
    do_send_bot_start_message(bot_user_id, dialog_id, parameter, m);
  }
  return m->message_id;
}

class MessagesManager::SendBotStartMessageLogEvent {
 public:
  UserId bot_user_id;
  DialogId dialog_id;
  string parameter;
  const Message *m_in = nullptr;
  unique_ptr<Message> m_out;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(bot_user_id, storer);
    td::store(dialog_id, storer);
    td::store(parameter, storer);
    td::store(*m_in, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(bot_user_id, parser);
    td::parse(dialog_id, parser);
    td::parse(parameter, parser);
    td::parse(m_out, parser);
  }
};

void MessagesManager::save_send_bot_start_message_log_event(UserId bot_user_id, DialogId dialog_id,
                                                            const string &parameter, const Message *m) {
  if (!G()->parameters().use_message_db) {
    return;
  }

  CHECK(m != nullptr);
  LOG(INFO) << "Save " << FullMessageId(dialog_id, m->message_id) << " to binlog";
  SendBotStartMessageLogEvent log_event;
  log_event.bot_user_id = bot_user_id;
  log_event.dialog_id = dialog_id;
  log_event.parameter = parameter;
  log_event.m_in = m;
  CHECK(m->send_message_log_event_id == 0);
  m->send_message_log_event_id = binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::SendBotStartMessage,
                                            get_log_event_storer(log_event));
}

void MessagesManager::do_send_bot_start_message(UserId bot_user_id, DialogId dialog_id, const string &parameter,
                                                const Message *m) {
  LOG(INFO) << "Do send bot start " << FullMessageId(dialog_id, m->message_id) << " to bot " << bot_user_id;

  int64 random_id = begin_send_message(dialog_id, m);
  telegram_api::object_ptr<telegram_api::InputPeer> input_peer = dialog_id.get_type() == DialogType::User
                                                                     ? make_tl_object<telegram_api::inputPeerEmpty>()
                                                                     : get_input_peer(dialog_id, AccessRights::Write);
  if (input_peer == nullptr) {
    return on_send_message_fail(random_id, Status::Error(400, "Have no info about the chat"));
  }
  auto bot_input_user = td_->contacts_manager_->get_input_user(bot_user_id);
  if (bot_input_user == nullptr) {
    return on_send_message_fail(random_id, Status::Error(400, "Have no info about the bot"));
  }

  m->send_query_ref = td_->create_handler<StartBotQuery>()->send(std::move(bot_input_user), dialog_id,
                                                                 std::move(input_peer), parameter, random_id);
}

Result<MessageId> MessagesManager::send_inline_query_result_message(DialogId dialog_id, MessageId top_thread_message_id,
                                                                    MessageId reply_to_message_id,
                                                                    tl_object_ptr<td_api::messageSendOptions> &&options,
                                                                    int64 query_id, const string &result_id,
                                                                    bool hide_via_bot) {
  LOG(INFO) << "Begin to send inline query result message to " << dialog_id << " in reply to " << reply_to_message_id;

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(5, "Chat not found");
  }

  TRY_STATUS(can_send_message(dialog_id));
  TRY_RESULT(message_send_options, process_message_send_options(dialog_id, std::move(options)));
  bool to_secret = false;
  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
      // ok
      break;
    case DialogType::Channel: {
      auto channel_status = td_->contacts_manager_->get_channel_permissions(dialog_id.get_channel_id());
      if (!channel_status.can_use_inline_bots()) {
        return Status::Error(400, "Can't use inline bots in the chat");
      }
      break;
    }
    case DialogType::SecretChat:
      to_secret = true;
      // ok
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  const InlineMessageContent *content = td_->inline_queries_manager_->get_inline_message_content(query_id, result_id);
  if (content == nullptr) {
    return Status::Error(5, "Inline query result not found");
  }

  reply_to_message_id = get_reply_to_message_id(d, top_thread_message_id, reply_to_message_id, false);
  TRY_STATUS(can_use_message_send_options(message_send_options, content->message_content, 0));
  TRY_STATUS(can_send_message_content(dialog_id, content->message_content.get(), false));
  TRY_STATUS(can_use_top_thread_message_id(d, top_thread_message_id, reply_to_message_id));

  bool need_update_dialog_pos = false;
  Message *m = get_message_to_send(d, top_thread_message_id, reply_to_message_id, message_send_options,
                                   dup_message_content(td_, dialog_id, content->message_content.get(),
                                                       MessageContentDupType::SendViaBot, MessageCopyOptions()),
                                   &need_update_dialog_pos, false, nullptr, true);
  m->hide_via_bot = hide_via_bot;
  if (!hide_via_bot) {
    m->via_bot_user_id = td_->inline_queries_manager_->get_inline_bot_user_id(query_id);
  }
  if (content->message_reply_markup != nullptr && !to_secret) {
    m->reply_markup = make_unique<ReplyMarkup>(*content->message_reply_markup);
  }
  m->disable_web_page_preview = content->disable_web_page_preview;
  m->clear_draft = true;

  if (top_thread_message_id.is_valid()) {
    set_dialog_draft_message(dialog_id, top_thread_message_id, nullptr).ignore();
  } else {
    update_dialog_draft_message(d, nullptr, false, !need_update_dialog_pos);
  }

  send_update_new_message(d, m);
  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "send_inline_query_result_message");
  }

  if (to_secret) {
    save_send_message_log_event(dialog_id, m);
    do_send_message(dialog_id, m);
    return m->message_id;
  }

  save_send_inline_query_result_message_log_event(dialog_id, m, query_id, result_id);
  do_send_inline_query_result_message(dialog_id, m, query_id, result_id);
  return m->message_id;
}

class MessagesManager::SendInlineQueryResultMessageLogEvent {
 public:
  DialogId dialog_id;
  int64 query_id;
  string result_id;
  const Message *m_in = nullptr;
  unique_ptr<Message> m_out;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id, storer);
    td::store(query_id, storer);
    td::store(result_id, storer);
    td::store(*m_in, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id, parser);
    td::parse(query_id, parser);
    td::parse(result_id, parser);
    td::parse(m_out, parser);
  }
};

void MessagesManager::save_send_inline_query_result_message_log_event(DialogId dialog_id, const Message *m,
                                                                      int64 query_id, const string &result_id) {
  if (!G()->parameters().use_message_db) {
    return;
  }

  CHECK(m != nullptr);
  LOG(INFO) << "Save " << FullMessageId(dialog_id, m->message_id) << " to binlog";
  SendInlineQueryResultMessageLogEvent log_event;
  log_event.dialog_id = dialog_id;
  log_event.query_id = query_id;
  log_event.result_id = result_id;
  log_event.m_in = m;
  CHECK(m->send_message_log_event_id == 0);
  m->send_message_log_event_id = binlog_add(
      G()->td_db()->get_binlog(), LogEvent::HandlerType::SendInlineQueryResultMessage, get_log_event_storer(log_event));
}

void MessagesManager::do_send_inline_query_result_message(DialogId dialog_id, const Message *m, int64 query_id,
                                                          const string &result_id) {
  LOG(INFO) << "Do send inline query result " << FullMessageId(dialog_id, m->message_id);

  int64 random_id = begin_send_message(dialog_id, m);
  auto flags = get_message_flags(m);
  if (!m->via_bot_user_id.is_valid() || m->hide_via_bot) {
    flags |= telegram_api::messages_sendInlineBotResult::HIDE_VIA_MASK;
  }
  m->send_query_ref = td_->create_handler<SendInlineBotResultQuery>()->send(
      flags, dialog_id, m->reply_to_message_id, get_message_schedule_date(m), random_id, query_id, result_id);
}

bool MessagesManager::can_edit_message(DialogId dialog_id, const Message *m, bool is_editing,
                                       bool only_reply_markup) const {
  if (m == nullptr) {
    return false;
  }
  if (m->message_id.is_yet_unsent()) {
    return false;
  }
  if (m->message_id.is_local()) {
    return false;
  }
  if (m->forward_info != nullptr || m->had_forward_info) {
    return false;
  }

  if (m->had_reply_markup) {
    return false;
  }
  if (m->reply_markup != nullptr && m->reply_markup->type != ReplyMarkup::Type::InlineKeyboard) {
    return false;
  }

  auto my_id = td_->contacts_manager_->get_my_id();
  if (m->via_bot_user_id.is_valid() && (m->via_bot_user_id != my_id || m->message_id.is_scheduled())) {
    return false;
  }

  bool is_bot = td_->auth_manager_->is_bot();
  auto content_type = m->content->get_type();
  DialogId my_dialog_id(my_id);
  bool has_edit_time_limit = !(is_bot && m->is_outgoing) && dialog_id != my_dialog_id &&
                             content_type != MessageContentType::Poll &&
                             content_type != MessageContentType::LiveLocation && !m->message_id.is_scheduled();
  switch (dialog_id.get_type()) {
    case DialogType::User:
      if (!m->is_outgoing && dialog_id != my_dialog_id && !m->via_bot_user_id.is_valid()) {
        return false;
      }
      break;
    case DialogType::Chat:
      if (!m->is_outgoing && !m->via_bot_user_id.is_valid()) {
        return false;
      }
      break;
    case DialogType::Channel: {
      if (m->via_bot_user_id.is_valid()) {
        // outgoing via_bot messages can always be edited
        break;
      }

      auto channel_id = dialog_id.get_channel_id();
      auto channel_status = td_->contacts_manager_->get_channel_permissions(channel_id);
      if (m->is_channel_post) {
        if (m->message_id.is_scheduled()) {
          if (!channel_status.can_post_messages()) {
            return false;
          }
        } else {
          if (!channel_status.can_edit_messages() && !(channel_status.can_post_messages() && m->is_outgoing)) {
            return false;
          }
          if (channel_status.can_edit_messages()) {
            has_edit_time_limit = false;
          }
        }
        if (is_bot && only_reply_markup) {
          has_edit_time_limit = false;
        }
      } else {
        if (!m->is_outgoing) {
          return false;
        }
        if (channel_status.can_pin_messages()) {
          has_edit_time_limit = false;
        }
      }
      break;
    }
    case DialogType::SecretChat:
      return false;
    case DialogType::None:
    default:
      UNREACHABLE();
      return false;
  }

  if (has_edit_time_limit) {
    const int32 DEFAULT_EDIT_TIME_LIMIT = 2 * 86400;
    int64 edit_time_limit = G()->shared_config().get_option_integer("edit_time_limit", DEFAULT_EDIT_TIME_LIMIT);
    if (G()->unix_time_cached() - m->date - (is_editing ? 300 : 0) >= edit_time_limit) {
      return false;
    }
  }

  switch (content_type) {
    case MessageContentType::Animation:
    case MessageContentType::Audio:
    case MessageContentType::Document:
    case MessageContentType::Game:
    case MessageContentType::Photo:
    case MessageContentType::Text:
    case MessageContentType::Video:
    case MessageContentType::VoiceNote:
      return true;
    case MessageContentType::LiveLocation: {
      if (is_bot && only_reply_markup) {
        // there is no caption to edit, but bot can edit inline reply_markup
        return true;
      }
      return G()->unix_time_cached() - m->date < get_message_content_live_location_period(m->content.get());
    }
    case MessageContentType::Poll: {
      if (is_bot && only_reply_markup) {
        // there is no caption to edit, but bot can edit inline reply_markup
        return true;
      }
      if (m->message_id.is_scheduled()) {
        return false;
      }
      return !get_message_content_poll_is_closed(td_, m->content.get());
    }
    case MessageContentType::Contact:
    case MessageContentType::Dice:
    case MessageContentType::Location:
    case MessageContentType::Sticker:
    case MessageContentType::Venue:
    case MessageContentType::VideoNote:
      // there is no caption to edit, but bot can edit inline reply_markup
      return is_bot && only_reply_markup;
    case MessageContentType::Invoice:
    case MessageContentType::Unsupported:
    case MessageContentType::ChatCreate:
    case MessageContentType::ChatChangeTitle:
    case MessageContentType::ChatChangePhoto:
    case MessageContentType::ChatDeletePhoto:
    case MessageContentType::ChatDeleteHistory:
    case MessageContentType::ChatAddUsers:
    case MessageContentType::ChatJoinedByLink:
    case MessageContentType::ChatDeleteUser:
    case MessageContentType::ChatMigrateTo:
    case MessageContentType::ChannelCreate:
    case MessageContentType::ChannelMigrateFrom:
    case MessageContentType::PinMessage:
    case MessageContentType::GameScore:
    case MessageContentType::ScreenshotTaken:
    case MessageContentType::ChatSetTtl:
    case MessageContentType::Call:
    case MessageContentType::PaymentSuccessful:
    case MessageContentType::ContactRegistered:
    case MessageContentType::ExpiredPhoto:
    case MessageContentType::ExpiredVideo:
    case MessageContentType::CustomServiceAction:
    case MessageContentType::WebsiteConnected:
    case MessageContentType::PassportDataSent:
    case MessageContentType::PassportDataReceived:
    case MessageContentType::ProximityAlertTriggered:
    case MessageContentType::GroupCall:
    case MessageContentType::InviteToGroupCall:
      return false;
    default:
      UNREACHABLE();
  }

  return false;
}

bool MessagesManager::can_resend_message(const Message *m) const {
  if (m->send_error_code != 429 && m->send_error_message != "Message is too old to be re-sent automatically" &&
      m->send_error_message != "SCHEDULE_TOO_MUCH") {
    return false;
  }
  if (m->is_bot_start_message) {
    return false;
  }
  if (m->forward_info != nullptr || m->real_forward_from_dialog_id.is_valid()) {
    // TODO implement resending of forwarded messages
    return false;
  }
  auto content_type = m->content->get_type();
  if (m->via_bot_user_id.is_valid() || m->hide_via_bot) {
    // via bot message
    if (!can_have_input_media(td_, m->content.get())) {
      return false;
    }

    // resend via_bot message as an ordinary message if error code is 429
    // TODO support other error codes
  }

  if (content_type == MessageContentType::ChatSetTtl || content_type == MessageContentType::ScreenshotTaken) {
    // TODO implement resending of ChatSetTtl and ScreenshotTaken messages
    return false;
  }
  return true;
}

bool MessagesManager::is_broadcast_channel(DialogId dialog_id) const {
  if (dialog_id.get_type() != DialogType::Channel) {
    return false;
  }

  return td_->contacts_manager_->get_channel_type(dialog_id.get_channel_id()) == ChannelType::Broadcast;
}

bool MessagesManager::is_deleted_secret_chat(const Dialog *d) const {
  if (d == nullptr) {
    return true;
  }
  if (d->dialog_id.get_type() != DialogType::SecretChat) {
    return false;
  }

  if (d->order != DEFAULT_ORDER || d->messages != nullptr) {
    return false;
  }

  auto state = td_->contacts_manager_->get_secret_chat_state(d->dialog_id.get_secret_chat_id());
  if (state != SecretChatState::Closed) {
    return false;
  }

  return true;
}

int32 MessagesManager::get_message_schedule_date(const Message *m) {
  if (!m->message_id.is_scheduled()) {
    return 0;
  }
  if (m->edited_schedule_date != 0) {
    return m->edited_schedule_date;
  }
  return m->date;
}

DialogId MessagesManager::get_message_original_sender(const Message *m) {
  if (m->forward_info != nullptr) {
    auto forward_info = m->forward_info.get();
    if (forward_info->is_imported || is_forward_info_sender_hidden(forward_info)) {
      return DialogId();
    }
    if (forward_info->message_id.is_valid() || forward_info->sender_dialog_id.is_valid()) {
      return forward_info->sender_dialog_id;
    }
    return DialogId(forward_info->sender_user_id);
  }
  if (m->sender_dialog_id.is_valid()) {
    return m->sender_dialog_id;
  }
  return DialogId(m->sender_user_id);
}

void MessagesManager::edit_message_text(FullMessageId full_message_id,
                                        tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                        tl_object_ptr<td_api::InputMessageContent> &&input_message_content,
                                        Promise<Unit> &&promise) {
  if (input_message_content == nullptr) {
    return promise.set_error(Status::Error(5, "Can't edit message without new content"));
  }
  int32 new_message_content_type = input_message_content->get_id();
  if (new_message_content_type != td_api::inputMessageText::ID) {
    return promise.set_error(Status::Error(5, "Input message content type must be InputMessageText"));
  }

  LOG(INFO) << "Begin to edit text of " << full_message_id;
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(5, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Edit)) {
    return promise.set_error(Status::Error(5, "Can't access the chat"));
  }

  const Message *m = get_message_force(d, full_message_id.get_message_id(), "edit_message_text");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }

  if (!can_edit_message(dialog_id, m, true)) {
    return promise.set_error(Status::Error(5, "Message can't be edited"));
  }

  MessageContentType old_message_content_type = m->content->get_type();
  if (old_message_content_type != MessageContentType::Text && old_message_content_type != MessageContentType::Game) {
    return promise.set_error(Status::Error(5, "There is no text in the message to edit"));
  }

  auto r_input_message_text = process_input_message_text(
      td_->contacts_manager_.get(), dialog_id, std::move(input_message_content), td_->auth_manager_->is_bot());
  if (r_input_message_text.is_error()) {
    return promise.set_error(r_input_message_text.move_as_error());
  }
  InputMessageText input_message_text = r_input_message_text.move_as_ok();

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false,
                                             has_message_sender_user_id(dialog_id, m));
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }
  auto input_reply_markup = get_input_reply_markup(r_new_reply_markup.ok());
  int32 flags = 0;
  if (input_message_text.disable_web_page_preview) {
    flags |= SEND_MESSAGE_FLAG_DISABLE_WEB_PAGE_PREVIEW;
  }

  send_closure(
      td_->create_net_actor<EditMessageActor>(std::move(promise)), &EditMessageActor::send, flags, dialog_id,
      m->message_id, input_message_text.text.text,
      get_input_message_entities(td_->contacts_manager_.get(), input_message_text.text.entities, "edit_message_text"),
      nullptr, std::move(input_reply_markup), get_message_schedule_date(m),
      get_sequence_dispatcher_id(dialog_id, MessageContentType::None));
}

void MessagesManager::edit_message_live_location(FullMessageId full_message_id,
                                                 tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                                 tl_object_ptr<td_api::location> &&input_location, int32 heading,
                                                 int32 proximity_alert_radius, Promise<Unit> &&promise) {
  LOG(INFO) << "Begin to edit live location of " << full_message_id;
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(5, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Edit)) {
    return promise.set_error(Status::Error(5, "Can't access the chat"));
  }

  const Message *m = get_message_force(d, full_message_id.get_message_id(), "edit_message_live_location");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }

  if (!can_edit_message(dialog_id, m, true)) {
    return promise.set_error(Status::Error(5, "Message can't be edited"));
  }

  MessageContentType old_message_content_type = m->content->get_type();
  if (old_message_content_type != MessageContentType::LiveLocation) {
    return promise.set_error(Status::Error(5, "There is no live location in the message to edit"));
  }
  if (m->message_id.is_scheduled()) {
    LOG(ERROR) << "Have " << full_message_id << " with live location";
    return promise.set_error(Status::Error(5, "Can't edit live location in scheduled message"));
  }

  Location location(input_location);
  if (location.empty() && input_location != nullptr) {
    return promise.set_error(Status::Error(400, "Invalid location specified"));
  }

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false,
                                             has_message_sender_user_id(dialog_id, m));
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }
  auto input_reply_markup = get_input_reply_markup(r_new_reply_markup.ok());

  int32 flags = 0;
  if (location.empty()) {
    flags |= telegram_api::inputMediaGeoLive::STOPPED_MASK;
  }
  if (heading != 0) {
    flags |= telegram_api::inputMediaGeoLive::HEADING_MASK;
  }
  flags |= telegram_api::inputMediaGeoLive::PROXIMITY_NOTIFICATION_RADIUS_MASK;
  auto input_media = telegram_api::make_object<telegram_api::inputMediaGeoLive>(
      flags, false /*ignored*/, location.get_input_geo_point(), heading, 0, proximity_alert_radius);
  send_closure(td_->create_net_actor<EditMessageActor>(std::move(promise)), &EditMessageActor::send, 0, dialog_id,
               m->message_id, string(), vector<tl_object_ptr<telegram_api::MessageEntity>>(), std::move(input_media),
               std::move(input_reply_markup), get_message_schedule_date(m),
               get_sequence_dispatcher_id(dialog_id, MessageContentType::None));
}

void MessagesManager::cancel_edit_message_media(DialogId dialog_id, Message *m, Slice error_message) {
  if (m->edited_content == nullptr) {
    return;
  }

  cancel_upload_message_content_files(m->edited_content.get());

  m->edited_content = nullptr;
  m->edited_reply_markup = nullptr;
  m->edit_generation = 0;
  m->edit_promise.set_error(Status::Error(400, error_message));
}

void MessagesManager::on_message_media_edited(DialogId dialog_id, MessageId message_id, FileId file_id,
                                              FileId thumbnail_file_id, bool was_uploaded, bool was_thumbnail_uploaded,
                                              string file_reference, int32 schedule_date, uint64 generation,
                                              Result<int32> &&result) {
  // must not run getDifference

  CHECK(message_id.is_any_server());
  auto m = get_message({dialog_id, message_id});
  if (m == nullptr || m->edit_generation != generation) {
    // message is already deleted or was edited again
    return;
  }

  CHECK(m->edited_content != nullptr);
  if (result.is_ok()) {
    // message content has already been replaced from updateEdit{Channel,}Message
    // need only merge files from edited_content with their uploaded counterparts
    // updateMessageContent was already sent and needs to be sent again,
    // only if 'i' and 't' sizes from edited_content was added to the photo
    auto pts = result.ok();
    LOG(INFO) << "Successfully edited " << message_id << " in " << dialog_id << " with pts = " << pts
              << " and last edit pts = " << m->last_edit_pts;
    std::swap(m->content, m->edited_content);
    bool need_send_update_message_content = m->edited_content->get_type() == MessageContentType::Photo &&
                                            m->content->get_type() == MessageContentType::Photo;
    bool need_merge_files = pts != 0 && pts == m->last_edit_pts;
    update_message_content(dialog_id, m, std::move(m->edited_content), need_send_update_message_content,
                           need_merge_files, true);
  } else {
    LOG(INFO) << "Failed to edit " << message_id << " in " << dialog_id << ": " << result.error();
    if (was_uploaded) {
      if (was_thumbnail_uploaded) {
        CHECK(thumbnail_file_id.is_valid());
        // always delete partial remote location for the thumbnail, because it can't be reused anyway
        td_->file_manager_->delete_partial_remote_location(thumbnail_file_id);
      }
      CHECK(file_id.is_valid());
      auto error_message = result.error().message();
      if (begins_with(error_message, "FILE_PART_") && ends_with(error_message, "_MISSING")) {
        do_send_message(dialog_id, m, {to_integer<int32>(error_message.substr(10))});
        return;
      }

      if (result.error().code() != 429 && result.error().code() < 500 && !G()->close_flag()) {
        td_->file_manager_->delete_partial_remote_location(file_id);
      }
    } else if (!td_->auth_manager_->is_bot() && FileReferenceManager::is_file_reference_error(result.error())) {
      if (file_id.is_valid()) {
        VLOG(file_references) << "Receive " << result.error() << " for " << file_id;
        td_->file_manager_->delete_file_reference(file_id, file_reference);
        do_send_message(dialog_id, m, {-1});
        return;
      } else {
        LOG(ERROR) << "Receive file reference error, but have no file_id";
      }
    }

    cancel_upload_message_content_files(m->edited_content.get());

    if (dialog_id.get_type() != DialogType::SecretChat) {
      get_message_from_server({dialog_id, m->message_id}, Auto());
    }
  }

  if (m->edited_schedule_date == schedule_date) {
    m->edited_schedule_date = 0;
  }
  m->edited_content = nullptr;
  m->edited_reply_markup = nullptr;
  m->edit_generation = 0;
  if (result.is_ok()) {
    m->edit_promise.set_value(Unit());
  } else {
    m->edit_promise.set_error(result.move_as_error());
  }
}

void MessagesManager::edit_message_media(FullMessageId full_message_id,
                                         tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                         tl_object_ptr<td_api::InputMessageContent> &&input_message_content,
                                         Promise<Unit> &&promise) {
  if (input_message_content == nullptr) {
    return promise.set_error(Status::Error(5, "Can't edit message without new content"));
  }
  int32 new_message_content_type = input_message_content->get_id();
  if (new_message_content_type != td_api::inputMessageAnimation::ID &&
      new_message_content_type != td_api::inputMessageAudio::ID &&
      new_message_content_type != td_api::inputMessageDocument::ID &&
      new_message_content_type != td_api::inputMessagePhoto::ID &&
      new_message_content_type != td_api::inputMessageVideo::ID) {
    return promise.set_error(Status::Error(5, "Unsupported input message content type"));
  }

  LOG(INFO) << "Begin to edit media of " << full_message_id;
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(5, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Edit)) {
    return promise.set_error(Status::Error(5, "Can't access the chat"));
  }

  Message *m = get_message_force(d, full_message_id.get_message_id(), "edit_message_media");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }

  if (!can_edit_message(dialog_id, m, true)) {
    return promise.set_error(Status::Error(5, "Message can't be edited"));
  }
  CHECK(m->message_id.is_any_server());

  MessageContentType old_message_content_type = m->content->get_type();
  if (old_message_content_type != MessageContentType::Animation &&
      old_message_content_type != MessageContentType::Audio &&
      old_message_content_type != MessageContentType::Document &&
      old_message_content_type != MessageContentType::Photo && old_message_content_type != MessageContentType::Video) {
    return promise.set_error(Status::Error(5, "There is no media in the message to edit"));
  }
  if (m->ttl > 0) {
    return promise.set_error(Status::Error(5, "Can't edit media in self-destructing message"));
  }

  auto r_input_message_content = process_input_message_content(dialog_id, std::move(input_message_content));
  if (r_input_message_content.is_error()) {
    return promise.set_error(r_input_message_content.move_as_error());
  }
  InputMessageContent content = r_input_message_content.move_as_ok();
  if (content.ttl > 0) {
    return promise.set_error(Status::Error(5, "Can't enable self-destruction for media"));
  }

  if (m->media_album_id != 0) {
    auto new_content_type = content.content->get_type();
    if (old_message_content_type != new_content_type) {
      if (!is_allowed_media_group_content(new_content_type)) {
        return promise.set_error(Status::Error(5, "Message content type can't be used in an album"));
      }
      if (is_homogenous_media_group_content(old_message_content_type) ||
          is_homogenous_media_group_content(new_content_type)) {
        return promise.set_error(Status::Error(5, "Can't change media type in the album"));
      }
    }
  }

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false,
                                             has_message_sender_user_id(dialog_id, m));
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }

  cancel_edit_message_media(dialog_id, m, "Cancelled by new editMessageMedia request");

  m->edited_content =
      dup_message_content(td_, dialog_id, content.content.get(), MessageContentDupType::Send, MessageCopyOptions());
  CHECK(m->edited_content != nullptr);
  m->edited_reply_markup = r_new_reply_markup.move_as_ok();
  m->edit_generation = ++current_message_edit_generation_;
  m->edit_promise = std::move(promise);

  do_send_message(dialog_id, m);
}

void MessagesManager::edit_message_caption(FullMessageId full_message_id,
                                           tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                           tl_object_ptr<td_api::formattedText> &&input_caption,
                                           Promise<Unit> &&promise) {
  LOG(INFO) << "Begin to edit caption of " << full_message_id;

  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(5, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Edit)) {
    return promise.set_error(Status::Error(5, "Can't access the chat"));
  }

  const Message *m = get_message_force(d, full_message_id.get_message_id(), "edit_message_caption");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }

  if (!can_edit_message(dialog_id, m, true)) {
    return promise.set_error(Status::Error(5, "Message can't be edited"));
  }

  if (!can_have_message_content_caption(m->content->get_type())) {
    return promise.set_error(Status::Error(400, "There is no caption in the message to edit"));
  }

  auto r_caption = process_input_caption(td_->contacts_manager_.get(), dialog_id, std::move(input_caption),
                                         td_->auth_manager_->is_bot());
  if (r_caption.is_error()) {
    return promise.set_error(r_caption.move_as_error());
  }
  auto caption = r_caption.move_as_ok();

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false,
                                             has_message_sender_user_id(dialog_id, m));
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }
  auto input_reply_markup = get_input_reply_markup(r_new_reply_markup.ok());

  send_closure(td_->create_net_actor<EditMessageActor>(std::move(promise)), &EditMessageActor::send, 1 << 11, dialog_id,
               m->message_id, caption.text,
               get_input_message_entities(td_->contacts_manager_.get(), caption.entities, "edit_message_caption"),
               nullptr, std::move(input_reply_markup), get_message_schedule_date(m),
               get_sequence_dispatcher_id(dialog_id, MessageContentType::None));
}

void MessagesManager::edit_message_reply_markup(FullMessageId full_message_id,
                                                tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                                Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    return promise.set_error(Status::Error(3, "Method is available only for bots"));
  }

  LOG(INFO) << "Begin to edit reply markup of " << full_message_id;
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(5, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Edit)) {
    return promise.set_error(Status::Error(5, "Can't access the chat"));
  }

  const Message *m = get_message_force(d, full_message_id.get_message_id(), "edit_message_reply_markup");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }

  if (!can_edit_message(dialog_id, m, true, true)) {
    return promise.set_error(Status::Error(5, "Message can't be edited"));
  }

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false,
                                             has_message_sender_user_id(dialog_id, m));
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }
  auto input_reply_markup = get_input_reply_markup(r_new_reply_markup.ok());
  send_closure(td_->create_net_actor<EditMessageActor>(std::move(promise)), &EditMessageActor::send, 0, dialog_id,
               m->message_id, string(), vector<tl_object_ptr<telegram_api::MessageEntity>>(), nullptr,
               std::move(input_reply_markup), get_message_schedule_date(m),
               get_sequence_dispatcher_id(dialog_id, MessageContentType::None));
}

void MessagesManager::edit_inline_message_text(const string &inline_message_id,
                                               tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                               tl_object_ptr<td_api::InputMessageContent> &&input_message_content,
                                               Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    return promise.set_error(Status::Error(3, "Method is available only for bots"));
  }

  if (input_message_content == nullptr) {
    return promise.set_error(Status::Error(5, "Can't edit message without new content"));
  }
  int32 new_message_content_type = input_message_content->get_id();
  if (new_message_content_type != td_api::inputMessageText::ID) {
    return promise.set_error(Status::Error(5, "Input message content type must be InputMessageText"));
  }

  auto r_input_message_text = process_input_message_text(
      td_->contacts_manager_.get(), DialogId(), std::move(input_message_content), td_->auth_manager_->is_bot());
  if (r_input_message_text.is_error()) {
    return promise.set_error(r_input_message_text.move_as_error());
  }
  InputMessageText input_message_text = r_input_message_text.move_as_ok();

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false, true);
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }

  auto input_bot_inline_message_id = td_->inline_queries_manager_->get_input_bot_inline_message_id(inline_message_id);
  if (input_bot_inline_message_id == nullptr) {
    return promise.set_error(Status::Error(400, "Invalid inline message identifier specified"));
  }

  int32 flags = 0;
  if (input_message_text.disable_web_page_preview) {
    flags |= SEND_MESSAGE_FLAG_DISABLE_WEB_PAGE_PREVIEW;
  }
  td_->create_handler<EditInlineMessageQuery>(std::move(promise))
      ->send(flags, std::move(input_bot_inline_message_id), input_message_text.text.text,
             get_input_message_entities(td_->contacts_manager_.get(), input_message_text.text.entities,
                                        "edit_inline_message_text"),
             nullptr, get_input_reply_markup(r_new_reply_markup.ok()));
}

void MessagesManager::edit_inline_message_live_location(const string &inline_message_id,
                                                        tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                                        tl_object_ptr<td_api::location> &&input_location, int32 heading,
                                                        int32 proximity_alert_radius, Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    return promise.set_error(Status::Error(3, "Method is available only for bots"));
  }

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false, true);
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }

  auto input_bot_inline_message_id = td_->inline_queries_manager_->get_input_bot_inline_message_id(inline_message_id);
  if (input_bot_inline_message_id == nullptr) {
    return promise.set_error(Status::Error(400, "Invalid inline message identifier specified"));
  }

  Location location(input_location);
  if (location.empty() && input_location != nullptr) {
    return promise.set_error(Status::Error(400, "Invalid location specified"));
  }

  int32 flags = 0;
  if (location.empty()) {
    flags |= telegram_api::inputMediaGeoLive::STOPPED_MASK;
  }
  if (heading != 0) {
    flags |= telegram_api::inputMediaGeoLive::HEADING_MASK;
  }
  flags |= telegram_api::inputMediaGeoLive::PROXIMITY_NOTIFICATION_RADIUS_MASK;
  auto input_media = telegram_api::make_object<telegram_api::inputMediaGeoLive>(
      flags, false /*ignored*/, location.get_input_geo_point(), heading, 0, proximity_alert_radius);
  td_->create_handler<EditInlineMessageQuery>(std::move(promise))
      ->send(0, std::move(input_bot_inline_message_id), "", vector<tl_object_ptr<telegram_api::MessageEntity>>(),
             std::move(input_media), get_input_reply_markup(r_new_reply_markup.ok()));
}

void MessagesManager::edit_inline_message_media(const string &inline_message_id,
                                                tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                                tl_object_ptr<td_api::InputMessageContent> &&input_message_content,
                                                Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    return promise.set_error(Status::Error(3, "Method is available only for bots"));
  }

  if (input_message_content == nullptr) {
    return promise.set_error(Status::Error(5, "Can't edit message without new content"));
  }
  int32 new_message_content_type = input_message_content->get_id();
  if (new_message_content_type != td_api::inputMessageAnimation::ID &&
      new_message_content_type != td_api::inputMessageAudio::ID &&
      new_message_content_type != td_api::inputMessageDocument::ID &&
      new_message_content_type != td_api::inputMessagePhoto::ID &&
      new_message_content_type != td_api::inputMessageVideo::ID) {
    return promise.set_error(Status::Error(5, "Unsupported input message content type"));
  }

  auto r_input_message_content = process_input_message_content(DialogId(), std::move(input_message_content));
  if (r_input_message_content.is_error()) {
    return promise.set_error(r_input_message_content.move_as_error());
  }
  InputMessageContent content = r_input_message_content.move_as_ok();
  if (content.ttl > 0) {
    LOG(ERROR) << "Have message content with TTL " << content.ttl;
    return promise.set_error(Status::Error(5, "Can't enable self-destruction for media"));
  }

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false, true);
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }

  auto input_bot_inline_message_id = td_->inline_queries_manager_->get_input_bot_inline_message_id(inline_message_id);
  if (input_bot_inline_message_id == nullptr) {
    return promise.set_error(Status::Error(400, "Invalid inline message identifier specified"));
  }

  auto input_media = get_input_media(content.content.get(), td_, 0, string(), true);
  if (input_media == nullptr) {
    return promise.set_error(Status::Error(400, "Invalid message content specified"));
  }

  const FormattedText *caption = get_message_content_caption(content.content.get());
  td_->create_handler<EditInlineMessageQuery>(std::move(promise))
      ->send(1 << 11, std::move(input_bot_inline_message_id), caption == nullptr ? "" : caption->text,
             get_input_message_entities(td_->contacts_manager_.get(), caption, "edit_inline_message_media"),
             std::move(input_media), get_input_reply_markup(r_new_reply_markup.ok()));
}

void MessagesManager::edit_inline_message_caption(const string &inline_message_id,
                                                  tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                                  tl_object_ptr<td_api::formattedText> &&input_caption,
                                                  Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    return promise.set_error(Status::Error(3, "Method is available only for bots"));
  }

  auto r_caption = process_input_caption(td_->contacts_manager_.get(), DialogId(), std::move(input_caption),
                                         td_->auth_manager_->is_bot());
  if (r_caption.is_error()) {
    return promise.set_error(r_caption.move_as_error());
  }
  auto caption = r_caption.move_as_ok();

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false, true);
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }

  auto input_bot_inline_message_id = td_->inline_queries_manager_->get_input_bot_inline_message_id(inline_message_id);
  if (input_bot_inline_message_id == nullptr) {
    return promise.set_error(Status::Error(400, "Invalid inline message identifier specified"));
  }

  td_->create_handler<EditInlineMessageQuery>(std::move(promise))
      ->send(1 << 11, std::move(input_bot_inline_message_id), caption.text,
             get_input_message_entities(td_->contacts_manager_.get(), caption.entities, "edit_inline_message_caption"),
             nullptr, get_input_reply_markup(r_new_reply_markup.ok()));
}

void MessagesManager::edit_inline_message_reply_markup(const string &inline_message_id,
                                                       tl_object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                                       Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    return promise.set_error(Status::Error(3, "Method is available only for bots"));
  }

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false, true);
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }

  auto input_bot_inline_message_id = td_->inline_queries_manager_->get_input_bot_inline_message_id(inline_message_id);
  if (input_bot_inline_message_id == nullptr) {
    return promise.set_error(Status::Error(400, "Invalid inline message identifier specified"));
  }

  td_->create_handler<EditInlineMessageQuery>(std::move(promise))
      ->send(0, std::move(input_bot_inline_message_id), string(), vector<tl_object_ptr<telegram_api::MessageEntity>>(),
             nullptr, get_input_reply_markup(r_new_reply_markup.ok()));
}

void MessagesManager::edit_message_scheduling_state(
    FullMessageId full_message_id, td_api::object_ptr<td_api::MessageSchedulingState> &&scheduling_state,
    Promise<Unit> &&promise) {
  auto r_schedule_date = get_message_schedule_date(std::move(scheduling_state));
  if (r_schedule_date.is_error()) {
    return promise.set_error(r_schedule_date.move_as_error());
  }
  auto schedule_date = r_schedule_date.move_as_ok();

  LOG(INFO) << "Begin to reschedule " << full_message_id << " to " << schedule_date;

  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(5, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Edit)) {
    return promise.set_error(Status::Error(5, "Can't access the chat"));
  }

  Message *m = get_message_force(d, full_message_id.get_message_id(), "edit_message_scheduling_state");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }

  if (!m->message_id.is_scheduled()) {
    return promise.set_error(Status::Error(5, "Message is not scheduled"));
  }
  if (!m->message_id.is_scheduled_server()) {
    return promise.set_error(Status::Error(5, "Can't reschedule the message"));
  }

  if (get_message_schedule_date(m) == schedule_date) {
    return promise.set_value(Unit());
  }
  m->edited_schedule_date = schedule_date;

  if (schedule_date > 0) {
    send_closure(td_->create_net_actor<EditMessageActor>(std::move(promise)), &EditMessageActor::send, 0, dialog_id,
                 m->message_id, string(), vector<tl_object_ptr<telegram_api::MessageEntity>>(), nullptr, nullptr,
                 schedule_date, get_sequence_dispatcher_id(dialog_id, MessageContentType::None));
  } else {
    send_closure(td_->create_net_actor<SendScheduledMessageActor>(std::move(promise)), &SendScheduledMessageActor::send,
                 dialog_id, m->message_id, get_sequence_dispatcher_id(dialog_id, MessageContentType::None));
  }
}

bool MessagesManager::is_discussion_message(DialogId dialog_id, const Message *m) const {
  if (m == nullptr || m->forward_info == nullptr) {
    return false;
  }
  if (m->sender_user_id.is_valid()) {
    if (!td_->auth_manager_->is_bot() || m->sender_user_id != ContactsManager::get_service_notifications_user_id()) {
      return false;
    }
  }
  if (!m->forward_info->from_dialog_id.is_valid() || !m->forward_info->from_message_id.is_valid()) {
    return false;
  }
  if (dialog_id.get_type() != DialogType::Channel || is_broadcast_channel(dialog_id)) {
    return false;
  }
  if (m->forward_info->from_dialog_id == dialog_id) {
    return false;
  }
  if (m->forward_info->from_dialog_id.get_type() != DialogType::Channel) {
    return false;
  }
  return true;
}

bool MessagesManager::has_message_sender_user_id(DialogId dialog_id, const Message *m) const {
  if (!m->sender_user_id.is_valid()) {
    return false;
  }
  if (td_->auth_manager_->is_bot() && is_discussion_message(dialog_id, m)) {
    return false;
  }
  return true;
}

bool MessagesManager::get_message_disable_web_page_preview(const Message *m) {
  // m->disable_web_page_preview is known only for sent from this client messages
  if (m->disable_web_page_preview) {
    return true;
  }
  if (m->content->get_type() != MessageContentType::Text) {
    return false;
  }
  return !has_message_content_web_page(m->content.get());
}

int32 MessagesManager::get_message_flags(const Message *m) {
  int32 flags = 0;
  if (m->reply_to_message_id.is_valid()) {
    flags |= SEND_MESSAGE_FLAG_IS_REPLY;
  }
  if (m->disable_web_page_preview) {
    flags |= SEND_MESSAGE_FLAG_DISABLE_WEB_PAGE_PREVIEW;
  }
  if (m->reply_markup != nullptr) {
    flags |= SEND_MESSAGE_FLAG_HAS_REPLY_MARKUP;
  }
  if (m->disable_notification) {
    flags |= SEND_MESSAGE_FLAG_DISABLE_NOTIFICATION;
  }
  if (m->from_background) {
    flags |= SEND_MESSAGE_FLAG_FROM_BACKGROUND;
  }
  if (m->clear_draft) {
    flags |= SEND_MESSAGE_FLAG_CLEAR_DRAFT;
  }
  if (m->message_id.is_scheduled()) {
    flags |= SEND_MESSAGE_FLAG_HAS_SCHEDULE_DATE;
  }
  return flags;
}

bool MessagesManager::can_set_game_score(DialogId dialog_id, const Message *m) const {
  if (m == nullptr) {
    return false;
  }
  if (m->message_id.is_scheduled()) {
    return false;
  }
  if (m->message_id.is_yet_unsent()) {
    return false;
  }
  if (m->message_id.is_local()) {
    return false;
  }
  if (m->via_bot_user_id.is_valid() && m->via_bot_user_id != td_->contacts_manager_->get_my_id()) {
    return false;
  }

  if (!td_->auth_manager_->is_bot()) {
    return false;
  }
  if (m->reply_markup == nullptr || m->reply_markup->type != ReplyMarkup::Type::InlineKeyboard ||
      m->reply_markup->inline_keyboard.empty()) {
    return false;
  }

  switch (dialog_id.get_type()) {
    case DialogType::User:
      if (!m->is_outgoing && dialog_id != get_my_dialog_id()) {
        return false;
      }
      break;
    case DialogType::Chat:
      if (!m->is_outgoing) {
        return false;
      }
      break;
    case DialogType::Channel: {
      if (m->via_bot_user_id.is_valid()) {
        // outgoing via_bot messages can always be edited
        break;
      }
      auto channel_id = dialog_id.get_channel_id();
      auto channel_status = td_->contacts_manager_->get_channel_permissions(channel_id);
      if (m->is_channel_post) {
        if (!channel_status.can_edit_messages() && !(channel_status.can_post_messages() && m->is_outgoing)) {
          return false;
        }
      } else {
        if (!m->is_outgoing) {
          return false;
        }
      }
      break;
    }
    case DialogType::SecretChat:
      return false;
    case DialogType::None:
    default:
      UNREACHABLE();
      return false;
  }

  return m->content->get_type() == MessageContentType::Game;
}

void MessagesManager::set_game_score(FullMessageId full_message_id, bool edit_message, UserId user_id, int32 score,
                                     bool force, Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    return promise.set_error(Status::Error(3, "Method is available only for bots"));
  }

  LOG(INFO) << "Begin to set game score of " << user_id << " in " << full_message_id;
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(5, "Chat not found"));
  }

  if (!have_input_peer(dialog_id, AccessRights::Edit)) {
    return promise.set_error(Status::Error(5, "Can't access the chat"));
  }

  const Message *m = get_message_force(d, full_message_id.get_message_id(), "set_game_score");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }

  auto input_user = td_->contacts_manager_->get_input_user(user_id);
  if (input_user == nullptr) {
    return promise.set_error(Status::Error(400, "Invalid user identifier specified"));
  }

  if (!can_set_game_score(dialog_id, m)) {
    return promise.set_error(Status::Error(5, "Game score can't be set"));
  }

  send_closure(td_->create_net_actor<SetGameScoreActor>(std::move(promise)), &SetGameScoreActor::send, dialog_id,
               m->message_id, edit_message, std::move(input_user), score, force,
               get_sequence_dispatcher_id(dialog_id, MessageContentType::None));
}

void MessagesManager::set_inline_game_score(const string &inline_message_id, bool edit_message, UserId user_id,
                                            int32 score, bool force, Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    return promise.set_error(Status::Error(3, "Method is available only for bots"));
  }

  auto input_bot_inline_message_id = td_->inline_queries_manager_->get_input_bot_inline_message_id(inline_message_id);
  if (input_bot_inline_message_id == nullptr) {
    return promise.set_error(Status::Error(400, "Invalid inline message identifier specified"));
  }

  auto input_user = td_->contacts_manager_->get_input_user(user_id);
  if (input_user == nullptr) {
    return promise.set_error(Status::Error(400, "Wrong user identifier specified"));
  }

  td_->create_handler<SetInlineGameScoreQuery>(std::move(promise))
      ->send(std::move(input_bot_inline_message_id), edit_message, std::move(input_user), score, force);
}

int64 MessagesManager::get_game_high_scores(FullMessageId full_message_id, UserId user_id, Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    promise.set_error(Status::Error(3, "Method is available only for bots"));
    return 0;
  }

  LOG(INFO) << "Begin to get game high scores of " << user_id << " in " << full_message_id;
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    promise.set_error(Status::Error(5, "Chat not found"));
    return 0;
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    promise.set_error(Status::Error(5, "Can't access the chat"));
    return 0;
  }

  const Message *m = get_message_force(d, full_message_id.get_message_id(), "get_game_high_scores");
  if (m == nullptr) {
    promise.set_error(Status::Error(5, "Message not found"));
    return 0;
  }
  if (m->message_id.is_scheduled() || !m->message_id.is_server()) {
    promise.set_error(Status::Error(5, "Wrong message identifier specified"));
    return 0;
  }

  auto input_user = td_->contacts_manager_->get_input_user(user_id);
  if (input_user == nullptr) {
    promise.set_error(Status::Error(400, "Wrong user identifier specified"));
    return 0;
  }

  int64 random_id = 0;
  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || game_high_scores_.find(random_id) != game_high_scores_.end());
  game_high_scores_[random_id];  // reserve place for result

  td_->create_handler<GetGameHighScoresQuery>(std::move(promise))
      ->send(dialog_id, m->message_id, std::move(input_user), random_id);
  return random_id;
}

int64 MessagesManager::get_inline_game_high_scores(const string &inline_message_id, UserId user_id,
                                                   Promise<Unit> &&promise) {
  if (!td_->auth_manager_->is_bot()) {
    promise.set_error(Status::Error(3, "Method is available only for bots"));
    return 0;
  }

  auto input_bot_inline_message_id = td_->inline_queries_manager_->get_input_bot_inline_message_id(inline_message_id);
  if (input_bot_inline_message_id == nullptr) {
    promise.set_error(Status::Error(400, "Invalid inline message identifier specified"));
    return 0;
  }

  auto input_user = td_->contacts_manager_->get_input_user(user_id);
  if (input_user == nullptr) {
    promise.set_error(Status::Error(400, "Wrong user identifier specified"));
    return 0;
  }

  int64 random_id = 0;
  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || game_high_scores_.find(random_id) != game_high_scores_.end());
  game_high_scores_[random_id];  // reserve place for result

  td_->create_handler<GetInlineGameHighScoresQuery>(std::move(promise))
      ->send(std::move(input_bot_inline_message_id), std::move(input_user), random_id);
  return random_id;
}

void MessagesManager::on_get_game_high_scores(int64 random_id,
                                              tl_object_ptr<telegram_api::messages_highScores> &&high_scores) {
  auto it = game_high_scores_.find(random_id);
  CHECK(it != game_high_scores_.end());
  auto &result = it->second;
  CHECK(result == nullptr);

  if (high_scores == nullptr) {
    game_high_scores_.erase(it);
    return;
  }

  td_->contacts_manager_->on_get_users(std::move(high_scores->users_), "on_get_game_high_scores");

  result = make_tl_object<td_api::gameHighScores>();

  for (auto &high_score : high_scores->scores_) {
    int32 position = high_score->pos_;
    if (position <= 0) {
      LOG(ERROR) << "Receive wrong position = " << position;
      continue;
    }
    UserId user_id(high_score->user_id_);
    LOG_IF(ERROR, !td_->contacts_manager_->have_user(user_id)) << "Have no info about " << user_id;
    int32 score = high_score->score_;
    if (score < 0) {
      LOG(ERROR) << "Receive wrong score = " << score;
      continue;
    }
    result->scores_.push_back(make_tl_object<td_api::gameHighScore>(
        position, td_->contacts_manager_->get_user_id_object(user_id, "gameHighScore"), score));
  }
}

tl_object_ptr<td_api::gameHighScores> MessagesManager::get_game_high_scores_object(int64 random_id) {
  auto it = game_high_scores_.find(random_id);
  CHECK(it != game_high_scores_.end());
  auto result = std::move(it->second);
  game_high_scores_.erase(it);
  return result;
}

bool MessagesManager::is_forward_info_sender_hidden(const MessageForwardInfo *forward_info) {
  CHECK(forward_info != nullptr);
  if (forward_info->is_imported) {
    return false;
  }
  if (!forward_info->sender_name.empty()) {
    return true;
  }
  DialogId hidden_sender_dialog_id(ChannelId(G()->is_test_dc() ? 10460537 : 1228946795));
  return forward_info->sender_dialog_id == hidden_sender_dialog_id && !forward_info->author_signature.empty() &&
         !forward_info->message_id.is_valid();
}

unique_ptr<MessagesManager::MessageForwardInfo> MessagesManager::get_message_forward_info(
    tl_object_ptr<telegram_api::messageFwdHeader> &&forward_header) {
  if (forward_header == nullptr) {
    return nullptr;
  }

  if (forward_header->date_ <= 0) {
    LOG(ERROR) << "Wrong date in message forward header: " << oneline(to_string(forward_header));
    return nullptr;
  }

  auto flags = forward_header->flags_;
  DialogId sender_dialog_id;
  MessageId message_id;
  string author_signature = std::move(forward_header->post_author_);
  DialogId from_dialog_id;
  MessageId from_message_id;
  string sender_name = std::move(forward_header->from_name_);
  bool is_imported = forward_header->imported_;
  if (forward_header->from_id_ != nullptr) {
    sender_dialog_id = DialogId(forward_header->from_id_);
    if (!sender_dialog_id.is_valid()) {
      LOG(ERROR) << "Receive invalid sender id in message forward header: " << oneline(to_string(forward_header));
      sender_dialog_id = DialogId();
    }
  }
  if ((flags & telegram_api::messageFwdHeader::CHANNEL_POST_MASK) != 0) {
    message_id = MessageId(ServerMessageId(forward_header->channel_post_));
    if (!message_id.is_valid()) {
      LOG(ERROR) << "Receive " << message_id << " in message forward header: " << oneline(to_string(forward_header));
      message_id = MessageId();
    }
  }
  if ((flags & telegram_api::messageFwdHeader::SAVED_FROM_PEER_MASK) != 0) {
    from_dialog_id = DialogId(forward_header->saved_from_peer_);
    from_message_id = MessageId(ServerMessageId(forward_header->saved_from_msg_id_));
    if (!from_dialog_id.is_valid() || !from_message_id.is_valid()) {
      LOG(ERROR) << "Receive " << from_message_id << " in " << from_dialog_id
                 << " in message forward header: " << oneline(to_string(forward_header));
      from_dialog_id = DialogId();
      from_message_id = MessageId();
    }
  }

  UserId sender_user_id;
  if (sender_dialog_id.get_type() == DialogType::User) {
    sender_user_id = sender_dialog_id.get_user_id();
    sender_dialog_id = DialogId();
  }
  if (!sender_dialog_id.is_valid()) {
    if (sender_user_id.is_valid()) {
      if (message_id.is_valid()) {
        LOG(ERROR) << "Receive non-empty message identifier in message forward header: "
                   << oneline(to_string(forward_header));
        message_id = MessageId();
      }
    } else if (sender_name.empty()) {
      LOG(ERROR) << "Receive wrong message forward header: " << oneline(to_string(forward_header));
      return nullptr;
    }
  } else if (sender_dialog_id.get_type() != DialogType::Channel) {
    LOG(ERROR) << "Receive wrong message forward header with non-channel sender: "
               << oneline(to_string(forward_header));
    return nullptr;
  } else {
    auto channel_id = sender_dialog_id.get_channel_id();
    LOG_IF(ERROR, td_->contacts_manager_->have_min_channel(channel_id)) << "Receive forward from min " << channel_id;
    force_create_dialog(sender_dialog_id, "message forward info", true);
    CHECK(!sender_user_id.is_valid());
  }
  if (from_dialog_id.is_valid()) {
    force_create_dialog(from_dialog_id, "message forward from info", true);
  }

  return td::make_unique<MessageForwardInfo>(sender_user_id, forward_header->date_, sender_dialog_id, message_id,
                                             std::move(author_signature), std::move(sender_name), from_dialog_id,
                                             from_message_id, std::move(forward_header->psa_type_), is_imported);
}

td_api::object_ptr<td_api::messageForwardInfo> MessagesManager::get_message_forward_info_object(
    const unique_ptr<MessageForwardInfo> &forward_info) const {
  if (forward_info == nullptr) {
    return nullptr;
  }

  auto origin = [&]() -> td_api::object_ptr<td_api::MessageForwardOrigin> {
    if (forward_info->is_imported) {
      return td_api::make_object<td_api::messageForwardOriginMessageImport>(forward_info->sender_name);
    }
    if (is_forward_info_sender_hidden(forward_info.get())) {
      return td_api::make_object<td_api::messageForwardOriginHiddenUser>(
          forward_info->sender_name.empty() ? forward_info->author_signature : forward_info->sender_name);
    }
    if (forward_info->message_id.is_valid()) {
      return td_api::make_object<td_api::messageForwardOriginChannel>(
          forward_info->sender_dialog_id.get(), forward_info->message_id.get(), forward_info->author_signature);
    }
    if (forward_info->sender_dialog_id.is_valid()) {
      return td_api::make_object<td_api::messageForwardOriginChat>(
          forward_info->sender_dialog_id.get(),
          forward_info->sender_name.empty() ? forward_info->author_signature : forward_info->sender_name);
    }
    return td_api::make_object<td_api::messageForwardOriginUser>(
        td_->contacts_manager_->get_user_id_object(forward_info->sender_user_id, "messageForwardOriginUser"));
  }();

  return td_api::make_object<td_api::messageForwardInfo>(std::move(origin), forward_info->date, forward_info->psa_type,
                                                         forward_info->from_dialog_id.get(),
                                                         forward_info->from_message_id.get());
}

Result<unique_ptr<ReplyMarkup>> MessagesManager::get_dialog_reply_markup(
    DialogId dialog_id, tl_object_ptr<td_api::ReplyMarkup> &&reply_markup_ptr) const {
  if (reply_markup_ptr == nullptr) {
    return nullptr;
  }

  auto dialog_type = dialog_id.get_type();
  bool is_anonymous = is_anonymous_administrator(dialog_id, nullptr);

  bool only_inline_keyboard = is_anonymous;
  bool request_buttons_allowed = dialog_type == DialogType::User;
  bool switch_inline_buttons_allowed = !is_anonymous;

  TRY_RESULT(reply_markup,
             get_reply_markup(std::move(reply_markup_ptr), td_->auth_manager_->is_bot(), only_inline_keyboard,
                              request_buttons_allowed, switch_inline_buttons_allowed));
  if (reply_markup == nullptr) {
    return nullptr;
  }

  switch (dialog_type) {
    case DialogType::User:
      if (reply_markup->type != ReplyMarkup::Type::InlineKeyboard) {
        reply_markup->is_personal = false;
      }
      break;
    case DialogType::Channel:
    case DialogType::Chat:
    case DialogType::SecretChat:
    case DialogType::None:
      // nothing special
      break;
    default:
      UNREACHABLE();
  }

  return std::move(reply_markup);
}

class MessagesManager::ForwardMessagesLogEvent {
 public:
  DialogId to_dialog_id;
  DialogId from_dialog_id;
  vector<MessageId> message_ids;
  vector<Message *> messages_in;
  vector<unique_ptr<Message>> messages_out;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(to_dialog_id, storer);
    td::store(from_dialog_id, storer);
    td::store(message_ids, storer);
    td::store(messages_in, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(to_dialog_id, parser);
    td::parse(from_dialog_id, parser);
    td::parse(message_ids, parser);
    td::parse(messages_out, parser);
  }
};

uint64 MessagesManager::save_forward_messages_log_event(DialogId to_dialog_id, DialogId from_dialog_id,
                                                        const vector<Message *> &messages,
                                                        const vector<MessageId> &message_ids) {
  ForwardMessagesLogEvent log_event{to_dialog_id, from_dialog_id, message_ids, messages, Auto()};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::ForwardMessages,
                    get_log_event_storer(log_event));
}

void MessagesManager::do_forward_messages(DialogId to_dialog_id, DialogId from_dialog_id,
                                          const vector<Message *> &messages, const vector<MessageId> &message_ids,
                                          uint64 log_event_id) {
  CHECK(messages.size() == message_ids.size());
  if (messages.empty()) {
    return;
  }

  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_forward_messages_log_event(to_dialog_id, from_dialog_id, messages, message_ids);
  }

  auto schedule_date = get_message_schedule_date(messages[0]);

  int32 flags = 0;
  if (messages[0]->disable_notification) {
    flags |= SEND_MESSAGE_FLAG_DISABLE_NOTIFICATION;
  }
  if (messages[0]->from_background) {
    flags |= SEND_MESSAGE_FLAG_FROM_BACKGROUND;
  }
  if (messages[0]->in_game_share) {
    flags |= SEND_MESSAGE_FLAG_WITH_MY_SCORE;
  }
  if (schedule_date != 0) {
    flags |= SEND_MESSAGE_FLAG_HAS_SCHEDULE_DATE;
  }

  vector<int64> random_ids =
      transform(messages, [this, to_dialog_id](const Message *m) { return begin_send_message(to_dialog_id, m); });
  send_closure(td_->create_net_actor<ForwardMessagesActor>(get_erase_log_event_promise(log_event_id)),
               &ForwardMessagesActor::send, flags, to_dialog_id, from_dialog_id, message_ids, std::move(random_ids),
               schedule_date, get_sequence_dispatcher_id(to_dialog_id, MessageContentType::None));
}

Result<MessageId> MessagesManager::forward_message(DialogId to_dialog_id, DialogId from_dialog_id, MessageId message_id,
                                                   tl_object_ptr<td_api::messageSendOptions> &&options,
                                                   bool in_game_share, MessageCopyOptions &&copy_options) {
  vector<MessageCopyOptions> all_copy_options;
  all_copy_options.push_back(std::move(copy_options));
  TRY_RESULT(result, forward_messages(to_dialog_id, from_dialog_id, {message_id}, std::move(options), in_game_share,
                                      std::move(all_copy_options)));
  CHECK(result.size() == 1);
  auto sent_message_id = result[0];
  if (sent_message_id == MessageId()) {
    return Status::Error(11, "Message can't be forwarded");
  }
  return sent_message_id;
}

Result<vector<MessageId>> MessagesManager::forward_messages(DialogId to_dialog_id, DialogId from_dialog_id,
                                                            vector<MessageId> message_ids,
                                                            tl_object_ptr<td_api::messageSendOptions> &&options,
                                                            bool in_game_share,
                                                            vector<MessageCopyOptions> &&copy_options) {
  CHECK(copy_options.size() == message_ids.size());
  if (message_ids.size() > 100) {  // TODO replace with const from config or implement mass-forward
    return Status::Error(4, "Too much messages to forward");
  }
  if (message_ids.empty()) {
    return Status::Error(4, "There are no messages to forward");
  }

  Dialog *from_dialog = get_dialog_force(from_dialog_id);
  if (from_dialog == nullptr) {
    return Status::Error(5, "Chat to forward messages from not found");
  }
  if (!have_input_peer(from_dialog_id, AccessRights::Read)) {
    return Status::Error(5, "Can't access the chat to forward messages from");
  }
  if (from_dialog_id.get_type() == DialogType::SecretChat) {
    return Status::Error(7, "Can't forward messages from secret chats");
  }

  Dialog *to_dialog = get_dialog_force(to_dialog_id);
  if (to_dialog == nullptr) {
    return Status::Error(5, "Chat to forward messages to not found");
  }

  TRY_STATUS(can_send_message(to_dialog_id));
  TRY_RESULT(message_send_options, process_message_send_options(to_dialog_id, std::move(options)));

  {
    MessageId last_message_id;
    for (auto message_id : message_ids) {
      if (message_id.is_valid_scheduled()) {
        return Status::Error(5, "Can't forward scheduled messages");
      }
      if (message_id.is_scheduled() || !message_id.is_valid()) {
        return Status::Error(5, "Invalid message identifier");
      }

      if (message_id <= last_message_id) {
        return Status::Error(400, "Message identifiers must be in a strictly increasing order");
      }
      last_message_id = message_id;
    }
  }

  bool to_secret = to_dialog_id.get_type() == DialogType::SecretChat;

  vector<MessageId> result(message_ids.size());
  vector<Message *> forwarded_messages;
  vector<MessageId> forwarded_message_ids;

  struct CopiedMessage {
    unique_ptr<MessageContent> content;
    MessageId top_thread_message_id;
    MessageId reply_to_message_id;
    unique_ptr<ReplyMarkup> reply_markup;
    int64 media_album_id;
    bool disable_web_page_preview;
    size_t index;
  };
  vector<CopiedMessage> copied_messages;

  struct ForwardedMessageContent {
    unique_ptr<MessageContent> content;
    int64 media_album_id;
    size_t index;
  };
  vector<ForwardedMessageContent> forwarded_message_contents;

  std::unordered_map<int64, std::pair<int64, int32>> new_media_album_ids;

  auto my_id = td_->contacts_manager_->get_my_id();
  bool need_update_dialog_pos = false;
  for (size_t i = 0; i < message_ids.size(); i++) {
    MessageId message_id = get_persistent_message_id(from_dialog, message_ids[i]);

    const Message *forwarded_message = get_message_force(from_dialog, message_id, "forward_messages");
    if (forwarded_message == nullptr) {
      LOG(INFO) << "Can't find " << message_id << " to forward";
      continue;
    }
    CHECK(message_id.is_valid());
    CHECK(message_id == forwarded_message->message_id);

    if (!can_forward_message(from_dialog_id, forwarded_message)) {
      LOG(INFO) << "Can't forward " << message_id;
      continue;
    }

    bool need_copy = !message_id.is_server() || to_secret || copy_options[i].send_copy;
    auto type = need_copy ? MessageContentDupType::Copy : MessageContentDupType::Forward;
    auto top_thread_message_id = copy_options[i].top_thread_message_id;
    auto reply_to_message_id = copy_options[i].reply_to_message_id;
    auto reply_markup = std::move(copy_options[i].reply_markup);
    unique_ptr<MessageContent> content =
        dup_message_content(td_, to_dialog_id, forwarded_message->content.get(), type, std::move(copy_options[i]));
    if (content == nullptr) {
      LOG(INFO) << "Can't forward " << message_id;
      continue;
    }

    auto can_send_status = can_send_message_content(to_dialog_id, content.get(), !need_copy);
    if (can_send_status.is_error()) {
      LOG(INFO) << "Can't forward " << message_id << ": " << can_send_status.message();
      continue;
    }

    auto can_use_options_status = can_use_message_send_options(message_send_options, content, 0);
    if (can_use_options_status.is_error()) {
      LOG(INFO) << "Can't forward " << message_id << ": " << can_send_status.message();
      continue;
    }

    if (can_use_top_thread_message_id(to_dialog, top_thread_message_id, reply_to_message_id).is_error()) {
      LOG(INFO) << "Ignore invalid message thread ID " << top_thread_message_id;
      top_thread_message_id = MessageId();
    }

    if (forwarded_message->media_album_id != 0) {
      auto &new_media_album_id = new_media_album_ids[forwarded_message->media_album_id];
      new_media_album_id.second++;
      if (new_media_album_id.second == 2) {  // have at least 2 messages in the new album
        CHECK(new_media_album_id.first == 0);
        new_media_album_id.first = generate_new_media_album_id();
      }
      if (new_media_album_id.second == MAX_GROUPED_MESSAGES + 1) {
        CHECK(new_media_album_id.first != 0);
        new_media_album_id.first = 0;  // just in case
      }
    }

    if (need_copy) {
      copied_messages.push_back({std::move(content), top_thread_message_id, reply_to_message_id,
                                 std::move(reply_markup), forwarded_message->media_album_id,
                                 get_message_disable_web_page_preview(forwarded_message), i});
    } else {
      forwarded_message_contents.push_back({std::move(content), forwarded_message->media_album_id, i});
    }
  }

  if (2 <= forwarded_message_contents.size() && forwarded_message_contents.size() <= MAX_GROUPED_MESSAGES) {
    std::unordered_set<MessageContentType, MessageContentTypeHash> message_content_types;
    std::unordered_set<DialogId, DialogIdHash> sender_dialog_ids;
    for (auto &message_content : forwarded_message_contents) {
      message_content_types.insert(message_content.content->get_type());

      MessageId message_id = get_persistent_message_id(from_dialog, message_ids[message_content.index]);
      sender_dialog_ids.insert(get_message_original_sender(get_message(from_dialog, message_id)));
    }
    if (message_content_types.size() == 1 && is_homogenous_media_group_content(*message_content_types.begin()) &&
        sender_dialog_ids.size() == 1 && *sender_dialog_ids.begin() != DialogId()) {
      new_media_album_ids[0].first = generate_new_media_album_id();
      for (auto &message : forwarded_message_contents) {
        message.media_album_id = 0;
      }
    }
  }

  for (size_t j = 0; j < forwarded_message_contents.size(); j++) {
    MessageId message_id = get_persistent_message_id(from_dialog, message_ids[forwarded_message_contents[j].index]);
    const Message *forwarded_message = get_message(from_dialog, message_id);
    CHECK(forwarded_message != nullptr);

    auto content = std::move(forwarded_message_contents[j].content);
    auto content_type = content->get_type();
    bool is_game = content_type == MessageContentType::Game;
    unique_ptr<MessageForwardInfo> forward_info;
    if (!is_game && content_type != MessageContentType::Audio) {
      DialogId saved_from_dialog_id;
      MessageId saved_from_message_id;
      if (to_dialog_id == DialogId(my_id)) {
        saved_from_dialog_id = from_dialog_id;
        saved_from_message_id = message_id;
      }

      if (forwarded_message->forward_info != nullptr) {
        forward_info = make_unique<MessageForwardInfo>(*forwarded_message->forward_info);
        forward_info->from_dialog_id = saved_from_dialog_id;
        forward_info->from_message_id = saved_from_message_id;
      } else {
        if (from_dialog_id != DialogId(my_id) || content_type == MessageContentType::Dice) {
          if (forwarded_message->is_channel_post) {
            if (is_broadcast_channel(from_dialog_id)) {
              auto author_signature = forwarded_message->sender_user_id.is_valid()
                                          ? td_->contacts_manager_->get_user_title(forwarded_message->sender_user_id)
                                          : forwarded_message->author_signature;
              forward_info = td::make_unique<MessageForwardInfo>(
                  UserId(), forwarded_message->date, from_dialog_id, forwarded_message->message_id,
                  std::move(author_signature), "", saved_from_dialog_id, saved_from_message_id, "", false);
            } else {
              LOG(ERROR) << "Don't know how to forward a channel post not from a channel";
            }
          } else if (forwarded_message->sender_user_id.is_valid() || forwarded_message->sender_dialog_id.is_valid()) {
            forward_info = td::make_unique<MessageForwardInfo>(
                forwarded_message->sender_user_id, forwarded_message->date, forwarded_message->sender_dialog_id,
                MessageId(), "", forwarded_message->author_signature, saved_from_dialog_id, saved_from_message_id, "",
                false);
          } else {
            LOG(ERROR) << "Don't know how to forward a non-channel post message without forward info and sender";
          }
        }
      }
    }

    Message *m = get_message_to_send(to_dialog, MessageId(), MessageId(), message_send_options, std::move(content),
                                     &need_update_dialog_pos, j + 1 != forwarded_message_contents.size(),
                                     std::move(forward_info));
    m->real_forward_from_dialog_id = from_dialog_id;
    m->real_forward_from_message_id = message_id;
    m->via_bot_user_id = forwarded_message->via_bot_user_id;
    m->in_game_share = in_game_share;
    m->media_album_id = new_media_album_ids[forwarded_message_contents[j].media_album_id].first;
    if (forwarded_message->view_count > 0 && m->forward_info != nullptr && m->view_count == 0 &&
        !(m->message_id.is_scheduled() && is_broadcast_channel(to_dialog_id))) {
      m->view_count = forwarded_message->view_count;
      m->forward_count = forwarded_message->forward_count;
      m->interaction_info_update_date = G()->unix_time();
    }

    if (is_game) {
      if (m->via_bot_user_id == my_id) {
        m->via_bot_user_id = UserId();
      } else if (m->via_bot_user_id == UserId()) {
        m->via_bot_user_id = forwarded_message->sender_user_id;
      }
    }
    if (!to_secret && forwarded_message->reply_markup != nullptr &&
        forwarded_message->reply_markup->type == ReplyMarkup::Type::InlineKeyboard) {
      bool need_reply_markup = true;
      for (auto &row : forwarded_message->reply_markup->inline_keyboard) {
        for (auto &button : row) {
          if (button.type == InlineKeyboardButton::Type::Url || button.type == InlineKeyboardButton::Type::UrlAuth) {
            // ok
            continue;
          }
          if (m->via_bot_user_id.is_valid() && (button.type == InlineKeyboardButton::Type::SwitchInline ||
                                                button.type == InlineKeyboardButton::Type::SwitchInlineCurrentDialog)) {
            // ok
            continue;
          }

          need_reply_markup = false;
        }
      }
      if (need_reply_markup) {
        m->reply_markup = make_unique<ReplyMarkup>(*forwarded_message->reply_markup);
        for (auto &row : m->reply_markup->inline_keyboard) {
          for (auto &button : row) {
            if (button.type == InlineKeyboardButton::Type::SwitchInlineCurrentDialog) {
              button.type = InlineKeyboardButton::Type::SwitchInline;
            }
            if (!button.forward_text.empty()) {
              button.text = std::move(button.forward_text);
              button.forward_text.clear();
            }
          }
        }
      }
    }

    send_update_new_message(to_dialog, m);

    result[forwarded_message_contents[j].index] = m->message_id;
    forwarded_messages.push_back(m);
    forwarded_message_ids.push_back(message_id);
  }

  if (!forwarded_messages.empty()) {
    do_forward_messages(to_dialog_id, from_dialog_id, forwarded_messages, forwarded_message_ids, 0);
  }

  new_media_album_ids.erase(0);
  if (2 <= copied_messages.size() && copied_messages.size() <= MAX_GROUPED_MESSAGES) {
    std::unordered_set<MessageContentType, MessageContentTypeHash> message_content_types;
    for (auto &copied_message : copied_messages) {
      message_content_types.insert(copied_message.content->get_type());
    }
    if (message_content_types.size() == 1 && is_homogenous_media_group_content(*message_content_types.begin())) {
      new_media_album_ids[0].first = generate_new_media_album_id();
      for (auto &message : copied_messages) {
        message.media_album_id = 0;
      }
    }
  }

  if (!copied_messages.empty()) {
    for (auto &copied_message : copied_messages) {
      Message *m = get_message_to_send(
          to_dialog, copied_message.top_thread_message_id, copied_message.reply_to_message_id, message_send_options,
          std::move(copied_message.content), &need_update_dialog_pos, false, nullptr, true);
      m->disable_web_page_preview = copied_message.disable_web_page_preview;
      m->media_album_id = new_media_album_ids[copied_message.media_album_id].first;
      m->reply_markup = std::move(copied_message.reply_markup);

      save_send_message_log_event(to_dialog_id, m);
      do_send_message(to_dialog_id, m);
      result[copied_message.index] = m->message_id;

      send_update_new_message(to_dialog, m);
    }
  }

  if (need_update_dialog_pos) {
    send_update_chat_last_message(to_dialog, "forward_messages");
  }

  return result;
}

Result<vector<MessageId>> MessagesManager::resend_messages(DialogId dialog_id, vector<MessageId> message_ids) {
  if (message_ids.empty()) {
    return Status::Error(4, "There are no messages to resend");
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(400, "Chat not found");
  }

  TRY_STATUS(can_send_message(dialog_id));

  MessageId last_message_id;
  for (auto &message_id : message_ids) {
    message_id = get_persistent_message_id(d, message_id);
    const Message *m = get_message_force(d, message_id, "resend_messages");
    if (m == nullptr) {
      return Status::Error(400, "Message not found");
    }
    if (!m->is_failed_to_send) {
      return Status::Error(400, "Message is not failed to send");
    }
    if (!can_resend_message(m)) {
      return Status::Error(400, "Message can't be re-sent");
    }
    if (m->try_resend_at > Time::now()) {
      return Status::Error(400, "Message can't be re-sent yet");
    }
    if (last_message_id != MessageId()) {
      if (m->message_id.is_scheduled() != last_message_id.is_scheduled()) {
        return Status::Error(400, "Messages must be all scheduled or ordinary");
      }
      if (m->message_id <= last_message_id) {
        return Status::Error(400, "Message identifiers must be in a strictly increasing order");
      }
    }
    last_message_id = m->message_id;
  }

  vector<unique_ptr<MessageContent>> new_contents(message_ids.size());
  std::unordered_map<int64, std::pair<int64, int32>> new_media_album_ids;
  for (size_t i = 0; i < message_ids.size(); i++) {
    MessageId message_id = message_ids[i];
    const Message *m = get_message(d, message_id);
    CHECK(m != nullptr);

    unique_ptr<MessageContent> content =
        dup_message_content(td_, dialog_id, m->content.get(), MessageContentDupType::Send, MessageCopyOptions());
    if (content == nullptr) {
      LOG(INFO) << "Can't resend " << m->message_id;
      continue;
    }

    auto can_send_status = can_send_message_content(dialog_id, content.get(), false);
    if (can_send_status.is_error()) {
      LOG(INFO) << "Can't resend " << m->message_id << ": " << can_send_status.message();
      continue;
    }

    new_contents[i] = std::move(content);

    if (m->media_album_id != 0) {
      auto &new_media_album_id = new_media_album_ids[m->media_album_id];
      new_media_album_id.second++;
      if (new_media_album_id.second == 2) {  // have at least 2 messages in the new album
        CHECK(new_media_album_id.first == 0);
        new_media_album_id.first = generate_new_media_album_id();
      }
      if (new_media_album_id.second == MAX_GROUPED_MESSAGES + 1) {
        CHECK(new_media_album_id.first != 0);
        new_media_album_id.first = 0;  // just in case
      }
    }
  }

  vector<MessageId> result(message_ids.size());
  bool need_update_dialog_pos = false;
  for (size_t i = 0; i < message_ids.size(); i++) {
    if (new_contents[i] == nullptr) {
      continue;
    }

    being_readded_message_id_ = {dialog_id, message_ids[i]};
    unique_ptr<Message> message = delete_message(d, message_ids[i], true, &need_update_dialog_pos, "resend_messages");
    CHECK(message != nullptr);
    send_update_delete_messages(dialog_id, {message->message_id.get()}, true, false);

    MessageSendOptions options(message->disable_notification, message->from_background,
                               get_message_schedule_date(message.get()));
    Message *m = get_message_to_send(
        d, message->top_thread_message_id,
        get_reply_to_message_id(d, message->top_thread_message_id, message->reply_to_message_id, false), options,
        std::move(new_contents[i]), &need_update_dialog_pos, false, nullptr, message->is_copy);
    m->reply_markup = std::move(message->reply_markup);
    m->via_bot_user_id = message->via_bot_user_id;
    m->disable_web_page_preview = message->disable_web_page_preview;
    m->clear_draft = false;  // never clear draft in resend
    m->ttl = message->ttl;
    m->is_content_secret = message->is_content_secret;
    m->media_album_id = new_media_album_ids[message->media_album_id].first;
    m->send_emoji = message->send_emoji;

    save_send_message_log_event(dialog_id, m);
    do_send_message(dialog_id, m);

    send_update_new_message(d, m);

    result[i] = m->message_id;
    being_readded_message_id_ = FullMessageId();
  }

  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "resend_messages");
  }

  return result;
}

Status MessagesManager::send_screenshot_taken_notification_message(DialogId dialog_id) {
  auto dialog_type = dialog_id.get_type();
  if (dialog_type != DialogType::User && dialog_type != DialogType::SecretChat) {
    return Status::Error(5, "Notification about taken screenshot can be sent only in private and secret chats");
  }

  LOG(INFO) << "Begin to send notification about taken screenshot in " << dialog_id;

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(5, "Chat not found");
  }

  TRY_STATUS(can_send_message(dialog_id));

  if (dialog_type == DialogType::User) {
    bool need_update_dialog_pos = false;
    const Message *m = get_message_to_send(d, MessageId(), MessageId(), MessageSendOptions(),
                                           create_screenshot_taken_message_content(), &need_update_dialog_pos);

    do_send_screenshot_taken_notification_message(dialog_id, m, 0);

    send_update_new_message(d, m);
    if (need_update_dialog_pos) {
      send_update_chat_last_message(d, "send_screenshot_taken_notification_message");
    }
  } else {
    send_closure(td_->secret_chats_manager_, &SecretChatsManager::notify_screenshot_taken,
                 dialog_id.get_secret_chat_id(),
                 Promise<>());  // TODO Promise
  }

  return Status::OK();
}

class MessagesManager::SendScreenshotTakenNotificationMessageLogEvent {
 public:
  DialogId dialog_id;
  const Message *m_in = nullptr;
  unique_ptr<Message> m_out;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id, storer);
    td::store(*m_in, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id, parser);
    td::parse(m_out, parser);
  }
};

uint64 MessagesManager::save_send_screenshot_taken_notification_message_log_event(DialogId dialog_id,
                                                                                  const Message *m) {
  if (!G()->parameters().use_message_db) {
    return 0;
  }

  CHECK(m != nullptr);
  LOG(INFO) << "Save " << FullMessageId(dialog_id, m->message_id) << " to binlog";
  SendScreenshotTakenNotificationMessageLogEvent log_event;
  log_event.dialog_id = dialog_id;
  log_event.m_in = m;
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::SendScreenshotTakenNotificationMessage,
                    get_log_event_storer(log_event));
}

void MessagesManager::do_send_screenshot_taken_notification_message(DialogId dialog_id, const Message *m,
                                                                    uint64 log_event_id) {
  LOG(INFO) << "Do send screenshot taken notification " << FullMessageId(dialog_id, m->message_id);
  CHECK(dialog_id.get_type() == DialogType::User);

  if (log_event_id == 0) {
    log_event_id = save_send_screenshot_taken_notification_message_log_event(dialog_id, m);
  }

  int64 random_id = begin_send_message(dialog_id, m);
  td_->create_handler<SendScreenshotNotificationQuery>(get_erase_log_event_promise(log_event_id))
      ->send(dialog_id, random_id);
}

Result<MessageId> MessagesManager::add_local_message(
    DialogId dialog_id, td_api::object_ptr<td_api::MessageSender> &&sender, MessageId reply_to_message_id,
    bool disable_notification, tl_object_ptr<td_api::InputMessageContent> &&input_message_content) {
  if (input_message_content == nullptr) {
    return Status::Error(5, "Can't add local message without content");
  }

  LOG(INFO) << "Begin to add local message to " << dialog_id << " in reply to " << reply_to_message_id;
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(5, "Chat not found");
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return Status::Error(400, "Can't access the chat");
  }
  TRY_RESULT(message_content, process_input_message_content(dialog_id, std::move(input_message_content)));
  if (message_content.content->get_type() == MessageContentType::Poll) {
    return Status::Error(400, "Can't add local poll message");
  }
  if (message_content.content->get_type() == MessageContentType::Game) {
    return Status::Error(400, "Can't add local game message");
  }
  if (message_content.content->get_type() == MessageContentType::Dice) {
    return Status::Error(400, "Can't add local dice message");
  }

  bool is_channel_post = is_broadcast_channel(dialog_id);
  UserId sender_user_id;
  DialogId sender_dialog_id;
  if (sender != nullptr) {
    switch (sender->get_id()) {
      case td_api::messageSenderUser::ID:
        sender_user_id = UserId(static_cast<const td_api::messageSenderUser *>(sender.get())->user_id_);
        if (!td_->contacts_manager_->have_user_force(sender_user_id)) {
          return Status::Error(400, "Sender user not found");
        }
        break;
      case td_api::messageSenderChat::ID:
        sender_dialog_id = DialogId(static_cast<const td_api::messageSenderChat *>(sender.get())->chat_id_);
        if (sender_dialog_id.get_type() != DialogType::Channel) {
          return Status::Error(400, "Sender chat must be a supergroup or channel");
        }
        if (!have_dialog_force(sender_dialog_id)) {
          return Status::Error(400, "Sender chat not found");
        }
        break;
      default:
        UNREACHABLE();
    }
  } else if (is_channel_post) {
    sender_dialog_id = dialog_id;
  } else {
    return Status::Error(400, "The message must have a sender");
  }
  if (is_channel_post && sender_user_id.is_valid()) {
    return Status::Error(400, "Channel post can't have a sender user");
  }
  if (is_channel_post && sender_dialog_id != dialog_id) {
    return Status::Error(400, "Channel post must have the channel as a sender");
  }

  auto dialog_type = dialog_id.get_type();
  auto my_id = td_->contacts_manager_->get_my_id();
  if (sender_user_id != my_id) {
    if (dialog_type == DialogType::User && DialogId(sender_user_id) != dialog_id) {
      return Status::Error(400, "Wrong sender user");
    }
    if (dialog_type == DialogType::SecretChat) {
      auto peer_user_id = td_->contacts_manager_->get_secret_chat_user_id(dialog_id.get_secret_chat_id());
      if (!peer_user_id.is_valid() || sender_user_id != peer_user_id) {
        return Status::Error(400, "Wrong sender user");
      }
    }
  }

  MessageId message_id = get_next_local_message_id(d);

  auto m = make_unique<Message>();
  set_message_id(m, message_id);
  if (is_channel_post) {
    // sender of the post can be hidden
    if (td_->contacts_manager_->get_channel_sign_messages(dialog_id.get_channel_id())) {
      m->author_signature = td_->contacts_manager_->get_user_title(sender_user_id);
    }
    m->sender_dialog_id = sender_dialog_id;
  } else {
    m->sender_user_id = sender_user_id;
    m->sender_dialog_id = sender_dialog_id;
  }
  m->date = G()->unix_time();
  m->reply_to_message_id = get_reply_to_message_id(d, MessageId(), reply_to_message_id, false);
  if (m->reply_to_message_id.is_valid()) {
    const Message *reply_m = get_message(d, m->reply_to_message_id);
    if (reply_m != nullptr) {
      m->top_thread_message_id = reply_m->top_thread_message_id;
    }
  }
  m->is_channel_post = is_channel_post;
  m->is_outgoing = dialog_id != DialogId(my_id) && sender_user_id == my_id;
  m->disable_notification = disable_notification;
  m->from_background = false;
  m->view_count = 0;
  m->forward_count = 0;
  m->content = std::move(message_content.content);
  m->disable_web_page_preview = message_content.disable_web_page_preview;
  m->clear_draft = message_content.clear_draft;
  if (dialog_type == DialogType::SecretChat) {
    m->ttl = td_->contacts_manager_->get_secret_chat_ttl(dialog_id.get_secret_chat_id());
    if (is_service_message_content(m->content->get_type())) {
      m->ttl = 0;
    }
  } else if (message_content.ttl > 0) {
    m->ttl = message_content.ttl;
  }
  m->is_content_secret = is_secret_message_content(m->ttl, m->content->get_type());
  m->send_emoji = std::move(message_content.emoji);

  m->have_previous = true;
  m->have_next = true;

  bool need_update = true;
  bool need_update_dialog_pos = false;
  auto result =
      add_message_to_dialog(d, std::move(m), true, &need_update, &need_update_dialog_pos, "add local message");
  LOG_CHECK(result != nullptr) << message_id << " " << debug_add_message_to_dialog_fail_reason_;
  register_new_local_message_id(d, result);

  if (is_message_auto_read(dialog_id, result->is_outgoing)) {
    if (result->is_outgoing) {
      read_history_outbox(dialog_id, message_id);
    } else {
      read_history_inbox(dialog_id, message_id, 0, "add_local_message");
    }
  }

  if (message_content.clear_draft) {
    update_dialog_draft_message(d, nullptr, false, !need_update_dialog_pos);
  }

  send_update_new_message(d, result);
  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "add_local_message");
  }

  return message_id;
}

void MessagesManager::get_message_file_type(const string &message_file_head,
                                            Promise<td_api::object_ptr<td_api::MessageFileType>> &&promise) {
  td_->create_handler<CheckHistoryImportQuery>(std::move(promise))->send(message_file_head);
}

Status MessagesManager::can_import_messages(DialogId dialog_id) {
  if (!have_dialog_force(dialog_id)) {
    return Status::Error(400, "Chat not found");
  }

  TRY_STATUS(can_send_message(dialog_id));

  switch (dialog_id.get_type()) {
    case DialogType::User:
      if (!td_->contacts_manager_->is_user_contact(dialog_id.get_user_id(), true)) {
        return Status::Error(400, "User must be a mutual contact");
      }
      break;
    case DialogType::Chat:
      return Status::Error(400, "Basic groups must be updagraded to supergroups first");
    case DialogType::Channel:
      if (is_broadcast_channel(dialog_id)) {
        return Status::Error(400, "Can't import messages to channels");
      }
      if (!td_->contacts_manager_->get_channel_status(dialog_id.get_channel_id()).can_change_info_and_settings()) {
        return Status::Error(400, "Not enough rights to import messages");
      }
      break;
    case DialogType::SecretChat:
      return Status::Error(400, "Can't import messages to secret chats");
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  return Status::OK();
}

void MessagesManager::get_message_import_confirmation_text(DialogId dialog_id, Promise<string> &&promise) {
  TRY_STATUS_PROMISE(promise, can_import_messages(dialog_id));

  td_->create_handler<CheckHistoryImportPeerQuery>(std::move(promise))->send(dialog_id);
}

void MessagesManager::import_messages(DialogId dialog_id, const td_api::object_ptr<td_api::InputFile> &message_file,
                                      const vector<td_api::object_ptr<td_api::InputFile>> &attached_files,
                                      Promise<Unit> &&promise) {
  TRY_STATUS_PROMISE(promise, can_import_messages(dialog_id));

  auto r_file_id = td_->file_manager_->get_input_file_id(FileType::Document, message_file, dialog_id, false, false);
  if (r_file_id.is_error()) {
    // TODO TRY_RESULT_PROMISE(promise, ...);
    return promise.set_error(Status::Error(400, r_file_id.error().message()));
  }
  FileId file_id = r_file_id.ok();

  vector<FileId> attached_file_ids;
  attached_file_ids.reserve(attached_files.size());
  for (auto &attached_file : attached_files) {
    auto file_type = td_->file_manager_->guess_file_type(attached_file);
    if (file_type != FileType::Animation && file_type != FileType::Audio && file_type != FileType::Document &&
        file_type != FileType::Photo && file_type != FileType::Sticker && file_type != FileType::Video &&
        file_type != FileType::VoiceNote) {
      LOG(INFO) << "Skip attached file of type " << file_type;
      continue;
    }
    auto r_attached_file_id = td_->file_manager_->get_input_file_id(file_type, attached_file, dialog_id, false, false);
    if (r_attached_file_id.is_error()) {
      // TODO TRY_RESULT_PROMISE(promise, ...);
      return promise.set_error(Status::Error(400, r_attached_file_id.error().message()));
    }
    attached_file_ids.push_back(r_attached_file_id.ok());
  }

  upload_imported_messages(dialog_id, td_->file_manager_->dup_file_id(file_id), std::move(attached_file_ids), false,
                           std::move(promise));
}

void MessagesManager::upload_imported_messages(DialogId dialog_id, FileId file_id, vector<FileId> attached_file_ids,
                                               bool is_reupload, Promise<Unit> &&promise, vector<int> bad_parts) {
  CHECK(file_id.is_valid());
  LOG(INFO) << "Ask to upload imported messages file " << file_id;
  CHECK(being_uploaded_imported_messages_.find(file_id) == being_uploaded_imported_messages_.end());
  being_uploaded_imported_messages_.emplace(
      file_id, td::make_unique<UploadedImportedMessagesInfo>(dialog_id, std::move(attached_file_ids), is_reupload,
                                                             std::move(promise)));
  // TODO use force_reupload if is_reupload
  td_->file_manager_->resume_upload(file_id, std::move(bad_parts), upload_imported_messages_callback_, 1, 0, false,
                                    true);
}

void MessagesManager::start_import_messages(DialogId dialog_id, int64 import_id, vector<FileId> &&attached_file_ids,
                                            Promise<Unit> &&promise) {
  if (G()->close_flag()) {
    return promise.set_error(Status::Error(500, "Request aborted"));
  }

  TRY_STATUS_PROMISE(promise, can_send_message(dialog_id));

  auto pending_message_import = make_unique<PendingMessageImport>();
  pending_message_import->dialog_id = dialog_id;
  pending_message_import->import_id = import_id;
  pending_message_import->promise = std::move(promise);

  auto &multipromise = pending_message_import->upload_files_multipromise;

  int64 random_id;
  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || pending_message_imports_.find(random_id) != pending_message_imports_.end());
  pending_message_imports_[random_id] = std::move(pending_message_import);

  multipromise.add_promise(PromiseCreator::lambda([random_id](Result<Unit> result) {
    send_closure_later(G()->messages_manager(), &MessagesManager::on_imported_message_attachments_uploaded, random_id,
                       std::move(result));
  }));
  auto lock_promise = multipromise.get_promise();

  for (auto attached_file_id : attached_file_ids) {
    upload_imported_message_attachment(dialog_id, import_id, td_->file_manager_->dup_file_id(attached_file_id), false,
                                       multipromise.get_promise());
  }

  lock_promise.set_value(Unit());
}

void MessagesManager::upload_imported_message_attachment(DialogId dialog_id, int64 import_id, FileId file_id,
                                                         bool is_reupload, Promise<Unit> &&promise,
                                                         vector<int> bad_parts) {
  CHECK(file_id.is_valid());
  LOG(INFO) << "Ask to upload improted message attached file " << file_id;
  CHECK(being_uploaded_imported_message_attachments_.find(file_id) ==
        being_uploaded_imported_message_attachments_.end());
  being_uploaded_imported_message_attachments_.emplace(
      file_id,
      td::make_unique<UploadedImportedMessageAttachmentInfo>(dialog_id, import_id, is_reupload, std::move(promise)));
  // TODO use force_reupload if is_reupload
  td_->file_manager_->resume_upload(file_id, std::move(bad_parts), upload_imported_message_attachment_callback_, 1, 0,
                                    false, true);
}

void MessagesManager::on_imported_message_attachments_uploaded(int64 random_id, Result<Unit> &&result) {
  if (G()->close_flag()) {
    result = Status::Error(500, "Request aborted");
  }

  auto it = pending_message_imports_.find(random_id);
  CHECK(it != pending_message_imports_.end());

  auto pending_message_import = std::move(it->second);
  CHECK(pending_message_import != nullptr);

  pending_message_imports_.erase(it);

  if (result.is_error()) {
    pending_message_import->promise.set_error(result.move_as_error());
    return;
  }

  CHECK(pending_message_import->upload_files_multipromise.promise_count() == 0);

  auto promise = std::move(pending_message_import->promise);
  auto dialog_id = pending_message_import->dialog_id;

  TRY_STATUS_PROMISE(promise, can_send_message(dialog_id));

  td_->create_handler<StartImportHistoryQuery>(std::move(promise))->send(dialog_id, pending_message_import->import_id);
}

bool MessagesManager::on_update_message_id(int64 random_id, MessageId new_message_id, const string &source) {
  if (!new_message_id.is_valid() || !new_message_id.is_server()) {
    LOG(ERROR) << "Receive " << new_message_id << " in updateMessageId with random_id " << random_id << " from "
               << source;
    return false;
  }

  auto it = being_sent_messages_.find(random_id);
  if (it == being_sent_messages_.end()) {
    // update about a new message sent from other device or a service message
    LOG(INFO) << "Receive not send outgoing " << new_message_id << " with random_id = " << random_id;
    return true;
  }

  auto dialog_id = it->second.get_dialog_id();
  auto old_message_id = it->second.get_message_id();

  being_sent_messages_.erase(it);

  LOG(INFO) << "Save correspondence from " << new_message_id << " in " << dialog_id << " to " << old_message_id;
  update_message_ids_[FullMessageId(dialog_id, new_message_id)] = old_message_id;
  return true;
}

bool MessagesManager::on_update_scheduled_message_id(int64 random_id, ScheduledServerMessageId new_message_id,
                                                     const string &source) {
  if (!new_message_id.is_valid()) {
    LOG(ERROR) << "Receive " << new_message_id << " in updateMessageId with random_id " << random_id << " from "
               << source;
    return false;
  }

  auto it = being_sent_messages_.find(random_id);
  if (it == being_sent_messages_.end()) {
    LOG(ERROR) << "Receive not send outgoing " << new_message_id << " with random_id = " << random_id;
    return false;
  }

  auto dialog_id = it->second.get_dialog_id();
  auto old_message_id = it->second.get_message_id();

  being_sent_messages_.erase(it);

  LOG(INFO) << "Save correspondence from " << new_message_id << " in " << dialog_id << " to " << old_message_id;
  update_scheduled_message_ids_[dialog_id][new_message_id] = old_message_id;
  return true;
}

bool MessagesManager::on_get_dialog_error(DialogId dialog_id, const Status &status, const string &source) {
  if (status.message() == CSlice("BOT_METHOD_INVALID")) {
    LOG(ERROR) << "Receive BOT_METHOD_INVALID from " << source;
    return true;
  }
  if (G()->is_expected_error(status)) {
    return true;
  }

  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
    case DialogType::SecretChat:
      // to be implemented if necessary
      break;
    case DialogType::Channel:
      return td_->contacts_manager_->on_get_channel_error(dialog_id.get_channel_id(), status, source);
    case DialogType::None:
      // to be implemented if necessary
      break;
    default:
      UNREACHABLE();
  }
  return false;
}

void MessagesManager::on_dialog_updated(DialogId dialog_id, const char *source) {
  if (G()->parameters().use_message_db) {
    LOG(INFO) << "Update " << dialog_id << " from " << source;
    pending_updated_dialog_timeout_.add_timeout_in(dialog_id.get(), MAX_SAVE_DIALOG_DELAY);
  }
}

void MessagesManager::send_update_new_message(const Dialog *d, const Message *m) {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  CHECK(d->is_update_new_chat_sent);
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateNewMessage>(get_message_object(d->dialog_id, m)));
}

MessagesManager::NotificationGroupInfo &MessagesManager::get_notification_group_info(Dialog *d, const Message *m) {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  return is_from_mention_notification_group(d, m) ? d->mention_notification_group : d->message_notification_group;
}

NotificationGroupId MessagesManager::get_dialog_notification_group_id(DialogId dialog_id,
                                                                      NotificationGroupInfo &group_info) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return NotificationGroupId();
  }
  if (!group_info.group_id.is_valid()) {
    NotificationGroupId next_notification_group_id;
    do {
      next_notification_group_id = td_->notification_manager_->get_next_notification_group_id();
      if (!next_notification_group_id.is_valid()) {
        return NotificationGroupId();
      }
    } while (get_message_notification_group_force(next_notification_group_id).dialog_id.is_valid());
    group_info.group_id = next_notification_group_id;
    group_info.is_changed = true;
    VLOG(notifications) << "Assign " << next_notification_group_id << " to " << dialog_id;
    on_dialog_updated(dialog_id, "get_dialog_notification_group_id");

    notification_group_id_to_dialog_id_.emplace(next_notification_group_id, dialog_id);

    if (running_get_channel_difference(dialog_id) || get_channel_difference_to_log_event_id_.count(dialog_id) != 0) {
      send_closure_later(G()->notification_manager(), &NotificationManager::before_get_chat_difference,
                         next_notification_group_id);
    }
  }

  CHECK(group_info.group_id.is_valid());

  // notification group must be preloaded to guarantee that there is no race between
  // get_message_notifications_from_database_force and new notifications added right now
  td_->notification_manager_->load_group_force(group_info.group_id);

  return group_info.group_id;
}

Result<MessagesManager::MessagePushNotificationInfo> MessagesManager::get_message_push_notification_info(
    DialogId dialog_id, MessageId message_id, int64 random_id, UserId sender_user_id, DialogId sender_dialog_id,
    int32 date, bool is_from_scheduled, bool contains_mention, bool is_pinned, bool is_from_binlog) {
  init();

  if (!is_from_scheduled && dialog_id == get_my_dialog_id()) {
    return Status::Error("Ignore notification in chat with self");
  }
  if (td_->auth_manager_->is_bot()) {
    return Status::Error("Ignore notification sent to bot");
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return Status::Error(406, "Ignore notification in unknown chat");
  }
  if (sender_dialog_id.is_valid() && !have_dialog_force(sender_dialog_id)) {
    return Status::Error(406, "Ignore notification sent by unknown chat");
  }

  if (is_from_scheduled && dialog_id != get_my_dialog_id() &&
      G()->shared_config().get_option_boolean("disable_sent_scheduled_message_notifications")) {
    return Status::Error("Ignore notification about sent scheduled message");
  }

  bool is_new_pinned = is_pinned && message_id.is_valid() && message_id > d->max_notification_message_id;
  CHECK(!message_id.is_scheduled());
  if (message_id.is_valid()) {
    if (message_id <= d->last_new_message_id) {
      return Status::Error("Ignore notification about known message");
    }
    if (!is_from_binlog && message_id == d->max_notification_message_id) {
      return Status::Error("Ignore previously added message push notification");
    }
    if (!is_from_binlog && message_id < d->max_notification_message_id) {
      return Status::Error("Ignore out of order message push notification");
    }
    if (message_id <= d->last_read_inbox_message_id) {
      return Status::Error("Ignore notification about read message");
    }
    if (message_id <= d->last_clear_history_message_id) {
      return Status::Error("Ignore notification about message from cleared chat history");
    }
    if (d->deleted_message_ids.count(message_id)) {
      return Status::Error("Ignore notification about deleted message");
    }
    if (message_id <= d->max_unavailable_message_id) {
      return Status::Error("Ignore notification about unavailable message");
    }
  }
  if (random_id != 0) {
    CHECK(dialog_id.get_type() == DialogType::SecretChat);
    if (get_message_id_by_random_id(d, random_id, "get_message_push_notification_info").is_valid()) {
      return Status::Error(406, "Ignore notification about known secret message");
    }
  }

  if (is_pinned) {
    contains_mention = !is_dialog_pinned_message_notifications_disabled(d);
  } else if (contains_mention && is_dialog_mention_notifications_disabled(d)) {
    contains_mention = false;
  }
  if (dialog_id.get_type() == DialogType::User) {
    contains_mention = false;
  }

  DialogId settings_dialog_id = dialog_id;
  Dialog *settings_dialog = d;
  if (contains_mention) {
    if (sender_user_id.is_valid()) {
      settings_dialog_id = DialogId(sender_user_id);
      settings_dialog = get_dialog_force(settings_dialog_id);
    } else if (sender_dialog_id.is_valid()) {
      settings_dialog_id = sender_dialog_id;
      settings_dialog = get_dialog_force(settings_dialog_id);
    }
  }

  bool have_settings;
  int32 mute_until;
  std::tie(have_settings, mute_until) = get_dialog_mute_until(settings_dialog_id, settings_dialog);
  if (have_settings && mute_until > date) {
    if (is_new_pinned) {
      remove_dialog_pinned_message_notification(d, "get_message_push_notification_info");
    }
    return Status::Error("Ignore notification in muted chat");
  }

  if (is_dialog_message_notification_disabled(settings_dialog_id, date)) {
    if (is_new_pinned) {
      remove_dialog_pinned_message_notification(d, "get_message_push_notification_info");
    }
    return Status::Error("Ignore notification in chat, because notifications are disabled in the chat");
  }

  auto group_id = get_dialog_notification_group_id(
      dialog_id, contains_mention ? d->mention_notification_group : d->message_notification_group);
  if (!group_id.is_valid()) {
    return Status::Error("Can't assign notification group ID");
  }

  if (message_id.is_valid() && message_id > d->max_notification_message_id) {
    if (is_new_pinned) {
      set_dialog_pinned_message_notification(d, contains_mention ? message_id : MessageId(),
                                             "get_message_push_notification_info");
    }
    d->max_notification_message_id = message_id;
    on_dialog_updated(dialog_id, "set_max_notification_message_id");
  }

  MessagePushNotificationInfo result;
  result.group_id = group_id;
  result.group_type = contains_mention ? NotificationGroupType::Mentions : NotificationGroupType::Messages;
  result.settings_dialog_id = settings_dialog_id;
  return result;
}

NotificationId MessagesManager::get_next_notification_id(Dialog *d, NotificationGroupId notification_group_id,
                                                         MessageId message_id) {
  CHECK(d != nullptr);
  CHECK(!message_id.is_scheduled());
  NotificationId notification_id;
  do {
    notification_id = td_->notification_manager_->get_next_notification_id();
    if (!notification_id.is_valid()) {
      return NotificationId();
    }
  } while (d->notification_id_to_message_id.count(notification_id) != 0 ||
           d->new_secret_chat_notification_id == notification_id ||
           notification_id.get() <= d->message_notification_group.last_notification_id.get() ||
           notification_id.get() <= d->message_notification_group.max_removed_notification_id.get() ||
           notification_id.get() <= d->mention_notification_group.last_notification_id.get() ||
           notification_id.get() <= d->mention_notification_group.max_removed_notification_id.get());  // just in case
  if (message_id.is_valid()) {
    add_notification_id_to_message_id_correspondence(d, notification_id, message_id);
  }
  return notification_id;
}

MessagesManager::MessageNotificationGroup MessagesManager::get_message_notification_group_force(
    NotificationGroupId group_id) {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(group_id.is_valid());
  Dialog *d = nullptr;
  auto it = notification_group_id_to_dialog_id_.find(group_id);
  if (it != notification_group_id_to_dialog_id_.end()) {
    d = get_dialog(it->second);
    CHECK(d != nullptr);
  } else if (G()->parameters().use_message_db) {
    G()->td_db()->get_dialog_db_sync()->begin_transaction().ensure();
    auto r_value = G()->td_db()->get_dialog_db_sync()->get_notification_group(group_id);
    if (r_value.is_ok()) {
      VLOG(notifications) << "Loaded " << r_value.ok() << " from database by " << group_id;
      d = get_dialog_force(r_value.ok().dialog_id);
    } else {
      CHECK(r_value.error().message() == "Not found");
      VLOG(notifications) << "Failed to load " << group_id << " from database";
    }
    G()->td_db()->get_dialog_db_sync()->commit_transaction().ensure();
  }

  if (d == nullptr) {
    return MessageNotificationGroup();
  }
  if (d->message_notification_group.group_id != group_id && d->mention_notification_group.group_id != group_id) {
    if (d->dialog_id.get_type() == DialogType::SecretChat && !d->message_notification_group.group_id.is_valid() &&
        !d->mention_notification_group.group_id.is_valid()) {
      // the group was reused, but wasn't deleted from the database, trying to resave it
      auto &group_info = d->message_notification_group;
      group_info.group_id = group_id;
      group_info.is_changed = true;
      group_info.try_reuse = true;
      save_dialog_to_database(d->dialog_id);
      group_info.group_id = NotificationGroupId();
      group_info.is_changed = false;
      group_info.try_reuse = false;
    }
  }

  LOG_CHECK(d->message_notification_group.group_id == group_id || d->mention_notification_group.group_id == group_id)
      << group_id << " " << d->message_notification_group.group_id << " " << d->mention_notification_group.group_id
      << " " << d->dialog_id << " " << notification_group_id_to_dialog_id_[group_id] << " "
      << notification_group_id_to_dialog_id_[d->message_notification_group.group_id] << " "
      << notification_group_id_to_dialog_id_[d->mention_notification_group.group_id];

  bool from_mentions = d->mention_notification_group.group_id == group_id;
  auto &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;

  MessageNotificationGroup result;
  VLOG(notifications) << "Found " << (from_mentions ? "Mentions " : "Messages ") << group_info.group_id << '/'
                      << d->dialog_id << " by " << group_id << " with " << d->unread_mention_count
                      << " unread mentions, pinned " << d->pinned_message_notification_message_id
                      << ", new secret chat " << d->new_secret_chat_notification_id << " and "
                      << d->server_unread_count + d->local_unread_count << " unread messages";
  result.dialog_id = d->dialog_id;
  result.total_count = get_dialog_pending_notification_count(d, from_mentions);
  auto pending_notification_count =
      from_mentions ? d->pending_new_mention_notifications.size() : d->pending_new_message_notifications.size();
  result.total_count -= static_cast<int32>(pending_notification_count);
  if (result.total_count < 0) {
    LOG(ERROR) << "Total notification count is " << result.total_count << " in " << d->dialog_id << " with "
               << pending_notification_count << " pending new notifications";
    result.total_count = 0;
  }
  if (d->new_secret_chat_notification_id.is_valid()) {
    CHECK(d->dialog_id.get_type() == DialogType::SecretChat);
    result.type = NotificationGroupType::SecretChat;
    result.notifications.emplace_back(d->new_secret_chat_notification_id,
                                      td_->contacts_manager_->get_secret_chat_date(d->dialog_id.get_secret_chat_id()),
                                      false, create_new_secret_chat_notification());
  } else {
    result.type = from_mentions ? NotificationGroupType::Mentions : NotificationGroupType::Messages;
    result.notifications = get_message_notifications_from_database_force(
        d, from_mentions, static_cast<int32>(td_->notification_manager_->get_max_notification_group_size()));
  }

  int32 last_notification_date = 0;
  NotificationId last_notification_id;
  if (!result.notifications.empty()) {
    last_notification_date = result.notifications[0].date;
    last_notification_id = result.notifications[0].notification_id;
  }
  if (last_notification_date != group_info.last_notification_date ||
      last_notification_id != group_info.last_notification_id) {
    LOG(ERROR) << "Fix last notification date in " << d->dialog_id << " from " << group_info.last_notification_date
               << " to " << last_notification_date << " and last notification id from "
               << group_info.last_notification_id << " to " << last_notification_id;
    set_dialog_last_notification(d->dialog_id, group_info, last_notification_date, last_notification_id,
                                 "get_message_notification_group_force");
  }

  std::reverse(result.notifications.begin(), result.notifications.end());

  return result;
}

bool MessagesManager::is_from_mention_notification_group(const Dialog *d, const Message *m) {
  return m->contains_mention && !m->is_mention_notification_disabled;
}

bool MessagesManager::is_message_notification_active(const Dialog *d, const Message *m) {
  CHECK(!m->message_id.is_scheduled());
  if (is_from_mention_notification_group(d, m)) {
    return m->notification_id.get() > d->mention_notification_group.max_removed_notification_id.get() &&
           m->message_id > d->mention_notification_group.max_removed_message_id &&
           (m->contains_unread_mention || m->message_id == d->pinned_message_notification_message_id);
  } else {
    return m->notification_id.get() > d->message_notification_group.max_removed_notification_id.get() &&
           m->message_id > d->message_notification_group.max_removed_message_id &&
           m->message_id > d->last_read_inbox_message_id;
  }
}

void MessagesManager::try_add_pinned_message_notification(Dialog *d, vector<Notification> &res,
                                                          NotificationId max_notification_id, int32 limit) {
  CHECK(d != nullptr);
  auto message_id = d->pinned_message_notification_message_id;
  if (!message_id.is_valid() || message_id > d->last_new_message_id) {
    CHECK(!message_id.is_scheduled());
    return;
  }

  auto m = get_message_force(d, message_id, "try_add_pinned_message_notification");
  if (m != nullptr && m->notification_id.get() > d->mention_notification_group.max_removed_notification_id.get() &&
      m->message_id > d->mention_notification_group.max_removed_message_id &&
      m->message_id > d->last_read_inbox_message_id && !is_dialog_pinned_message_notifications_disabled(d)) {
    if (m->notification_id.get() < max_notification_id.get()) {
      VLOG(notifications) << "Add " << m->notification_id << " about pinned " << message_id << " in " << d->dialog_id;
      auto pinned_message_id = get_message_content_pinned_message_id(m->content.get());
      if (pinned_message_id.is_valid()) {
        get_message_force(d, pinned_message_id, "try_add_pinned_message_notification 2");  // preload pinned message
      }

      auto pos = res.size();
      res.emplace_back(m->notification_id, m->date, m->disable_notification,
                       create_new_message_notification(message_id));
      while (pos > 0 && res[pos - 1].type->get_message_id() < message_id) {
        std::swap(res[pos - 1], res[pos]);
        pos--;
      }
      if (pos > 0 && res[pos - 1].type->get_message_id() == message_id) {
        res.erase(res.begin() + pos);  // notification was already there
      }
      if (res.size() > static_cast<size_t>(limit)) {
        res.pop_back();
        CHECK(res.size() == static_cast<size_t>(limit));
      }
    }
  } else {
    remove_dialog_pinned_message_notification(d, "try_add_pinned_message_notification");
  }
}

vector<Notification> MessagesManager::get_message_notifications_from_database_force(Dialog *d, bool from_mentions,
                                                                                    int32 limit) {
  CHECK(d != nullptr);
  if (!G()->parameters().use_message_db || td_->auth_manager_->is_bot()) {
    return {};
  }

  auto &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;
  auto from_notification_id = NotificationId::max();
  auto from_message_id = MessageId::max();
  vector<Notification> res;
  if (!from_mentions && from_message_id <= d->last_read_inbox_message_id) {
    return res;
  }
  while (true) {
    auto result = do_get_message_notifications_from_database_force(d, from_mentions, from_notification_id,
                                                                   from_message_id, limit);
    if (result.is_error()) {
      break;
    }
    auto messages = result.move_as_ok();
    if (messages.empty()) {
      break;
    }

    bool is_found = false;
    VLOG(notifications) << "Loaded " << messages.size() << (from_mentions ? " mention" : "")
                        << " messages with notifications from database in " << group_info.group_id << '/'
                        << d->dialog_id;
    for (auto &message : messages) {
      auto m = on_get_message_from_database(d->dialog_id, d, std::move(message), false,
                                            "get_message_notifications_from_database_force");
      if (m == nullptr) {
        VLOG(notifications) << "Receive from database a broken message";
        continue;
      }

      auto notification_id = m->notification_id.is_valid() ? m->notification_id : m->removed_notification_id;
      if (!notification_id.is_valid()) {
        VLOG(ERROR) << "Can't find notification ID for " << m->message_id << " in " << d->dialog_id;
        continue;
      }
      CHECK(m->message_id.is_valid());

      bool is_correct = true;
      if (notification_id.get() >= from_notification_id.get()) {
        // possible if two messages has the same notification_id
        LOG(ERROR) << "Have nonmonotoic notification ids: " << d->dialog_id << " " << m->message_id << " "
                   << notification_id << " " << from_message_id << " " << from_notification_id;
        is_correct = false;
      } else {
        from_notification_id = notification_id;
        is_found = true;
      }
      if (m->message_id >= from_message_id) {
        LOG(ERROR) << "Have nonmonotoic message ids: " << d->dialog_id << " " << m->message_id << " " << notification_id
                   << " " << from_message_id << " " << from_notification_id;
        is_correct = false;
      } else {
        from_message_id = m->message_id;
        is_found = true;
      }

      if (notification_id.get() <= group_info.max_removed_notification_id.get() ||
          m->message_id <= group_info.max_removed_message_id ||
          (!from_mentions && m->message_id <= d->last_read_inbox_message_id)) {
        // if message still has notification_id, but it was removed via max_removed_notification_id,
        // or max_removed_message_id, or last_read_inbox_message_id,
        // then there will be no more messages with active notifications
        is_found = false;
        break;
      }

      if (!m->notification_id.is_valid()) {
        // notification_id can be empty if it is deleted in memory, but not in the database
        VLOG(notifications) << "Receive from database " << m->message_id << " with removed "
                            << m->removed_notification_id;
        continue;
      }

      if (is_from_mention_notification_group(d, m) != from_mentions) {
        VLOG(notifications) << "Receive from database " << m->message_id << " with " << m->notification_id
                            << " from another group";
        continue;
      }

      if (!is_message_notification_active(d, m)) {
        CHECK(from_mentions);
        CHECK(!m->contains_unread_mention);
        CHECK(m->message_id != d->pinned_message_notification_message_id);
        // skip read mentions
        continue;
      }

      if (is_correct) {
        // skip mention messages returned among unread messages
        res.emplace_back(m->notification_id, m->date, m->disable_notification,
                         create_new_message_notification(m->message_id));
      } else {
        remove_message_notification_id(d, m, true, false);
        on_message_changed(d, m, false, "get_message_notifications_from_database_force");
      }
    }
    if (!res.empty() || !is_found) {
      break;
    }
  }
  if (from_mentions) {
    try_add_pinned_message_notification(d, res, NotificationId::max(), limit);
  }
  return res;
}

Result<vector<BufferSlice>> MessagesManager::do_get_message_notifications_from_database_force(
    Dialog *d, bool from_mentions, NotificationId from_notification_id, MessageId from_message_id, int32 limit) {
  CHECK(G()->parameters().use_message_db);
  CHECK(!from_message_id.is_scheduled());

  auto *db = G()->td_db()->get_messages_db_sync();
  if (!from_mentions) {
    CHECK(from_message_id > d->last_read_inbox_message_id);
    VLOG(notifications) << "Trying to load " << limit << " messages with notifications in "
                        << d->message_notification_group.group_id << '/' << d->dialog_id << " from "
                        << from_notification_id;
    return db->get_messages_from_notification_id(d->dialog_id, from_notification_id, limit);
  } else {
    VLOG(notifications) << "Trying to load " << limit << " messages with unread mentions in "
                        << d->mention_notification_group.group_id << '/' << d->dialog_id << " from " << from_message_id;

    // ignore first_db_message_id, notifications can be nonconsecutive
    MessagesDbMessagesQuery db_query;
    db_query.dialog_id = d->dialog_id;
    db_query.index_mask = message_search_filter_index_mask(MessageSearchFilter::UnreadMention);
    db_query.from_message_id = from_message_id;
    db_query.offset = 0;
    db_query.limit = limit;
    return db->get_messages(db_query);
  }
}

vector<NotificationGroupKey> MessagesManager::get_message_notification_group_keys_from_database(
    NotificationGroupKey from_group_key, int32 limit) {
  if (!G()->parameters().use_message_db) {
    return {};
  }

  init();

  VLOG(notifications) << "Trying to load " << limit << " message notification groups from database from "
                      << from_group_key;

  G()->td_db()->get_dialog_db_sync()->begin_transaction().ensure();
  Result<vector<NotificationGroupKey>> r_notification_group_keys =
      G()->td_db()->get_dialog_db_sync()->get_notification_groups_by_last_notification_date(from_group_key, limit);
  r_notification_group_keys.ensure();
  auto group_keys = r_notification_group_keys.move_as_ok();

  vector<NotificationGroupKey> result;
  for (auto &group_key : group_keys) {
    CHECK(group_key.dialog_id.is_valid());
    const Dialog *d = get_dialog_force(group_key.dialog_id);
    if (d == nullptr || (d->message_notification_group.group_id != group_key.group_id &&
                         d->mention_notification_group.group_id != group_key.group_id)) {
      continue;
    }

    CHECK(d->dialog_id == group_key.dialog_id);
    CHECK(notification_group_id_to_dialog_id_[group_key.group_id] == d->dialog_id);

    VLOG(notifications) << "Loaded " << group_key << " from database";
    result.push_back(group_key);
  }
  G()->td_db()->get_dialog_db_sync()->commit_transaction().ensure();
  return result;
}

void MessagesManager::get_message_notifications_from_database(DialogId dialog_id, NotificationGroupId group_id,
                                                              NotificationId from_notification_id,
                                                              MessageId from_message_id, int32 limit,
                                                              Promise<vector<Notification>> promise) {
  if (!G()->parameters().use_message_db) {
    return promise.set_error(Status::Error(500, "There is no message database"));
  }
  if (td_->auth_manager_->is_bot()) {
    return promise.set_error(Status::Error(500, "Bots have no notifications"));
  }

  CHECK(dialog_id.is_valid());
  CHECK(group_id.is_valid());
  CHECK(!from_message_id.is_scheduled());
  CHECK(limit > 0);

  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  if (d->message_notification_group.group_id != group_id && d->mention_notification_group.group_id != group_id) {
    return promise.set_value(vector<Notification>());
  }

  VLOG(notifications) << "Get " << limit << " message notifications from database in " << group_id << " from "
                      << dialog_id << " from " << from_notification_id << "/" << from_message_id;
  bool from_mentions = d->mention_notification_group.group_id == group_id;
  if (d->new_secret_chat_notification_id.is_valid()) {
    CHECK(d->dialog_id.get_type() == DialogType::SecretChat);
    vector<Notification> notifications;
    if (!from_mentions && d->new_secret_chat_notification_id.get() < from_notification_id.get()) {
      notifications.emplace_back(d->new_secret_chat_notification_id,
                                 td_->contacts_manager_->get_secret_chat_date(d->dialog_id.get_secret_chat_id()), false,
                                 create_new_secret_chat_notification());
    }
    return promise.set_value(std::move(notifications));
  }

  do_get_message_notifications_from_database(d, from_mentions, from_notification_id, from_notification_id,
                                             from_message_id, limit, std::move(promise));
}

void MessagesManager::do_get_message_notifications_from_database(Dialog *d, bool from_mentions,
                                                                 NotificationId initial_from_notification_id,
                                                                 NotificationId from_notification_id,
                                                                 MessageId from_message_id, int32 limit,
                                                                 Promise<vector<Notification>> promise) {
  CHECK(G()->parameters().use_message_db);
  CHECK(!from_message_id.is_scheduled());

  auto &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;
  if (from_notification_id.get() <= group_info.max_removed_notification_id.get() ||
      from_message_id <= group_info.max_removed_message_id ||
      (!from_mentions && from_message_id <= d->last_read_inbox_message_id)) {
    return promise.set_value(vector<Notification>());
  }

  auto dialog_id = d->dialog_id;
  auto new_promise =
      PromiseCreator::lambda([actor_id = actor_id(this), dialog_id, from_mentions, initial_from_notification_id, limit,
                              promise = std::move(promise)](Result<vector<BufferSlice>> result) mutable {
        send_closure(actor_id, &MessagesManager::on_get_message_notifications_from_database, dialog_id, from_mentions,
                     initial_from_notification_id, limit, std::move(result), std::move(promise));
      });

  auto *db = G()->td_db()->get_messages_db_async();
  if (!from_mentions) {
    VLOG(notifications) << "Trying to load " << limit << " messages with notifications in " << group_info.group_id
                        << '/' << dialog_id << " from " << from_notification_id;
    return db->get_messages_from_notification_id(d->dialog_id, from_notification_id, limit, std::move(new_promise));
  } else {
    VLOG(notifications) << "Trying to load " << limit << " messages with unread mentions in " << group_info.group_id
                        << '/' << dialog_id << " from " << from_message_id;

    // ignore first_db_message_id, notifications can be nonconsecutive
    MessagesDbMessagesQuery db_query;
    db_query.dialog_id = dialog_id;
    db_query.index_mask = message_search_filter_index_mask(MessageSearchFilter::UnreadMention);
    db_query.from_message_id = from_message_id;
    db_query.offset = 0;
    db_query.limit = limit;
    return db->get_messages(db_query, std::move(new_promise));
  }
}

void MessagesManager::on_get_message_notifications_from_database(DialogId dialog_id, bool from_mentions,
                                                                 NotificationId initial_from_notification_id,
                                                                 int32 limit, Result<vector<BufferSlice>> result,
                                                                 Promise<vector<Notification>> promise) {
  if (G()->close_flag()) {
    result = Status::Error(500, "Request aborted");
  }
  if (result.is_error()) {
    return promise.set_error(result.move_as_error());
  }

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  auto &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;
  if (!group_info.group_id.is_valid()) {
    return promise.set_error(Status::Error("Notification group was deleted"));
  }

  auto messages = result.move_as_ok();
  vector<Notification> res;
  res.reserve(messages.size());
  NotificationId from_notification_id;
  MessageId from_message_id;
  VLOG(notifications) << "Loaded " << messages.size() << " messages with notifications in " << group_info.group_id
                      << '/' << dialog_id << " from database";
  for (auto &message : messages) {
    auto m = on_get_message_from_database(dialog_id, d, std::move(message), false,
                                          "on_get_message_notifications_from_database");
    if (m == nullptr) {
      VLOG(notifications) << "Receive from database a broken message";
      continue;
    }

    auto notification_id = m->notification_id.is_valid() ? m->notification_id : m->removed_notification_id;
    if (!notification_id.is_valid()) {
      VLOG(ERROR) << "Can't find notification ID for " << m->message_id << " in " << d->dialog_id;
      continue;
    }
    CHECK(m->message_id.is_valid());

    bool is_correct = true;
    if (from_notification_id.is_valid() && notification_id.get() >= from_notification_id.get()) {
      LOG(ERROR) << "Receive " << m->message_id << "/" << notification_id << " after " << from_message_id << "/"
                 << from_notification_id;
      is_correct = false;
    } else {
      from_notification_id = notification_id;
    }
    if (from_message_id.is_valid() && m->message_id >= from_message_id) {
      LOG(ERROR) << "Receive " << m->message_id << "/" << notification_id << " after " << from_message_id << "/"
                 << from_notification_id;
      is_correct = false;
    } else {
      from_message_id = m->message_id;
    }

    if (notification_id.get() <= group_info.max_removed_notification_id.get() ||
        m->message_id <= group_info.max_removed_message_id ||
        (!from_mentions && m->message_id <= d->last_read_inbox_message_id)) {
      // if message still has notification_id, but it was removed via max_removed_notification_id,
      // or max_removed_message_id, or last_read_inbox_message_id,
      // then there will be no more messages with active notifications
      from_notification_id = NotificationId();  // stop requesting database
      break;
    }

    if (!m->notification_id.is_valid()) {
      // notification_id can be empty if it is deleted in memory, but not in the database
      VLOG(notifications) << "Receive from database " << m->message_id << " with removed "
                          << m->removed_notification_id;
      continue;
    }

    if (is_from_mention_notification_group(d, m) != from_mentions) {
      VLOG(notifications) << "Receive from database " << m->message_id << " with " << m->notification_id
                          << " from another category";
      continue;
    }

    if (!is_message_notification_active(d, m)) {
      CHECK(from_mentions);
      CHECK(!m->contains_unread_mention);
      CHECK(m->message_id != d->pinned_message_notification_message_id);
      // skip read mentions
      continue;
    }

    if (is_correct) {
      // skip mention messages returned among unread messages
      res.emplace_back(m->notification_id, m->date, m->disable_notification,
                       create_new_message_notification(m->message_id));
    } else {
      remove_message_notification_id(d, m, true, false);
      on_message_changed(d, m, false, "on_get_message_notifications_from_database");
    }
  }
  if (!res.empty() || !from_notification_id.is_valid() || static_cast<size_t>(limit) > messages.size()) {
    if (from_mentions) {
      try_add_pinned_message_notification(d, res, initial_from_notification_id, limit);
    }

    std::reverse(res.begin(), res.end());
    return promise.set_value(std::move(res));
  }

  // try again from adjusted from_notification_id and from_message_id
  do_get_message_notifications_from_database(d, from_mentions, initial_from_notification_id, from_notification_id,
                                             from_message_id, limit, std::move(promise));
}

void MessagesManager::remove_message_notification(DialogId dialog_id, NotificationGroupId group_id,
                                                  NotificationId notification_id) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(ERROR) << "Can't find " << dialog_id;
    return;
  }
  if (d->message_notification_group.group_id != group_id && d->mention_notification_group.group_id != group_id) {
    LOG(ERROR) << "There is no " << group_id << " in " << dialog_id;
    return;
  }
  if (notification_id == NotificationId::max() || !notification_id.is_valid()) {
    return;  // there can be no notification with this ID
  }

  bool from_mentions = d->mention_notification_group.group_id == group_id;
  if (d->new_secret_chat_notification_id.is_valid()) {
    if (!from_mentions && d->new_secret_chat_notification_id == notification_id) {
      return remove_new_secret_chat_notification(d, false);
    }
    return;
  }

  auto it = d->notification_id_to_message_id.find(notification_id);
  if (it != d->notification_id_to_message_id.end()) {
    auto m = get_message(d, it->second);
    CHECK(m != nullptr);
    CHECK(m->notification_id == notification_id);
    CHECK(!m->message_id.is_scheduled());
    if (is_from_mention_notification_group(d, m) == from_mentions && is_message_notification_active(d, m)) {
      remove_message_notification_id(d, m, false, false);
    }
    return;
  }

  if (G()->parameters().use_message_db) {
    G()->td_db()->get_messages_db_async()->get_messages_from_notification_id(
        dialog_id, NotificationId(notification_id.get() + 1), 1,
        PromiseCreator::lambda(
            [dialog_id, from_mentions, notification_id, actor_id = actor_id(this)](vector<BufferSlice> result) {
              send_closure(actor_id, &MessagesManager::do_remove_message_notification, dialog_id, from_mentions,
                           notification_id, std::move(result));
            }));
  }
}

void MessagesManager::remove_message_notifications_by_message_ids(DialogId dialog_id,
                                                                  const vector<MessageId> &message_ids) {
  VLOG(notifications) << "Trying to remove notification about " << message_ids << " in " << dialog_id;
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return;
  }

  bool need_update_dialog_pos = false;
  vector<int64> deleted_message_ids;
  for (auto message_id : message_ids) {
    CHECK(!message_id.is_scheduled());
    // can't remove just notification_id, because total_count will stay wrong after restart
    // delete whole message
    auto message =
        delete_message(d, message_id, true, &need_update_dialog_pos, "remove_message_notifications_by_message_ids");
    if (message == nullptr) {
      LOG(INFO) << "Can't delete " << message_id << " because it is not found";
      // call synchronously to remove them before ProcessPush returns
      td_->notification_manager_->remove_temporary_notification_by_message_id(
          d->message_notification_group.group_id, message_id, true, "remove_message_notifications_by_message_ids");
      td_->notification_manager_->remove_temporary_notification_by_message_id(
          d->mention_notification_group.group_id, message_id, true, "remove_message_notifications_by_message_ids");
      continue;
    }
    deleted_message_ids.push_back(message->message_id.get());
  }

  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "remove_message_notifications_by_message_ids");
  }
  send_update_delete_messages(dialog_id, std::move(deleted_message_ids), true, false);
}

void MessagesManager::do_remove_message_notification(DialogId dialog_id, bool from_mentions,
                                                     NotificationId notification_id, vector<BufferSlice> result) {
  if (result.empty() || G()->close_flag()) {
    return;
  }
  CHECK(result.size() == 1);

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  auto m = on_get_message_from_database(dialog_id, d, std::move(result[0]), false, "do_remove_message_notification");
  if (m != nullptr && m->notification_id == notification_id &&
      is_from_mention_notification_group(d, m) == from_mentions && is_message_notification_active(d, m)) {
    remove_message_notification_id(d, m, false, false);
  }
}

void MessagesManager::remove_message_notifications(DialogId dialog_id, NotificationGroupId group_id,
                                                   NotificationId max_notification_id, MessageId max_message_id) {
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(ERROR) << "Can't find " << dialog_id;
    return;
  }
  if (d->message_notification_group.group_id != group_id && d->mention_notification_group.group_id != group_id) {
    LOG(ERROR) << "There is no " << group_id << " in " << dialog_id;
    return;
  }
  if (!max_notification_id.is_valid()) {
    return;
  }
  CHECK(!max_message_id.is_scheduled());

  bool from_mentions = d->mention_notification_group.group_id == group_id;
  if (d->new_secret_chat_notification_id.is_valid()) {
    if (!from_mentions && d->new_secret_chat_notification_id.get() <= max_notification_id.get()) {
      return remove_new_secret_chat_notification(d, false);
    }
    return;
  }
  auto &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;
  if (max_notification_id.get() <= group_info.max_removed_notification_id.get()) {
    return;
  }
  if (max_message_id > group_info.max_removed_message_id) {
    VLOG(notifications) << "Set max_removed_message_id in " << group_info.group_id << '/' << dialog_id << " to "
                        << max_message_id;
    group_info.max_removed_message_id = max_message_id.get_prev_server_message_id();
  }

  VLOG(notifications) << "Set max_removed_notification_id in " << group_info.group_id << '/' << dialog_id << " to "
                      << max_notification_id;
  group_info.max_removed_notification_id = max_notification_id;
  on_dialog_updated(dialog_id, "remove_message_notifications");

  if (group_info.last_notification_id.is_valid() &&
      max_notification_id.get() >= group_info.last_notification_id.get()) {
    bool is_changed =
        set_dialog_last_notification(dialog_id, group_info, 0, NotificationId(), "remove_message_notifications");
    CHECK(is_changed);
  }
}

int32 MessagesManager::get_dialog_pending_notification_count(const Dialog *d, bool from_mentions) const {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(d != nullptr);
  if (from_mentions) {
    bool has_pinned_message = d->pinned_message_notification_message_id.is_valid() &&
                              d->pinned_message_notification_message_id <= d->last_new_message_id;
    return d->unread_mention_count + static_cast<int32>(has_pinned_message);
  } else {
    if (d->new_secret_chat_notification_id.is_valid()) {
      return 1;
    }
    if (is_dialog_muted(d)) {
      return narrow_cast<int32>(d->pending_new_message_notifications.size());  // usually 0
    }

    return d->server_unread_count + d->local_unread_count;
  }
}

void MessagesManager::update_dialog_mention_notification_count(const Dialog *d) {
  CHECK(d != nullptr);
  if (td_->auth_manager_->is_bot() || !d->mention_notification_group.group_id.is_valid()) {
    return;
  }
  auto total_count =
      get_dialog_pending_notification_count(d, true) - static_cast<int32>(d->pending_new_mention_notifications.size());
  if (total_count < 0) {
    LOG(ERROR) << "Total mention notification count is " << total_count << " in " << d->dialog_id << " with "
               << d->pending_new_mention_notifications << " pending new mention notifications";
    total_count = 0;
  }
  send_closure_later(G()->notification_manager(), &NotificationManager::set_notification_total_count,
                     d->mention_notification_group.group_id, total_count);
}

bool MessagesManager::is_message_notification_disabled(const Dialog *d, const Message *m) const {
  CHECK(d != nullptr);
  CHECK(m != nullptr);

  if (!has_incoming_notification(d->dialog_id, m) || td_->auth_manager_->is_bot()) {
    return true;
  }
  if (m->is_from_scheduled && d->dialog_id != get_my_dialog_id() &&
      G()->shared_config().get_option_boolean("disable_sent_scheduled_message_notifications")) {
    return true;
  }
  if (m->forward_info != nullptr && m->forward_info->is_imported) {
    return true;
  }

  switch (m->content->get_type()) {
    case MessageContentType::ChatDeleteHistory:
    case MessageContentType::ChatMigrateTo:
    case MessageContentType::Unsupported:
    case MessageContentType::ExpiredPhoto:
    case MessageContentType::ExpiredVideo:
    case MessageContentType::PassportDataSent:
    case MessageContentType::PassportDataReceived:
      VLOG(notifications) << "Disable notification for " << m->message_id << " in " << d->dialog_id
                          << " with content of type " << m->content->get_type();
      return true;
    case MessageContentType::ContactRegistered:
      if (m->disable_notification) {
        return true;
      }
      break;
    default:
      break;
  }

  return is_dialog_message_notification_disabled(d->dialog_id, m->date);
}

bool MessagesManager::is_dialog_message_notification_disabled(DialogId dialog_id, int32 message_date) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      break;
    case DialogType::Chat:
      if (!td_->contacts_manager_->get_chat_is_active(dialog_id.get_chat_id())) {
        return true;
      }
      break;
    case DialogType::Channel:
      if (!td_->contacts_manager_->get_channel_status(dialog_id.get_channel_id()).is_member() ||
          message_date < td_->contacts_manager_->get_channel_date(dialog_id.get_channel_id())) {
        return true;
      }
      break;
    case DialogType::SecretChat:
      if (td_->contacts_manager_->get_secret_chat_state(dialog_id.get_secret_chat_id()) == SecretChatState::Closed) {
        return true;
      }
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  return false;
}

bool MessagesManager::may_need_message_notification(const Dialog *d, const Message *m) const {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  CHECK(m->message_id.is_valid());

  if (is_message_notification_disabled(d, m)) {
    return false;
  }

  if (is_from_mention_notification_group(d, m)) {
    return true;
  }

  bool have_settings;
  int32 mute_until;
  std::tie(have_settings, mute_until) = get_dialog_mute_until(d->dialog_id, d);
  return !have_settings || mute_until <= m->date;
}

bool MessagesManager::add_new_message_notification(Dialog *d, Message *m, bool force) {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  CHECK(m->message_id.is_valid());

  if (!force) {
    if (d->message_notification_group.group_id.is_valid()) {
      send_closure_later(G()->notification_manager(), &NotificationManager::remove_temporary_notifications,
                         d->message_notification_group.group_id, "add_new_message_notification 1");
    }
    if (d->mention_notification_group.group_id.is_valid()) {
      send_closure_later(G()->notification_manager(), &NotificationManager::remove_temporary_notifications,
                         d->mention_notification_group.group_id, "add_new_message_notification 2");
    }
  }

  CHECK(!m->notification_id.is_valid());
  if (is_message_notification_disabled(d, m)) {
    return false;
  }

  auto from_mentions = is_from_mention_notification_group(d, m);
  bool is_pinned = m->content->get_type() == MessageContentType::PinMessage;
  bool is_active =
      from_mentions ? m->contains_unread_mention || is_pinned : m->message_id > d->last_read_inbox_message_id;
  if (is_active) {
    auto &group = from_mentions ? d->mention_notification_group : d->message_notification_group;
    if (group.max_removed_message_id >= m->message_id) {
      is_active = false;
    }
  }
  if (!is_active) {
    VLOG(notifications) << "Disable inactive notification for " << m->message_id << " in " << d->dialog_id;
    if (is_pinned) {
      remove_dialog_pinned_message_notification(d, "add_new_message_notification");
    }
    return false;
  }

  VLOG(notifications) << "Trying to " << (force ? "forcely " : "") << "add new message notification for "
                      << m->message_id << " in " << d->dialog_id
                      << (m->disable_notification ? " silently" : " with sound");

  DialogId settings_dialog_id = d->dialog_id;
  Dialog *settings_dialog = d;
  if (m->contains_mention && !m->is_mention_notification_disabled) {
    // have a mention, so use notification settings from the dialog with the sender
    if (m->sender_user_id.is_valid()) {
      settings_dialog_id = DialogId(m->sender_user_id);
      settings_dialog = get_dialog_force(settings_dialog_id);
    } else if (m->sender_dialog_id.is_valid()) {
      settings_dialog_id = m->sender_dialog_id;
      settings_dialog = get_dialog_force(settings_dialog_id);
    }
  }

  bool have_settings;
  int32 mute_until;
  std::tie(have_settings, mute_until) = get_dialog_mute_until(settings_dialog_id, settings_dialog);
  if (mute_until > m->date && (have_settings || force)) {
    VLOG(notifications) << "Disable notification, because " << settings_dialog_id << " is muted";
    if (is_pinned) {
      remove_dialog_pinned_message_notification(d, "add_new_message_notification");
    }
    return false;
  }

  MessageId missing_pinned_message_id;
  if (is_pinned) {
    auto message_id = get_message_content_pinned_message_id(m->content.get());
    if (message_id.is_valid() &&
        !have_message_force({d->dialog_id, message_id},
                            force ? "add_new_message_notification force" : "add_new_message_notification not force")) {
      missing_pinned_message_id = message_id;
    }
  }

  auto &pending_notifications =
      from_mentions ? d->pending_new_mention_notifications : d->pending_new_message_notifications;
  if (!force && (!have_settings || !pending_notifications.empty() || missing_pinned_message_id.is_valid())) {
    VLOG(notifications) << "Delay new message notification for " << m->message_id << " in " << d->dialog_id << " with "
                        << pending_notifications.size() << " already waiting messages";
    if (pending_notifications.empty()) {
      VLOG(notifications) << "Create FlushPendingNewMessageNotificationsSleepActor for " << d->dialog_id;
      create_actor<SleepActor>("FlushPendingNewMessageNotificationsSleepActor", 5.0,
                               PromiseCreator::lambda([actor_id = actor_id(this), dialog_id = d->dialog_id,
                                                       from_mentions](Result<Unit> result) {
                                 VLOG(notifications)
                                     << "Pending notifications timeout in " << dialog_id << " has expired";
                                 send_closure(actor_id, &MessagesManager::flush_pending_new_message_notifications,
                                              dialog_id, from_mentions, DialogId());
                               }))
          .release();
    }
    auto last_settings_dialog_id = (pending_notifications.empty() ? DialogId() : pending_notifications.back().first);
    pending_notifications.emplace_back((have_settings ? DialogId() : settings_dialog_id), m->message_id);
    if (!have_settings && last_settings_dialog_id != settings_dialog_id) {
      VLOG(notifications) << "Fetch notification settings for " << settings_dialog_id;
      auto promise = PromiseCreator::lambda([actor_id = actor_id(this), dialog_id = d->dialog_id, from_mentions,
                                             settings_dialog_id](Result<Unit> result) {
        send_closure(actor_id, &MessagesManager::flush_pending_new_message_notifications, dialog_id, from_mentions,
                     settings_dialog_id);
      });
      if (settings_dialog == nullptr && have_input_peer(settings_dialog_id, AccessRights::Read)) {
        force_create_dialog(settings_dialog_id, "add_new_message_notification 2");
        settings_dialog = get_dialog(settings_dialog_id);
      }
      if (settings_dialog != nullptr) {
        send_get_dialog_notification_settings_query(settings_dialog_id, std::move(promise));
      } else {
        send_get_dialog_query(settings_dialog_id, std::move(promise), 0, "add_new_message_notification");
      }
    }
    if (missing_pinned_message_id.is_valid()) {
      VLOG(notifications) << "Fetch pinned " << missing_pinned_message_id;
      auto promise = PromiseCreator::lambda(
          [actor_id = actor_id(this), dialog_id = d->dialog_id, from_mentions](Result<Unit> result) {
            send_closure(actor_id, &MessagesManager::flush_pending_new_message_notifications, dialog_id, from_mentions,
                         dialog_id);
          });
      get_message_from_server({d->dialog_id, missing_pinned_message_id}, std::move(promise));
    }
    return false;
  }

  LOG_IF(WARNING, !have_settings) << "Have no notification settings for " << settings_dialog_id
                                  << ", but forced to send notification about " << m->message_id << " in "
                                  << d->dialog_id;
  auto &group_info = get_notification_group_info(d, m);
  auto notification_group_id = get_dialog_notification_group_id(d->dialog_id, group_info);
  if (!notification_group_id.is_valid()) {
    return false;
  }
  // if !force, then add_message_to_dialog will add the correspondence
  m->notification_id = get_next_notification_id(d, notification_group_id, force ? m->message_id : MessageId());
  if (!m->notification_id.is_valid()) {
    return false;
  }
  bool is_changed = set_dialog_last_notification(d->dialog_id, group_info, m->date, m->notification_id,
                                                 "add_new_message_notification 3");
  CHECK(is_changed);
  if (is_pinned) {
    set_dialog_pinned_message_notification(d, from_mentions ? m->message_id : MessageId(),
                                           "add_new_message_notification");
  }
  if (!m->notification_id.is_valid()) {
    // protection from accidental notification_id removal in set_dialog_pinned_message_notification
    return false;
  }
  VLOG(notifications) << "Create " << m->notification_id << " with " << m->message_id << " in " << group_info.group_id
                      << '/' << d->dialog_id;
  int32 min_delay_ms = 0;
  if (need_delay_message_content_notification(m->content.get(), td_->contacts_manager_->get_my_id())) {
    min_delay_ms = 3000;  // 3 seconds
  } else if (td_->is_online() && d->is_opened) {
    min_delay_ms = 1000;  // 1 second
  }
  bool is_silent = m->disable_notification || m->message_id <= d->max_notification_message_id;
  send_closure_later(G()->notification_manager(), &NotificationManager::add_notification, notification_group_id,
                     from_mentions ? NotificationGroupType::Mentions : NotificationGroupType::Messages, d->dialog_id,
                     m->date, settings_dialog_id, m->disable_notification, is_silent, min_delay_ms, m->notification_id,
                     create_new_message_notification(m->message_id), "add_new_message_notification");
  return true;
}

void MessagesManager::flush_pending_new_message_notifications(DialogId dialog_id, bool from_mentions,
                                                              DialogId settings_dialog_id) {
  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  auto &pending_notifications =
      from_mentions ? d->pending_new_mention_notifications : d->pending_new_message_notifications;
  if (pending_notifications.empty()) {
    VLOG(notifications) << "Have no pending notifications in " << dialog_id << " to flush";
    return;
  }
  for (auto &it : pending_notifications) {
    if (it.first == settings_dialog_id || !settings_dialog_id.is_valid()) {
      it.first = DialogId();
    }
  }

  VLOG(notifications) << "Flush pending notifications in " << dialog_id
                      << " because of received notification settings in " << settings_dialog_id;
  auto it = pending_notifications.begin();
  while (it != pending_notifications.end() && it->first == DialogId()) {
    auto m = get_message(d, it->second);
    if (m != nullptr) {
      if (add_new_message_notification(d, m, true)) {
        on_message_changed(d, m, false, "flush_pending_new_message_notifications");
      }
    }
    ++it;
  }

  if (it == pending_notifications.end()) {
    reset_to_empty(pending_notifications);
  } else {
    pending_notifications.erase(pending_notifications.begin(), it);
  }
}

void MessagesManager::remove_all_dialog_notifications(Dialog *d, bool from_mentions, const char *source) {
  // removes up to group_info.last_notification_id
  NotificationGroupInfo &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;
  if (group_info.group_id.is_valid() && group_info.last_notification_id.is_valid() &&
      group_info.max_removed_notification_id != group_info.last_notification_id) {
    VLOG(notifications) << "Set max_removed_notification_id in " << group_info.group_id << '/' << d->dialog_id << " to "
                        << group_info.last_notification_id << " from " << source;
    group_info.max_removed_notification_id = group_info.last_notification_id;
    if (d->max_notification_message_id > group_info.max_removed_message_id) {
      group_info.max_removed_message_id = d->max_notification_message_id.get_prev_server_message_id();
    }
    if (!d->pending_new_message_notifications.empty()) {
      for (auto &it : d->pending_new_message_notifications) {
        it.first = DialogId();
      }
      flush_pending_new_message_notifications(d->dialog_id, from_mentions, DialogId(UserId(2)));
    }
    // remove_message_notifications will be called by NotificationManager
    send_closure_later(G()->notification_manager(), &NotificationManager::remove_notification_group,
                       group_info.group_id, group_info.last_notification_id, MessageId(), 0, true, Promise<Unit>());
    if (d->new_secret_chat_notification_id.is_valid() && &group_info == &d->message_notification_group) {
      remove_new_secret_chat_notification(d, false);
    } else {
      bool is_changed = set_dialog_last_notification(d->dialog_id, group_info, 0, NotificationId(), source);
      CHECK(is_changed);
    }
  }
}

void MessagesManager::remove_message_dialog_notifications(Dialog *d, MessageId max_message_id, bool from_mentions,
                                                          const char *source) {
  // removes up to max_message_id
  CHECK(!max_message_id.is_scheduled());
  NotificationGroupInfo &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;
  if (!group_info.group_id.is_valid()) {
    return;
  }

  VLOG(notifications) << "Remove message dialog notifications in " << group_info.group_id << '/' << d->dialog_id
                      << " up to " << max_message_id << " from " << source;

  if (!d->pending_new_message_notifications.empty()) {
    for (auto &it : d->pending_new_message_notifications) {
      if (it.second <= max_message_id) {
        it.first = DialogId();
      }
    }
    flush_pending_new_message_notifications(d->dialog_id, from_mentions, DialogId(UserId(3)));
  }

  auto max_notification_message_id = max_message_id;
  if (d->last_message_id.is_valid() && max_notification_message_id >= d->last_message_id) {
    max_notification_message_id = d->last_message_id;
    set_dialog_last_notification(d->dialog_id, group_info, 0, NotificationId(),
                                 "remove_message_dialog_notifications 1");
  } else if (max_notification_message_id == MessageId::max()) {
    max_notification_message_id = get_next_local_message_id(d);
    set_dialog_last_notification(d->dialog_id, group_info, 0, NotificationId(),
                                 "remove_message_dialog_notifications 2");
  } else {
    LOG(FATAL) << "TODO support notification deletion up to " << max_message_id << " if will be ever needed";
  }

  send_closure_later(G()->notification_manager(), &NotificationManager::remove_notification_group, group_info.group_id,
                     NotificationId(), max_notification_message_id, 0, true, Promise<Unit>());
}

void MessagesManager::send_update_message_send_succeeded(Dialog *d, MessageId old_message_id, const Message *m) const {
  CHECK(m != nullptr);
  CHECK(d->is_update_new_chat_sent);
  if (!td_->auth_manager_->is_bot()) {
    d->yet_unsent_message_id_to_persistent_message_id.emplace(old_message_id, m->message_id);
  }
  send_closure(
      G()->td(), &Td::send_update,
      make_tl_object<td_api::updateMessageSendSucceeded>(get_message_object(d->dialog_id, m), old_message_id.get()));
}

void MessagesManager::send_update_message_content(DialogId dialog_id, MessageId message_id,
                                                  const MessageContent *content, int32 message_date,
                                                  bool is_content_secret, const char *source) const {
  LOG(INFO) << "Send updateMessageContent for " << message_id << " in " << dialog_id << " from " << source;
  LOG_CHECK(have_dialog(dialog_id)) << "Send updateMessageContent in unknown " << dialog_id << " from " << source
                                    << " with load count " << loaded_dialogs_.count(dialog_id);
  auto content_object = get_message_content_object(content, td_, message_date, is_content_secret);
  send_closure(
      G()->td(), &Td::send_update,
      td_api::make_object<td_api::updateMessageContent>(dialog_id.get(), message_id.get(), std::move(content_object)));
}

void MessagesManager::send_update_message_edited(DialogId dialog_id, const Message *m) {
  CHECK(m != nullptr);
  cancel_user_dialog_action(dialog_id, m);
  auto edit_date = m->hide_edit_date ? 0 : m->edit_date;
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateMessageEdited>(dialog_id.get(), m->message_id.get(), edit_date,
                                                           get_reply_markup_object(m->reply_markup)));
}

void MessagesManager::send_update_message_interaction_info(DialogId dialog_id, const Message *m) const {
  CHECK(m != nullptr);
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateMessageInteractionInfo>(dialog_id.get(), m->message_id.get(),
                                                                    get_message_interaction_info_object(dialog_id, m)));
}

void MessagesManager::send_update_message_live_location_viewed(FullMessageId full_message_id) {
  CHECK(get_message(full_message_id) != nullptr);
  send_closure(G()->td(), &Td::send_update,
               td_api::make_object<td_api::updateMessageLiveLocationViewed>(full_message_id.get_dialog_id().get(),
                                                                            full_message_id.get_message_id().get()));
}

void MessagesManager::send_update_delete_messages(DialogId dialog_id, vector<int64> &&message_ids, bool is_permanent,
                                                  bool from_cache) const {
  if (message_ids.empty()) {
    return;
  }

  LOG_CHECK(have_dialog(dialog_id)) << "Wrong " << dialog_id << " in send_update_delete_messages";
  send_closure(
      G()->td(), &Td::send_update,
      make_tl_object<td_api::updateDeleteMessages>(dialog_id.get(), std::move(message_ids), is_permanent, from_cache));
}

void MessagesManager::send_update_new_chat(Dialog *d) {
  CHECK(d != nullptr);
  CHECK(d->messages == nullptr);
  auto chat_object = get_chat_object(d);
  bool has_action_bar = chat_object->action_bar_ != nullptr;
  d->last_sent_has_scheduled_messages = chat_object->has_scheduled_messages_;
  send_closure(G()->td(), &Td::send_update, make_tl_object<td_api::updateNewChat>(std::move(chat_object)));
  d->is_update_new_chat_sent = true;

  if (has_action_bar) {
    send_update_secret_chats_with_user_action_bar(d);
  }
}

void MessagesManager::send_update_chat_draft_message(const Dialog *d) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  CHECK(d != nullptr);
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_draft_message";
  on_dialog_updated(d->dialog_id, "send_update_chat_draft_message");
  if (d->draft_message == nullptr || can_send_message(d->dialog_id).is_ok()) {
    send_closure(G()->td(), &Td::send_update,
                 make_tl_object<td_api::updateChatDraftMessage>(
                     d->dialog_id.get(), get_draft_message_object(d->draft_message), get_chat_positions_object(d)));
  }
}

void MessagesManager::send_update_chat_last_message(Dialog *d, const char *source) {
  update_dialog_pos(d, source, false);
  send_update_chat_last_message_impl(d, source);
}

void MessagesManager::send_update_chat_last_message_impl(const Dialog *d, const char *source) const {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_last_message from "
                                        << source;
  LOG(INFO) << "Send updateChatLastMessage in " << d->dialog_id << " to " << d->last_message_id << " from " << source;
  auto update = make_tl_object<td_api::updateChatLastMessage>(
      d->dialog_id.get(), get_message_object(d->dialog_id, get_message(d, d->last_message_id)),
      get_chat_positions_object(d));
  send_closure(G()->td(), &Td::send_update, std::move(update));
}

void MessagesManager::send_update_chat_filters() {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  is_update_chat_filters_sent_ = true;
  send_closure(G()->td(), &Td::send_update, get_update_chat_filters_object());
}

void MessagesManager::save_dialog_filters() {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  DialogFiltersLogEvent log_event;
  log_event.updated_date = dialog_filters_updated_date_;
  log_event.server_dialog_filters_in = &server_dialog_filters_;
  log_event.dialog_filters_in = &dialog_filters_;

  LOG(INFO) << "Save server chat filters " << get_dialog_filter_ids(server_dialog_filters_)
            << " and local chat filters " << get_dialog_filter_ids(dialog_filters_);

  G()->td_db()->get_binlog_pmc()->set("dialog_filters", log_event_store(log_event).as_slice().str());
}

void MessagesManager::send_update_unread_message_count(DialogList &list, DialogId dialog_id, bool force,
                                                       const char *source, bool from_database) {
  if (td_->auth_manager_->is_bot() || !G()->parameters().use_message_db) {
    return;
  }

  auto dialog_list_id = list.dialog_list_id;
  CHECK(list.is_message_unread_count_inited_);
  if (list.unread_message_muted_count_ < 0 || list.unread_message_muted_count_ > list.unread_message_total_count_) {
    LOG(ERROR) << "Unread message count became invalid in " << dialog_list_id << ": "
               << list.unread_message_total_count_ << '/'
               << list.unread_message_total_count_ - list.unread_message_muted_count_ << " from " << source << " and "
               << dialog_id;
    if (list.unread_message_muted_count_ < 0) {
      list.unread_message_muted_count_ = 0;
    }
    if (list.unread_message_muted_count_ > list.unread_message_total_count_) {
      list.unread_message_total_count_ = list.unread_message_muted_count_;
    }
  }

  if (!from_database) {
    G()->td_db()->get_binlog_pmc()->set(
        PSTRING() << "unread_message_count" << dialog_list_id.get(),
        PSTRING() << list.unread_message_total_count_ << ' ' << list.unread_message_muted_count_);
  }

  int32 unread_unmuted_count = list.unread_message_total_count_ - list.unread_message_muted_count_;
  if (!force && running_get_difference_) {
    LOG(INFO) << "Postpone updateUnreadMessageCount in " << dialog_list_id << " to " << list.unread_message_total_count_
              << '/' << unread_unmuted_count << " from " << source << " and " << dialog_id;
    postponed_unread_message_count_updates_.insert(dialog_list_id);
  } else {
    postponed_unread_message_count_updates_.erase(dialog_list_id);
    LOG(INFO) << "Send updateUnreadMessageCount in " << dialog_list_id << " to " << list.unread_message_total_count_
              << '/' << unread_unmuted_count << " from " << source << " and " << dialog_id;
    send_closure(G()->td(), &Td::send_update, get_update_unread_message_count_object(list));
  }
}

void MessagesManager::send_update_unread_chat_count(DialogList &list, DialogId dialog_id, bool force,
                                                    const char *source, bool from_database) {
  if (td_->auth_manager_->is_bot() || !G()->parameters().use_message_db) {
    return;
  }

  auto dialog_list_id = list.dialog_list_id;
  CHECK(list.is_dialog_unread_count_inited_);
  if (list.unread_dialog_muted_marked_count_ < 0 ||
      list.unread_dialog_marked_count_ < list.unread_dialog_muted_marked_count_ ||
      list.unread_dialog_muted_count_ < list.unread_dialog_muted_marked_count_ ||
      list.unread_dialog_total_count_ + list.unread_dialog_muted_marked_count_ <
          list.unread_dialog_muted_count_ + list.unread_dialog_marked_count_) {
    LOG(ERROR) << "Unread chat count became invalid in " << dialog_list_id << ": " << list.unread_dialog_total_count_
               << '/' << list.unread_dialog_total_count_ - list.unread_dialog_muted_count_ << '/'
               << list.unread_dialog_marked_count_ << '/'
               << list.unread_dialog_marked_count_ - list.unread_dialog_muted_marked_count_ << " from " << source
               << " and " << dialog_id;
    if (list.unread_dialog_muted_marked_count_ < 0) {
      list.unread_dialog_muted_marked_count_ = 0;
    }
    if (list.unread_dialog_marked_count_ < list.unread_dialog_muted_marked_count_) {
      list.unread_dialog_marked_count_ = list.unread_dialog_muted_marked_count_;
    }
    if (list.unread_dialog_muted_count_ < list.unread_dialog_muted_marked_count_) {
      list.unread_dialog_muted_count_ = list.unread_dialog_muted_marked_count_;
    }
    if (list.unread_dialog_total_count_ + list.unread_dialog_muted_marked_count_ <
        list.unread_dialog_muted_count_ + list.unread_dialog_marked_count_) {
      list.unread_dialog_total_count_ =
          list.unread_dialog_muted_count_ + list.unread_dialog_marked_count_ - list.unread_dialog_muted_marked_count_;
    }
  }

  if (!from_database) {
    save_unread_chat_count(list);
  }

  bool need_postpone = !force && running_get_difference_;
  int32 unread_unmuted_count = list.unread_dialog_total_count_ - list.unread_dialog_muted_count_;
  int32 unread_unmuted_marked_count = list.unread_dialog_marked_count_ - list.unread_dialog_muted_marked_count_;
  LOG(INFO) << (need_postpone ? "Postpone" : "Send") << " updateUnreadChatCount in " << dialog_list_id << " to "
            << list.in_memory_dialog_total_count_ << '/' << list.server_dialog_total_count_ << '+'
            << list.secret_chat_total_count_ << '/' << list.unread_dialog_total_count_ << '/' << unread_unmuted_count
            << '/' << list.unread_dialog_marked_count_ << '/' << unread_unmuted_marked_count << " from " << source
            << " and " << dialog_id;
  if (need_postpone) {
    postponed_unread_chat_count_updates_.insert(dialog_list_id);
  } else {
    postponed_unread_chat_count_updates_.erase(dialog_list_id);
    send_closure(G()->td(), &Td::send_update, get_update_unread_chat_count_object(list));
  }
}

void MessagesManager::save_unread_chat_count(const DialogList &list) {
  LOG(INFO) << "Save unread chat count in " << list.dialog_list_id;
  G()->td_db()->get_binlog_pmc()->set(
      PSTRING() << "unread_dialog_count" << list.dialog_list_id.get(),
      PSTRING() << list.unread_dialog_total_count_ << ' ' << list.unread_dialog_muted_count_ << ' '
                << list.unread_dialog_marked_count_ << ' ' << list.unread_dialog_muted_marked_count_ << ' '
                << list.server_dialog_total_count_ << ' ' << list.secret_chat_total_count_);
}

void MessagesManager::send_update_chat_read_inbox(const Dialog *d, bool force, const char *source) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_read_inbox from "
                                        << source;
  on_dialog_updated(d->dialog_id, source);
  if (!force && (running_get_difference_ || running_get_channel_difference(d->dialog_id) ||
                 get_channel_difference_to_log_event_id_.count(d->dialog_id) != 0)) {
    LOG(INFO) << "Postpone updateChatReadInbox in " << d->dialog_id << "(" << get_dialog_title(d->dialog_id) << ") to "
              << d->server_unread_count << " + " << d->local_unread_count << " from " << source;
    postponed_chat_read_inbox_updates_.insert(d->dialog_id);
  } else {
    postponed_chat_read_inbox_updates_.erase(d->dialog_id);
    LOG(INFO) << "Send updateChatReadInbox in " << d->dialog_id << "(" << get_dialog_title(d->dialog_id) << ") to "
              << d->server_unread_count << " + " << d->local_unread_count << " from " << source;
    send_closure(G()->td(), &Td::send_update,
                 make_tl_object<td_api::updateChatReadInbox>(d->dialog_id.get(), d->last_read_inbox_message_id.get(),
                                                             d->server_unread_count + d->local_unread_count));
  }
}

void MessagesManager::send_update_chat_read_outbox(const Dialog *d) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_read_outbox";
  on_dialog_updated(d->dialog_id, "send_update_chat_read_outbox");
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateChatReadOutbox>(d->dialog_id.get(), d->last_read_outbox_message_id.get()));
}

void MessagesManager::send_update_chat_unread_mention_count(const Dialog *d) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_unread_mention_count";
  LOG(INFO) << "Update unread mention message count in " << d->dialog_id << " to " << d->unread_mention_count;
  on_dialog_updated(d->dialog_id, "send_update_chat_unread_mention_count");
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateChatUnreadMentionCount>(d->dialog_id.get(), d->unread_mention_count));
}

void MessagesManager::send_update_chat_position(DialogListId dialog_list_id, const Dialog *d,
                                                const char *source) const {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_position";
  LOG(INFO) << "Send updateChatPosition for " << d->dialog_id << " in " << dialog_list_id << " from " << source;
  auto position = get_chat_position_object(dialog_list_id, d);
  if (position == nullptr) {
    position = td_api::make_object<td_api::chatPosition>(dialog_list_id.get_chat_list_object(), 0, false, nullptr);
  }
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateChatPosition>(d->dialog_id.get(), std::move(position)));
}

void MessagesManager::send_update_chat_online_member_count(DialogId dialog_id, int32 online_member_count) const {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateChatOnlineMemberCount>(dialog_id.get(), online_member_count));
}

void MessagesManager::send_update_secret_chats_with_user_action_bar(const Dialog *d) const {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  if (d->dialog_id.get_type() != DialogType::User) {
    return;
  }

  td_->contacts_manager_->for_each_secret_chat_with_user(
      d->dialog_id.get_user_id(), [this, user_d = d](SecretChatId secret_chat_id) {
        DialogId dialog_id(secret_chat_id);
        auto secret_chat_d = get_dialog(dialog_id);  // must not create the dialog
        if (secret_chat_d != nullptr && secret_chat_d->is_update_new_chat_sent) {
          send_closure(
              G()->td(), &Td::send_update,
              td_api::make_object<td_api::updateChatActionBar>(dialog_id.get(), get_chat_action_bar_object(user_d)));
        }
      });
}

void MessagesManager::send_update_chat_action_bar(const Dialog *d) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_action_bar";
  on_dialog_updated(d->dialog_id, "send_update_chat_action_bar");
  send_closure(G()->td(), &Td::send_update,
               td_api::make_object<td_api::updateChatActionBar>(d->dialog_id.get(), get_chat_action_bar_object(d)));

  send_update_secret_chats_with_user_action_bar(d);
}

void MessagesManager::send_update_chat_voice_chat(const Dialog *d) {
  CHECK(d != nullptr);
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_voice_chat";
  on_dialog_updated(d->dialog_id, "send_update_chat_voice_chat");
  auto group_call_id = td_->group_call_manager_->get_group_call_id(d->active_group_call_id, d->dialog_id);
  send_closure(G()->td(), &Td::send_update,
               td_api::make_object<td_api::updateChatVoiceChat>(d->dialog_id.get(), group_call_id.get(),
                                                                d->is_group_call_empty));
}

void MessagesManager::send_update_chat_message_ttl_setting(const Dialog *d) {
  CHECK(d != nullptr);
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_message_ttl_setting";
  on_dialog_updated(d->dialog_id, "send_update_chat_message_ttl_setting");
  send_closure(G()->td(), &Td::send_update,
               td_api::make_object<td_api::updateChatMessageTtlSetting>(
                   d->dialog_id.get(), d->message_ttl_setting.get_message_ttl_setting_object()));
}

void MessagesManager::send_update_chat_has_scheduled_messages(Dialog *d, bool from_deletion) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  if (d->scheduled_messages == nullptr) {
    if (d->has_scheduled_database_messages) {
      if (d->has_loaded_scheduled_messages_from_database) {
        set_dialog_has_scheduled_database_messages_impl(d, false);
      } else {
        CHECK(G()->parameters().use_message_db);
        repair_dialog_scheduled_messages(d);
      }
    }
    if (d->has_scheduled_server_messages) {
      if (from_deletion && d->scheduled_messages_sync_generation > 0) {
        set_dialog_has_scheduled_server_messages(d, false);
      } else {
        d->last_repair_scheduled_messages_generation = 0;
        repair_dialog_scheduled_messages(d);
      }
    }
  }

  LOG(INFO) << "In " << d->dialog_id << " have scheduled messages on server = " << d->has_scheduled_server_messages
            << ", in database = " << d->has_scheduled_database_messages
            << " and in memory = " << (d->scheduled_messages != nullptr)
            << "; was loaded from database = " << d->has_loaded_scheduled_messages_from_database;
  bool has_scheduled_messages = get_dialog_has_scheduled_messages(d);
  if (has_scheduled_messages == d->last_sent_has_scheduled_messages) {
    return;
  }
  d->last_sent_has_scheduled_messages = has_scheduled_messages;

  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in send_update_chat_has_scheduled_messages";
  send_closure(G()->td(), &Td::send_update,
               td_api::make_object<td_api::updateChatHasScheduledMessages>(d->dialog_id.get(), has_scheduled_messages));
}

void MessagesManager::send_update_user_chat_action(DialogId dialog_id, MessageId top_thread_message_id, UserId user_id,
                                                   DialogAction action) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  LOG(DEBUG) << "Send " << action << " of " << user_id << " in thread of " << top_thread_message_id << " in "
             << dialog_id;
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateUserChatAction>(
                   dialog_id.get(), top_thread_message_id.get(),
                   td_->contacts_manager_->get_user_id_object(user_id, "send_update_user_chat_action"),
                   action.get_chat_action_object()));
}

void MessagesManager::on_send_message_get_quick_ack(int64 random_id) {
  auto it = being_sent_messages_.find(random_id);
  if (it == being_sent_messages_.end()) {
    LOG(ERROR) << "Receive quick ack about unknown message with random_id = " << random_id;
    return;
  }

  auto dialog_id = it->second.get_dialog_id();
  auto message_id = it->second.get_message_id();

  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateMessageSendAcknowledged>(dialog_id.get(), message_id.get()));
}

void MessagesManager::check_send_message_result(int64 random_id, DialogId dialog_id,
                                                const telegram_api::Updates *updates_ptr, const char *source) {
  CHECK(updates_ptr != nullptr);
  CHECK(source != nullptr);
  auto sent_messages = UpdatesManager::get_new_messages(updates_ptr);
  auto sent_messages_random_ids = UpdatesManager::get_sent_messages_random_ids(updates_ptr);
  if (sent_messages.size() != 1u || sent_messages_random_ids.size() != 1u ||
      *sent_messages_random_ids.begin() != random_id || get_message_dialog_id(*sent_messages[0]) != dialog_id) {
    LOG(ERROR) << "Receive wrong result for sending message with random_id " << random_id << " from " << source
               << " to " << dialog_id << ": " << oneline(to_string(*updates_ptr));
    Dialog *d = get_dialog(dialog_id);
    CHECK(d != nullptr);
    if (dialog_id.get_type() == DialogType::Channel) {
      get_channel_difference(dialog_id, d->pts, true, "check_send_message_result");
    } else {
      td_->updates_manager_->schedule_get_difference("check_send_message_result");
    }
    repair_dialog_scheduled_messages(d);
  }
}

FullMessageId MessagesManager::on_send_message_success(int64 random_id, MessageId new_message_id, int32 date,
                                                       int32 ttl_period, FileId new_file_id, const char *source) {
  CHECK(source != nullptr);
  // do not try to run getDifference from this function
  if (DROP_SEND_MESSAGE_UPDATES) {
    return {};
  }
  if (!new_message_id.is_valid()) {
    LOG(ERROR) << "Receive " << new_message_id << " as sent message from " << source;
    on_send_message_fail(
        random_id,
        Status::Error(500, "Internal Server Error: receive invalid message identifier as sent message identifier"));
    return {};
  }
  if (new_message_id.is_yet_unsent()) {
    LOG(ERROR) << "Receive " << new_message_id << " as sent message from " << source;
    on_send_message_fail(random_id,
                         Status::Error(500, "Internal Server Error: receive yet unsent message as sent message"));
    return {};
  }

  auto it = being_sent_messages_.find(random_id);
  if (it == being_sent_messages_.end()) {
    LOG(ERROR) << "Result from sendMessage for " << new_message_id << " with random_id " << random_id << " sent at "
               << date << " comes from " << source << " after updateNewMessageId, but was not discarded by pts";
    return {};
  }

  auto dialog_id = it->second.get_dialog_id();
  auto old_message_id = it->second.get_message_id();

  if (new_message_id.is_local() && dialog_id.get_type() != DialogType::SecretChat) {
    LOG(ERROR) << "Receive " << new_message_id << " as sent message from " << source;
    on_send_message_fail(random_id, Status::Error(500, "Internal Server Error: receive local as sent message"));
    return {};
  }

  being_sent_messages_.erase(it);

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  bool need_update_dialog_pos = false;
  being_readded_message_id_ = {dialog_id, old_message_id};
  unique_ptr<Message> sent_message = delete_message(d, old_message_id, false, &need_update_dialog_pos, source);
  if (sent_message == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel
    // don't need to send update to the user, because the message has already been deleted
    LOG(INFO) << "Delete already deleted sent " << new_message_id << " from server";
    delete_message_from_server(dialog_id, new_message_id, true);
    being_readded_message_id_ = FullMessageId();
    return {};
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    // LOG(ERROR) << "Found " << old_message_id << " in inaccessible " << dialog_id;
    // dump_debug_message_op(d, 5);
  }

  // imitation of update_message(d, sent_message.get(), std::move(new_message), &need_update_dialog_pos);
  if (date <= 0) {
    LOG(ERROR) << "Receive " << new_message_id << " in " << dialog_id << " with wrong date " << date << " from "
               << source;
  } else {
    LOG_CHECK(sent_message->date > 0) << old_message_id << ' ' << sent_message->message_id << ' ' << new_message_id
                                      << ' ' << sent_message->date << ' ' << date << ' ' << source;
    sent_message->date = date;
    CHECK(d->last_message_id != old_message_id);
  }

  sent_message->ttl_period = ttl_period;

  // reply_to message may be already deleted
  // but can't use get_message_force for check, because the message can be already unloaded from the memory
  // if (get_message_force(d, sent_message->reply_to_message_id, "on_send_message_success 2") == nullptr) {
  //   sent_message->reply_to_message_id = MessageId();
  // }

  if (merge_message_content_file_id(td_, sent_message->content.get(), new_file_id)) {
    send_update_message_content(dialog_id, old_message_id, sent_message->content.get(), sent_message->date,
                                sent_message->is_content_secret, source);
  }

  set_message_id(sent_message, new_message_id);

  sent_message->from_database = false;
  sent_message->have_previous = true;
  sent_message->have_next = true;

  bool need_update = true;
  Message *m = add_message_to_dialog(d, std::move(sent_message), true, &need_update, &need_update_dialog_pos, source);
  LOG_CHECK(m != nullptr) << td_->contacts_manager_->get_my_id() << " " << dialog_id << " " << old_message_id << " "
                          << new_message_id << " " << d->last_clear_history_message_id << " "
                          << d->max_unavailable_message_id << " " << d->last_message_id << " " << d->last_new_message_id
                          << " " << d->last_assigned_message_id << " " << have_input_peer(dialog_id, AccessRights::Read)
                          << " " << debug_add_message_to_dialog_fail_reason_ << " " << source;

  send_update_message_send_succeeded(d, old_message_id, m);
  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "on_send_message_success");
  }
  try_add_active_live_location(dialog_id, m);
  update_reply_count_by_message(d, +1, m);
  update_forward_count(dialog_id, m);
  being_readded_message_id_ = FullMessageId();
  return {dialog_id, new_message_id};
}

void MessagesManager::on_send_message_file_part_missing(int64 random_id, int bad_part) {
  auto it = being_sent_messages_.find(random_id);
  if (it == being_sent_messages_.end()) {
    // we can't receive fail more than once
    // but message can be successfully sent before
    LOG(WARNING) << "Receive FILE_PART_" << bad_part
                 << "_MISSING about successfully sent message with random_id = " << random_id;
    return;
  }

  auto full_message_id = it->second;

  being_sent_messages_.erase(it);

  Message *m = get_message(full_message_id);
  if (m == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel
    // don't need to send error to the user, because the message has already been deleted
    // and there is nothing to be deleted from the server
    LOG(INFO) << "Fail to send already deleted by the user or sent to inaccessible chat " << full_message_id;
    return;
  }

  auto dialog_id = full_message_id.get_dialog_id();
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    // LOG(ERROR) << "Found " << m->message_id << " in inaccessible " << dialog_id;
    // dump_debug_message_op(get_dialog(dialog_id), 5);
  }

  if (dialog_id.get_type() == DialogType::SecretChat) {
    CHECK(!m->message_id.is_scheduled());
    Dialog *d = get_dialog(dialog_id);
    CHECK(d != nullptr);

    // need to change message random_id before resending
    do {
      m->random_id = Random::secure_int64();
    } while (m->random_id == 0 || message_random_ids_.find(m->random_id) != message_random_ids_.end());
    message_random_ids_.insert(m->random_id);

    delete_random_id_to_message_id_correspondence(d, random_id, m->message_id);
    add_random_id_to_message_id_correspondence(d, m->random_id, m->message_id);

    auto log_event = SendMessageLogEvent(dialog_id, m);
    CHECK(m->send_message_log_event_id != 0);
    binlog_rewrite(G()->td_db()->get_binlog(), m->send_message_log_event_id, LogEvent::HandlerType::SendMessage,
                   get_log_event_storer(log_event));
  }

  do_send_message(dialog_id, m, {bad_part});
}

void MessagesManager::on_send_message_file_reference_error(int64 random_id) {
  auto it = being_sent_messages_.find(random_id);
  if (it == being_sent_messages_.end()) {
    // we can't receive fail more than once
    // but message can be successfully sent before
    LOG(WARNING) << "Receive file reference invalid error about successfully sent message with random_id = "
                 << random_id;
    return;
  }

  auto full_message_id = it->second;

  being_sent_messages_.erase(it);

  Message *m = get_message(full_message_id);
  if (m == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel
    // don't need to send error to the user, because the message has already been deleted
    // and there is nothing to be deleted from the server
    LOG(INFO) << "Fail to send already deleted by the user or sent to inaccessible chat " << full_message_id;
    return;
  }

  auto dialog_id = full_message_id.get_dialog_id();
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    // LOG(ERROR) << "Found " << m->message_id << " in inaccessible " << dialog_id;
    // dump_debug_message_op(get_dialog(dialog_id), 5);
  }

  if (dialog_id.get_type() == DialogType::SecretChat) {
    CHECK(!m->message_id.is_scheduled());
    Dialog *d = get_dialog(dialog_id);
    CHECK(d != nullptr);

    // need to change message random_id before resending
    do {
      m->random_id = Random::secure_int64();
    } while (m->random_id == 0 || message_random_ids_.find(m->random_id) != message_random_ids_.end());
    message_random_ids_.insert(m->random_id);

    delete_random_id_to_message_id_correspondence(d, random_id, m->message_id);
    add_random_id_to_message_id_correspondence(d, m->random_id, m->message_id);

    auto log_event = SendMessageLogEvent(dialog_id, m);
    CHECK(m->send_message_log_event_id != 0);
    binlog_rewrite(G()->td_db()->get_binlog(), m->send_message_log_event_id, LogEvent::HandlerType::SendMessage,
                   get_log_event_storer(log_event));
  }

  do_send_message(dialog_id, m, {-1});
}

void MessagesManager::on_send_media_group_file_reference_error(DialogId dialog_id, vector<int64> random_ids) {
  int64 media_album_id = 0;
  vector<MessageId> message_ids;
  vector<Message *> messages;
  for (auto &random_id : random_ids) {
    auto it = being_sent_messages_.find(random_id);
    if (it == being_sent_messages_.end()) {
      // we can't receive fail more than once
      // but message can be successfully sent before
      LOG(ERROR) << "Receive file reference invalid error about successfully sent message with random_id = "
                 << random_id;
      continue;
    }

    auto full_message_id = it->second;

    being_sent_messages_.erase(it);

    Message *m = get_message(full_message_id);
    if (m == nullptr) {
      // message has already been deleted by the user or sent to inaccessible channel
      // don't need to send error to the user, because the message has already been deleted
      // and there is nothing to be deleted from the server
      LOG(INFO) << "Fail to send already deleted by the user or sent to inaccessible chat " << full_message_id;
      continue;
    }

    CHECK(m->media_album_id != 0);
    CHECK(media_album_id == 0 || media_album_id == m->media_album_id);
    media_album_id = m->media_album_id;

    CHECK(dialog_id == full_message_id.get_dialog_id());
    message_ids.push_back(m->message_id);
    messages.push_back(m);
  }

  CHECK(dialog_id.get_type() != DialogType::SecretChat);

  if (message_ids.empty()) {
    // all messages was deleted, nothing to do
    return;
  }

  auto &request = pending_message_group_sends_[media_album_id];
  CHECK(!request.dialog_id.is_valid());
  CHECK(request.finished_count == 0);
  CHECK(request.results.empty());
  request.dialog_id = dialog_id;
  request.message_ids = std::move(message_ids);
  request.is_finished.resize(request.message_ids.size(), false);
  for (size_t i = 0; i < request.message_ids.size(); i++) {
    request.results.push_back(Status::OK());
  }

  for (auto m : messages) {
    do_send_message(dialog_id, m, {-1});
  }
}

void MessagesManager::on_send_message_fail(int64 random_id, Status error) {
  CHECK(error.is_error());

  auto it = being_sent_messages_.find(random_id);
  if (it == being_sent_messages_.end()) {
    // we can't receive fail more than once
    // but message can be successfully sent before
    if (error.code() != NetQuery::Cancelled) {
      LOG(ERROR) << "Receive error " << error << " about successfully sent message with random_id = " << random_id;
    }
    return;
  }

  auto full_message_id = it->second;

  being_sent_messages_.erase(it);

  Message *m = get_message(full_message_id);
  if (m == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel
    // don't need to send error to the user, because the message has already been deleted
    // and there is nothing to be deleted from the server
    LOG(INFO) << "Fail to send already deleted by the user or sent to inaccessible chat " << full_message_id;
    return;
  }
  LOG_IF(ERROR, error.code() == NetQuery::Cancelled)
      << "Receive error " << error << " about sent message with random_id = " << random_id;

  auto dialog_id = full_message_id.get_dialog_id();
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    // LOG(ERROR) << "Found " << m->message_id << " in inaccessible " << dialog_id;
    // dump_debug_message_op(get_dialog(dialog_id), 5);
  }

  int error_code = error.code();
  string error_message = error.message().str();
  switch (error_code) {
    case 420:
      error_code = 429;
      LOG(ERROR) << "Receive error 420: " << error_message;
      break;
    case 429:
      // nothing special, error description has already been changed
      LOG_IF(ERROR, !begins_with(error_message, "Too Many Requests: retry after "))
          << "Wrong error message: " << error_message;
      break;
    case 400:
      if (error.message() == "MESSAGE_TOO_LONG") {
        error_message = "Message is too long";
        // TODO move check to send_message
      } else if (error.message() == "INPUT_USER_DEACTIVATED") {
        error_code = 403;
        error_message = "User is deactivated";
      } else if (error.message() == "USER_IS_BLOCKED") {
        error_code = 403;
        if (td_->auth_manager_->is_bot()) {
          switch (dialog_id.get_type()) {
            case DialogType::User:
              error_message = "Bot was blocked by the user";
              break;
            case DialogType::Chat:
            case DialogType::Channel:
              error_message = "Bot was kicked from the chat";
              break;
            case DialogType::SecretChat:
              break;
            case DialogType::None:
            default:
              UNREACHABLE();
          }
        } else {
          switch (dialog_id.get_type()) {
            case DialogType::User:
              error_message = "User was blocked by the other user";
              break;
            case DialogType::Chat:
            case DialogType::Channel:
              error_message = "User is not in the chat";
              break;
            case DialogType::SecretChat:
              break;
            case DialogType::None:
            default:
              UNREACHABLE();
          }
        }
        // TODO add check to send_message
      } else if (error.message() == "USER_IS_BOT") {
        if (td_->auth_manager_->is_bot() && dialog_id.get_type() == DialogType::User) {
          error_code = 403;
          if (td_->contacts_manager_->is_user_bot(dialog_id.get_user_id())) {
            error_message = "Bot can't send messages to bots";
          } else {
            error_message = "Bot can't send messages to the user";
          }
          // TODO move check to send_message
        }
      } else if (error.message() == "PEER_ID_INVALID") {
        error_code = 403;
        if (td_->auth_manager_->is_bot()) {
          error_message = "Bot can't initiate conversation with a user";
        }
      } else if (error.message() == "WC_CONVERT_URL_INVALID" || error.message() == "EXTERNAL_URL_INVALID") {
        error_message = "Wrong HTTP URL specified";
      } else if (error.message() == "WEBPAGE_CURL_FAILED") {
        error_message = "Failed to get HTTP URL content";
      } else if (error.message() == "WEBPAGE_MEDIA_EMPTY") {
        error_message = "Wrong type of the web page content";
      } else if (error.message() == "MEDIA_EMPTY") {
        auto content_type = m->content->get_type();
        if (content_type == MessageContentType::Game) {
          error_message = "Wrong game short name specified";
        } else if (content_type == MessageContentType::Invoice) {
          error_message = "Wrong invoice information specified";
        } else if (content_type == MessageContentType::Poll) {
          error_message = "Wrong poll data specified";
        } else if (content_type == MessageContentType::Contact) {
          error_message = "Wrong phone number specified";
        } else {
          error_message = "Wrong file identifier/HTTP URL specified";
        }
      } else if (error.message() == "PHOTO_EXT_INVALID") {
        error_message = "Photo has unsupported extension. Use one of .jpg, .jpeg, .gif, .png, .tif or .bmp";
      }
      break;
    case 403:
      if (error.message() == "MESSAGE_DELETE_FORBIDDEN") {
        error_code = 400;
        error_message = "Message can't be deleted";
      } else if (error.message() != "CHANNEL_PUBLIC_GROUP_NA" && error.message() != "USER_IS_BLOCKED" &&
                 error.message() != "USER_BOT_INVALID" && error.message() != "USER_DELETED") {
        error_code = 400;
      }
      break;
    // TODO other codes
    default:
      break;
  }
  if (error.message() == "REPLY_MARKUP_INVALID") {
    if (m->reply_markup == nullptr) {
      LOG(ERROR) << "Receive " << error.message() << " for " << oneline(to_string(get_message_object(dialog_id, m)));
    } else {
      LOG(ERROR) << "Receive " << error.message() << " for " << full_message_id << " with keyboard "
                 << *m->reply_markup;
    }
  }
  LOG_IF(WARNING, error_code != 403) << "Fail to send " << full_message_id << " with the error " << error;
  if (error_code <= 0) {
    error_code = 500;
  }
  fail_send_message(full_message_id, error_code, error_message);
}

MessageId MessagesManager::get_next_message_id(Dialog *d, MessageType type) {
  CHECK(d != nullptr);
  MessageId last_message_id =
      std::max({d->last_message_id, d->last_new_message_id, d->last_database_message_id, d->last_assigned_message_id,
                d->last_clear_history_message_id, d->deleted_last_message_id, d->max_unavailable_message_id,
                d->max_added_message_id});
  if (last_message_id < d->last_read_inbox_message_id &&
      d->last_read_inbox_message_id < d->last_new_message_id.get_next_server_message_id()) {
    last_message_id = d->last_read_inbox_message_id;
  }
  if (last_message_id < d->last_read_outbox_message_id &&
      d->last_read_outbox_message_id < d->last_new_message_id.get_next_server_message_id()) {
    last_message_id = d->last_read_outbox_message_id;
  }

  d->last_assigned_message_id = last_message_id.get_next_message_id(type);
  if (d->last_assigned_message_id > MessageId::max()) {
    LOG(FATAL) << "Force restart because of message_id overflow: " << d->last_assigned_message_id;
  }
  CHECK(d->last_assigned_message_id.is_valid());
  return d->last_assigned_message_id;
}

MessageId MessagesManager::get_next_yet_unsent_message_id(Dialog *d) {
  return get_next_message_id(d, MessageType::YetUnsent);
}

MessageId MessagesManager::get_next_local_message_id(Dialog *d) {
  return get_next_message_id(d, MessageType::Local);
}

MessageId MessagesManager::get_next_yet_unsent_scheduled_message_id(Dialog *d, int32 date) {
  CHECK(date > 0);

  MessageId message_id(ScheduledServerMessageId(1), date);

  auto it = MessagesConstIterator(d, MessageId(ScheduledServerMessageId(), date + 1, true));
  if (*it != nullptr && (*it)->message_id > message_id) {
    message_id = (*it)->message_id;
  }

  auto &last_assigned_message_id = d->last_assigned_scheduled_message_id[date];
  if (last_assigned_message_id != MessageId() && last_assigned_message_id > message_id) {
    message_id = last_assigned_message_id;
  }

  last_assigned_message_id = message_id.get_next_message_id(MessageType::YetUnsent);
  return last_assigned_message_id;
}

void MessagesManager::fail_send_message(FullMessageId full_message_id, int error_code, const string &error_message) {
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  MessageId old_message_id = full_message_id.get_message_id();
  CHECK(old_message_id.is_valid() || old_message_id.is_valid_scheduled());
  CHECK(old_message_id.is_yet_unsent());

  bool need_update_dialog_pos = false;
  being_readded_message_id_ = full_message_id;
  unique_ptr<Message> message = delete_message(d, old_message_id, false, &need_update_dialog_pos, "fail send message");
  if (message == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel
    // don't need to send update to the user, because the message has already been deleted
    // and there is nothing to be deleted from the server
    being_readded_message_id_ = FullMessageId();
    return;
  }

  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    // LOG(ERROR) << "Found " << old_message_id << " in inaccessible " << dialog_id;
    // dump_debug_message_op(d, 5);
  }

  MessageId new_message_id =
      old_message_id.get_next_message_id(MessageType::Local);  // trying to not change message place
  if (!old_message_id.is_scheduled()) {
    if (get_message_force(d, new_message_id, "fail_send_message") != nullptr ||
        d->deleted_message_ids.count(new_message_id) || new_message_id <= d->last_clear_history_message_id) {
      new_message_id = get_next_local_message_id(d);
    } else if (new_message_id > d->last_assigned_message_id) {
      d->last_assigned_message_id = new_message_id;
    }
  } else {
    // check deleted_message_ids, because the new_message_id is not a server scheduled
    while (get_message_force(d, new_message_id, "fail_send_message") != nullptr ||
           d->deleted_message_ids.count(new_message_id)) {
      new_message_id = new_message_id.get_next_message_id(MessageType::Local);
    }
  }

  set_message_id(message, new_message_id);
  if (old_message_id.is_scheduled()) {
    CHECK(message->message_id.is_valid_scheduled());
  } else {
    CHECK(message->message_id.is_valid());
  }
  if (message->forward_info == nullptr && message->view_count == 1) {
    message->view_count = 0;
  }
  message->is_failed_to_send = true;
  message->send_error_code = error_code;
  message->send_error_message = error_message;
  message->try_resend_at = 0.0;
  Slice retry_after_prefix("Too Many Requests: retry after ");
  if (error_code == 429 && begins_with(error_message, retry_after_prefix)) {
    auto r_retry_after = to_integer_safe<int32>(error_message.substr(retry_after_prefix.size()));
    if (r_retry_after.is_ok() && r_retry_after.ok() > 0) {
      message->try_resend_at = Time::now() + r_retry_after.ok();
    }
  }
  update_failed_to_send_message_content(td_, message->content);

  message->from_database = false;
  message->have_previous = true;
  message->have_next = true;

  bool need_update = false;
  Message *m = add_message_to_dialog(dialog_id, std::move(message), false, &need_update, &need_update_dialog_pos,
                                     "fail_send_message");
  LOG_CHECK(m != nullptr) << "Failed to add failed to send " << new_message_id << " to " << dialog_id << " due to "
                          << debug_add_message_to_dialog_fail_reason_;
  if (!m->message_id.is_scheduled()) {
    // add_message_to_dialog will not update counts, because need_update == false
    update_message_count_by_index(d, +1, m);
    update_reply_count_by_message(d, +1, m);  // no-op because the message isn't server
  }
  register_new_local_message_id(d, m);

  LOG(INFO) << "Send updateMessageSendFailed for " << full_message_id;
  if (!td_->auth_manager_->is_bot()) {
    d->yet_unsent_message_id_to_persistent_message_id.emplace(old_message_id, m->message_id);
  }
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateMessageSendFailed>(get_message_object(dialog_id, m), old_message_id.get(),
                                                               error_code, error_message));
  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "fail_send_message");
  }
  being_readded_message_id_ = FullMessageId();
}

void MessagesManager::fail_send_message(FullMessageId full_message_id, Status error) {
  fail_send_message(full_message_id, error.code() > 0 ? error.code() : 500,
                    error.message().str());  // TODO CHECK that status has always a code
}

void MessagesManager::fail_edit_message_media(FullMessageId full_message_id, Status &&error) {
  auto dialog_id = full_message_id.get_dialog_id();
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  MessageId message_id = full_message_id.get_message_id();
  CHECK(message_id.is_any_server());

  auto m = get_message(d, message_id);
  if (m == nullptr) {
    // message has already been deleted by the user or sent to inaccessible channel
    return;
  }
  CHECK(m->edited_content != nullptr);
  m->edit_promise.set_error(std::move(error));
  cancel_edit_message_media(dialog_id, m, "Failed to edit message. MUST BE IGNORED");
}

void MessagesManager::on_update_dialog_draft_message(DialogId dialog_id,
                                                     tl_object_ptr<telegram_api::DraftMessage> &&draft_message) {
  if (!dialog_id.is_valid()) {
    LOG(ERROR) << "Receive update chat draft in invalid " << dialog_id;
    return;
  }
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(INFO) << "Ignore update chat draft in unknown " << dialog_id;
    if (!have_input_peer(dialog_id, AccessRights::Read)) {
      LOG(ERROR) << "Have no read access to " << dialog_id << " to repair chat draft message";
    } else {
      send_get_dialog_query(dialog_id, Promise<Unit>(), 0, "on_update_dialog_draft_message");
    }
    return;
  }
  update_dialog_draft_message(d, get_draft_message(td_->contacts_manager_.get(), std::move(draft_message)), true, true);
}

bool MessagesManager::update_dialog_draft_message(Dialog *d, unique_ptr<DraftMessage> &&draft_message, bool from_update,
                                                  bool need_update_dialog_pos) {
  CHECK(d != nullptr);
  if (from_update && d->is_opened && d->draft_message != nullptr) {
    // send the update anyway, despite it shouldn't be applied client-side
    // return false;
  }
  if (draft_message == nullptr) {
    if (d->draft_message != nullptr) {
      d->draft_message = nullptr;
      if (need_update_dialog_pos) {
        update_dialog_pos(d, "update_dialog_draft_message", false);
      }
      send_update_chat_draft_message(d);
      return true;
    }
  } else {
    if (d->draft_message != nullptr && d->draft_message->reply_to_message_id == draft_message->reply_to_message_id &&
        d->draft_message->input_message_text == draft_message->input_message_text) {
      if (d->draft_message->date < draft_message->date) {
        d->draft_message->date = draft_message->date;
        if (need_update_dialog_pos) {
          update_dialog_pos(d, "update_dialog_draft_message 2", false);
        }
        send_update_chat_draft_message(d);
        return true;
      }
    } else {
      if (!from_update || d->draft_message == nullptr || d->draft_message->date <= draft_message->date) {
        d->draft_message = std::move(draft_message);
        if (need_update_dialog_pos) {
          update_dialog_pos(d, "update_dialog_draft_message 3", false);
        }
        send_update_chat_draft_message(d);
        return true;
      }
    }
  }
  return false;
}

void MessagesManager::on_update_dialog_is_pinned(FolderId folder_id, DialogId dialog_id, bool is_pinned) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  if (!dialog_id.is_valid()) {
    LOG(ERROR) << "Receive pin of invalid " << dialog_id;
    return;
  }

  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(INFO) << "Can't apply updateDialogPinned in " << folder_id << " with unknown " << dialog_id;
    on_update_pinned_dialogs(folder_id);
    return;
  }
  if (d->order == DEFAULT_ORDER) {
    // the chat can't be pinned or is already unpinned
    // don't change it's folder_id
    LOG(INFO) << "Can't apply updateDialogPinned in " << folder_id << " with " << dialog_id;
    return;
  }

  auto *list = get_dialog_list(DialogListId(folder_id));
  CHECK(list != nullptr);
  if (!list->are_pinned_dialogs_inited_) {
    return;
  }

  set_dialog_folder_id(d, folder_id);
  set_dialog_is_pinned(DialogListId(folder_id), d, is_pinned);
}

void MessagesManager::on_update_pinned_dialogs(FolderId folder_id) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  // TODO log event + delete_log_event_promise

  auto *list = get_dialog_list(DialogListId(folder_id));
  if (list == nullptr || !list->are_pinned_dialogs_inited_) {
    return;
  }
  // preload all pinned dialogs
  get_dialogs(DialogListId(folder_id), {SPONSORED_DIALOG_ORDER - 1, DialogId()},
              narrow_cast<int32>(list->pinned_dialogs_.size()), true, Auto());
  reload_pinned_dialogs(DialogListId(folder_id), Auto());
}

void MessagesManager::on_update_dialog_is_marked_as_unread(DialogId dialog_id, bool is_marked_as_unread) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  if (!dialog_id.is_valid()) {
    LOG(ERROR) << "Receive marking as unread of invalid " << dialog_id;
    return;
  }

  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    // nothing to do
    return;
  }

  if (is_marked_as_unread == d->is_marked_as_unread) {
    return;
  }

  set_dialog_is_marked_as_unread(d, is_marked_as_unread);
}

void MessagesManager::set_dialog_is_marked_as_unread(Dialog *d, bool is_marked_as_unread) {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  CHECK(d != nullptr);
  CHECK(d->is_marked_as_unread != is_marked_as_unread);
  d->is_marked_as_unread = is_marked_as_unread;
  on_dialog_updated(d->dialog_id, "set_dialog_is_marked_as_unread");

  LOG(INFO) << "Set " << d->dialog_id << " is marked as unread to " << is_marked_as_unread;
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in set_dialog_is_marked_as_unread";
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateChatIsMarkedAsUnread>(d->dialog_id.get(), is_marked_as_unread));

  if (d->server_unread_count + d->local_unread_count == 0 && need_unread_counter(d->order)) {
    int32 delta = d->is_marked_as_unread ? 1 : -1;
    for (auto &list : get_dialog_lists(d)) {
      if (list.is_dialog_unread_count_inited_) {
        list.unread_dialog_total_count_ += delta;
        list.unread_dialog_marked_count_ += delta;
        if (is_dialog_muted(d)) {
          list.unread_dialog_muted_count_ += delta;
          list.unread_dialog_muted_marked_count_ += delta;
        }
        send_update_unread_chat_count(list, d->dialog_id, true, "set_dialog_is_marked_as_unread");
      }
    }

    if (!dialog_filters_.empty()) {
      update_dialog_lists(d, get_dialog_positions(d), true, false, "set_dialog_is_marked_as_unread");
    }
  }
}

void MessagesManager::on_update_dialog_is_blocked(DialogId dialog_id, bool is_blocked) {
  if (!dialog_id.is_valid()) {
    LOG(ERROR) << "Receive pinned message in invalid " << dialog_id;
    return;
  }
  if (dialog_id.get_type() == DialogType::User) {
    td_->contacts_manager_->on_update_user_is_blocked(dialog_id.get_user_id(), is_blocked);
  }

  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    // nothing to do
    return;
  }

  if (d->is_blocked == is_blocked) {
    if (!d->is_is_blocked_inited) {
      CHECK(is_blocked == false);
      d->is_is_blocked_inited = true;
      on_dialog_updated(dialog_id, "on_update_dialog_is_blocked");
    }
    return;
  }

  set_dialog_is_blocked(d, is_blocked);
}

void MessagesManager::set_dialog_is_blocked(Dialog *d, bool is_blocked) {
  CHECK(d != nullptr);
  CHECK(d->is_blocked != is_blocked);
  d->is_blocked = is_blocked;
  d->is_is_blocked_inited = true;
  on_dialog_updated(d->dialog_id, "set_dialog_is_blocked");

  LOG(INFO) << "Set " << d->dialog_id << " is_blocked to " << is_blocked;
  LOG_CHECK(d->is_update_new_chat_sent) << "Wrong " << d->dialog_id << " in set_dialog_is_blocked";
  send_closure(G()->td(), &Td::send_update,
               make_tl_object<td_api::updateChatIsBlocked>(d->dialog_id.get(), is_blocked));

  if (d->dialog_id.get_type() == DialogType::User) {
    td_->contacts_manager_->on_update_user_is_blocked(d->dialog_id.get_user_id(), is_blocked);

    if (d->know_action_bar) {
      if (is_blocked) {
        if (d->can_report_spam || d->can_share_phone_number || d->can_block_user || d->can_add_contact ||
            d->can_unarchive || d->distance >= 0) {
          d->can_report_spam = false;
          d->can_share_phone_number = false;
          d->can_block_user = false;
          d->can_add_contact = false;
          d->can_unarchive = false;
          d->distance = -1;
          send_update_chat_action_bar(d);
        }
      } else {
        repair_dialog_action_bar(d, "on_dialog_user_is_blocked_updated");
      }
    }

    td_->contacts_manager_->for_each_secret_chat_with_user(
        d->dialog_id.get_user_id(), [this, is_blocked](SecretChatId secret_chat_id) {
          DialogId dialog_id(secret_chat_id);
          auto d = get_dialog(dialog_id);  // must not create the dialog
          if (d != nullptr && d->is_update_new_chat_sent && d->is_blocked != is_blocked) {
            set_dialog_is_blocked(d, is_blocked);
          }
        });
  }
}

void MessagesManager::on_update_dialog_last_pinned_message_id(DialogId dialog_id, MessageId pinned_message_id) {
  if (!dialog_id.is_valid()) {
    LOG(ERROR) << "Receive pinned message in invalid " << dialog_id;
    return;
  }
  if (!pinned_message_id.is_valid() && pinned_message_id != MessageId()) {
    LOG(ERROR) << "Receive as pinned message " << pinned_message_id;
    return;
  }

  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    // nothing to do
    return;
  }

  if (d->last_pinned_message_id == pinned_message_id) {
    LOG(INFO) << "Pinned message in " << d->dialog_id << " is still " << pinned_message_id;
    if (!d->is_last_pinned_message_id_inited) {
      d->is_last_pinned_message_id_inited = true;
      on_dialog_updated(dialog_id, "on_update_dialog_last_pinned_message_id");
    }
    Message *m = get_message_force(d, pinned_message_id, "on_update_dialog_last_pinned_message_id");
    if (m != nullptr && update_message_is_pinned(d, m, true, "on_update_dialog_last_pinned_message_id")) {
      on_message_changed(d, m, true, "on_update_dialog_last_pinned_message_id");
    }
    return;
  }

  set_dialog_last_pinned_message_id(d, pinned_message_id);
}

void MessagesManager::set_dialog_last_pinned_message_id(Dialog *d, MessageId pinned_message_id) {
  CHECK(d != nullptr);
  Message *m = get_message_force(d, pinned_message_id, "set_dialog_last_pinned_message_id");
  if (m != nullptr && update_message_is_pinned(d, m, true, "set_dialog_last_pinned_message_id")) {
    on_message_changed(d, m, true, "set_dialog_last_pinned_message_id");
  }

  if (d->last_pinned_message_id == pinned_message_id) {
    return;
  }
  d->last_pinned_message_id = pinned_message_id;
  d->is_last_pinned_message_id_inited = true;
  on_dialog_updated(d->dialog_id, "set_dialog_last_pinned_message_id");

  LOG(INFO) << "Set " << d->dialog_id << " pinned message to " << pinned_message_id;
}

void MessagesManager::drop_dialog_last_pinned_message_id(Dialog *d) {
  d->last_pinned_message_id = MessageId();
  d->is_last_pinned_message_id_inited = false;
  on_dialog_updated(d->dialog_id, "drop_dialog_last_pinned_message_id");

  LOG(INFO) << "Drop " << d->dialog_id << " pinned message";

  create_actor<SleepActor>(
      "ReloadDialogFullInfoActor", 1.0,
      PromiseCreator::lambda([actor_id = actor_id(this), dialog_id = d->dialog_id](Result<Unit> result) {
        send_closure(actor_id, &MessagesManager::reload_dialog_info_full, dialog_id);
      }))
      .release();
}

void MessagesManager::repair_dialog_scheduled_messages(Dialog *d) {
  if (td_->auth_manager_->is_bot() || d->dialog_id.get_type() == DialogType::SecretChat) {
    return;
  }

  if (d->last_repair_scheduled_messages_generation == scheduled_messages_sync_generation_) {
    return;
  }
  d->last_repair_scheduled_messages_generation = scheduled_messages_sync_generation_;

  // TODO create log event
  auto dialog_id = d->dialog_id;
  LOG(INFO) << "Repair scheduled messages in " << dialog_id << " with generation "
            << d->last_repair_scheduled_messages_generation;
  get_dialog_scheduled_messages(dialog_id, false, true,
                                PromiseCreator::lambda([actor_id = actor_id(this), dialog_id](Unit) {
                                  send_closure(G()->messages_manager(), &MessagesManager::get_dialog_scheduled_messages,
                                               dialog_id, true, true, Promise<Unit>());
                                }));
}

void MessagesManager::on_update_dialog_has_scheduled_server_messages(DialogId dialog_id,
                                                                     bool has_scheduled_server_messages) {
  if (!dialog_id.is_valid()) {
    LOG(ERROR) << "Receive has_scheduled_server_messages in invalid " << dialog_id;
    return;
  }
  if (td_->auth_manager_->is_bot() || dialog_id.get_type() == DialogType::SecretChat) {
    return;
  }

  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    // nothing to do
    return;
  }

  LOG(INFO) << "Receive has_scheduled_server_messages = " << has_scheduled_server_messages << " in " << dialog_id;
  if (d->has_scheduled_server_messages != has_scheduled_server_messages) {
    set_dialog_has_scheduled_server_messages(d, has_scheduled_server_messages);
  } else if (has_scheduled_server_messages !=
             (d->has_scheduled_database_messages || d->scheduled_messages != nullptr)) {
    repair_dialog_scheduled_messages(d);
  }
}

void MessagesManager::set_dialog_has_scheduled_server_messages(Dialog *d, bool has_scheduled_server_messages) {
  CHECK(d != nullptr);
  CHECK(d->has_scheduled_server_messages != has_scheduled_server_messages);
  d->has_scheduled_server_messages = has_scheduled_server_messages;
  repair_dialog_scheduled_messages(d);
  on_dialog_updated(d->dialog_id, "set_dialog_has_scheduled_server_messages");

  LOG(INFO) << "Set " << d->dialog_id << " has_scheduled_server_messages to " << has_scheduled_server_messages;

  send_update_chat_has_scheduled_messages(d, false);
}

void MessagesManager::set_dialog_has_scheduled_database_messages(DialogId dialog_id,
                                                                 bool has_scheduled_database_messages) {
  if (G()->close_flag()) {
    return;
  }
  return set_dialog_has_scheduled_database_messages_impl(get_dialog(dialog_id), has_scheduled_database_messages);
}

void MessagesManager::set_dialog_has_scheduled_database_messages_impl(Dialog *d, bool has_scheduled_database_messages) {
  CHECK(d != nullptr);
  if (d->has_scheduled_database_messages == has_scheduled_database_messages) {
    return;
  }

  if (d->has_scheduled_database_messages && d->scheduled_messages != nullptr &&
      !d->scheduled_messages->message_id.is_yet_unsent()) {
    // to prevent race between add_message_to_database and check of has_scheduled_database_messages
    return;
  }

  CHECK(G()->parameters().use_message_db);

  d->has_scheduled_database_messages = has_scheduled_database_messages;
  on_dialog_updated(d->dialog_id, "set_dialog_has_scheduled_database_messages");
}

void MessagesManager::on_update_dialog_folder_id(DialogId dialog_id, FolderId folder_id) {
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    // nothing to do
    return;
  }

  set_dialog_folder_id(d, folder_id);
}

void MessagesManager::set_dialog_folder_id(Dialog *d, FolderId folder_id) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);

  if (d->folder_id == folder_id) {
    if (!d->is_folder_id_inited) {
      LOG(INFO) << "Folder of " << d->dialog_id << " is still " << folder_id;
      do_set_dialog_folder_id(d, folder_id);
    }
    return;
  }

  LOG(INFO) << "Change " << d->dialog_id << " folder from " << d->folder_id << " to " << folder_id;

  auto dialog_positions = get_dialog_positions(d);

  if (get_dialog_pinned_order(DialogListId(d->folder_id), d->dialog_id) != DEFAULT_ORDER) {
    set_dialog_is_pinned(DialogListId(d->folder_id), d, false, false);
  }

  DialogDate dialog_date(d->order, d->dialog_id);
  auto *folder = get_dialog_folder(d->folder_id);
  if (folder->ordered_dialogs_.erase(dialog_date) == 0) {
    LOG_IF(ERROR, d->order != DEFAULT_ORDER) << d->dialog_id << " not found in the chat list";
  }

  do_set_dialog_folder_id(d, folder_id);

  get_dialog_folder(d->folder_id)->ordered_dialogs_.insert(dialog_date);

  update_dialog_lists(d, std::move(dialog_positions), true, false, "set_dialog_folder_id");
}

void MessagesManager::do_set_dialog_folder_id(Dialog *d, FolderId folder_id) {
  CHECK(!td_->auth_manager_->is_bot());
  if (d->folder_id == folder_id && d->is_folder_id_inited) {
    return;
  }

  d->folder_id = folder_id;
  d->is_folder_id_inited = true;

  if (d->dialog_id.get_type() == DialogType::User) {
    if (d->can_unarchive && folder_id != FolderId::archive()) {
      d->can_unarchive = false;
      d->can_report_spam = false;
      d->can_block_user = false;
      // keep d->can_add_contact
      send_update_chat_action_bar(d);
    }
  } else if (d->dialog_id.get_type() == DialogType::SecretChat) {
    // need to change action bar only for the secret chat and keep unarchive for the main chat
    auto user_id = td_->contacts_manager_->get_secret_chat_user_id(d->dialog_id.get_secret_chat_id());
    if (d->is_update_new_chat_sent && user_id.is_valid()) {
      const Dialog *user_d = get_dialog(DialogId(user_id));
      if (user_d != nullptr && user_d->can_unarchive && user_d->know_action_bar) {
        send_closure(
            G()->td(), &Td::send_update,
            td_api::make_object<td_api::updateChatActionBar>(d->dialog_id.get(), get_chat_action_bar_object(d)));
      }
    }
  }

  on_dialog_updated(d->dialog_id, "do_set_dialog_folder_id");
}

void MessagesManager::on_update_dialog_group_call(DialogId dialog_id, bool has_active_group_call,
                                                  bool is_group_call_empty, const char *source) {
  LOG(INFO) << "Update voice chat in " << dialog_id << " with has_active_voice_chat = " << has_active_group_call
            << " and is_voice_chat_empty = " << is_group_call_empty << " from " << source;

  CHECK(dialog_id.is_valid());
  Dialog *d = get_dialog(dialog_id);  // must not create the Dialog, because is called from on_get_chat
  if (d == nullptr) {
    LOG(INFO) << "Can't find " << dialog_id;
    pending_dialog_group_call_updates_[dialog_id] = {has_active_group_call, is_group_call_empty};
    return;
  }

  if (!has_active_group_call) {
    is_group_call_empty = false;
  }
  if (d->has_active_group_call == has_active_group_call && d->is_group_call_empty == is_group_call_empty) {
    return;
  }

  if (d->has_active_group_call && !has_active_group_call && d->active_group_call_id.is_valid()) {
    d->active_group_call_id = InputGroupCallId();
    d->has_active_group_call = false;
    d->is_group_call_empty = false;
    send_update_chat_voice_chat(d);
  } else if (d->has_active_group_call && has_active_group_call) {
    d->is_group_call_empty = is_group_call_empty;
    send_update_chat_voice_chat(d);
  } else {
    d->has_active_group_call = has_active_group_call;
    d->is_group_call_empty = is_group_call_empty;
    on_dialog_updated(dialog_id, "on_update_dialog_group_call");

    if (has_active_group_call && !d->active_group_call_id.is_valid()) {
      repair_dialog_active_group_call_id(dialog_id);
    }
  }
}

void MessagesManager::on_update_dialog_group_call_id(DialogId dialog_id, InputGroupCallId input_group_call_id) {
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    // nothing to do
    return;
  }

  if (d->active_group_call_id != input_group_call_id) {
    d->active_group_call_id = input_group_call_id;
    bool has_active_group_call = input_group_call_id.is_valid();
    if (has_active_group_call != d->has_active_group_call) {
      LOG(ERROR) << "Receive invalid has_active_group_call flag " << d->has_active_group_call << ", but have "
                 << input_group_call_id << " in " << dialog_id;
      d->has_active_group_call = has_active_group_call;
      if (!has_active_group_call) {
        d->is_group_call_empty = false;
      }
    }
    send_update_chat_voice_chat(d);
  }
}

void MessagesManager::on_update_dialog_message_ttl_setting(DialogId dialog_id, MessageTtlSetting message_ttl_setting) {
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    // nothing to do
    return;
  }

  if (d->message_ttl_setting != message_ttl_setting) {
    d->message_ttl_setting = message_ttl_setting;
    d->is_message_ttl_setting_inited = true;
    send_update_chat_message_ttl_setting(d);
  }
  if (!d->is_message_ttl_setting_inited) {
    d->is_message_ttl_setting_inited = true;
    on_dialog_updated(dialog_id, "on_update_dialog_message_ttl_setting");
  }
}

void MessagesManager::on_update_dialog_filters() {
  if (td_->auth_manager_->is_bot()) {
    // just in case
    return;
  }

  schedule_dialog_filters_reload(0.0);
}

void MessagesManager::on_create_new_dialog_success(int64 random_id, tl_object_ptr<telegram_api::Updates> &&updates,
                                                   DialogType expected_type, Promise<Unit> &&promise) {
  auto sent_messages = UpdatesManager::get_new_messages(updates.get());
  auto sent_messages_random_ids = UpdatesManager::get_sent_messages_random_ids(updates.get());
  if (sent_messages.size() != 1u || sent_messages_random_ids.size() != 1u) {
    LOG(ERROR) << "Receive wrong result for create group or channel chat " << oneline(to_string(updates));
    return on_create_new_dialog_fail(random_id, Status::Error(500, "Unsupported server response"), std::move(promise));
  }

  auto message = *sent_messages.begin();
  // int64 message_random_id = *sent_messages_random_ids.begin();
  // TODO check that message_random_id equals random_id after messages_createChat will be updated

  auto dialog_id = get_message_dialog_id(*message);
  if (dialog_id.get_type() != expected_type) {
    return on_create_new_dialog_fail(random_id, Status::Error(500, "Chat of wrong type has been created"),
                                     std::move(promise));
  }

  auto it = created_dialogs_.find(random_id);
  CHECK(it != created_dialogs_.end());
  CHECK(it->second == DialogId());

  it->second = dialog_id;

  const Dialog *d = get_dialog(dialog_id);
  if (d != nullptr && d->last_new_message_id.is_valid()) {
    // dialog have been already created and at least one non-temporary message was added,
    // i.e. we are not interested in the creation of dialog by searchMessages
    // then messages have already been added, so just set promise
    return promise.set_value(Unit());
  }

  if (pending_created_dialogs_.find(dialog_id) == pending_created_dialogs_.end()) {
    pending_created_dialogs_.emplace(dialog_id, std::move(promise));
  } else {
    LOG(ERROR) << dialog_id << " returned twice as result of chat creation";
    return on_create_new_dialog_fail(random_id, Status::Error(500, "Chat was created earlier"), std::move(promise));
  }

  td_->updates_manager_->on_get_updates(std::move(updates), Promise<Unit>());
}

void MessagesManager::on_create_new_dialog_fail(int64 random_id, Status error, Promise<Unit> &&promise) {
  LOG(INFO) << "Clean up creation of group or channel chat";
  auto it = created_dialogs_.find(random_id);
  CHECK(it != created_dialogs_.end());
  CHECK(it->second == DialogId());
  created_dialogs_.erase(it);

  CHECK(error.is_error());
  promise.set_error(std::move(error));

  // repairing state by running get difference
  td_->updates_manager_->get_difference("on_create_new_dialog_fail");
}

void MessagesManager::on_dialog_bots_updated(DialogId dialog_id, vector<UserId> bot_user_ids, bool from_database) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  auto d = from_database ? get_dialog(dialog_id) : get_dialog_force(dialog_id);
  if (d == nullptr || d->reply_markup_message_id == MessageId()) {
    return;
  }
  const Message *m = get_message_force(d, d->reply_markup_message_id, "on_dialog_bots_updated");
  if (m == nullptr || (m->sender_user_id.is_valid() && !td::contains(bot_user_ids, m->sender_user_id))) {
    LOG(INFO) << "Remove reply markup in " << dialog_id << ", because bot "
              << (m == nullptr ? UserId() : m->sender_user_id) << " isn't a member of the chat";
    set_dialog_reply_markup(d, MessageId());
  }
}

void MessagesManager::on_dialog_photo_updated(DialogId dialog_id) {
  auto d = get_dialog(dialog_id);  // called from update_user, must not create the dialog
  if (d != nullptr && d->is_update_new_chat_sent) {
    send_closure(
        G()->td(), &Td::send_update,
        make_tl_object<td_api::updateChatPhoto>(
            dialog_id.get(), get_chat_photo_info_object(td_->file_manager_.get(), get_dialog_photo(dialog_id))));
  }
}

void MessagesManager::on_dialog_title_updated(DialogId dialog_id) {
  auto d = get_dialog(dialog_id);  // called from update_user, must not create the dialog
  if (d != nullptr) {
    update_dialogs_hints(d);
    if (d->is_update_new_chat_sent) {
      send_closure(G()->td(), &Td::send_update,
                   make_tl_object<td_api::updateChatTitle>(dialog_id.get(), get_dialog_title(dialog_id)));
    }
  }
}

void MessagesManager::on_dialog_permissions_updated(DialogId dialog_id) {
  auto d = get_dialog(dialog_id);  // called from update_user, must not create the dialog
  if (d != nullptr && d->is_update_new_chat_sent) {
    send_closure(G()->td(), &Td::send_update,
                 td_api::make_object<td_api::updateChatPermissions>(
                     dialog_id.get(), get_dialog_permissions(dialog_id).get_chat_permissions_object()));
  }
}

void MessagesManager::on_dialog_user_is_contact_updated(DialogId dialog_id, bool is_contact) {
  CHECK(dialog_id.get_type() == DialogType::User);
  auto d = get_dialog(dialog_id);  // called from update_user, must not create the dialog
  if (d != nullptr && d->is_update_new_chat_sent) {
    if (d->know_action_bar) {
      if (is_contact) {
        if (d->can_block_user || d->can_add_contact) {
          d->can_block_user = false;
          d->can_add_contact = false;
          // keep d->can_unarchive
          d->distance = -1;
          send_update_chat_action_bar(d);
        }
      } else {
        repair_dialog_action_bar(d, "on_dialog_user_is_contact_updated");
      }
    }

    if (!dialog_filters_.empty() && d->order != DEFAULT_ORDER) {
      update_dialog_lists(d, get_dialog_positions(d), true, false, "on_dialog_user_is_contact_updated");
      td_->contacts_manager_->for_each_secret_chat_with_user(
          d->dialog_id.get_user_id(), [this](SecretChatId secret_chat_id) {
            DialogId dialog_id(secret_chat_id);
            auto d = get_dialog(dialog_id);  // must not create the dialog
            if (d != nullptr && d->is_update_new_chat_sent && d->order != DEFAULT_ORDER) {
              update_dialog_lists(d, get_dialog_positions(d), true, false, "on_dialog_user_is_contact_updated");
            }
          });
    }
  }
}

void MessagesManager::on_dialog_user_is_deleted_updated(DialogId dialog_id, bool is_deleted) {
  CHECK(dialog_id.get_type() == DialogType::User);
  auto d = get_dialog(dialog_id);  // called from update_user, must not create the dialog
  if (d != nullptr && d->is_update_new_chat_sent) {
    if (d->know_action_bar) {
      if (is_deleted) {
        if (d->can_share_phone_number || d->can_block_user || d->can_add_contact || d->distance >= 0) {
          d->can_share_phone_number = false;
          d->can_block_user = false;
          d->can_add_contact = false;
          d->distance = -1;
          send_update_chat_action_bar(d);
        }
      } else {
        repair_dialog_action_bar(d, "on_dialog_user_is_deleted_updated");
      }
    }

    if (!dialog_filters_.empty() && d->order != DEFAULT_ORDER) {
      update_dialog_lists(d, get_dialog_positions(d), true, false, "on_dialog_user_is_deleted_updated");
      td_->contacts_manager_->for_each_secret_chat_with_user(
          d->dialog_id.get_user_id(), [this](SecretChatId secret_chat_id) {
            DialogId dialog_id(secret_chat_id);
            auto d = get_dialog(dialog_id);  // must not create the dialog
            if (d != nullptr && d->is_update_new_chat_sent && d->order != DEFAULT_ORDER) {
              update_dialog_lists(d, get_dialog_positions(d), true, false, "on_dialog_user_is_deleted_updated");
            }
          });
    }
  }
}

void MessagesManager::on_dialog_linked_channel_updated(DialogId dialog_id, ChannelId old_linked_channel_id,
                                                       ChannelId new_linked_channel_id) const {
  CHECK(dialog_id.get_type() == DialogType::Channel);
  if (!is_broadcast_channel(dialog_id)) {
    return;
  }
  auto d = get_dialog(dialog_id);  // no need to create the dialog
  if (d != nullptr && d->is_update_new_chat_sent) {
    vector<MessageId> message_ids;
    find_messages(d->messages.get(), message_ids, [old_linked_channel_id, new_linked_channel_id](const Message *m) {
      return !m->reply_info.is_empty() && m->reply_info.channel_id.is_valid() &&
             (m->reply_info.channel_id == old_linked_channel_id || m->reply_info.channel_id == new_linked_channel_id);
    });
    LOG(INFO) << "Found discussion messages " << message_ids;
    for (auto message_id : message_ids) {
      send_update_message_interaction_info(dialog_id, get_message(d, message_id));
      if (message_id == d->last_message_id) {
        send_update_chat_last_message_impl(d, "on_dialog_linked_channel_updated");
      }
    }
  }
}

DialogId MessagesManager::resolve_dialog_username(const string &username) const {
  auto cleaned_username = clean_username(username);
  auto it = resolved_usernames_.find(cleaned_username);
  if (it != resolved_usernames_.end()) {
    return it->second.dialog_id;
  }

  auto it2 = inaccessible_resolved_usernames_.find(cleaned_username);
  if (it2 != inaccessible_resolved_usernames_.end()) {
    return it2->second;
  }

  return DialogId();
}

DialogId MessagesManager::search_public_dialog(const string &username_to_search, bool force, Promise<Unit> &&promise) {
  string username = clean_username(username_to_search);
  if (username[0] == '@') {
    username = username.substr(1);
  }
  if (username.empty()) {
    promise.set_error(Status::Error(200, "Username is invalid"));
    return DialogId();
  }

  DialogId dialog_id;
  auto it = resolved_usernames_.find(username);
  if (it != resolved_usernames_.end()) {
    if (it->second.expires_at < Time::now()) {
      td_->create_handler<ResolveUsernameQuery>(Promise<>())->send(username);
    }
    dialog_id = it->second.dialog_id;
  } else {
    auto it2 = inaccessible_resolved_usernames_.find(username);
    if (it2 != inaccessible_resolved_usernames_.end()) {
      dialog_id = it2->second;
    }
  }

  if (dialog_id.is_valid()) {
    if (have_input_peer(dialog_id, AccessRights::Read)) {
      if (td_->auth_manager_->is_bot()) {
        force_create_dialog(dialog_id, "search public dialog", true);
      } else {
        const Dialog *d = get_dialog_force(dialog_id);
        if (!is_dialog_inited(d)) {
          send_get_dialog_query(dialog_id, std::move(promise), 0, "search_public_dialog");
          return DialogId();
        }
      }

      promise.set_value(Unit());
      return dialog_id;
    } else {
      // bot username maybe known despite there is no access_hash
      if (force || dialog_id.get_type() != DialogType::User) {
        force_create_dialog(dialog_id, "search public dialog", true);
        promise.set_value(Unit());
        return dialog_id;
      }
    }
  }

  td_->create_handler<ResolveUsernameQuery>(std::move(promise))->send(username);
  return DialogId();
}

void MessagesManager::send_get_dialog_notification_settings_query(DialogId dialog_id, Promise<Unit> &&promise) {
  if (td_->auth_manager_->is_bot() || dialog_id.get_type() == DialogType::SecretChat) {
    LOG(WARNING) << "Can't get notification settings for " << dialog_id;
    return promise.set_error(Status::Error(500, "Wrong getDialogNotificationSettings query"));
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    LOG(WARNING) << "Have no access to " << dialog_id << " to get notification settings";
    return promise.set_error(Status::Error(400, "Can't access the chat"));
  }

  LOG(INFO) << "Send GetDialogNotifySettingsQuery for " << dialog_id;
  auto &promises = get_dialog_notification_settings_queries_[dialog_id];
  promises.push_back(std::move(promise));
  if (promises.size() != 1) {
    // query has already been sent, just wait for the result
    return;
  }

  td_->create_handler<GetDialogNotifySettingsQuery>()->send(dialog_id);
}

void MessagesManager::send_get_scope_notification_settings_query(NotificationSettingsScope scope,
                                                                 Promise<Unit> &&promise) {
  if (td_->auth_manager_->is_bot()) {
    LOG(ERROR) << "Can't get notification settings for " << scope;
    return promise.set_error(Status::Error(500, "Wrong getScopeNotificationSettings query"));
  }

  td_->create_handler<GetScopeNotifySettingsQuery>(std::move(promise))->send(scope);
}

void MessagesManager::on_get_dialog_notification_settings_query_finished(DialogId dialog_id, Status &&status) {
  CHECK(!td_->auth_manager_->is_bot());
  auto it = get_dialog_notification_settings_queries_.find(dialog_id);
  CHECK(it != get_dialog_notification_settings_queries_.end());
  CHECK(!it->second.empty());
  auto promises = std::move(it->second);
  get_dialog_notification_settings_queries_.erase(it);

  for (auto &promise : promises) {
    if (status.is_ok()) {
      promise.set_value(Unit());
    } else {
      promise.set_error(status.clone());
    }
  }
}

class MessagesManager::GetDialogFromServerLogEvent {
 public:
  DialogId dialog_id_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
  }
};

uint64 MessagesManager::save_get_dialog_from_server_log_event(DialogId dialog_id) {
  GetDialogFromServerLogEvent log_event{dialog_id};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::GetDialogFromServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::send_get_dialog_query(DialogId dialog_id, Promise<Unit> &&promise, uint64 log_event_id,
                                            const char *source) {
  if (td_->auth_manager_->is_bot() || dialog_id.get_type() == DialogType::SecretChat) {
    if (log_event_id != 0) {
      binlog_erase(G()->td_db()->get_binlog(), log_event_id);
    }
    return promise.set_error(Status::Error(500, "Wrong getDialog query"));
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    if (log_event_id != 0) {
      binlog_erase(G()->td_db()->get_binlog(), log_event_id);
    }
    return promise.set_error(Status::Error(400, "Can't access the chat"));
  }

  auto &promises = get_dialog_queries_[dialog_id];
  promises.push_back(std::move(promise));
  if (promises.size() != 1) {
    if (log_event_id != 0) {
      LOG(INFO) << "Duplicate getDialog query for " << dialog_id << " from " << source;
      binlog_erase(G()->td_db()->get_binlog(), log_event_id);
    }
    // query has already been sent, just wait for the result
    return;
  }

  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_get_dialog_from_server_log_event(dialog_id);
  }
  if (log_event_id != 0) {
    auto result = get_dialog_query_log_event_id_.emplace(dialog_id, log_event_id);
    CHECK(result.second);
  }
  if (G()->close_flag()) {
    // request will be sent after restart
    return;
  }

  LOG(INFO) << "Send get " << dialog_id << " query from " << source;
  td_->create_handler<GetDialogQuery>()->send(dialog_id);
}

void MessagesManager::on_get_dialog_query_finished(DialogId dialog_id, Status &&status) {
  LOG(INFO) << "Finished getting " << dialog_id << " with result " << status;
  auto it = get_dialog_queries_.find(dialog_id);
  CHECK(it != get_dialog_queries_.end());
  CHECK(!it->second.empty());
  auto promises = std::move(it->second);
  get_dialog_queries_.erase(it);

  auto log_event_it = get_dialog_query_log_event_id_.find(dialog_id);
  if (log_event_it != get_dialog_query_log_event_id_.end()) {
    if (!G()->close_flag()) {
      binlog_erase(G()->td_db()->get_binlog(), log_event_it->second);
    }
    get_dialog_query_log_event_id_.erase(log_event_it);
  }

  for (auto &promise : promises) {
    if (status.is_ok()) {
      promise.set_value(Unit());
    } else {
      promise.set_error(status.clone());
    }
  }
}

bool MessagesManager::is_update_about_username_change_received(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      return td_->contacts_manager_->is_update_about_username_change_received(dialog_id.get_user_id());
    case DialogType::Chat:
      return true;
    case DialogType::Channel:
      return td_->contacts_manager_->get_channel_status(dialog_id.get_channel_id()).is_member();
    case DialogType::SecretChat:
      return true;
    case DialogType::None:
    default:
      UNREACHABLE();
      return false;
  }
}

void MessagesManager::on_dialog_username_updated(DialogId dialog_id, const string &old_username,
                                                 const string &new_username) {
  auto d = get_dialog(dialog_id);
  if (d != nullptr) {
    update_dialogs_hints(d);
  }
  if (old_username != new_username) {
    public_message_links_[0].erase(dialog_id);
    public_message_links_[1].erase(dialog_id);
  }
  if (!old_username.empty() && old_username != new_username) {
    resolved_usernames_.erase(clean_username(old_username));
    inaccessible_resolved_usernames_.erase(clean_username(old_username));
  }
  if (!new_username.empty()) {
    auto cache_time = is_update_about_username_change_received(dialog_id) ? USERNAME_CACHE_EXPIRE_TIME
                                                                          : USERNAME_CACHE_EXPIRE_TIME_SHORT;
    resolved_usernames_[clean_username(new_username)] = ResolvedUsername{dialog_id, Time::now() + cache_time};
  }
}

void MessagesManager::on_resolved_username(const string &username, DialogId dialog_id) {
  if (!dialog_id.is_valid()) {
    LOG(ERROR) << "Resolve username \"" << username << "\" to invalid " << dialog_id;
    return;
  }

  auto it = resolved_usernames_.find(clean_username(username));
  if (it != resolved_usernames_.end()) {
    LOG_IF(ERROR, it->second.dialog_id != dialog_id)
        << "Resolve username \"" << username << "\" to " << dialog_id << ", but have it in " << it->second.dialog_id;
    return;
  }

  inaccessible_resolved_usernames_[clean_username(username)] = dialog_id;
}

void MessagesManager::drop_username(const string &username) {
  inaccessible_resolved_usernames_.erase(clean_username(username));

  auto it = resolved_usernames_.find(clean_username(username));
  if (it == resolved_usernames_.end()) {
    return;
  }

  auto dialog_id = it->second.dialog_id;
  if (have_input_peer(dialog_id, AccessRights::Read)) {
    CHECK(dialog_id.get_type() != DialogType::SecretChat);
    send_get_dialog_query(dialog_id, Auto(), 0, "drop_username");
  }

  resolved_usernames_.erase(it);
}

const DialogPhoto *MessagesManager::get_dialog_photo(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      return td_->contacts_manager_->get_user_dialog_photo(dialog_id.get_user_id());
    case DialogType::Chat:
      return td_->contacts_manager_->get_chat_dialog_photo(dialog_id.get_chat_id());
    case DialogType::Channel:
      return td_->contacts_manager_->get_channel_dialog_photo(dialog_id.get_channel_id());
    case DialogType::SecretChat:
      return td_->contacts_manager_->get_secret_chat_dialog_photo(dialog_id.get_secret_chat_id());
    case DialogType::None:
    default:
      UNREACHABLE();
      return nullptr;
  }
}

string MessagesManager::get_dialog_title(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      return td_->contacts_manager_->get_user_title(dialog_id.get_user_id());
    case DialogType::Chat:
      return td_->contacts_manager_->get_chat_title(dialog_id.get_chat_id());
    case DialogType::Channel:
      return td_->contacts_manager_->get_channel_title(dialog_id.get_channel_id());
    case DialogType::SecretChat:
      return td_->contacts_manager_->get_secret_chat_title(dialog_id.get_secret_chat_id());
    case DialogType::None:
    default:
      UNREACHABLE();
      return string();
  }
}

string MessagesManager::get_dialog_username(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      return td_->contacts_manager_->get_user_username(dialog_id.get_user_id());
    case DialogType::Chat:
      return string();
    case DialogType::Channel:
      return td_->contacts_manager_->get_channel_username(dialog_id.get_channel_id());
    case DialogType::SecretChat:
      return td_->contacts_manager_->get_secret_chat_username(dialog_id.get_secret_chat_id());
    case DialogType::None:
    default:
      UNREACHABLE();
      return string();
  }
}

RestrictedRights MessagesManager::get_dialog_permissions(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      return td_->contacts_manager_->get_user_default_permissions(dialog_id.get_user_id());
    case DialogType::Chat:
      return td_->contacts_manager_->get_chat_default_permissions(dialog_id.get_chat_id());
    case DialogType::Channel:
      return td_->contacts_manager_->get_channel_default_permissions(dialog_id.get_channel_id());
    case DialogType::SecretChat:
      return td_->contacts_manager_->get_secret_chat_default_permissions(dialog_id.get_secret_chat_id());
    case DialogType::None:
    default:
      UNREACHABLE();
      return RestrictedRights(false, false, false, false, false, false, false, false, false, false, false);
  }
}

bool MessagesManager::get_dialog_has_scheduled_messages(const Dialog *d) const {
  if (!have_input_peer(d->dialog_id, AccessRights::Read)) {
    return false;
  }
  if (is_broadcast_channel(d->dialog_id) &&
      !td_->contacts_manager_->get_channel_status(d->dialog_id.get_channel_id()).can_post_messages()) {
    return false;
  }
  // TODO send updateChatHasScheduledMessage when can_post_messages changes

  return d->has_scheduled_server_messages || d->has_scheduled_database_messages || d->scheduled_messages != nullptr;
}

bool MessagesManager::is_dialog_action_unneeded(DialogId dialog_id) const {
  if (is_anonymous_administrator(dialog_id, nullptr)) {
    return true;
  }

  auto dialog_type = dialog_id.get_type();
  if (dialog_type == DialogType::User || dialog_type == DialogType::SecretChat) {
    UserId user_id = dialog_type == DialogType::User
                         ? dialog_id.get_user_id()
                         : td_->contacts_manager_->get_secret_chat_user_id(dialog_id.get_secret_chat_id());
    if (td_->contacts_manager_->is_user_deleted(user_id)) {
      return true;
    }
    if (td_->contacts_manager_->is_user_bot(user_id) && !td_->contacts_manager_->is_user_support(user_id)) {
      return true;
    }
    if (user_id == td_->contacts_manager_->get_my_id()) {
      return true;
    }

    if (!td_->auth_manager_->is_bot()) {
      if (td_->contacts_manager_->is_user_status_exact(user_id)) {
        if (!td_->contacts_manager_->is_user_online(user_id, 30)) {
          return true;
        }
      } else {
        // return true;
      }
    }
  }
  return false;
}

void MessagesManager::send_dialog_action(DialogId dialog_id, MessageId top_thread_message_id, DialogAction action,
                                         Promise<Unit> &&promise) {
  if (!have_dialog_force(dialog_id)) {
    return promise.set_error(Status::Error(5, "Chat not found"));
  }
  if (top_thread_message_id != MessageId() &&
      (!top_thread_message_id.is_valid() || !top_thread_message_id.is_server())) {
    return promise.set_error(Status::Error(5, "Invalid message thread specified"));
  }

  auto can_send_status = can_send_message(dialog_id);
  if (can_send_status.is_error()) {
    if (td_->auth_manager_->is_bot()) {
      return promise.set_error(can_send_status.move_as_error());
    }
    return promise.set_value(Unit());
  }

  if (is_dialog_action_unneeded(dialog_id)) {
    return promise.set_value(Unit());
  }

  if (dialog_id.get_type() == DialogType::SecretChat) {
    send_closure(G()->secret_chats_manager(), &SecretChatsManager::send_message_action, dialog_id.get_secret_chat_id(),
                 action.get_secret_input_send_message_action());
    promise.set_value(Unit());
    return;
  }

  auto &query_ref = set_typing_query_[dialog_id];
  if (!query_ref.empty() && !td_->auth_manager_->is_bot()) {
    LOG(INFO) << "Cancel previous send chat action query";
    cancel_query(query_ref);
  }
  query_ref = td_->create_handler<SetTypingQuery>(std::move(promise))
                  ->send(dialog_id, top_thread_message_id, action.get_input_send_message_action());
}

void MessagesManager::on_send_dialog_action_timeout(DialogId dialog_id) {
  LOG(INFO) << "Receive send_chat_action timeout in " << dialog_id;
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  if (can_send_message(dialog_id).is_error()) {
    return;
  }

  auto queue_id = get_sequence_dispatcher_id(dialog_id, MessageContentType::Photo);
  CHECK(queue_id & 1);

  auto queue_it = yet_unsent_media_queues_.find(queue_id);
  if (queue_it == yet_unsent_media_queues_.end()) {
    return;
  }

  pending_send_dialog_action_timeout_.add_timeout_in(dialog_id.get(), 4.0);

  CHECK(!queue_it->second.empty());
  const Message *m = get_message(d, queue_it->second.begin()->first);
  if (m == nullptr) {
    return;
  }
  if (m->forward_info != nullptr || m->had_forward_info || m->message_id.is_scheduled()) {
    return;
  }

  auto file_id = get_message_content_upload_file_id(m->content.get());
  if (!file_id.is_valid()) {
    LOG(ERROR) << "Have no file in "
               << to_string(get_message_content_object(m->content.get(), td_, m->date, m->is_content_secret));
    return;
  }
  auto file_view = td_->file_manager_->get_file_view(file_id);
  if (!file_view.is_uploading()) {
    return;
  }
  int64 total_size = file_view.expected_size();
  int64 uploaded_size = file_view.remote_size();
  int32 progress = 0;
  if (total_size > 0 && uploaded_size > 0) {
    if (uploaded_size > total_size) {
      uploaded_size = total_size;  // just in case
    }
    progress = static_cast<int32>(100 * uploaded_size / total_size);
  }

  DialogAction action = DialogAction::get_uploading_action(m->content->get_type(), progress);
  if (action == DialogAction()) {
    return;
  }
  LOG(INFO) << "Send " << action << " in " << dialog_id;
  send_dialog_action(dialog_id, m->top_thread_message_id, std::move(action), Promise<Unit>());
}

void MessagesManager::on_active_dialog_action_timeout(DialogId dialog_id) {
  LOG(DEBUG) << "Receive active dialog action timeout in " << dialog_id;
  auto actions_it = active_dialog_actions_.find(dialog_id);
  if (actions_it == active_dialog_actions_.end()) {
    return;
  }
  CHECK(!actions_it->second.empty());

  auto now = Time::now();
  UserId prev_user_id;
  while (actions_it->second[0].start_time + DIALOG_ACTION_TIMEOUT < now + 0.1) {
    CHECK(actions_it->second[0].user_id != prev_user_id);
    prev_user_id = actions_it->second[0].user_id;
    on_user_dialog_action(dialog_id, actions_it->second[0].top_thread_message_id, actions_it->second[0].user_id,
                          DialogAction(), 0);

    actions_it = active_dialog_actions_.find(dialog_id);
    if (actions_it == active_dialog_actions_.end()) {
      return;
    }
    CHECK(!actions_it->second.empty());
  }

  LOG(DEBUG) << "Schedule next action timeout in " << dialog_id;
  active_dialog_action_timeout_.add_timeout_in(dialog_id.get(),
                                               actions_it->second[0].start_time + DIALOG_ACTION_TIMEOUT - now);
}

void MessagesManager::clear_active_dialog_actions(DialogId dialog_id) {
  LOG(DEBUG) << "Clear active dialog actions in " << dialog_id;
  auto actions_it = active_dialog_actions_.find(dialog_id);
  while (actions_it != active_dialog_actions_.end()) {
    CHECK(!actions_it->second.empty());
    on_user_dialog_action(dialog_id, actions_it->second[0].top_thread_message_id, actions_it->second[0].user_id,
                          DialogAction(), 0);
    actions_it = active_dialog_actions_.find(dialog_id);
  }
}

vector<DialogListId> MessagesManager::get_dialog_lists_to_add_dialog(DialogId dialog_id) {
  vector<DialogListId> result;
  const Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr || d->order == DEFAULT_ORDER || !have_input_peer(dialog_id, AccessRights::Read)) {
    return result;
  }

  if (dialog_id != get_my_dialog_id() && dialog_id != DialogId(ContactsManager::get_service_notifications_user_id())) {
    result.push_back(DialogListId(d->folder_id == FolderId::archive() ? FolderId::main() : FolderId::archive()));
  }

  for (const auto &dialog_filter : dialog_filters_) {
    auto dialog_filter_id = dialog_filter->dialog_filter_id;
    if (!InputDialogId::contains(dialog_filter->included_dialog_ids, dialog_id) &&
        !InputDialogId::contains(dialog_filter->pinned_dialog_ids, dialog_id)) {
      // the dialog isn't added yet to the dialog list
      // check that it can be actually added
      if (dialog_filter->included_dialog_ids.size() + dialog_filter->pinned_dialog_ids.size() <
          DialogFilter::MAX_INCLUDED_FILTER_DIALOGS) {
        // fast path
        result.push_back(DialogListId(dialog_filter_id));
        continue;
      }

      auto new_dialog_filter = make_unique<DialogFilter>(*dialog_filter);
      new_dialog_filter->included_dialog_ids.push_back(get_input_dialog_id(dialog_id));
      td::remove_if(new_dialog_filter->excluded_dialog_ids, [dialog_id](InputDialogId input_dialog_id) {
        return dialog_id == input_dialog_id.get_dialog_id();
      });

      if (new_dialog_filter->check_limits().is_ok()) {
        result.push_back(DialogListId(dialog_filter_id));
      }
    }
  }
  return result;
}

void MessagesManager::add_dialog_to_list(DialogId dialog_id, DialogListId dialog_list_id, Promise<Unit> &&promise) {
  LOG(INFO) << "Receive addChatToList request to add " << dialog_id << " to " << dialog_list_id;
  CHECK(!td_->auth_manager_->is_bot());

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    return promise.set_error(Status::Error(6, "Can't access the chat"));
  }

  if (d->order == DEFAULT_ORDER) {
    return promise.set_error(Status::Error(400, "Chat is not in a chat list"));
  }

  if (get_dialog_list(dialog_list_id) == nullptr) {
    return promise.set_error(Status::Error(400, "Chat list not found"));
  }

  if (dialog_list_id.is_filter()) {
    CHECK(is_update_chat_filters_sent_);
    auto dialog_filter_id = dialog_list_id.get_filter_id();
    auto old_dialog_filter = get_dialog_filter(dialog_filter_id);
    CHECK(old_dialog_filter != nullptr);
    if (InputDialogId::contains(old_dialog_filter->included_dialog_ids, dialog_id) ||
        InputDialogId::contains(old_dialog_filter->pinned_dialog_ids, dialog_id)) {
      return promise.set_value(Unit());
    }

    auto new_dialog_filter = make_unique<DialogFilter>(*old_dialog_filter);
    new_dialog_filter->included_dialog_ids.push_back(get_input_dialog_id(dialog_id));
    td::remove_if(new_dialog_filter->excluded_dialog_ids,
                  [dialog_id](InputDialogId input_dialog_id) { return dialog_id == input_dialog_id.get_dialog_id(); });

    auto status = new_dialog_filter->check_limits();
    if (status.is_error()) {
      return promise.set_error(std::move(status));
    }
    sort_dialog_filter_input_dialog_ids(new_dialog_filter.get());

    edit_dialog_filter(std::move(new_dialog_filter), "add_dialog_to_list");
    save_dialog_filters();
    send_update_chat_filters();

    if (dialog_id.get_type() != DialogType::SecretChat) {
      synchronize_dialog_filters();
    }

    return promise.set_value(Unit());
  }

  CHECK(dialog_list_id.is_folder());
  auto folder_id = dialog_list_id.get_folder_id();
  if (d->folder_id == folder_id) {
    return promise.set_value(Unit());
  }

  if (folder_id == FolderId::archive() &&
      (dialog_id == get_my_dialog_id() ||
       dialog_id == DialogId(ContactsManager::get_service_notifications_user_id()))) {
    return promise.set_error(Status::Error(400, "Chat can't be archived"));
  }

  set_dialog_folder_id(d, folder_id);

  if (dialog_id.get_type() != DialogType::SecretChat) {
    set_dialog_folder_id_on_server(dialog_id, false);
  }
  promise.set_value(Unit());
}

class MessagesManager::SetDialogFolderIdOnServerLogEvent {
 public:
  DialogId dialog_id_;
  FolderId folder_id_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
    td::store(folder_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
    td::parse(folder_id_, parser);
  }
};

void MessagesManager::set_dialog_folder_id_on_server(DialogId dialog_id, bool from_binlog) {
  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  if (!from_binlog && G()->parameters().use_message_db) {
    SetDialogFolderIdOnServerLogEvent log_event;
    log_event.dialog_id_ = dialog_id;
    log_event.folder_id_ = d->folder_id;
    add_log_event(d->set_folder_id_log_event_id, get_log_event_storer(log_event),
                  LogEvent::HandlerType::SetDialogFolderIdOnServer, "set chat folder");
  }

  Promise<> promise;
  if (d->set_folder_id_log_event_id.log_event_id != 0) {
    d->set_folder_id_log_event_id.generation++;
    promise = PromiseCreator::lambda([actor_id = actor_id(this), dialog_id,
                                      generation = d->set_folder_id_log_event_id.generation](Result<Unit> result) {
      if (!G()->close_flag()) {
        send_closure(actor_id, &MessagesManager::on_updated_dialog_folder_id, dialog_id, generation);
      }
    });
  }

  // TODO do not send two queries simultaneously or use SequenceDispatcher
  td_->create_handler<EditPeerFoldersQuery>(std::move(promise))->send(dialog_id, d->folder_id);
}

void MessagesManager::on_updated_dialog_folder_id(DialogId dialog_id, uint64 generation) {
  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  delete_log_event(d->set_folder_id_log_event_id, generation, "set chat folder");
}

void MessagesManager::set_dialog_photo(DialogId dialog_id, const tl_object_ptr<td_api::InputChatPhoto> &input_photo,
                                       Promise<Unit> &&promise) {
  LOG(INFO) << "Receive setChatPhoto request to change photo of " << dialog_id;

  if (!have_dialog_force(dialog_id)) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  switch (dialog_id.get_type()) {
    case DialogType::User:
      return promise.set_error(Status::Error(3, "Can't change private chat photo"));
    case DialogType::Chat: {
      auto chat_id = dialog_id.get_chat_id();
      auto status = td_->contacts_manager_->get_chat_permissions(chat_id);
      if (!status.can_change_info_and_settings() ||
          (td_->auth_manager_->is_bot() && !td_->contacts_manager_->is_appointed_chat_administrator(chat_id))) {
        return promise.set_error(Status::Error(3, "Not enough rights to change chat photo"));
      }
      break;
    }
    case DialogType::Channel: {
      auto status = td_->contacts_manager_->get_channel_permissions(dialog_id.get_channel_id());
      if (!status.can_change_info_and_settings()) {
        return promise.set_error(Status::Error(3, "Not enough rights to change chat photo"));
      }
      break;
    }
    case DialogType::SecretChat:
      return promise.set_error(Status::Error(3, "Can't change secret chat photo"));
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  const td_api::object_ptr<td_api::InputFile> *input_file = nullptr;
  double main_frame_timestamp = 0.0;
  bool is_animation = false;
  if (input_photo != nullptr) {
    switch (input_photo->get_id()) {
      case td_api::inputChatPhotoPrevious::ID: {
        auto photo = static_cast<const td_api::inputChatPhotoPrevious *>(input_photo.get());
        auto file_id = td_->contacts_manager_->get_profile_photo_file_id(photo->chat_photo_id_);
        if (!file_id.is_valid()) {
          return promise.set_error(Status::Error(400, "Unknown profile photo ID specified"));
        }

        auto file_view = td_->file_manager_->get_file_view(file_id);
        auto input_chat_photo =
            make_tl_object<telegram_api::inputChatPhoto>(file_view.main_remote_location().as_input_photo());
        send_edit_dialog_photo_query(dialog_id, file_id, std::move(input_chat_photo), std::move(promise));
        return;
      }
      case td_api::inputChatPhotoStatic::ID: {
        auto photo = static_cast<const td_api::inputChatPhotoStatic *>(input_photo.get());
        input_file = &photo->photo_;
        break;
      }
      case td_api::inputChatPhotoAnimation::ID: {
        auto photo = static_cast<const td_api::inputChatPhotoAnimation *>(input_photo.get());
        input_file = &photo->animation_;
        main_frame_timestamp = photo->main_frame_timestamp_;
        is_animation = true;
        break;
      }
      default:
        UNREACHABLE();
        break;
    }
  }
  if (input_file == nullptr) {
    send_edit_dialog_photo_query(dialog_id, FileId(), make_tl_object<telegram_api::inputChatPhotoEmpty>(),
                                 std::move(promise));
    return;
  }

  const double MAX_ANIMATION_DURATION = 10.0;
  if (main_frame_timestamp < 0.0 || main_frame_timestamp > MAX_ANIMATION_DURATION) {
    return promise.set_error(Status::Error(400, "Wrong main frame timestamp specified"));
  }

  auto file_type = is_animation ? FileType::Animation : FileType::Photo;
  auto r_file_id = td_->file_manager_->get_input_file_id(file_type, *input_file, dialog_id, true, false);
  if (r_file_id.is_error()) {
    // TODO promise.set_error(std::move(status));
    return promise.set_error(Status::Error(400, r_file_id.error().message()));
  }
  FileId file_id = r_file_id.ok();
  if (!file_id.is_valid()) {
    send_edit_dialog_photo_query(dialog_id, FileId(), make_tl_object<telegram_api::inputChatPhotoEmpty>(),
                                 std::move(promise));
    return;
  }

  upload_dialog_photo(dialog_id, td_->file_manager_->dup_file_id(file_id), is_animation, main_frame_timestamp, false,
                      std::move(promise));
}

void MessagesManager::send_edit_dialog_photo_query(DialogId dialog_id, FileId file_id,
                                                   tl_object_ptr<telegram_api::InputChatPhoto> &&input_chat_photo,
                                                   Promise<Unit> &&promise) {
  // TODO invoke after
  td_->create_handler<EditDialogPhotoQuery>(std::move(promise))->send(dialog_id, file_id, std::move(input_chat_photo));
}

void MessagesManager::upload_dialog_photo(DialogId dialog_id, FileId file_id, bool is_animation,
                                          double main_frame_timestamp, bool is_reupload, Promise<Unit> &&promise,
                                          vector<int> bad_parts) {
  CHECK(file_id.is_valid());
  LOG(INFO) << "Ask to upload chat photo " << file_id;
  CHECK(being_uploaded_dialog_photos_.find(file_id) == being_uploaded_dialog_photos_.end());
  being_uploaded_dialog_photos_.emplace(
      file_id, UploadedDialogPhotoInfo{dialog_id, main_frame_timestamp, is_animation, is_reupload, std::move(promise)});
  // TODO use force_reupload if is_reupload
  td_->file_manager_->resume_upload(file_id, std::move(bad_parts), upload_dialog_photo_callback_, 32, 0);
}

void MessagesManager::set_dialog_title(DialogId dialog_id, const string &title, Promise<Unit> &&promise) {
  LOG(INFO) << "Receive setChatTitle request to change title of " << dialog_id << " to \"" << title << '"';

  if (!have_dialog_force(dialog_id)) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  auto new_title = clean_name(title, MAX_TITLE_LENGTH);
  if (new_title.empty()) {
    return promise.set_error(Status::Error(3, "Title can't be empty"));
  }

  switch (dialog_id.get_type()) {
    case DialogType::User:
      return promise.set_error(Status::Error(3, "Can't change private chat title"));
    case DialogType::Chat: {
      auto chat_id = dialog_id.get_chat_id();
      auto status = td_->contacts_manager_->get_chat_permissions(chat_id);
      if (!status.can_change_info_and_settings() ||
          (td_->auth_manager_->is_bot() && !td_->contacts_manager_->is_appointed_chat_administrator(chat_id))) {
        return promise.set_error(Status::Error(3, "Not enough rights to change chat title"));
      }
      break;
    }
    case DialogType::Channel: {
      auto status = td_->contacts_manager_->get_channel_permissions(dialog_id.get_channel_id());
      if (!status.can_change_info_and_settings()) {
        return promise.set_error(Status::Error(3, "Not enough rights to change chat title"));
      }
      break;
    }
    case DialogType::SecretChat:
      return promise.set_error(Status::Error(3, "Can't change secret chat title"));
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  // TODO this can be wrong if there was previous change title requests
  if (get_dialog_title(dialog_id) == new_title) {
    return promise.set_value(Unit());
  }

  // TODO invoke after
  td_->create_handler<EditDialogTitleQuery>(std::move(promise))->send(dialog_id, new_title);
}

void MessagesManager::set_dialog_message_ttl_setting(DialogId dialog_id, int32 ttl, Promise<Unit> &&promise) {
  if (ttl < 0) {
    return promise.set_error(Status::Error(400, "Message auto-delete time can't be negative"));
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(400, "Chat not found"));
  }
  if (!have_input_peer(dialog_id, AccessRights::Write)) {
    return promise.set_error(Status::Error(400, "Have no write access to the chat"));
  }

  LOG(INFO) << "Begin to set message TTL in " << dialog_id << " to " << ttl;

  switch (dialog_id.get_type()) {
    case DialogType::User:
      if (dialog_id == get_my_dialog_id() ||
          dialog_id == DialogId(ContactsManager::get_service_notifications_user_id())) {
        return promise.set_error(Status::Error(400, "Message auto-delete time in the chat can't be changed"));
      }
      break;
    case DialogType::Chat: {
      auto chat_id = dialog_id.get_chat_id();
      auto status = td_->contacts_manager_->get_chat_permissions(chat_id);
      if (!status.can_delete_messages()) {
        return promise.set_error(
            Status::Error(400, "Not enough rights to change message auto-delete time in the chat"));
      }
      break;
    }
    case DialogType::Channel: {
      auto status = td_->contacts_manager_->get_channel_permissions(dialog_id.get_channel_id());
      if (!status.can_change_info_and_settings()) {
        return promise.set_error(
            Status::Error(400, "Not enough rights to change message auto-delete time in the chat"));
      }
      break;
    }
    case DialogType::SecretChat:
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  if (dialog_id.get_type() != DialogType::SecretChat) {
    // TODO invoke after
    td_->create_handler<SetHistoryTtlQuery>(std::move(promise))->send(dialog_id, ttl);
  } else {
    bool need_update_dialog_pos = false;
    Message *m = get_message_to_send(d, MessageId(), MessageId(), MessageSendOptions(),
                                     create_chat_set_ttl_message_content(ttl), &need_update_dialog_pos);

    send_update_new_message(d, m);
    if (need_update_dialog_pos) {
      send_update_chat_last_message(d, "set_dialog_message_ttl_setting");
    }

    int64 random_id = begin_send_message(dialog_id, m);

    send_closure(td_->secret_chats_manager_, &SecretChatsManager::send_set_ttl_message, dialog_id.get_secret_chat_id(),
                 ttl, random_id, std::move(promise));
  }
}

void MessagesManager::set_dialog_permissions(DialogId dialog_id,
                                             const td_api::object_ptr<td_api::chatPermissions> &permissions,
                                             Promise<Unit> &&promise) {
  LOG(INFO) << "Receive setChatPermissions request to change permissions of " << dialog_id << " to "
            << to_string(permissions);

  if (!have_dialog_force(dialog_id)) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }
  if (!have_input_peer(dialog_id, AccessRights::Write)) {
    return promise.set_error(Status::Error(3, "Can't access the chat"));
  }

  if (permissions == nullptr) {
    return promise.set_error(Status::Error(3, "New permissions must be non-empty"));
  }

  switch (dialog_id.get_type()) {
    case DialogType::User:
      return promise.set_error(Status::Error(3, "Can't change private chat permissions"));
    case DialogType::Chat: {
      auto chat_id = dialog_id.get_chat_id();
      auto status = td_->contacts_manager_->get_chat_permissions(chat_id);
      if (!status.can_restrict_members()) {
        return promise.set_error(Status::Error(3, "Not enough rights to change chat permissions"));
      }
      break;
    }
    case DialogType::Channel: {
      if (is_broadcast_channel(dialog_id)) {
        return promise.set_error(Status::Error(3, "Can't change channel chat permissions"));
      }
      auto status = td_->contacts_manager_->get_channel_permissions(dialog_id.get_channel_id());
      if (!status.can_restrict_members()) {
        return promise.set_error(Status::Error(3, "Not enough rights to change chat permissions"));
      }
      break;
    }
    case DialogType::SecretChat:
      return promise.set_error(Status::Error(3, "Can't change secret chat permissions"));
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  auto new_permissions = get_restricted_rights(permissions);

  // TODO this can be wrong if there was previous change permissions requests
  if (get_dialog_permissions(dialog_id) == new_permissions) {
    return promise.set_value(Unit());
  }

  // TODO invoke after
  td_->create_handler<EditChatDefaultBannedRightsQuery>(std::move(promise))->send(dialog_id, new_permissions);
}

void MessagesManager::set_dialog_description(DialogId dialog_id, const string &description, Promise<Unit> &&promise) {
  LOG(INFO) << "Receive setChatDescription request to set description of " << dialog_id << " to \"" << description
            << '"';

  if (!have_dialog_force(dialog_id)) {
    return promise.set_error(Status::Error(3, "Chat not found"));
  }

  switch (dialog_id.get_type()) {
    case DialogType::User:
      return promise.set_error(Status::Error(3, "Can't change private chat description"));
    case DialogType::Chat:
      return td_->contacts_manager_->set_chat_description(dialog_id.get_chat_id(), description, std::move(promise));
    case DialogType::Channel:
      return td_->contacts_manager_->set_channel_description(dialog_id.get_channel_id(), description,
                                                             std::move(promise));
    case DialogType::SecretChat:
      return promise.set_error(Status::Error(3, "Can't change secret chat description"));
    case DialogType::None:
    default:
      UNREACHABLE();
  }
}

Status MessagesManager::can_pin_messages(DialogId dialog_id) const {
  switch (dialog_id.get_type()) {
    case DialogType::User:
      break;
    case DialogType::Chat: {
      auto chat_id = dialog_id.get_chat_id();
      auto status = td_->contacts_manager_->get_chat_permissions(chat_id);
      if (!status.can_pin_messages() ||
          (td_->auth_manager_->is_bot() && !td_->contacts_manager_->is_appointed_chat_administrator(chat_id))) {
        return Status::Error(400, "Not enough rights to manage pinned messages in the chat");
      }
      break;
    }
    case DialogType::Channel: {
      auto status = td_->contacts_manager_->get_channel_permissions(dialog_id.get_channel_id());
      bool can_pin = is_broadcast_channel(dialog_id) ? status.can_edit_messages() : status.can_pin_messages();
      if (!can_pin) {
        return Status::Error(400, "Not enough rights to manage pinned messages in the chat");
      }
      break;
    }
    case DialogType::SecretChat:
      return Status::Error(400, "Secret chats can't have pinned messages");
    case DialogType::None:
    default:
      UNREACHABLE();
  }
  if (!have_input_peer(dialog_id, AccessRights::Write)) {
    return Status::Error(400, "Not enough rights");
  }

  return Status::OK();
}

void MessagesManager::pin_dialog_message(DialogId dialog_id, MessageId message_id, bool disable_notification,
                                         bool only_for_self, bool is_unpin, Promise<Unit> &&promise) {
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(400, "Chat not found"));
  }
  TRY_STATUS_PROMISE(promise, can_pin_messages(dialog_id));

  const Message *m = get_message_force(d, message_id, "pin_dialog_message");
  if (m == nullptr) {
    return promise.set_error(Status::Error(6, "Message not found"));
  }
  if (message_id.is_scheduled()) {
    return promise.set_error(Status::Error(6, "Scheduled message can't be pinned"));
  }
  if (!message_id.is_server()) {
    return promise.set_error(Status::Error(6, "Message can't be pinned"));
  }

  if (is_service_message_content(m->content->get_type())) {
    return promise.set_error(Status::Error(6, "A service message can't be pinned"));
  }

  if (only_for_self && dialog_id.get_type() != DialogType::User) {
    return promise.set_error(Status::Error(6, "Messages can't be pinned only for self in the chat"));
  }

  // TODO log event
  td_->create_handler<UpdateDialogPinnedMessageQuery>(std::move(promise))
      ->send(dialog_id, message_id, is_unpin, disable_notification, only_for_self);
}

void MessagesManager::unpin_all_dialog_messages(DialogId dialog_id, Promise<Unit> &&promise) {
  auto d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    return promise.set_error(Status::Error(6, "Chat not found"));
  }
  TRY_STATUS_PROMISE(promise, can_pin_messages(dialog_id));

  vector<MessageId> message_ids;
  find_messages(d->messages.get(), message_ids, [](const Message *m) { return m->is_pinned; });

  vector<int64> deleted_message_ids;
  for (auto message_id : message_ids) {
    auto m = get_message(d, message_id);
    CHECK(m != nullptr);

    m->is_pinned = false;
    send_closure(G()->td(), &Td::send_update,
                 make_tl_object<td_api::updateMessageIsPinned>(d->dialog_id.get(), m->message_id.get(), m->is_pinned));
    on_message_changed(d, m, true, "unpin_all_dialog_messages");
  }

  set_dialog_last_pinned_message_id(d, MessageId());
  if (d->message_count_by_index[message_search_filter_index(MessageSearchFilter::Pinned)] != 0) {
    d->message_count_by_index[message_search_filter_index(MessageSearchFilter::Pinned)] = 0;
    on_dialog_updated(dialog_id, "unpin_all_dialog_messages");
  }

  unpin_all_dialog_messages_on_server(dialog_id, 0, std::move(promise));
}

class MessagesManager::UnpinAllDialogMessagesOnServerLogEvent {
 public:
  DialogId dialog_id_;

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(dialog_id_, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(dialog_id_, parser);
  }
};

uint64 MessagesManager::save_unpin_all_dialog_messages_on_server_log_event(DialogId dialog_id) {
  UnpinAllDialogMessagesOnServerLogEvent log_event{dialog_id};
  return binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::UnpinAllDialogMessagesOnServer,
                    get_log_event_storer(log_event));
}

void MessagesManager::unpin_all_dialog_messages_on_server(DialogId dialog_id, uint64 log_event_id,
                                                          Promise<Unit> &&promise) {
  if (log_event_id == 0 && G()->parameters().use_message_db) {
    log_event_id = save_unpin_all_dialog_messages_on_server_log_event(dialog_id);
  }

  td_->create_handler<UnpinAllMessagesQuery>(get_erase_log_event_promise(log_event_id, std::move(promise)))
      ->send(dialog_id);
}

tl_object_ptr<telegram_api::channelAdminLogEventsFilter> MessagesManager::get_channel_admin_log_events_filter(
    const tl_object_ptr<td_api::chatEventLogFilters> &filters) {
  if (filters == nullptr) {
    return nullptr;
  }

  int32 flags = 0;
  if (filters->message_edits_) {
    flags |= telegram_api::channelAdminLogEventsFilter::EDIT_MASK;
  }
  if (filters->message_deletions_) {
    flags |= telegram_api::channelAdminLogEventsFilter::DELETE_MASK;
  }
  if (filters->message_pins_) {
    flags |= telegram_api::channelAdminLogEventsFilter::PINNED_MASK;
  }
  if (filters->member_joins_) {
    flags |= telegram_api::channelAdminLogEventsFilter::JOIN_MASK;
  }
  if (filters->member_leaves_) {
    flags |= telegram_api::channelAdminLogEventsFilter::LEAVE_MASK;
  }
  if (filters->member_invites_) {
    flags |= telegram_api::channelAdminLogEventsFilter::INVITE_MASK;
  }
  if (filters->member_promotions_) {
    flags |= telegram_api::channelAdminLogEventsFilter::PROMOTE_MASK;
    flags |= telegram_api::channelAdminLogEventsFilter::DEMOTE_MASK;
  }
  if (filters->member_restrictions_) {
    flags |= telegram_api::channelAdminLogEventsFilter::BAN_MASK;
    flags |= telegram_api::channelAdminLogEventsFilter::UNBAN_MASK;
    flags |= telegram_api::channelAdminLogEventsFilter::KICK_MASK;
    flags |= telegram_api::channelAdminLogEventsFilter::UNKICK_MASK;
  }
  if (filters->info_changes_) {
    flags |= telegram_api::channelAdminLogEventsFilter::INFO_MASK;
  }
  if (filters->setting_changes_) {
    flags |= telegram_api::channelAdminLogEventsFilter::SETTINGS_MASK;
  }
  if (filters->invite_link_changes_) {
    flags |= telegram_api::channelAdminLogEventsFilter::GROUP_CALL_MASK;
  }
  if (filters->voice_chat_changes_) {
    flags |= telegram_api::channelAdminLogEventsFilter::INVITES_MASK;
  }

  return make_tl_object<telegram_api::channelAdminLogEventsFilter>(
      flags, false /*ignored*/, false /*ignored*/, false /*ignored*/, false /*ignored*/, false /*ignored*/,
      false /*ignored*/, false /*ignored*/, false /*ignored*/, false /*ignored*/, false /*ignored*/, false /*ignored*/,
      false /*ignored*/, false /*ignored*/, false /*ignored*/, false /*ignored*/, false /*ignored*/);
}

int64 MessagesManager::get_dialog_event_log(DialogId dialog_id, const string &query, int64 from_event_id, int32 limit,
                                            const tl_object_ptr<td_api::chatEventLogFilters> &filters,
                                            const vector<UserId> &user_ids, Promise<Unit> &&promise) {
  if (td_->auth_manager_->is_bot()) {
    promise.set_error(Status::Error(3, "Method is not available for bots"));
    return 0;
  }

  if (!have_dialog_force(dialog_id)) {
    promise.set_error(Status::Error(3, "Chat not found"));
    return 0;
  }

  if (dialog_id.get_type() != DialogType::Channel) {
    promise.set_error(Status::Error(3, "Chat is not a supergroup chat"));
    return 0;
  }

  auto channel_id = dialog_id.get_channel_id();
  if (!td_->contacts_manager_->have_channel(channel_id)) {
    promise.set_error(Status::Error(3, "Chat info not found"));
    return 0;
  }

  if (!td_->contacts_manager_->get_channel_status(channel_id).is_administrator()) {
    promise.set_error(Status::Error(3, "Not enough rights to get event log"));
    return 0;
  }

  vector<tl_object_ptr<telegram_api::InputUser>> input_users;
  for (auto user_id : user_ids) {
    auto input_user = td_->contacts_manager_->get_input_user(user_id);
    if (input_user == nullptr) {
      promise.set_error(Status::Error(3, "User not found"));
      return 0;
    }
    input_users.push_back(std::move(input_user));
  }

  int64 random_id = 0;
  do {
    random_id = Random::secure_int64();
  } while (random_id == 0 || chat_events_.find(random_id) != chat_events_.end());
  chat_events_[random_id];  // reserve place for result

  td_->create_handler<GetChannelAdminLogQuery>(std::move(promise))
      ->send(channel_id, query, from_event_id, limit, get_channel_admin_log_events_filter(filters),
             std::move(input_users), random_id);

  return random_id;
}

tl_object_ptr<td_api::ChatEventAction> MessagesManager::get_chat_event_action_object(
    ChannelId channel_id, tl_object_ptr<telegram_api::ChannelAdminLogEventAction> &&action_ptr) {
  CHECK(action_ptr != nullptr);
  switch (action_ptr->get_id()) {
    case telegram_api::channelAdminLogEventActionParticipantJoin::ID:
      return make_tl_object<td_api::chatEventMemberJoined>();
    case telegram_api::channelAdminLogEventActionParticipantJoinByInvite::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionParticipantJoinByInvite>(action_ptr);
      DialogInviteLink invite_link(std::move(action->invite_));
      if (!invite_link.is_valid()) {
        LOG(ERROR) << "Wrong invite link: " << invite_link;
        return nullptr;
      }
      return make_tl_object<td_api::chatEventMemberJoinedByInviteLink>(
          invite_link.get_chat_invite_link_object(td_->contacts_manager_.get()));
    }
    case telegram_api::channelAdminLogEventActionParticipantLeave::ID:
      return make_tl_object<td_api::chatEventMemberLeft>();
    case telegram_api::channelAdminLogEventActionParticipantInvite::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionParticipantInvite>(action_ptr);
      DialogParticipant dialog_participant(std::move(action->participant_));
      if (!dialog_participant.is_valid()) {
        LOG(ERROR) << "Wrong invite: " << dialog_participant;
        return nullptr;
      }
      return make_tl_object<td_api::chatEventMemberInvited>(
          td_->contacts_manager_->get_user_id_object(dialog_participant.user_id, "chatEventMemberInvited"),
          dialog_participant.status.get_chat_member_status_object());
    }
    case telegram_api::channelAdminLogEventActionParticipantToggleBan::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionParticipantToggleBan>(action_ptr);
      DialogParticipant old_dialog_participant(std::move(action->prev_participant_));
      DialogParticipant new_dialog_participant(std::move(action->new_participant_));
      if (old_dialog_participant.user_id != new_dialog_participant.user_id) {
        LOG(ERROR) << old_dialog_participant.user_id << " VS " << new_dialog_participant.user_id;
        return nullptr;
      }
      if (!old_dialog_participant.is_valid() || !new_dialog_participant.is_valid()) {
        LOG(ERROR) << "Wrong restrict: " << old_dialog_participant << " -> " << new_dialog_participant;
        return nullptr;
      }
      return make_tl_object<td_api::chatEventMemberRestricted>(
          td_->contacts_manager_->get_user_id_object(old_dialog_participant.user_id, "chatEventMemberRestricted"),
          old_dialog_participant.status.get_chat_member_status_object(),
          new_dialog_participant.status.get_chat_member_status_object());
    }
    case telegram_api::channelAdminLogEventActionParticipantToggleAdmin::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionParticipantToggleAdmin>(action_ptr);
      DialogParticipant old_dialog_participant(std::move(action->prev_participant_));
      DialogParticipant new_dialog_participant(std::move(action->new_participant_));
      if (old_dialog_participant.user_id != new_dialog_participant.user_id) {
        LOG(ERROR) << old_dialog_participant.user_id << " VS " << new_dialog_participant.user_id;
        return nullptr;
      }
      if (!old_dialog_participant.is_valid() || !new_dialog_participant.is_valid()) {
        LOG(ERROR) << "Wrong edit administrator: " << old_dialog_participant << " -> " << new_dialog_participant;
        return nullptr;
      }
      return make_tl_object<td_api::chatEventMemberPromoted>(
          td_->contacts_manager_->get_user_id_object(old_dialog_participant.user_id, "chatEventMemberPromoted"),
          old_dialog_participant.status.get_chat_member_status_object(),
          new_dialog_participant.status.get_chat_member_status_object());
    }
    case telegram_api::channelAdminLogEventActionChangeTitle::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionChangeTitle>(action_ptr);
      return make_tl_object<td_api::chatEventTitleChanged>(std::move(action->prev_value_),
                                                           std::move(action->new_value_));
    }
    case telegram_api::channelAdminLogEventActionChangeAbout::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionChangeAbout>(action_ptr);
      return make_tl_object<td_api::chatEventDescriptionChanged>(std::move(action->prev_value_),
                                                                 std::move(action->new_value_));
    }
    case telegram_api::channelAdminLogEventActionChangeUsername::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionChangeUsername>(action_ptr);
      return make_tl_object<td_api::chatEventUsernameChanged>(std::move(action->prev_value_),
                                                              std::move(action->new_value_));
    }
    case telegram_api::channelAdminLogEventActionChangePhoto::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionChangePhoto>(action_ptr);
      auto file_manager = td_->file_manager_.get();
      auto old_photo = get_photo(file_manager, std::move(action->prev_photo_), DialogId(channel_id));
      auto new_photo = get_photo(file_manager, std::move(action->new_photo_), DialogId(channel_id));
      return make_tl_object<td_api::chatEventPhotoChanged>(get_chat_photo_object(file_manager, old_photo),
                                                           get_chat_photo_object(file_manager, new_photo));
    }
    case telegram_api::channelAdminLogEventActionDefaultBannedRights::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionDefaultBannedRights>(action_ptr);
      auto old_permissions = get_restricted_rights(std::move(action->prev_banned_rights_));
      auto new_permissions = get_restricted_rights(std::move(action->new_banned_rights_));
      return make_tl_object<td_api::chatEventPermissionsChanged>(old_permissions.get_chat_permissions_object(),
                                                                 new_permissions.get_chat_permissions_object());
    }
    case telegram_api::channelAdminLogEventActionToggleInvites::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionToggleInvites>(action_ptr);
      return make_tl_object<td_api::chatEventInvitesToggled>(action->new_value_);
    }
    case telegram_api::channelAdminLogEventActionToggleSignatures::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionToggleSignatures>(action_ptr);
      return make_tl_object<td_api::chatEventSignMessagesToggled>(action->new_value_);
    }
    case telegram_api::channelAdminLogEventActionUpdatePinned::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionUpdatePinned>(action_ptr);
      auto message = create_message(
          parse_telegram_api_message(std::move(action->message_), false, "channelAdminLogEventActionUpdatePinned"),
          true);
      if (message.second == nullptr) {
        LOG(ERROR) << "Failed to get pinned message";
        return nullptr;
      }
      auto message_object = get_message_object(message.first, message.second.get(), true);
      if (message.second->is_pinned) {
        return make_tl_object<td_api::chatEventMessagePinned>(std::move(message_object));
      } else {
        return make_tl_object<td_api::chatEventMessageUnpinned>(std::move(message_object));
      }
    }
    case telegram_api::channelAdminLogEventActionEditMessage::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionEditMessage>(action_ptr);
      auto old_message = create_message(parse_telegram_api_message(std::move(action->prev_message_), false,
                                                                   "prev channelAdminLogEventActionEditMessage"),
                                        true);
      auto new_message = create_message(parse_telegram_api_message(std::move(action->new_message_), false,
                                                                   "new channelAdminLogEventActionEditMessage"),
                                        true);
      if (old_message.second == nullptr || new_message.second == nullptr || old_message.first != new_message.first) {
        LOG(ERROR) << "Failed to get edited message";
        return nullptr;
      }
      return make_tl_object<td_api::chatEventMessageEdited>(
          get_message_object(old_message.first, old_message.second.get(), true),
          get_message_object(new_message.first, new_message.second.get(), true));
    }
    case telegram_api::channelAdminLogEventActionStopPoll::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionStopPoll>(action_ptr);
      auto message = create_message(
          parse_telegram_api_message(std::move(action->message_), false, "channelAdminLogEventActionStopPoll"), true);
      if (message.second == nullptr) {
        LOG(ERROR) << "Failed to get stopped poll message";
        return nullptr;
      }
      if (message.second->content->get_type() != MessageContentType::Poll) {
        LOG(ERROR) << "Receive not a poll in channelAdminLogEventActionStopPoll";
        return nullptr;
      }
      return make_tl_object<td_api::chatEventPollStopped>(
          get_message_object(message.first, message.second.get(), true));
    }
    case telegram_api::channelAdminLogEventActionDeleteMessage::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionDeleteMessage>(action_ptr);
      auto message = create_message(
          parse_telegram_api_message(std::move(action->message_), false, "channelAdminLogEventActionDeleteMessage"),
          true);
      if (message.second == nullptr) {
        LOG(ERROR) << "Failed to get deleted message";
        return nullptr;
      }
      return make_tl_object<td_api::chatEventMessageDeleted>(
          get_message_object(message.first, message.second.get(), true));
    }
    case telegram_api::channelAdminLogEventActionChangeStickerSet::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionChangeStickerSet>(action_ptr);
      auto old_sticker_set_id = add_sticker_set(td_, std::move(action->prev_stickerset_));
      auto new_sticker_set_id = add_sticker_set(td_, std::move(action->new_stickerset_));
      return make_tl_object<td_api::chatEventStickerSetChanged>(old_sticker_set_id.get(), new_sticker_set_id.get());
    }
    case telegram_api::channelAdminLogEventActionTogglePreHistoryHidden::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionTogglePreHistoryHidden>(action_ptr);
      return make_tl_object<td_api::chatEventIsAllHistoryAvailableToggled>(!action->new_value_);
    }
    case telegram_api::channelAdminLogEventActionChangeLinkedChat::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionChangeLinkedChat>(action_ptr);

      auto get_dialog_from_channel_id = [this](int32 channel_id_int) {
        ChannelId channel_id(channel_id_int);
        if (!channel_id.is_valid()) {
          return DialogId();
        }

        DialogId dialog_id(channel_id);
        force_create_dialog(dialog_id, "get_dialog_from_channel_id");
        return dialog_id;
      };

      auto old_linked_dialog_id = get_dialog_from_channel_id(action->prev_value_);
      auto new_linked_dialog_id = get_dialog_from_channel_id(action->new_value_);
      if (old_linked_dialog_id == new_linked_dialog_id) {
        LOG(ERROR) << "Receive the same linked " << new_linked_dialog_id;
        return nullptr;
      }
      return make_tl_object<td_api::chatEventLinkedChatChanged>(old_linked_dialog_id.get(), new_linked_dialog_id.get());
    }
    case telegram_api::channelAdminLogEventActionChangeLocation::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionChangeLocation>(action_ptr);
      auto old_location = DialogLocation(std::move(action->prev_value_));
      auto new_location = DialogLocation(std::move(action->new_value_));
      return make_tl_object<td_api::chatEventLocationChanged>(old_location.get_chat_location_object(),
                                                              new_location.get_chat_location_object());
    }
    case telegram_api::channelAdminLogEventActionToggleSlowMode::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionToggleSlowMode>(action_ptr);
      auto old_slow_mode_delay = clamp(action->prev_value_, 0, 86400 * 366);
      auto new_slow_mode_delay = clamp(action->new_value_, 0, 86400 * 366);
      return make_tl_object<td_api::chatEventSlowModeDelayChanged>(old_slow_mode_delay, new_slow_mode_delay);
    }
    case telegram_api::channelAdminLogEventActionExportedInviteEdit::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionExportedInviteEdit>(action_ptr);
      DialogInviteLink old_invite_link(std::move(action->prev_invite_));
      DialogInviteLink new_invite_link(std::move(action->new_invite_));
      if (!old_invite_link.is_valid() || !new_invite_link.is_valid()) {
        LOG(ERROR) << "Wrong edited invite link: " << old_invite_link << " -> " << new_invite_link;
        return nullptr;
      }
      return make_tl_object<td_api::chatEventInviteLinkEdited>(
          old_invite_link.get_chat_invite_link_object(td_->contacts_manager_.get()),
          new_invite_link.get_chat_invite_link_object(td_->contacts_manager_.get()));
    }
    case telegram_api::channelAdminLogEventActionExportedInviteRevoke::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionExportedInviteRevoke>(action_ptr);
      DialogInviteLink invite_link(std::move(action->invite_));
      if (!invite_link.is_valid()) {
        LOG(ERROR) << "Wrong revoked invite link: " << invite_link;
        return nullptr;
      }
      return make_tl_object<td_api::chatEventInviteLinkRevoked>(
          invite_link.get_chat_invite_link_object(td_->contacts_manager_.get()));
    }
    case telegram_api::channelAdminLogEventActionExportedInviteDelete::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionExportedInviteDelete>(action_ptr);
      DialogInviteLink invite_link(std::move(action->invite_));
      if (!invite_link.is_valid()) {
        LOG(ERROR) << "Wrong deleted invite link: " << invite_link;
        return nullptr;
      }
      return make_tl_object<td_api::chatEventInviteLinkDeleted>(
          invite_link.get_chat_invite_link_object(td_->contacts_manager_.get()));
    }
    case telegram_api::channelAdminLogEventActionStartGroupCall::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionStartGroupCall>(action_ptr);
      auto input_group_call_id = InputGroupCallId(action->call_);
      if (!input_group_call_id.is_valid()) {
        return nullptr;
      }
      return make_tl_object<td_api::chatEventVoiceChatCreated>(
          td_->group_call_manager_->get_group_call_id(input_group_call_id, DialogId(channel_id)).get());
    }
    case telegram_api::channelAdminLogEventActionDiscardGroupCall::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionDiscardGroupCall>(action_ptr);
      auto input_group_call_id = InputGroupCallId(action->call_);
      if (!input_group_call_id.is_valid()) {
        return nullptr;
      }
      return make_tl_object<td_api::chatEventVoiceChatDiscarded>(
          td_->group_call_manager_->get_group_call_id(input_group_call_id, DialogId(channel_id)).get());
    }
    case telegram_api::channelAdminLogEventActionParticipantMute::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionParticipantMute>(action_ptr);
      GroupCallParticipant participant(std::move(action->participant_));
      if (!participant.is_valid()) {
        return nullptr;
      }
      return make_tl_object<td_api::chatEventVoiceChatParticipantIsMutedToggled>(
          td_->contacts_manager_->get_user_id_object(participant.user_id, "LogEventActionParticipantMute"), true);
    }
    case telegram_api::channelAdminLogEventActionParticipantUnmute::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionParticipantUnmute>(action_ptr);
      GroupCallParticipant participant(std::move(action->participant_));
      if (!participant.is_valid()) {
        return nullptr;
      }
      return make_tl_object<td_api::chatEventVoiceChatParticipantIsMutedToggled>(
          td_->contacts_manager_->get_user_id_object(participant.user_id, "LogEventActionParticipantUnmute"), false);
    }
    case telegram_api::channelAdminLogEventActionParticipantVolume::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionParticipantVolume>(action_ptr);
      GroupCallParticipant participant(std::move(action->participant_));
      if (!participant.is_valid()) {
        return nullptr;
      }
      return make_tl_object<td_api::chatEventVoiceChatParticipantVolumeLevelChanged>(
          td_->contacts_manager_->get_user_id_object(participant.user_id, "LogEventActionParticipantVolume"),
          participant.volume_level);
    }
    case telegram_api::channelAdminLogEventActionToggleGroupCallSetting::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionToggleGroupCallSetting>(action_ptr);
      return make_tl_object<td_api::chatEventVoiceChatMuteNewParticipantsToggled>(action->join_muted_);
    }
    case telegram_api::channelAdminLogEventActionChangeHistoryTTL::ID: {
      auto action = move_tl_object_as<telegram_api::channelAdminLogEventActionChangeHistoryTTL>(action_ptr);
      auto old_value = MessageTtlSetting(clamp(action->prev_value_, 0, 86400 * 366));
      auto new_value = MessageTtlSetting(clamp(action->new_value_, 0, 86400 * 366));
      return make_tl_object<td_api::chatEventMessageTtlSettingChanged>(old_value.get_message_ttl_setting_object(),
                                                                       new_value.get_message_ttl_setting_object());
    }
    default:
      UNREACHABLE();
      return nullptr;
  }
}

void MessagesManager::on_get_event_log(ChannelId channel_id, int64 random_id,
                                       tl_object_ptr<telegram_api::channels_adminLogResults> &&events) {
  auto it = chat_events_.find(random_id);
  CHECK(it != chat_events_.end());
  auto &result = it->second;
  CHECK(result == nullptr);

  if (events == nullptr) {
    chat_events_.erase(it);
    return;
  }

  LOG(INFO) << "Receive in " << channel_id << " " << to_string(events);

  td_->contacts_manager_->on_get_users(std::move(events->users_), "on_get_event_log");
  td_->contacts_manager_->on_get_chats(std::move(events->chats_), "on_get_event_log");

  result = make_tl_object<td_api::chatEvents>();
  result->events_.reserve(events->events_.size());
  for (auto &event : events->events_) {
    if (event->date_ <= 0) {
      LOG(ERROR) << "Receive wrong event date = " << event->date_;
      event->date_ = 0;
    }

    UserId user_id(event->user_id_);
    if (!user_id.is_valid()) {
      LOG(ERROR) << "Receive invalid " << user_id;
      continue;
    }
    LOG_IF(ERROR, !td_->contacts_manager_->have_user(user_id)) << "Have no info about " << user_id;

    auto action = get_chat_event_action_object(channel_id, std::move(event->action_));
    if (action == nullptr) {
      continue;
    }
    result->events_.push_back(make_tl_object<td_api::chatEvent>(
        event->id_, event->date_, td_->contacts_manager_->get_user_id_object(user_id, "chatEvent"), std::move(action)));
  }
}

tl_object_ptr<td_api::chatEvents> MessagesManager::get_chat_events_object(int64 random_id) {
  auto it = chat_events_.find(random_id);
  CHECK(it != chat_events_.end());
  auto result = std::move(it->second);
  chat_events_.erase(it);
  return result;
}

unique_ptr<MessagesManager::Message> *MessagesManager::treap_find_message(unique_ptr<Message> *v,
                                                                          MessageId message_id) {
  return const_cast<unique_ptr<Message> *>(treap_find_message(static_cast<const unique_ptr<Message> *>(v), message_id));
}

const unique_ptr<MessagesManager::Message> *MessagesManager::treap_find_message(const unique_ptr<Message> *v,
                                                                                MessageId message_id) {
  while (*v != nullptr) {
    if ((*v)->message_id < message_id) {
      v = &(*v)->right;
    } else if ((*v)->message_id > message_id) {
      v = &(*v)->left;
    } else {
      break;
    }
  }
  return v;
}

MessagesManager::Message *MessagesManager::treap_insert_message(unique_ptr<Message> *v, unique_ptr<Message> message) {
  auto message_id = message->message_id;
  while (*v != nullptr && (*v)->random_y >= message->random_y) {
    if ((*v)->message_id < message_id) {
      v = &(*v)->right;
    } else if ((*v)->message_id == message_id) {
      UNREACHABLE();
    } else {
      v = &(*v)->left;
    }
  }

  unique_ptr<Message> *left = &message->left;
  unique_ptr<Message> *right = &message->right;

  unique_ptr<Message> cur = std::move(*v);
  while (cur != nullptr) {
    if (cur->message_id < message_id) {
      *left = std::move(cur);
      left = &((*left)->right);
      cur = std::move(*left);
    } else {
      *right = std::move(cur);
      right = &((*right)->left);
      cur = std::move(*right);
    }
  }
  CHECK(*left == nullptr);
  CHECK(*right == nullptr);
  *v = std::move(message);
  return v->get();
}

unique_ptr<MessagesManager::Message> MessagesManager::treap_delete_message(unique_ptr<Message> *v) {
  unique_ptr<Message> result = std::move(*v);
  unique_ptr<Message> left = std::move(result->left);
  unique_ptr<Message> right = std::move(result->right);

  while (left != nullptr || right != nullptr) {
    if (left == nullptr || (right != nullptr && right->random_y > left->random_y)) {
      *v = std::move(right);
      v = &((*v)->left);
      right = std::move(*v);
    } else {
      *v = std::move(left);
      v = &((*v)->right);
      left = std::move(*v);
    }
  }
  CHECK(*v == nullptr);

  return result;
}

MessagesManager::Message *MessagesManager::get_message(Dialog *d, MessageId message_id) {
  return const_cast<Message *>(get_message(static_cast<const Dialog *>(d), message_id));
}

const MessagesManager::Message *MessagesManager::get_message(const Dialog *d, MessageId message_id) {
  if (!message_id.is_valid() && !message_id.is_valid_scheduled()) {
    return nullptr;
  }

  CHECK(d != nullptr);
  bool is_scheduled = message_id.is_scheduled();
  if (is_scheduled && message_id.is_scheduled_server()) {
    auto server_message_id = message_id.get_scheduled_server_message_id();
    auto it = d->scheduled_message_date.find(server_message_id);
    if (it != d->scheduled_message_date.end()) {
      int32 date = it->second;
      message_id = MessageId(server_message_id, date);
      CHECK(message_id.is_scheduled_server());
    }
  }
  auto result = treap_find_message(is_scheduled ? &d->scheduled_messages : &d->messages, message_id)->get();
  if (result != nullptr && !is_scheduled) {
    result->last_access_date = G()->unix_time_cached();
  }
  LOG(INFO) << "Search for " << message_id << " in " << d->dialog_id << " found " << result;
  return result;
}

MessagesManager::Message *MessagesManager::get_message_force(Dialog *d, MessageId message_id, const char *source) {
  if (!message_id.is_valid() && !message_id.is_valid_scheduled()) {
    return nullptr;
  }

  auto result = get_message(d, message_id);
  if (result != nullptr) {
    return result;
  }

  if (!G()->parameters().use_message_db || message_id.is_yet_unsent()) {
    return nullptr;
  }

  if (d->deleted_message_ids.count(message_id)) {
    return nullptr;
  }

  if (message_id.is_scheduled()) {
    if (d->has_loaded_scheduled_messages_from_database) {
      return nullptr;
    }
    if (message_id.is_scheduled_server() &&
        d->deleted_scheduled_server_message_ids.count(message_id.get_scheduled_server_message_id())) {
      return nullptr;
    }
  }

  LOG(INFO) << "Trying to load " << FullMessageId{d->dialog_id, message_id} << " from database from " << source;

  auto r_value = G()->td_db()->get_messages_db_sync()->get_message({d->dialog_id, message_id});
  if (r_value.is_error()) {
    return nullptr;
  }
  return on_get_message_from_database(d->dialog_id, d, r_value.ok(), message_id.is_scheduled(), source);
}

MessagesManager::Message *MessagesManager::on_get_message_from_database(DialogId dialog_id, Dialog *d,
                                                                        const BufferSlice &value, bool is_scheduled,
                                                                        const char *source) {
  if (value.empty()) {
    return nullptr;
  }

  auto m = parse_message(dialog_id, std::move(value), is_scheduled);
  if (m == nullptr) {
    return nullptr;
  }

  if (d == nullptr) {
    LOG(ERROR) << "Can't find " << dialog_id << ", but have a message from it from " << source;
    if (!dialog_id.is_valid()) {
      LOG(ERROR) << "Got message in invalid " << dialog_id << " from " << source;
      return nullptr;
    }

    if (m->message_id.is_valid() && m->message_id.is_any_server() &&
        (dialog_id.get_type() == DialogType::User || dialog_id.get_type() == DialogType::Chat)) {
      get_message_from_server({dialog_id, m->message_id}, Auto());
    }

    force_create_dialog(dialog_id, source);
    d = get_dialog_force(dialog_id);
    CHECK(d != nullptr);
  }

  if (!have_input_peer(d->dialog_id, AccessRights::Read)) {
    return nullptr;
  }

  auto old_message = get_message(d, m->message_id);
  if (old_message != nullptr) {
    // data in the database is always outdated, so return a message from the memory
    if (dialog_id.get_type() == DialogType::SecretChat) {
      CHECK(!is_scheduled);
      // just in case restore random_id to message_id corespondence
      // can be needed if there was newer unloaded message with the same random_id
      add_random_id_to_message_id_correspondence(d, old_message->random_id, old_message->message_id);
    }

    if (old_message->notification_id.is_valid() && !is_scheduled) {
      add_notification_id_to_message_id_correspondence(d, old_message->notification_id, old_message->message_id);
    }

    return old_message;
  }

  Dependencies dependencies;
  add_message_dependencies(dependencies, d->dialog_id, m.get());
  resolve_dependencies_force(td_, dependencies, "get_message");

  m->have_previous = false;
  m->have_next = false;
  m->from_database = true;
  bool need_update = false;
  bool need_update_dialog_pos = false;
  auto result = add_message_to_dialog(d, std::move(m), false, &need_update, &need_update_dialog_pos, source);
  if (need_update_dialog_pos) {
    LOG(ERROR) << "Need update dialog pos after load " << (result == nullptr ? MessageId() : result->message_id)
               << " in " << d->dialog_id << " from " << source;
    send_update_chat_last_message(d, source);
  }
  return result;
}

int32 MessagesManager::get_random_y(MessageId message_id) {
  return static_cast<int32>(static_cast<uint32>(message_id.get() * 2101234567u));
}

void MessagesManager::set_message_id(unique_ptr<Message> &message, MessageId message_id) {
  message->message_id = message_id;
  message->random_y = get_random_y(message_id);
}

MessagesManager::Message *MessagesManager::add_message_to_dialog(DialogId dialog_id, unique_ptr<Message> message,
                                                                 bool from_update, bool *need_update,
                                                                 bool *need_update_dialog_pos, const char *source) {
  CHECK(message != nullptr);
  CHECK(dialog_id.get_type() != DialogType::None);
  CHECK(need_update_dialog_pos != nullptr);

  MessageId message_id = message->message_id;
  if (!message_id.is_valid() && !message_id.is_valid_scheduled()) {
    LOG(ERROR) << "Receive " << message_id << " in " << dialog_id << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "invalid message identifier";
    return nullptr;
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    d = add_dialog(dialog_id);
    *need_update_dialog_pos = true;
  } else {
    CHECK(d->dialog_id == dialog_id);
  }
  return add_message_to_dialog(d, std::move(message), from_update, need_update, need_update_dialog_pos, source);
}

MessagesManager::Message *MessagesManager::add_message_to_dialog(Dialog *d, unique_ptr<Message> message,
                                                                 bool from_update, bool *need_update,
                                                                 bool *need_update_dialog_pos, const char *source) {
  CHECK(message != nullptr);
  CHECK(d != nullptr);
  CHECK(need_update != nullptr);
  CHECK(need_update_dialog_pos != nullptr);
  CHECK(source != nullptr);
  debug_add_message_to_dialog_fail_reason_ = "success";

  auto debug_have_previous = message->have_previous;
  auto debug_have_next = message->have_next;

  DialogId dialog_id = d->dialog_id;
  MessageId message_id = message->message_id;

  if (!has_message_sender_user_id(dialog_id, message.get()) && !message->sender_dialog_id.is_valid()) {
    if (is_broadcast_channel(dialog_id)) {
      message->sender_dialog_id = dialog_id;
    } else {
      if (is_discussion_message(dialog_id, message.get())) {
        message->sender_dialog_id = message->forward_info->from_dialog_id;
      } else {
        LOG(ERROR) << "Failed to repair sender chat in " << message_id << " in " << dialog_id;
      }
    }
  }
  if (!message->top_thread_message_id.is_valid() && !is_broadcast_channel(dialog_id) &&
      is_visible_message_reply_info(dialog_id, message.get())) {
    message->top_thread_message_id = message_id;
  }

  if (!message_id.is_scheduled() && message_id <= d->last_clear_history_message_id) {
    LOG(INFO) << "Skip adding cleared " << message_id << " to " << dialog_id << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "cleared full history";
    return nullptr;
  }
  if (d->deleted_message_ids.count(message->reply_to_message_id)) {
    // LOG(INFO) << "Remove reply to deleted " << message->reply_to_message_id << " in " << message_id << " from " << dialog_id << " from " << source;
    // we don't want to lose information that the message was a reply
    // message->reply_to_message_id = MessageId();
  }

  LOG(INFO) << "Adding " << message_id << " of type " << message->content->get_type() << " to " << dialog_id << " from "
            << source << ". Last new is " << d->last_new_message_id << ", last is " << d->last_message_id
            << ", from_update = " << from_update << ", have_previous = " << message->have_previous
            << ", have_next = " << message->have_next;

  if (!message_id.is_valid()) {
    if (message_id.is_valid_scheduled()) {
      return add_scheduled_message_to_dialog(d, std::move(message), from_update, need_update, source);
    }
    LOG(ERROR) << "Receive " << message_id << " in " << dialog_id << " from " << source;
    CHECK(!message->from_database);
    debug_add_message_to_dialog_fail_reason_ = "invalid message identifier";
    return nullptr;
  }

  if (*need_update) {
    CHECK(from_update);
  }

  if (d->deleted_message_ids.count(message_id)) {
    LOG(INFO) << "Skip adding deleted " << message_id << " to " << dialog_id << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "adding deleted message";
    return nullptr;
  }

  auto message_content_type = message->content->get_type();
  if (is_debug_message_op_enabled()) {
    d->debug_message_op.emplace_back(Dialog::MessageOp::Add, message_id, message_content_type, from_update,
                                     message->have_previous, message->have_next, source);
  }

  message->last_access_date = G()->unix_time_cached();

  if (from_update) {
    CHECK(message->have_next);
    CHECK(message->have_previous);
    if (message_id <= d->last_new_message_id && dialog_id.get_type() != DialogType::Channel) {
      if (!G()->parameters().use_message_db) {
        if (td_->auth_manager_->is_bot() && Time::now() > start_time_ + 300 &&
            MessageId(ServerMessageId(100)) <= message_id && message_id <= MessageId(ServerMessageId(1000)) &&
            d->last_new_message_id >= MessageId(ServerMessageId(2147483000))) {
          LOG(FATAL) << "Force restart because of message_id overflow in " << dialog_id << " from "
                     << d->last_new_message_id << " to " << message_id;
        }
        LOG(ERROR) << "New " << message_id << " in " << dialog_id << " from " << source
                   << " has id less than last_new_message_id = " << d->last_new_message_id;
        dump_debug_message_op(d);
      }
    }
  }

  if (!from_update && !message->is_failed_to_send) {
    MessageId max_message_id;
    if (message_id.is_server()) {
      if (d->being_added_message_id.is_valid()) {
        // if a too new message not from update has failed to preload before being_added_message_id was set,
        // then it should fail to load even after it is set and last_new_message_id has changed
        max_message_id = d->being_updated_last_new_message_id;
      } else {
        max_message_id = d->last_new_message_id;
      }
    } else if (message_id.is_local()) {
      if (d->being_added_message_id.is_valid()) {
        max_message_id = d->being_updated_last_database_message_id;
      } else {
        max_message_id = d->last_database_message_id;
      }
    }
    if (max_message_id != MessageId() && message_id > max_message_id) {
      if (!message->from_database) {
        LOG(ERROR) << "Ignore " << message_id << " in " << dialog_id << " received not through update from " << source
                   << ". Last is " << max_message_id << ", channel difference " << debug_channel_difference_dialog_
                   << " " << to_string(get_message_object(dialog_id, message.get()));
        dump_debug_message_op(d, 3);

        // keep consistent with need_channel_difference_to_add_message
        if (dialog_id.get_type() == DialogType::Channel && have_input_peer(dialog_id, AccessRights::Read) &&
            dialog_id != debug_channel_difference_dialog_) {
          LOG(INFO) << "Schedule getDifference in " << dialog_id.get_channel_id();
          channel_get_difference_retry_timeout_.add_timeout_in(dialog_id.get(), 0.001);
        }
      } else {
        LOG(INFO) << "Ignore " << message_id << " in " << dialog_id << " received not through update from " << source;
      }
      debug_add_message_to_dialog_fail_reason_ = "too new message not from update";
      return nullptr;
    }
  }
  if ((message_id.is_server() || (message_id.is_local() && dialog_id.get_type() == DialogType::SecretChat)) &&
      message_id <= d->max_unavailable_message_id) {
    LOG(INFO) << "Can't add an unavailable " << message_id << " to " << dialog_id << " from " << source;
    if (message->from_database) {
      delete_message_from_database(d, message_id, message.get(), true);
    }
    debug_add_message_to_dialog_fail_reason_ = "ignore unavailable message";
    return nullptr;
  }

  if (message_content_type == MessageContentType::ChatDeleteHistory) {
    {
      auto m = delete_message(d, message_id, true, need_update_dialog_pos, "message chat delete history");
      if (m != nullptr) {
        send_update_delete_messages(dialog_id, {m->message_id.get()}, true, false);
      }
    }
    int32 last_message_date = 0;
    if (d->last_message_id != MessageId()) {
      auto last_message = get_message(d, d->last_message_id);
      CHECK(last_message != nullptr);
      last_message_date = last_message->date - 1;
    } else {
      last_message_date = d->last_clear_history_date;
    }
    if (message->date > last_message_date) {
      set_dialog_last_clear_history_date(d, message->date, message_id, "update_last_clear_history_date");
      *need_update_dialog_pos = true;
    }
    LOG(INFO) << "Process MessageChatDeleteHistory in " << message_id << " in " << dialog_id << " with date "
              << message->date << " from " << source;
    CHECK(!message->from_database);
    debug_add_message_to_dialog_fail_reason_ = "skip adding MessageChatDeleteHistory";
    return nullptr;
  }

  if (*need_update && message_id <= d->last_new_message_id && !td_->auth_manager_->is_bot()) {
    *need_update = false;
  }

  if (message->reply_markup != nullptr &&
      (message->reply_markup->type == ReplyMarkup::Type::RemoveKeyboard ||
       (message->reply_markup->type == ReplyMarkup::Type::ForceReply && !message->reply_markup->is_personal)) &&
      !td_->auth_manager_->is_bot()) {
    if (*need_update && message->reply_markup->is_personal) {  // if this keyboard is for us
      if (d->reply_markup_message_id != MessageId()) {
        const Message *old_message = get_message_force(d, d->reply_markup_message_id, "add_message_to_dialog 1");
        if (old_message == nullptr ||
            (old_message->sender_user_id.is_valid() && old_message->sender_user_id == message->sender_user_id)) {
          set_dialog_reply_markup(d, MessageId());
        }
      }
    }
    message->had_reply_markup = message->reply_markup->is_personal;
    message->reply_markup = nullptr;
  }

  bool auto_attach = message->have_previous && message->have_next &&
                     (from_update || message_id.is_local() || message_id.is_yet_unsent());

  {
    Message *m = message->from_database ? get_message(d, message_id)
                                        : get_message_force(d, message_id, "add_message_to_dialog 2");
    if (m != nullptr) {
      LOG(INFO) << "Adding already existing " << message_id << " in " << dialog_id << " from " << source;
      if (*need_update) {
        *need_update = false;
        if (!G()->parameters().use_message_db) {
          // can happen for bots if the message is received first through getMessage in an unknown chat without
          // last_new_message_id and only after that received through getDifference or getChannelDifference
          if (d->last_new_message_id.is_valid()) {
            LOG(ERROR) << "Receive again " << (message->is_outgoing ? "outgoing" : "incoming")
                       << (message->forward_info == nullptr ? " not" : "") << " forwarded " << message_id
                       << " with content of type " << message_content_type << " in " << dialog_id << " from " << source
                       << ", current last new is " << d->last_new_message_id << ", last is " << d->last_message_id;
            dump_debug_message_op(d, 1);
          }
        }
      }
      if (auto_attach) {
        CHECK(message->have_previous);
        CHECK(message->have_next);
        message->have_previous = false;
        message->have_next = false;
      }
      if (!message->from_database) {
        const int32 INDEX_MASK_MASK = ~message_search_filter_index_mask(MessageSearchFilter::UnreadMention);
        auto old_index_mask = get_message_index_mask(dialog_id, m) & INDEX_MASK_MASK;
        bool was_deleted = delete_active_live_location(dialog_id, m);
        auto old_file_ids = get_message_content_file_ids(m->content.get(), td_);
        bool need_send_update = update_message(d, m, std::move(message), need_update_dialog_pos);
        if (!need_send_update) {
          LOG(INFO) << message_id << " in " << dialog_id << " is not changed";
        }
        auto new_index_mask = get_message_index_mask(dialog_id, m) & INDEX_MASK_MASK;
        if (was_deleted) {
          try_add_active_live_location(dialog_id, m);
        }
        change_message_files(dialog_id, m, old_file_ids);
        if (need_send_update && m->notification_id.is_valid() && is_message_notification_active(d, m)) {
          auto &group_info = get_notification_group_info(d, m);
          if (group_info.group_id.is_valid()) {
            send_closure_later(G()->notification_manager(), &NotificationManager::edit_notification,
                               group_info.group_id, m->notification_id, create_new_message_notification(m->message_id));
          }
        }
        if (need_send_update && m->is_pinned && d->pinned_message_notification_message_id.is_valid() &&
            d->mention_notification_group.group_id.is_valid()) {
          auto pinned_message = get_message_force(d, d->pinned_message_notification_message_id, "after update_message");
          if (pinned_message != nullptr && pinned_message->notification_id.is_valid() &&
              is_message_notification_active(d, pinned_message) &&
              get_message_content_pinned_message_id(pinned_message->content.get()) == message_id) {
            send_closure_later(G()->notification_manager(), &NotificationManager::edit_notification,
                               d->mention_notification_group.group_id, pinned_message->notification_id,
                               create_new_message_notification(pinned_message->message_id));
          }
        }
        update_message_count_by_index(d, -1, old_index_mask & ~new_index_mask);
        update_message_count_by_index(d, +1, new_index_mask & ~old_index_mask);
      }
      return m;
    }
  }

  if (*need_update && !td_->auth_manager_->is_bot()) {
    if (message_content_type == MessageContentType::PinMessage) {
      if (is_dialog_pinned_message_notifications_disabled(d) ||
          !get_message_content_pinned_message_id(message->content.get()).is_valid()) {
        // treat message pin without pinned message as an ordinary message
        message->contains_mention = false;
      }
    } else if (message->contains_mention && is_dialog_mention_notifications_disabled(d)) {
      // disable mention notification
      message->is_mention_notification_disabled = true;
    }
  }

  if (message->contains_unread_mention && message_id <= d->last_read_all_mentions_message_id) {
    LOG(INFO) << "Ignore unread mention in " << message_id;
    message->contains_unread_mention = false;
    if (message->from_database) {
      on_message_changed(d, message.get(), false, "add already read mention message to dialog");
    }
  }

  if (*need_update && may_need_message_notification(d, message.get())) {
    // notification group must be created here because it may force adding new messages from database
    // in get_message_notification_group_force
    get_dialog_notification_group_id(d->dialog_id, get_notification_group_info(d, message.get()));
  }
  if (*need_update || (!d->last_new_message_id.is_valid() && !message_id.is_yet_unsent() && from_update)) {
    auto pinned_message_id = get_message_content_pinned_message_id(message->content.get());
    if (pinned_message_id.is_valid() && pinned_message_id < message_id &&
        have_message_force({dialog_id, pinned_message_id}, "preload pinned message")) {
      LOG(INFO) << "Preloaded pinned " << pinned_message_id << " from database";
    }

    if (d->pinned_message_notification_message_id.is_valid() &&
        d->pinned_message_notification_message_id != message_id &&
        have_message_force({dialog_id, d->pinned_message_notification_message_id},
                           "preload previously pinned message")) {
      LOG(INFO) << "Preloaded previously pinned " << d->pinned_message_notification_message_id << " from database";
    }
  }
  if (from_update && message->top_thread_message_id.is_valid() && message->top_thread_message_id != message_id &&
      message_id.is_server() &&
      have_message_force({dialog_id, message->top_thread_message_id}, "preload top reply message")) {
    LOG(INFO) << "Preloaded top thread " << message->top_thread_message_id << " from database";

    Message *top_m = get_message(d, message->top_thread_message_id);
    CHECK(top_m != nullptr);
    if (is_active_message_reply_info(dialog_id, top_m->reply_info) && is_discussion_message(dialog_id, top_m) &&
        have_message_force({top_m->forward_info->from_dialog_id, top_m->forward_info->from_message_id},
                           "preload discussed message")) {
      LOG(INFO) << "Preloaded discussed "
                << FullMessageId{top_m->forward_info->from_dialog_id, top_m->forward_info->from_message_id}
                << " from database";
    }
  }

  // there must be no two recursive calls to add_message_to_dialog
  LOG_CHECK(!d->being_added_message_id.is_valid())
      << d->dialog_id << " " << d->being_added_message_id << " " << message_id << " " << *need_update << " "
      << d->pinned_message_notification_message_id << " " << d->last_new_message_id << " " << source;
  LOG_CHECK(!d->being_deleted_message_id.is_valid())
      << d->being_deleted_message_id << " " << message_id << " " << source;

  d->being_added_message_id = message_id;
  d->being_updated_last_new_message_id = d->last_new_message_id;
  d->being_updated_last_database_message_id = d->last_database_message_id;

  if (d->new_secret_chat_notification_id.is_valid()) {
    remove_new_secret_chat_notification(d, true);
  }

  if (message->message_id > d->max_added_message_id) {
    d->max_added_message_id = message->message_id;
  }

  if (d->have_full_history && !message->from_database && !from_update && !message_id.is_local() &&
      !message_id.is_yet_unsent()) {
    LOG(ERROR) << "Have full history in " << dialog_id << ", but receive unknown " << message_id
               << " with content of type " << message_content_type << " from " << source << ". Last new is "
               << d->last_new_message_id << ", last is " << d->last_message_id << ", first database is "
               << d->first_database_message_id << ", last database is " << d->last_database_message_id
               << ", last read inbox is " << d->last_read_inbox_message_id << ", last read outbox is "
               << d->last_read_inbox_message_id << ", last read all mentions is "
               << d->last_read_all_mentions_message_id << ", max unavailable is " << d->max_unavailable_message_id
               << ", last assigned is " << d->last_assigned_message_id;
    d->have_full_history = false;
    on_dialog_updated(dialog_id, "drop have_full_history");
  }

  if (!d->is_opened && d->messages != nullptr && is_message_unload_enabled() && !d->has_unload_timeout) {
    LOG(INFO) << "Schedule unload of " << dialog_id;
    pending_unload_dialog_timeout_.add_timeout_in(dialog_id.get(), get_unload_dialog_delay());
    d->has_unload_timeout = true;
  }

  if (message->ttl > 0 && message->ttl_expires_at != 0) {
    auto now = Time::now();
    if (message->ttl_expires_at <= now) {
      if (dialog_id.get_type() == DialogType::SecretChat) {
        LOG(INFO) << "Can't add " << message_id << " with expired TTL to " << dialog_id << " from " << source;
        delete_message_from_database(d, message_id, message.get(), true);
        debug_add_message_to_dialog_fail_reason_ = "delete expired by TTL message";
        d->being_added_message_id = MessageId();
        return nullptr;
      } else {
        on_message_ttl_expired_impl(d, message.get());
        message_content_type = message->content->get_type();
        if (message->from_database) {
          on_message_changed(d, message.get(), false, "add expired message to dialog");
        }
      }
    } else {
      ttl_register_message(dialog_id, message.get(), now);
    }
  }
  if (message->ttl_period > 0) {
    CHECK(dialog_id.get_type() != DialogType::SecretChat);
    auto server_time = G()->server_time();
    if (message->date + message->ttl_period <= server_time) {
      LOG(INFO) << "Can't add " << message_id << " with expired TTL period to " << dialog_id << " from " << source;
      delete_message_from_database(d, message_id, message.get(), true);
      debug_add_message_to_dialog_fail_reason_ = "delete expired by TTL period message";
      d->being_added_message_id = MessageId();
      return nullptr;
    } else {
      ttl_period_register_message(dialog_id, message.get(), server_time);
    }
  }

  LOG(INFO) << "Adding not found " << message_id << " to " << dialog_id << " from " << source;
  if (d->is_empty) {
    d->is_empty = false;
    *need_update_dialog_pos = true;
  }

  if (dialog_id.get_type() == DialogType::Channel && !message->contains_unread_mention) {
    auto channel_read_media_period =
        G()->shared_config().get_option_integer("channels_read_media_period", (G()->is_test_dc() ? 300 : 7 * 86400));
    if (message->date < G()->unix_time_cached() - channel_read_media_period) {
      update_opened_message_content(message->content.get());
    }
  }

  if (G()->parameters().use_file_db && message_id.is_yet_unsent() && !message->via_bot_user_id.is_valid() &&
      !message->hide_via_bot && !message->is_copy) {
    auto queue_id = get_sequence_dispatcher_id(dialog_id, message_content_type);
    if (queue_id & 1) {
      LOG(INFO) << "Add " << message_id << " from " << source << " to queue " << queue_id;
      yet_unsent_media_queues_[queue_id][message_id];  // reserve place for promise
      if (!td_->auth_manager_->is_bot()) {
        pending_send_dialog_action_timeout_.add_timeout_in(dialog_id.get(), 1.0);
      }
    }
  }

  if (!(d->have_full_history && auto_attach) && d->last_message_id.is_valid() &&
      d->last_message_id < MessageId(ServerMessageId(1)) && message_id >= MessageId(ServerMessageId(1))) {
    set_dialog_last_message_id(d, MessageId(), "add_message_to_dialog");

    set_dialog_first_database_message_id(d, MessageId(), "add_message_to_dialog");
    set_dialog_last_database_message_id(d, MessageId(), source);
    d->have_full_history = false;
    invalidate_message_indexes(d);
    d->local_unread_count = 0;  // read all local messages. They will not be reachable anymore

    on_dialog_updated(dialog_id, "add gap to dialog");

    send_update_chat_last_message(d, "add gap to dialog");
    *need_update_dialog_pos = false;
  }

  if (from_update && message_id > d->last_new_message_id && !message_id.is_yet_unsent()) {
    if (dialog_id.get_type() == DialogType::SecretChat || message_id.is_server()) {
      // can delete messages, therefore must be called before message attaching/adding
      set_dialog_last_new_message_id(d, message_id, "add_message_to_dialog");
    }
  }

  bool is_attached = false;
  if (auto_attach) {
    auto it = MessagesIterator(d, message_id);
    Message *previous_message = *it;
    if (previous_message != nullptr) {
      auto previous_message_id = previous_message->message_id;
      CHECK(previous_message_id < message_id);
      if (previous_message->have_next || (d->last_message_id.is_valid() && previous_message_id >= d->last_message_id)) {
        if (message_id.is_server() && previous_message_id.is_server() && previous_message->have_next) {
          ++it;
          auto next_message = *it;
          if (next_message != nullptr) {
            if (next_message->message_id.is_server()) {
              LOG(ERROR) << "Attach " << message_id << " from " << source << " before " << next_message->message_id
                         << " and after " << previous_message_id << " in " << dialog_id;
              dump_debug_message_op(d);
            }
          } else {
            LOG(ERROR) << "Have_next is true, but there is no next message after " << previous_message_id << " from "
                       << source << " in " << dialog_id;
            dump_debug_message_op(d);
          }
        }

        LOG(INFO) << "Attach " << message_id << " to the previous " << previous_message_id << " in " << dialog_id;
        message->have_previous = true;
        message->have_next = previous_message->have_next;
        previous_message->have_next = true;
        is_attached = true;
      }
    }
    if (!is_attached && !message_id.is_yet_unsent()) {
      // message may be attached to the next message if there is no previous message
      Message *cur = d->messages.get();
      Message *next_message = nullptr;
      while (cur != nullptr) {
        if (cur->message_id < message_id) {
          cur = cur->right.get();
        } else {
          next_message = cur;
          cur = cur->left.get();
        }
      }
      if (next_message != nullptr) {
        CHECK(!next_message->have_previous);
        LOG(INFO) << "Attach " << message_id << " to the next " << next_message->message_id << " in " << dialog_id;
        if (from_update && !next_message->message_id.is_yet_unsent()) {
          LOG(ERROR) << "Attach " << message_id << " from " << source << " to the next " << next_message->message_id
                     << " in " << dialog_id;
        }
        message->have_next = true;
        message->have_previous = next_message->have_previous;
        next_message->have_previous = true;
        is_attached = true;
      }
    }
    if (!is_attached) {
      LOG(INFO) << "Can't auto-attach " << message_id << " in " << dialog_id;
      message->have_previous = false;
      message->have_next = false;
    }
  }

  if (!td_->auth_manager_->is_bot()) {
    if (*need_update) {
      // notification must be added before updating unread_count to have correct total notification count
      // in get_message_notification_group_force
      add_new_message_notification(d, message.get(), false);
    } else {
      if (message->from_database && message->notification_id.is_valid() &&
          is_from_mention_notification_group(d, message.get()) && is_message_notification_active(d, message.get()) &&
          is_dialog_mention_notifications_disabled(d) && message_id != d->pinned_message_notification_message_id) {
        auto notification_id = message->notification_id;
        VLOG(notifications) << "Remove mention " << notification_id << " in " << message_id << " in " << dialog_id;
        message->notification_id = NotificationId();
        if (d->mention_notification_group.last_notification_id == notification_id) {
          // last notification is deleted, need to find new last notification
          fix_dialog_last_notification_id(d, true, message_id);
        }

        send_closure_later(G()->notification_manager(), &NotificationManager::remove_notification,
                           d->mention_notification_group.group_id, notification_id, false, false, Promise<Unit>(),
                           "remove disabled mention notification");

        on_message_changed(d, message.get(), false, "remove_mention_notification");
      }
    }
  }

  if (*need_update && message_id > d->last_read_inbox_message_id && !td_->auth_manager_->is_bot()) {
    if (has_incoming_notification(dialog_id, message.get())) {
      int32 server_unread_count = d->server_unread_count;
      int32 local_unread_count = d->local_unread_count;
      if (message_id.is_server()) {
        server_unread_count++;
      } else {
        local_unread_count++;
      }
      set_dialog_last_read_inbox_message_id(d, MessageId::min(), server_unread_count, local_unread_count, false,
                                            source);
    } else {
      // if non-scheduled outgoing message has id one greater than last_read_inbox_message_id,
      // then definitely there are no unread incoming messages before it
      if (message_id.is_server() && d->last_read_inbox_message_id.is_valid() &&
          d->last_read_inbox_message_id.is_server() &&
          message_id.get_server_message_id().get() == d->last_read_inbox_message_id.get_server_message_id().get() + 1) {
        read_history_inbox(dialog_id, message_id, 0, "add_message_to_dialog");
      }
    }
  }
  if (*need_update && message->contains_unread_mention) {
    set_dialog_unread_mention_count(d, d->unread_mention_count + 1);
    send_update_chat_unread_mention_count(d);
  }
  if (*need_update) {
    update_message_count_by_index(d, +1, message.get());
  }
  if (auto_attach && message_id > d->last_message_id && message_id >= d->last_new_message_id) {
    set_dialog_last_message_id(d, message_id, "add_message_to_dialog");
    *need_update_dialog_pos = true;
  }
  if (auto_attach && !message_id.is_yet_unsent() && message_id >= d->last_new_message_id &&
      (d->last_new_message_id.is_valid() ||
       (message_id.is_local() && d->last_message_id.is_valid() &&
        (message_id >= d->last_message_id ||
         (d->last_database_message_id.is_valid() && message_id > d->last_database_message_id))))) {
    CHECK(message_id <= d->last_message_id);
    if (message_id > d->last_database_message_id) {
      set_dialog_last_database_message_id(d, message_id, "add_message_to_dialog");
      if (!d->first_database_message_id.is_valid()) {
        set_dialog_first_database_message_id(d, message_id, "add_message_to_dialog");
        try_restore_dialog_reply_markup(d, message.get());
      }
    }
  }

  const Message *m = message.get();
  if (m->message_id.is_yet_unsent() && m->reply_to_message_id.is_valid() && !m->reply_to_message_id.is_yet_unsent()) {
    replied_by_yet_unsent_messages_[FullMessageId{dialog_id, m->reply_to_message_id}]++;
  }

  if (!m->from_database && !m->message_id.is_yet_unsent()) {
    add_message_to_database(d, m, "add_message_to_dialog");
  }

  if (from_update && dialog_id.get_type() == DialogType::Channel) {
    auto now = max(G()->unix_time_cached(), m->date);
    if (m->date < now - 2 * 86400 && Slice(source) == Slice("updateNewChannelMessage")) {
      // if the message is pretty old, we might have missed the update that the message has already been read
      repair_channel_server_unread_count(d);
    }
    if (m->date + 3600 >= now && m->is_outgoing) {
      auto channel_id = dialog_id.get_channel_id();
      auto slow_mode_delay = td_->contacts_manager_->get_channel_slow_mode_delay(channel_id);
      auto status = td_->contacts_manager_->get_channel_status(dialog_id.get_channel_id());
      if (m->date + slow_mode_delay > now && !status.is_administrator()) {
        td_->contacts_manager_->on_update_channel_slow_mode_next_send_date(channel_id, m->date + slow_mode_delay);
      }
    }
    if (m->date > now - 14 * 86400) {
      td_->contacts_manager_->remove_inactive_channel(dialog_id.get_channel_id());
    }
  }

  if (!is_attached && !m->have_next && !m->have_previous) {
    MessagesIterator it(d, m->message_id);
    if (*it != nullptr && (*it)->have_next) {
      // need to drop a connection between messages
      auto previous_message = *it;
      ++it;
      auto next_message = *it;
      if (next_message != nullptr) {
        if (next_message->message_id.is_server() &&
            !(td_->auth_manager_->is_bot() && Slice(source) == Slice("GetChannelMessagesQuery"))) {
          LOG(ERROR) << "Can't attach " << m->message_id << " from " << source << " before " << next_message->message_id
                     << " and after " << previous_message->message_id << " in " << dialog_id;
          dump_debug_message_op(d);
        }

        next_message->have_previous = false;
        previous_message->have_next = false;
      } else {
        LOG(ERROR) << "Have_next is true, but there is no next message after " << previous_message->message_id
                   << " from " << source << " in " << dialog_id;
        dump_debug_message_op(d);
      }
    }
  }

  if (message_content_type == MessageContentType::ContactRegistered && !d->has_contact_registered_message) {
    d->has_contact_registered_message = true;
    on_dialog_updated(dialog_id, "update_has_contact_registered_message");
  }

  reget_message_from_server_if_needed(dialog_id, m);

  add_message_file_sources(dialog_id, m);

  register_message_content(td_, m->content.get(), {dialog_id, m->message_id}, "add_message_to_dialog");

  if (*need_update && m->message_id.is_server() && message_content_type == MessageContentType::PinMessage) {
    auto pinned_message_id = get_message_content_pinned_message_id(m->content.get());
    if (d->is_last_pinned_message_id_inited && pinned_message_id > d->last_pinned_message_id) {
      on_update_dialog_last_pinned_message_id(dialog_id, pinned_message_id);
    }
  }

  if (from_update) {
    speculatively_update_channel_participants(dialog_id, m);
    update_sent_message_contents(dialog_id, m);
    update_used_hashtags(dialog_id, m);
    update_top_dialogs(dialog_id, m);
    cancel_user_dialog_action(dialog_id, m);
    try_hide_distance(dialog_id, m);

    if (!td_->auth_manager_->is_bot() && d->messages == nullptr && !m->is_outgoing && dialog_id != get_my_dialog_id()) {
      switch (dialog_id.get_type()) {
        case DialogType::User:
          td_->contacts_manager_->invalidate_user_full(dialog_id.get_user_id());
          td_->contacts_manager_->reload_user_full(dialog_id.get_user_id());
          break;
        case DialogType::Chat:
        case DialogType::Channel:
          // nothing to do
          break;
        case DialogType::SecretChat: {
          auto user_id = td_->contacts_manager_->get_secret_chat_user_id(dialog_id.get_secret_chat_id());
          if (user_id.is_valid()) {
            td_->contacts_manager_->invalidate_user_full(user_id);
            td_->contacts_manager_->reload_user_full(user_id);
          }
          break;
        }
        case DialogType::None:
        default:
          UNREACHABLE();
      }
    }
  }

  Message *result_message = treap_insert_message(&d->messages, std::move(message));
  CHECK(result_message != nullptr);
  CHECK(result_message == m);
  CHECK(d->messages != nullptr);

  if (!is_attached) {
    if (m->have_next) {
      LOG_CHECK(!m->have_previous) << auto_attach << " " << dialog_id << " " << m->message_id << " " << from_update
                                   << " " << *need_update << " " << d->being_updated_last_new_message_id << " "
                                   << d->last_new_message_id << " " << d->being_updated_last_database_message_id << " "
                                   << d->last_database_message_id << " " << debug_have_previous << " "
                                   << debug_have_next << " " << source;
      attach_message_to_next(d, m->message_id, source);
    } else if (m->have_previous) {
      attach_message_to_previous(d, m->message_id, source);
    }
  }

  if (m->message_id.is_yet_unsent() && m->top_thread_message_id.is_valid()) {
    auto is_inserted = d->yet_unsent_thread_message_ids[m->top_thread_message_id].insert(m->message_id).second;
    CHECK(is_inserted);
  }

  switch (dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
      if (m->message_id.is_server()) {
        message_id_to_dialog_id_[m->message_id] = dialog_id;
      }
      break;
    case DialogType::Channel:
      // nothing to do
      break;
    case DialogType::SecretChat:
      add_random_id_to_message_id_correspondence(d, m->random_id, m->message_id);
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  if (m->notification_id.is_valid()) {
    add_notification_id_to_message_id_correspondence(d, m->notification_id, m->message_id);
  }

  d->being_added_message_id = MessageId();

  if (!td_->auth_manager_->is_bot() && from_update && d->reply_markup_message_id != MessageId()) {
    auto deleted_user_id = get_message_content_deleted_user_id(m->content.get());
    if (deleted_user_id.is_valid()) {  // do not check for is_user_bot to allow deleted bots
      const Message *old_message = get_message_force(d, d->reply_markup_message_id, "add_message_to_dialog 3");
      if (old_message == nullptr || old_message->sender_user_id == deleted_user_id) {
        LOG(INFO) << "Remove reply markup in " << dialog_id << ", because bot " << deleted_user_id
                  << " isn't a member of the chat";
        set_dialog_reply_markup(d, MessageId());
      }
    }
  }

  return result_message;
}

MessagesManager::Message *MessagesManager::add_scheduled_message_to_dialog(Dialog *d, unique_ptr<Message> message,
                                                                           bool from_update, bool *need_update,
                                                                           const char *source) {
  CHECK(message != nullptr);
  CHECK(d != nullptr);
  CHECK(need_update != nullptr);
  CHECK(source != nullptr);

  DialogId dialog_id = d->dialog_id;
  MessageId message_id = message->message_id;
  CHECK(message_id.is_valid_scheduled());
  CHECK(!message->notification_id.is_valid());
  CHECK(!message->removed_notification_id.is_valid());

  if (d->deleted_message_ids.count(message_id)) {
    LOG(INFO) << "Skip adding deleted " << message_id << " to " << dialog_id << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "adding deleted scheduled message";
    return nullptr;
  }

  if (message_id.is_scheduled_server() &&
      d->deleted_scheduled_server_message_ids.count(message_id.get_scheduled_server_message_id())) {
    LOG(INFO) << "Skip adding deleted " << message_id << " to " << dialog_id << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "adding deleted scheduled server message";
    return nullptr;
  }

  if (dialog_id.get_type() == DialogType::SecretChat) {
    LOG(ERROR) << "Tried to add " << message_id << " to " << dialog_id << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "skip adding scheduled message to secret chat";
    return nullptr;
  }
  if (message->ttl != 0 || message->ttl_expires_at != 0) {
    LOG(ERROR) << "Tried to add " << message_id << " with TTL " << message->ttl << "/" << message->ttl_expires_at
               << " to " << dialog_id << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "skip adding secret scheduled message";
    return nullptr;
  }
  if (message->ttl_period != 0) {
    LOG(ERROR) << "Tried to add " << message_id << " with TTL period " << message->ttl_period << " to " << dialog_id
               << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "skip adding auto-deleting scheduled message";
    return nullptr;
  }
  if (td_->auth_manager_->is_bot()) {
    LOG(ERROR) << "Bot tried to add " << message_id << " to " << dialog_id << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "skip adding scheduled message by bot";
    return nullptr;
  }

  auto message_content_type = message->content->get_type();
  if (is_service_message_content(message_content_type) || message_content_type == MessageContentType::LiveLocation ||
      message_content_type == MessageContentType::ExpiredPhoto ||
      message_content_type == MessageContentType::ExpiredVideo) {
    LOG(ERROR) << "Tried to add " << message_id << " of type " << message_content_type << " to " << dialog_id
               << " from " << source;
    debug_add_message_to_dialog_fail_reason_ = "skip adding message of unexpected type";
    return nullptr;
  }

  {
    Message *m = message->from_database ? get_message(d, message_id)
                                        : get_message_force(d, message_id, "add_scheduled_message_to_dialog");
    if (m != nullptr) {
      auto old_message_id = m->message_id;
      LOG(INFO) << "Adding already existing " << old_message_id << " in " << dialog_id << " from " << source;
      set_message_id(message, old_message_id);
      if (!message->from_database) {
        auto old_file_ids = get_message_content_file_ids(m->content.get(), td_);
        bool need_update_dialog_pos = false;
        update_message(d, m, std::move(message), &need_update_dialog_pos);
        CHECK(need_update_dialog_pos == false);
        change_message_files(dialog_id, m, old_file_ids);
      }
      if (old_message_id != message_id) {
        being_readded_message_id_ = {dialog_id, old_message_id};
        message = do_delete_scheduled_message(d, old_message_id, false, "add_scheduled_message_to_dialog");
        CHECK(message != nullptr);
        send_update_delete_messages(dialog_id, {message->message_id.get()}, false, false);
        set_message_id(message, message_id);
        message->from_database = false;
      } else {
        *need_update = false;
        return m;
      }
    }
  }

  LOG(INFO) << "Adding not found " << message_id << " to " << dialog_id << " from " << source;

  const Message *m = message.get();
  if (m->message_id.is_yet_unsent() && m->reply_to_message_id.is_valid() && !m->reply_to_message_id.is_yet_unsent()) {
    replied_by_yet_unsent_messages_[FullMessageId{dialog_id, m->reply_to_message_id}]++;
  }

  if (!m->from_database && !m->message_id.is_yet_unsent()) {
    add_message_to_database(d, m, "add_scheduled_message_to_dialog");
  }

  reget_message_from_server_if_needed(dialog_id, m);

  add_message_file_sources(dialog_id, m);

  register_message_content(td_, m->content.get(), {dialog_id, m->message_id}, "add_scheduled_message_to_dialog");

  if (from_update) {
    update_sent_message_contents(dialog_id, m);
    update_used_hashtags(dialog_id, m);
    try_hide_distance(dialog_id, m);
  }

  if (m->message_id.is_scheduled_server()) {
    int32 &date = d->scheduled_message_date[m->message_id.get_scheduled_server_message_id()];
    CHECK(date == 0);
    date = m->date;
  }

  Message *result_message = treap_insert_message(&d->scheduled_messages, std::move(message));
  CHECK(result_message != nullptr);
  CHECK(d->scheduled_messages != nullptr);
  being_readded_message_id_ = FullMessageId();
  return result_message;
}

void MessagesManager::register_new_local_message_id(Dialog *d, const Message *m) {
  if (m == nullptr) {
    return;
  }
  if (m->message_id.is_scheduled()) {
    return;
  }
  CHECK(m->message_id.is_local());
  if (m->top_thread_message_id.is_valid() && m->top_thread_message_id != m->message_id) {
    Message *top_m = get_message_force(d, m->top_thread_message_id, "register_new_local_message_id");
    if (top_m != nullptr && top_m->top_thread_message_id == top_m->message_id) {
      auto it = std::lower_bound(top_m->local_thread_message_ids.begin(), top_m->local_thread_message_ids.end(),
                                 m->message_id);
      if (it == top_m->local_thread_message_ids.end() || *it != m->message_id) {
        top_m->local_thread_message_ids.insert(it, m->message_id);
        if (top_m->local_thread_message_ids.size() >= 1000) {
          top_m->local_thread_message_ids.erase(top_m->local_thread_message_ids.begin());
        }
        on_message_changed(d, top_m, false, "register_new_local_message_id");
      }
    }
  }
}

void MessagesManager::on_message_changed(const Dialog *d, const Message *m, bool need_send_update, const char *source) {
  CHECK(d != nullptr);
  CHECK(m != nullptr);
  if (need_send_update && m->message_id == d->last_message_id) {
    send_update_chat_last_message_impl(d, source);
  }

  if (m->message_id == d->last_database_message_id) {
    on_dialog_updated(d->dialog_id, source);
  }

  if (!m->message_id.is_yet_unsent()) {
    add_message_to_database(d, m, source);
  }
}

void MessagesManager::add_message_to_database(const Dialog *d, const Message *m, const char *source) {
  if (!G()->parameters().use_message_db) {
    return;
  }

  CHECK(d != nullptr);
  CHECK(m != nullptr);
  MessageId message_id = m->message_id;

  LOG(INFO) << "Add " << FullMessageId(d->dialog_id, message_id) << " to database from " << source;

  if (message_id.is_scheduled()) {
    set_dialog_has_scheduled_database_messages(d->dialog_id, true);
    G()->td_db()->get_messages_db_async()->add_scheduled_message({d->dialog_id, message_id}, log_event_store(*m),
                                                                 Auto());  // TODO Promise
    return;
  }
  LOG_CHECK(message_id.is_server() || message_id.is_local()) << source;

  ServerMessageId unique_message_id;
  int64 random_id = 0;
  int64 search_id = 0;
  string text;
  switch (d->dialog_id.get_type()) {
    case DialogType::User:
    case DialogType::Chat:
      if (message_id.is_server()) {
        unique_message_id = message_id.get_server_message_id();
      }
      // FOR DEBUG
      // text = get_message_search_text(m);
      // if (!text.empty()) {
      //   search_id = (static_cast<int64>(m->date) << 32) | static_cast<uint32>(Random::secure_int32());
      // }
      break;
    case DialogType::Channel:
      break;
    case DialogType::SecretChat:
      random_id = m->random_id;
      text = get_message_search_text(m);
      if (!text.empty()) {
        search_id = (static_cast<int64>(m->date) << 32) | static_cast<uint32>(m->random_id);
      }
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  int32 ttl_expires_at = 0;
  if (m->ttl_expires_at != 0) {
    ttl_expires_at = static_cast<int32>(m->ttl_expires_at - Time::now() + G()->server_time()) + 1;
  }
  if (m->ttl_period != 0 && (ttl_expires_at == 0 || m->date + m->ttl_period < ttl_expires_at)) {
    ttl_expires_at = m->date + m->ttl_period;
  }
  G()->td_db()->get_messages_db_async()->add_message({d->dialog_id, message_id}, unique_message_id, m->sender_user_id,
                                                     random_id, ttl_expires_at, get_message_index_mask(d->dialog_id, m),
                                                     search_id, text, m->notification_id, m->top_thread_message_id,
                                                     log_event_store(*m),
                                                     Auto());  // TODO Promise
}

void MessagesManager::delete_all_dialog_messages_from_database(Dialog *d, MessageId max_message_id,
                                                               const char *source) {
  CHECK(d != nullptr);
  CHECK(max_message_id.is_valid());
  if (d->new_secret_chat_notification_id.is_valid()) {
    remove_new_secret_chat_notification(d, true);
  }
  if (d->pinned_message_notification_message_id.is_valid() &&
      d->pinned_message_notification_message_id <= max_message_id) {
    remove_dialog_pinned_message_notification(d, source);
  }
  remove_message_dialog_notifications(d, max_message_id, false, source);
  remove_message_dialog_notifications(d, max_message_id, true, source);

  if (!G()->parameters().use_message_db) {
    return;
  }

  auto dialog_id = d->dialog_id;
  LOG(INFO) << "Delete all messages in " << dialog_id << " from database up to " << max_message_id << " from "
            << source;
  /*
  if (dialog_id.get_type() == DialogType::User && max_message_id.is_server()) {
    bool need_save = false;
    int i = 0;
    for (auto &first_message_id : calls_db_state_.first_calls_database_message_id_by_index) {
      if (first_message_id <= max_message_id) {
        first_message_id = max_message_id.get_next_server_message_id();
        calls_db_state_.message_count_by_index[i] = -1;
        need_save = true;
      }
      i++;
    }
    if (need_save) {
      save_calls_db_state();
    }
  }
  */
  G()->td_db()->get_messages_db_async()->delete_all_dialog_messages(dialog_id, max_message_id,
                                                                    Auto());  // TODO Promise
}

class MessagesManager::DeleteMessageLogEvent {
 public:
  LogEvent::Id id_{0};
  FullMessageId full_message_id_;
  std::vector<FileId> file_ids_;

  template <class StorerT>
  void store(StorerT &storer) const {
    bool has_file_ids = !file_ids_.empty();
    BEGIN_STORE_FLAGS();
    STORE_FLAG(has_file_ids);
    END_STORE_FLAGS();

    td::store(full_message_id_, storer);
    if (has_file_ids) {
      td::store(file_ids_, storer);
    }
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    bool has_file_ids;
    BEGIN_PARSE_FLAGS();
    PARSE_FLAG(has_file_ids);
    END_PARSE_FLAGS();

    td::parse(full_message_id_, parser);
    if (has_file_ids) {
      td::parse(file_ids_, parser);
    }
  }
};

void MessagesManager::delete_message_files(DialogId dialog_id, const Message *m) const {
  for (auto file_id : get_message_file_ids(m)) {
    if (need_delete_file({dialog_id, m->message_id}, file_id)) {
      send_closure(G()->file_manager(), &FileManager::delete_file, file_id, Promise<>(), "delete_message_files");
    }
  }
}

bool MessagesManager::need_delete_file(FullMessageId full_message_id, FileId file_id) const {
  if (being_readded_message_id_ == full_message_id) {
    return false;
  }

  auto main_file_id = td_->file_manager_->get_file_view(file_id).file_id();
  auto full_message_ids = td_->file_reference_manager_->get_some_message_file_sources(main_file_id);
  LOG(INFO) << "Receive " << full_message_ids << " as sources for file " << main_file_id << "/" << file_id << " from "
            << full_message_id;
  for (auto other_full_messsage_id : full_message_ids) {
    if (other_full_messsage_id != full_message_id) {
      return false;
    }
  }

  return true;
}

bool MessagesManager::need_delete_message_files(DialogId dialog_id, const Message *m) const {
  if (m == nullptr) {
    return false;
  }

  auto dialog_type = dialog_id.get_type();
  if (!m->message_id.is_scheduled() && !m->message_id.is_server() && dialog_type != DialogType::SecretChat) {
    return false;
  }
  if (being_readded_message_id_ == FullMessageId{dialog_id, m->message_id}) {
    return false;
  }

  if (m->forward_info != nullptr && m->forward_info->from_dialog_id.is_valid() &&
      m->forward_info->from_message_id.is_valid()) {
    // this function must not try to load the message, because it can be called from
    // do_delete_message or add_scheduled_message_to_dialog
    const Message *old_m = get_message({m->forward_info->from_dialog_id, m->forward_info->from_message_id});
    if (old_m != nullptr && get_message_file_ids(old_m) == get_message_file_ids(m)) {
      return false;
    }
  }

  return true;
}

void MessagesManager::delete_message_from_database(Dialog *d, MessageId message_id, const Message *m,
                                                   bool is_permanently_deleted) {
  CHECK(d != nullptr);
  if (!message_id.is_valid() && !message_id.is_valid_scheduled()) {
    return;
  }

  if (message_id.is_yet_unsent()) {
    return;
  }

  if (m != nullptr && !m->message_id.is_scheduled() && m->message_id.is_local() &&
      m->top_thread_message_id.is_valid() && m->top_thread_message_id != m->message_id) {
    // must not load the message from the database
    Message *top_m = get_message(d, m->top_thread_message_id);
    if (top_m != nullptr && top_m->top_thread_message_id == top_m->message_id) {
      auto it = std::lower_bound(top_m->local_thread_message_ids.begin(), top_m->local_thread_message_ids.end(),
                                 m->message_id);
      if (it != top_m->local_thread_message_ids.end() && *it == m->message_id) {
        top_m->local_thread_message_ids.erase(it);
        on_message_changed(d, top_m, false, "delete_message_from_database");
      }
    }
  }

  if (is_permanently_deleted) {
    if (message_id.is_scheduled() && message_id.is_scheduled_server()) {
      d->deleted_scheduled_server_message_ids.insert(message_id.get_scheduled_server_message_id());
    } else {
      // don't store failed to send message identifiers for bots to reduce memory usage
      if (m == nullptr || !td_->auth_manager_->is_bot() || !m->is_failed_to_send) {
        d->deleted_message_ids.insert(message_id);
      }
    }

    if (message_id.is_any_server()) {
      auto old_message_id = find_old_message_id(d->dialog_id, message_id);
      if (old_message_id.is_valid()) {
        LOG(WARNING) << "Sent " << FullMessageId{d->dialog_id, message_id} << " was deleted before it was received";
        send_closure_later(actor_id(this), &MessagesManager::delete_messages, d->dialog_id,
                           vector<MessageId>{old_message_id}, false, Promise<Unit>());
        delete_update_message_id(d->dialog_id, message_id);
      }
    }
  }

  if (m != nullptr && m->random_id != 0 && (m->is_outgoing || d->dialog_id == get_my_dialog_id())) {
    message_random_ids_.erase(m->random_id);
  }

  if (m != nullptr && m->notification_id.is_valid()) {
    CHECK(!message_id.is_scheduled());
    auto from_mentions = is_from_mention_notification_group(d, m);
    auto &group_info = from_mentions ? d->mention_notification_group : d->message_notification_group;

    if (group_info.group_id.is_valid()) {
      if (group_info.last_notification_id == m->notification_id) {
        // last notification is deleted, need to find new last notification
        fix_dialog_last_notification_id(d, from_mentions, m->message_id);
      }
      if (is_message_notification_active(d, m)) {
        send_closure_later(G()->notification_manager(), &NotificationManager::remove_notification, group_info.group_id,
                           m->notification_id, true, false, Promise<Unit>(), "delete_message_from_database");
      }
    }
  } else if (!message_id.is_scheduled() && message_id > d->last_new_message_id) {
    send_closure_later(G()->notification_manager(), &NotificationManager::remove_temporary_notification_by_message_id,
                       d->message_notification_group.group_id, message_id, false, "delete_message_from_database");
    send_closure_later(G()->notification_manager(), &NotificationManager::remove_temporary_notification_by_message_id,
                       d->mention_notification_group.group_id, message_id, false, "delete_message_from_database");
  }

  auto need_delete_files = need_delete_message_files(d->dialog_id, m);
  if (need_delete_files) {
    delete_message_files(d->dialog_id, m);
  }

  if (!G()->parameters().use_message_db) {
    return;
  }

  DeleteMessageLogEvent log_event;

  log_event.full_message_id_ = {d->dialog_id, message_id};

  if (need_delete_files) {
    log_event.file_ids_ = get_message_file_ids(m);
  }

  do_delete_message_log_event(log_event);
}

void MessagesManager::do_delete_message_log_event(const DeleteMessageLogEvent &log_event) const {
  CHECK(G()->parameters().use_message_db);

  Promise<Unit> db_promise;
  if (!log_event.file_ids_.empty()) {
    auto log_event_id = log_event.id_;
    if (log_event_id == 0) {
      log_event_id =
          binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::DeleteMessage, get_log_event_storer(log_event));
    }

    MultiPromiseActorSafe mpas{"DeleteMessageMultiPromiseActor"};
    mpas.add_promise(PromiseCreator::lambda([log_event_id](Result<Unit> result) {
      if (result.is_error() || G()->close_flag()) {
        return;
      }
      binlog_erase(G()->td_db()->get_binlog(), log_event_id);
    }));

    auto lock = mpas.get_promise();
    for (auto file_id : log_event.file_ids_) {
      if (need_delete_file(log_event.full_message_id_, file_id)) {
        send_closure(G()->file_manager(), &FileManager::delete_file, file_id, mpas.get_promise(),
                     "do_delete_message_log_event");
      }
    }
    db_promise = mpas.get_promise();
    lock.set_value(Unit());
  }

  // message may not exist in the dialog
  LOG(INFO) << "Delete " << log_event.full_message_id_ << " from database";
  G()->td_db()->get_messages_db_async()->delete_message(log_event.full_message_id_, std::move(db_promise));
}

void MessagesManager::attach_message_to_previous(Dialog *d, MessageId message_id, const char *source) {
  CHECK(d != nullptr);
  CHECK(message_id.is_valid());
  MessagesIterator it(d, message_id);
  Message *m = *it;
  CHECK(m != nullptr);
  CHECK(m->message_id == message_id);
  LOG_CHECK(m->have_previous) << d->dialog_id << " " << message_id << " " << source;
  --it;
  LOG_CHECK(*it != nullptr) << d->dialog_id << " " << message_id << " " << source;
  LOG(INFO) << "Attach " << message_id << " to the previous " << (*it)->message_id << " in " << d->dialog_id;
  if ((*it)->have_next) {
    m->have_next = true;
  } else {
    (*it)->have_next = true;
  }
}

void MessagesManager::attach_message_to_next(Dialog *d, MessageId message_id, const char *source) {
  CHECK(d != nullptr);
  CHECK(message_id.is_valid());
  MessagesIterator it(d, message_id);
  Message *m = *it;
  CHECK(m != nullptr);
  CHECK(m->message_id == message_id);
  LOG_CHECK(m->have_next) << d->dialog_id << " " << message_id << " " << source;
  ++it;
  LOG_CHECK(*it != nullptr) << d->dialog_id << " " << message_id << " " << source;
  LOG(INFO) << "Attach " << message_id << " to the next " << (*it)->message_id << " in " << d->dialog_id;
  if ((*it)->have_previous) {
    m->have_previous = true;
  } else {
    (*it)->have_previous = true;
  }
}

bool MessagesManager::update_message(Dialog *d, Message *old_message, unique_ptr<Message> new_message,
                                     bool *need_update_dialog_pos) {
  CHECK(d != nullptr);
  CHECK(old_message != nullptr);
  CHECK(new_message != nullptr);
  CHECK(old_message->message_id == new_message->message_id);
  CHECK(old_message->random_y == new_message->random_y);
  CHECK(need_update_dialog_pos != nullptr);

  DialogId dialog_id = d->dialog_id;
  MessageId message_id = old_message->message_id;
  auto old_content_type = old_message->content->get_type();
  auto new_content_type = new_message->content->get_type();
  bool is_scheduled = message_id.is_scheduled();
  bool need_send_update = false;
  bool is_new_available = new_content_type != MessageContentType::ChatDeleteHistory;
  bool replace_legacy = (old_message->legacy_layer != 0 &&
                         (new_message->legacy_layer == 0 || old_message->legacy_layer < new_message->legacy_layer)) ||
                        old_content_type == MessageContentType::Unsupported;
  bool was_visible_message_reply_info = is_visible_message_reply_info(dialog_id, old_message);
  if (old_message->date != new_message->date) {
    if (new_message->date > 0) {
      if (!(is_scheduled || message_id.is_yet_unsent() ||
            (message_id.is_server() && message_id.get_server_message_id().get() == 1) ||
            old_content_type == MessageContentType::ChannelMigrateFrom ||
            old_content_type == MessageContentType::ChannelCreate)) {
        LOG(ERROR) << "Date has changed for " << message_id << " in " << dialog_id << " from " << old_message->date
                   << " to " << new_message->date << ", message content type is " << old_content_type << '/'
                   << new_content_type;
      }
      CHECK(old_message->date > 0);
      LOG(DEBUG) << "Message date has changed from " << old_message->date << " to " << new_message->date;
      old_message->date = new_message->date;
      if (!is_scheduled && d->last_message_id == message_id) {
        *need_update_dialog_pos = true;
      }
      need_send_update = true;
    } else {
      LOG(ERROR) << "Receive " << message_id << " in " << dialog_id << " with wrong date " << new_message->date
                 << ", message content type is " << old_content_type << '/' << new_content_type;
    }
  }
  if (old_message->date == old_message->edited_schedule_date) {
    old_message->edited_schedule_date = 0;
  }
  bool is_edited = false;
  int32 old_shown_edit_date = old_message->hide_edit_date ? 0 : old_message->edit_date;
  if (old_message->edit_date != new_message->edit_date) {
    if (new_message->edit_date > 0) {
      if (new_message->edit_date > old_message->edit_date) {
        LOG(DEBUG) << "Message edit date has changed from " << old_message->edit_date << " to "
                   << new_message->edit_date;

        old_message->edit_date = new_message->edit_date;
        need_send_update = true;
      }
    } else {
      LOG(ERROR) << "Receive " << message_id << " in " << dialog_id << " of type " << old_content_type << "/"
                 << new_content_type << " with wrong edit date " << new_message->edit_date
                 << ", old edit date = " << old_message->edit_date;
    }
  }

  if (old_message->author_signature != new_message->author_signature) {
    LOG(DEBUG) << "Author signature has changed for " << message_id << " in " << dialog_id << " sent by "
               << old_message->sender_user_id << "/" << new_message->sender_user_id << " or "
               << old_message->sender_dialog_id << "/" << new_message->sender_dialog_id << " from "
               << old_message->author_signature << " to " << new_message->author_signature;
    old_message->author_signature = std::move(new_message->author_signature);
    need_send_update = true;
  }
  if (old_message->sender_user_id != new_message->sender_user_id) {
    // there can be race for sent signed posts or changed anonymous flag
    LOG_IF(ERROR, old_message->sender_user_id != UserId() && new_message->sender_user_id != UserId())
        << message_id << " in " << dialog_id << " has changed sender from " << old_message->sender_user_id << " to "
        << new_message->sender_user_id << ", message content type is " << old_content_type << '/' << new_content_type;

    LOG_IF(WARNING, (new_message->sender_user_id.is_valid() || old_message->author_signature.empty()) &&
                        !old_message->sender_dialog_id.is_valid() && !new_message->sender_dialog_id.is_valid())
        << "Update message sender from " << old_message->sender_user_id << " to " << new_message->sender_user_id
        << " in " << dialog_id;
    LOG(DEBUG) << "Change message sender";
    old_message->sender_user_id = new_message->sender_user_id;
    need_send_update = true;
  }
  if (old_message->sender_dialog_id != new_message->sender_dialog_id) {
    // there can be race for changed anonymous flag
    LOG_IF(ERROR, old_message->sender_dialog_id != DialogId() && new_message->sender_dialog_id != DialogId())
        << message_id << " in " << dialog_id << " has changed sender from " << old_message->sender_dialog_id << " to "
        << new_message->sender_dialog_id << ", message content type is " << old_content_type << '/' << new_content_type;

    LOG(DEBUG) << "Change message sender";
    old_message->sender_dialog_id = new_message->sender_dialog_id;
    need_send_update = true;
  }
  if (old_message->forward_info == nullptr) {
    if (new_message->forward_info != nullptr) {
      if (!replace_legacy) {
        LOG(ERROR) << message_id << " in " << dialog_id << " has received forward info " << *new_message->forward_info
                   << ", really forwarded from " << old_message->real_forward_from_message_id << " in "
                   << old_message->real_forward_from_dialog_id << ", message content type is " << old_content_type
                   << '/' << new_content_type;
      }
      old_message->forward_info = std::move(new_message->forward_info);
      need_send_update = true;
    }
  } else {
    if (new_message->forward_info != nullptr) {
      if (old_message->forward_info->author_signature != new_message->forward_info->author_signature) {
        old_message->forward_info->author_signature = new_message->forward_info->author_signature;
        LOG(DEBUG) << "Change message signature";
        need_send_update = true;
      }
      if (*old_message->forward_info != *new_message->forward_info) {
        if (!is_forward_info_sender_hidden(new_message->forward_info.get()) && !replace_legacy) {
          LOG(ERROR) << message_id << " in " << dialog_id << " has changed forward info from "
                     << *old_message->forward_info << " to " << *new_message->forward_info << ", really forwarded from "
                     << old_message->real_forward_from_message_id << " in " << old_message->real_forward_from_dialog_id
                     << ", message content type is " << old_content_type << '/' << new_content_type;
        }
        old_message->forward_info = std::move(new_message->forward_info);
        need_send_update = true;
      }
    } else if (is_new_available) {
      LOG(ERROR) << message_id << " in " << dialog_id << " sent by " << old_message->sender_user_id << "/"
                 << old_message->sender_dialog_id << " has lost forward info " << *old_message->forward_info
                 << ", really forwarded from " << old_message->real_forward_from_message_id << " in "
                 << old_message->real_forward_from_dialog_id << ", message content type is " << old_content_type << '/'
                 << new_content_type;
      old_message->forward_info = nullptr;
      need_send_update = true;
    }
  }
  if (old_message->had_forward_info != new_message->had_forward_info) {
    old_message->had_forward_info = new_message->had_forward_info;
    need_send_update = true;
  }
  if (old_message->notification_id != new_message->notification_id) {
    CHECK(!is_scheduled);
    if (old_message->notification_id.is_valid()) {
      if (new_message->notification_id.is_valid()) {
        LOG(ERROR) << "Notification id for " << message_id << " in " << dialog_id << " has tried to change from "
                   << old_message->notification_id << " to " << new_message->notification_id
                   << ", message content type is " << old_content_type << '/' << new_content_type;
      }
    } else {
      CHECK(new_message->notification_id.is_valid());
      add_notification_id_to_message_id_correspondence(d, new_message->notification_id, message_id);
      old_message->notification_id = new_message->notification_id;
    }
  }
  if (new_message->is_mention_notification_disabled) {
    old_message->is_mention_notification_disabled = true;
  }

  if (old_message->ttl_period != new_message->ttl_period) {
    if (old_message->ttl_period != 0 || !message_id.is_yet_unsent()) {
      LOG(ERROR) << message_id << " in " << dialog_id << " has changed TTL period from " << old_message->ttl_period
                 << " to " << new_message->ttl_period;
    } else {
      LOG(DEBUG) << "Change message TTL period";
      old_message->ttl_period = new_message->ttl_period;
      need_send_update = true;
    }
  }

  if (old_message->reply_to_message_id != new_message->reply_to_message_id) {
    // Can't check "&& get_message_force(d, old_message->reply_to_message_id, "update_message") == nullptr", because it
    // can change message tree and invalidate reference to old_message
    if (new_message->reply_to_message_id == MessageId() || replace_legacy) {
      LOG(DEBUG) << "Drop message reply_to_message_id";
      old_message->reply_to_message_id = MessageId();
      need_send_update = true;
    } else if (is_new_available) {
      LOG(ERROR) << message_id << " in " << dialog_id << " has changed message it is reply to from "
                 << old_message->reply_to_message_id << " to " << new_message->reply_to_message_id
                 << ", message content type is " << old_content_type << '/' << new_content_type;
    }
  }
  if (old_message->reply_in_dialog_id != new_message->reply_in_dialog_id) {
    if (new_message->reply_in_dialog_id == DialogId() || replace_legacy) {
      LOG(DEBUG) << "Drop message reply_in_dialog_id";
      old_message->reply_in_dialog_id = DialogId();
      need_send_update = true;
    } else if (is_new_available && old_message->reply_in_dialog_id.is_valid()) {
      LOG(ERROR) << message_id << " in " << dialog_id << " has changed dialog it is reply in from "
                 << old_message->reply_in_dialog_id << " to " << new_message->reply_in_dialog_id
                 << ", message content type is " << old_content_type << '/' << new_content_type;
    }
  }
  if (old_message->top_thread_message_id != new_message->top_thread_message_id) {
    if (new_message->top_thread_message_id == MessageId() || old_message->top_thread_message_id == MessageId()) {
      LOG(DEBUG) << "Change message thread from " << old_message->top_thread_message_id << " to "
                 << new_message->top_thread_message_id;
      old_message->top_thread_message_id = new_message->top_thread_message_id;
      need_send_update = true;
    } else if (is_new_available) {
      LOG(ERROR) << message_id << " in " << dialog_id << " has changed message thread from "
                 << old_message->top_thread_message_id << " to " << new_message->top_thread_message_id
                 << ", message content type is " << old_content_type << '/' << new_content_type;
    }
  }
  if (old_message->via_bot_user_id != new_message->via_bot_user_id) {
    if ((!message_id.is_yet_unsent() || old_message->via_bot_user_id.is_valid()) && is_new_available &&
        !replace_legacy) {
      LOG(ERROR) << message_id << " in " << dialog_id << " has changed bot via it is sent from "
                 << old_message->via_bot_user_id << " to " << new_message->via_bot_user_id
                 << ", message content type is " << old_content_type << '/' << new_content_type;
    }
    LOG(DEBUG) << "Change message via_bot from " << old_message->via_bot_user_id << " to "
               << new_message->via_bot_user_id;
    old_message->via_bot_user_id = new_message->via_bot_user_id;
    need_send_update = true;

    if (old_message->hide_via_bot && old_message->via_bot_user_id.is_valid()) {
      // wrongly set hide_via_bot
      old_message->hide_via_bot = false;
    }
  }
  if (old_message->is_outgoing != new_message->is_outgoing && is_new_available) {
    if (!replace_legacy && !(message_id.is_scheduled() && dialog_id == get_my_dialog_id())) {
      LOG(ERROR) << message_id << " in " << dialog_id << " has changed is_outgoing from " << old_message->is_outgoing
                 << " to " << new_message->is_outgoing << ", message content type is " << old_content_type << '/'
                 << new_content_type;
    }
    old_message->is_outgoing = new_message->is_outgoing;
    need_send_update = true;
  }
  LOG_IF(ERROR, old_message->is_channel_post != new_message->is_channel_post)
      << message_id << " in " << dialog_id << " has changed is_channel_post from " << old_message->is_channel_post
      << " to " << new_message->is_channel_post << ", message content type is " << old_content_type << '/'
      << new_content_type;
  if (old_message->contains_mention != new_message->contains_mention) {
    if (old_message->edit_date == 0 && is_new_available && old_content_type != MessageContentType::PinMessage &&
        old_content_type != MessageContentType::ExpiredPhoto && old_content_type != MessageContentType::ExpiredVideo &&
        !replace_legacy) {
      LOG(ERROR) << message_id << " in " << dialog_id << " has changed contains_mention from "
                 << old_message->contains_mention << " to " << new_message->contains_mention
                 << ", is_outgoing = " << old_message->is_outgoing << ", message content type is " << old_content_type
                 << '/' << new_content_type;
    }
    // contains_mention flag shouldn't be changed, because the message will not be added to unread mention list
    // and we are unable to show/hide message notification
    // old_message->contains_mention = new_message->contains_mention;
    // need_send_update = true;
  }
  if (old_message->disable_notification != new_message->disable_notification) {
    LOG_IF(ERROR, old_message->edit_date == 0 && is_new_available && !replace_legacy)
        << "Disable_notification has changed from " << old_message->disable_notification << " to "
        << new_message->disable_notification
        << ". Old message: " << to_string(get_message_object(dialog_id, old_message))
        << ". New message: " << to_string(get_message_object(dialog_id, new_message.get()));
    // disable_notification flag shouldn't be changed, because we are unable to show/hide message notification
    // old_message->disable_notification = new_message->disable_notification;
    // need_send_update = true;
  }

  if (!is_scheduled &&
      update_message_contains_unread_mention(d, old_message, new_message->contains_unread_mention, "update_message")) {
    need_send_update = true;
  }
  if (update_message_interaction_info(dialog_id, old_message, new_message->view_count, new_message->forward_count, true,
                                      std::move(new_message->reply_info))) {
    need_send_update = true;
  }
  if (old_message->restriction_reasons != new_message->restriction_reasons) {
    old_message->restriction_reasons = std::move(new_message->restriction_reasons);
  }
  if (old_message->legacy_layer != new_message->legacy_layer) {
    old_message->legacy_layer = new_message->legacy_layer;
  }
  if ((old_message->media_album_id == 0 || td_->auth_manager_->is_bot()) && new_message->media_album_id != 0) {
    old_message->media_album_id = new_message->media_album_id;
    LOG(DEBUG) << "Update message media_album_id";
    need_send_update = true;
  }
  if (old_message->hide_edit_date != new_message->hide_edit_date) {
    old_message->hide_edit_date = new_message->hide_edit_date;
    if (old_message->edit_date > 0) {
      need_send_update = true;
    }
  }
  int32 new_shown_edit_date = old_message->hide_edit_date ? 0 : old_message->edit_date;
  if (new_shown_edit_date != old_shown_edit_date) {
    is_edited = true;
  }

  if (old_message->is_from_scheduled != new_message->is_from_scheduled) {
    // is_from_scheduled flag shouldn't be changed, because we are unable to show/hide message notification
    // old_message->is_from_scheduled = new_message->is_from_scheduled;
  }

  if (!is_scheduled && update_message_is_pinned(d, old_message, new_message->is_pinned, "update_message")) {
    need_send_update = true;
  }

  if (old_message->edit_date > 0) {
    // inline keyboard can be edited
    bool reply_markup_changed =
        ((old_message->reply_markup == nullptr) != (new_message->reply_markup == nullptr)) ||
        (old_message->reply_markup != nullptr && *old_message->reply_markup != *new_message->reply_markup);
    if (reply_markup_changed) {
      if (d->reply_markup_message_id == message_id && !td_->auth_manager_->is_bot() &&
          new_message->reply_markup == nullptr) {
        set_dialog_reply_markup(d, MessageId());
      }
      LOG(DEBUG) << "Update message reply keyboard";
      old_message->reply_markup = std::move(new_message->reply_markup);
      is_edited = true;
      need_send_update = true;
    }
    old_message->had_reply_markup = false;
  } else {
    if (old_message->reply_markup == nullptr) {
      if (new_message->reply_markup != nullptr) {
        // MessageGame and MessageInvoice reply markup can be generated server side
        // some forwards retain their reply markup
        if (old_content_type != MessageContentType::Game && old_content_type != MessageContentType::Invoice &&
            need_message_changed_warning(old_message) && !replace_legacy) {
          LOG(ERROR) << message_id << " in " << dialog_id << " has received reply markup " << *new_message->reply_markup
                     << ", message content type is " << old_content_type << '/' << new_content_type;
        } else {
          LOG(DEBUG) << "Add message reply keyboard";
        }

        old_message->had_reply_markup = false;
        old_message->reply_markup = std::move(new_message->reply_markup);
        need_send_update = true;
      }
    } else {
      if (new_message->reply_markup != nullptr) {
        if (replace_legacy ||
            (message_id.is_yet_unsent() && old_message->reply_markup->type == ReplyMarkup::Type::InlineKeyboard &&
             new_message->reply_markup->type == ReplyMarkup::Type::InlineKeyboard)) {
          // allow the server to update inline keyboard for sent messages
          // this is needed to get correct button_id for UrlAuth buttons
          old_message->had_reply_markup = false;
          old_message->reply_markup = std::move(new_message->reply_markup);
          need_send_update = true;
        } else if (need_message_changed_warning(old_message)) {
          LOG_IF(WARNING, *old_message->reply_markup != *new_message->reply_markup)
              << message_id << " in " << dialog_id << " has changed reply_markup from " << *old_message->reply_markup
              << " to " << *new_message->reply_markup;
        }
      } else {
        // if the message is not accessible anymore, then we don't need a warning
        if (need_message_changed_warning(old_message) && is_new_available) {
          LOG(ERROR) << message_id << " in " << dialog_id << " sent by " << old_message->sender_user_id << "/"
                     << old_message->sender_dialog_id << " has lost reply markup " << *old_message->reply_markup
                     << ". Old message: " << to_string(get_message_object(dialog_id, old_message))
                     << ". New message: " << to_string(get_message_object(dialog_id, new_message.get()));
        }
      }
    }
  }

  if (old_message->last_access_date < new_message->last_access_date) {
    old_message->last_access_date = new_message->last_access_date;
  }

  if (!is_scheduled) {
    CHECK(!new_message->have_previous || !new_message->have_next);
    if (new_message->have_previous && !old_message->have_previous) {
      old_message->have_previous = true;
      attach_message_to_previous(d, message_id, "update_message");
    } else if (new_message->have_next && !old_message->have_next) {
      old_message->have_next = true;
      attach_message_to_next(d, message_id, "update_message");
    }
  }

  if (update_message_content(dialog_id, old_message, std::move(new_message->content), true,
                             message_id.is_yet_unsent() && new_message->edit_date == 0,
                             get_message(d, message_id) != nullptr)) {
    need_send_update = true;
  }

  if (was_visible_message_reply_info && !is_visible_message_reply_info(dialog_id, old_message)) {
    send_update_message_interaction_info(dialog_id, old_message);
  }

  if (is_edited && !td_->auth_manager_->is_bot()) {
    d->last_edited_message_id = message_id;
    send_update_message_edited(dialog_id, old_message);
  }

  if (!was_visible_message_reply_info && is_visible_message_reply_info(dialog_id, old_message)) {
    send_update_message_interaction_info(dialog_id, old_message);
  }

  on_message_changed(d, old_message, need_send_update, "update_message");
  return need_send_update;
}

bool MessagesManager::need_message_changed_warning(const Message *old_message) {
  if (old_message->edit_date > 0) {
    // message was edited
    return false;
  }
  if (old_message->message_id.is_yet_unsent() &&
      (old_message->forward_info != nullptr || old_message->had_forward_info ||
       old_message->real_forward_from_dialog_id.is_valid())) {
    // original message may be edited
    return false;
  }
  if (old_message->ttl > 0) {
    // message can expire
    return false;
  }
  return true;
}

bool MessagesManager::update_message_content(DialogId dialog_id, Message *old_message,
                                             unique_ptr<MessageContent> new_content,
                                             bool need_send_update_message_content, bool need_merge_files,
                                             bool is_message_in_dialog) {
  bool is_content_changed = false;
  bool need_update = false;
  unique_ptr<MessageContent> &old_content = old_message->content;
  MessageContentType old_content_type = old_content->get_type();
  MessageContentType new_content_type = new_content->get_type();

  auto old_file_id = get_message_content_any_file_id(old_content.get());
  bool need_finish_upload = old_file_id.is_valid() && need_merge_files;
  if (old_content_type != new_content_type) {
    if (old_message->ttl > 0 && old_message->ttl_expires_at > 0 &&
        ((new_content_type == MessageContentType::ExpiredPhoto && old_content_type == MessageContentType::Photo) ||
         (new_content_type == MessageContentType::ExpiredVideo && old_content_type == MessageContentType::Video))) {
      LOG(INFO) << "Do not apply expired message content early";
    } else {
      need_update = true;
      LOG(INFO) << "Message content has changed its type from " << old_content_type << " to " << new_content_type;

      old_message->is_content_secret = is_secret_message_content(old_message->ttl, new_content->get_type());
    }

    if (need_merge_files && old_file_id.is_valid()) {
      auto new_file_id = get_message_content_any_file_id(new_content.get());
      if (new_file_id.is_valid()) {
        FileView old_file_view = td_->file_manager_->get_file_view(old_file_id);
        FileView new_file_view = td_->file_manager_->get_file_view(new_file_id);
        // if file type has changed, but file size remains the same, we are trying to update local location of the new
        // file with the old local location
        if (old_file_view.has_local_location() && !new_file_view.has_local_location() && old_file_view.size() != 0 &&
            old_file_view.size() == new_file_view.size()) {
          auto old_file_type = old_file_view.get_type();
          auto new_file_type = new_file_view.get_type();
          auto is_document_file_type = [](FileType file_type) {
            switch (file_type) {
              case FileType::Animation:
              case FileType::Audio:
              case FileType::Document:
              case FileType::DocumentAsFile:
              case FileType::Sticker:
              case FileType::Video:
              case FileType::VideoNote:
              case FileType::VoiceNote:
                return true;
              default:
                return false;
            }
          };

          if (is_document_file_type(old_file_type) && is_document_file_type(new_file_type)) {
            auto &old_location = old_file_view.local_location();
            auto r_file_id = td_->file_manager_->register_local(
                FullLocalFileLocation(new_file_type, old_location.path_, old_location.mtime_nsec_), dialog_id,
                old_file_view.size());
            if (r_file_id.is_ok()) {
              LOG_STATUS(td_->file_manager_->merge(new_file_id, r_file_id.ok()));
            }
          }
        }
      }
    }
  } else {
    merge_message_contents(td_, old_content.get(), new_content.get(), need_message_changed_warning(old_message),
                           dialog_id, need_merge_files, is_content_changed, need_update);
  }
  if (need_finish_upload) {
    // the file is likely to be already merged with a server file, but if not we need to
    // cancel file upload of the main file to allow next upload with the same file to succeed
    cancel_upload_file(old_file_id);
  }

  if (is_content_changed || need_update) {
    if (is_message_in_dialog) {
      reregister_message_content(td_, old_content.get(), new_content.get(), {dialog_id, old_message->message_id},
                                 "update_message_content");
    }
    old_content = std::move(new_content);
    old_message->last_edit_pts = 0;
    update_message_content_file_id_remote(old_content.get(), old_file_id);
  } else {
    update_message_content_file_id_remote(old_content.get(), get_message_content_any_file_id(new_content.get()));
  }
  if (is_content_changed && !need_update) {
    LOG(INFO) << "Content of " << old_message->message_id << " in " << dialog_id << " has changed";
  }

  if (need_update && need_send_update_message_content) {
    send_update_message_content(dialog_id, old_message->message_id, old_content.get(), old_message->date,
                                old_message->is_content_secret, "update_message_content");
  }
  return is_content_changed || need_update;
}

MessagesManager::Dialog *MessagesManager::get_dialog_by_message_id(MessageId message_id) {
  CHECK(message_id.is_valid() && message_id.is_server());
  auto it = message_id_to_dialog_id_.find(message_id);
  if (it == message_id_to_dialog_id_.end()) {
    if (G()->parameters().use_message_db) {
      auto r_value =
          G()->td_db()->get_messages_db_sync()->get_message_by_unique_message_id(message_id.get_server_message_id());
      if (r_value.is_ok()) {
        DialogId dialog_id(r_value.ok().first);
        Message *m = on_get_message_from_database(dialog_id, get_dialog_force(dialog_id), r_value.ok().second, false,
                                                  "get_dialog_by_message_id");
        if (m != nullptr) {
          CHECK(m->message_id == message_id);
          CHECK(message_id_to_dialog_id_[message_id] == dialog_id);
          Dialog *d = get_dialog(dialog_id);
          CHECK(d != nullptr);
          return d;
        }
      }
    }

    LOG(INFO) << "Can't find the chat by " << message_id;
    return nullptr;
  }

  return get_dialog(it->second);
}

MessageId MessagesManager::get_message_id_by_random_id(Dialog *d, int64 random_id, const char *source) {
  CHECK(d != nullptr);
  CHECK(d->dialog_id.get_type() == DialogType::SecretChat);
  if (random_id == 0) {
    return MessageId();
  }
  auto it = d->random_id_to_message_id.find(random_id);
  if (it == d->random_id_to_message_id.end()) {
    if (G()->parameters().use_message_db) {
      auto r_value = G()->td_db()->get_messages_db_sync()->get_message_by_random_id(d->dialog_id, random_id);
      if (r_value.is_ok()) {
        debug_add_message_to_dialog_fail_reason_ = "not called";
        Message *m = on_get_message_from_database(d->dialog_id, d, r_value.ok(), false, "get_message_id_by_random_id");
        if (m != nullptr) {
          LOG_CHECK(m->random_id == random_id)
              << random_id << " " << m->random_id << " " << d->random_id_to_message_id[random_id] << " "
              << d->random_id_to_message_id[m->random_id] << " " << m->message_id << " " << source << " "
              << m->from_database << get_message(d, m->message_id) << " " << m << " "
              << debug_add_message_to_dialog_fail_reason_;
          LOG_CHECK(d->random_id_to_message_id.count(random_id))
              << source << " " << random_id << " " << m->message_id << " " << m->is_failed_to_send << " "
              << m->is_outgoing << " " << m->from_database << " " << get_message(d, m->message_id) << " " << m << " "
              << debug_add_message_to_dialog_fail_reason_;
          LOG_CHECK(d->random_id_to_message_id[random_id] == m->message_id)
              << source << " " << random_id << " " << d->random_id_to_message_id[random_id] << " " << m->message_id
              << " " << m->is_failed_to_send << " " << m->is_outgoing << " " << m->from_database << " "
              << get_message(d, m->message_id) << " " << m << " " << debug_add_message_to_dialog_fail_reason_;
          return m->message_id;
        }
      }
    }

    return MessageId();
  }

  return it->second;
}

void MessagesManager::force_create_dialog(DialogId dialog_id, const char *source, bool expect_no_access,
                                          bool force_update_dialog_pos) {
  LOG_CHECK(dialog_id.is_valid()) << source;
  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(INFO) << "Force create " << dialog_id << " from " << source;
    if (loaded_dialogs_.count(dialog_id) > 0) {
      LOG(INFO) << "Skip creation of " << dialog_id << ", because it is being loaded now";
      return;
    }

    d = add_dialog(dialog_id);
    update_dialog_pos(d, "force_create_dialog");

    if (dialog_id.get_type() == DialogType::SecretChat && !d->notification_settings.is_synchronized) {
      // secret chat is being created
      // let's copy notification settings from main chat if available
      VLOG(notifications) << "Create new secret " << dialog_id << " from " << source;
      auto secret_chat_id = dialog_id.get_secret_chat_id();
      {
        auto user_id = td_->contacts_manager_->get_secret_chat_user_id(secret_chat_id);
        Dialog *user_d = get_dialog_force(DialogId(user_id));
        if (user_d != nullptr && user_d->notification_settings.is_synchronized) {
          VLOG(notifications) << "Copy notification settings from " << user_d->dialog_id << " to " << dialog_id;
          auto new_notification_settings = user_d->notification_settings;
          new_notification_settings.use_default_show_preview = true;
          new_notification_settings.show_preview = false;
          new_notification_settings.is_secret_chat_show_preview_fixed = true;
          update_dialog_notification_settings(dialog_id, &d->notification_settings, new_notification_settings);
        } else {
          d->notification_settings.is_synchronized = true;
        }
      }

      if (G()->parameters().use_message_db && !td_->auth_manager_->is_bot() &&
          !td_->contacts_manager_->get_secret_chat_is_outbound(secret_chat_id)) {
        auto notification_group_id = get_dialog_notification_group_id(dialog_id, d->message_notification_group);
        if (notification_group_id.is_valid()) {
          if (d->new_secret_chat_notification_id.is_valid()) {
            LOG(ERROR) << "Found previously created " << d->new_secret_chat_notification_id << " in " << d->dialog_id
                       << ", when creating it from " << source;
          } else {
            d->new_secret_chat_notification_id = get_next_notification_id(d, notification_group_id, MessageId());
            if (d->new_secret_chat_notification_id.is_valid()) {
              auto date = td_->contacts_manager_->get_secret_chat_date(secret_chat_id);
              bool is_changed = set_dialog_last_notification(dialog_id, d->message_notification_group, date,
                                                             d->new_secret_chat_notification_id, "add_new_secret_chat");
              CHECK(is_changed);
              VLOG(notifications) << "Create " << d->new_secret_chat_notification_id << " with " << secret_chat_id;
              send_closure_later(G()->notification_manager(), &NotificationManager::add_notification,
                                 notification_group_id, NotificationGroupType::SecretChat, dialog_id, date, dialog_id,
                                 false, false, 0, d->new_secret_chat_notification_id,
                                 create_new_secret_chat_notification(), "add_new_secret_chat_notification");
            }
          }
        }
      }
    }
    if (!have_input_peer(dialog_id, AccessRights::Read)) {
      if (!have_dialog_info(dialog_id)) {
        LOG(ERROR) << "Have no info about " << dialog_id << " received from " << source << ", but forced to create it";
      } else if (!expect_no_access) {
        LOG(ERROR) << "Have no access to " << dialog_id << " received from " << source << ", but forced to create it";
      }
    }
  } else if (force_update_dialog_pos) {
    update_dialog_pos(d, "force update dialog pos");
  }
}

MessagesManager::Dialog *MessagesManager::add_dialog(DialogId dialog_id) {
  LOG(DEBUG) << "Creating " << dialog_id;
  CHECK(!have_dialog(dialog_id));

  if (G()->parameters().use_message_db) {
    // TODO preload dialog asynchronously, remove loading from this function
    auto r_value = G()->td_db()->get_dialog_db_sync()->get_dialog(dialog_id);
    if (r_value.is_ok()) {
      LOG(INFO) << "Synchronously loaded " << dialog_id << " from database";
      return add_new_dialog(parse_dialog(dialog_id, r_value.ok()), true);
    }
  }

  auto d = make_unique<Dialog>();
  d->dialog_id = dialog_id;
  invalidate_message_indexes(d.get());

  return add_new_dialog(std::move(d), false);
}

MessagesManager::Dialog *MessagesManager::add_new_dialog(unique_ptr<Dialog> &&d, bool is_loaded_from_database) {
  auto dialog_id = d->dialog_id;
  switch (dialog_id.get_type()) {
    case DialogType::User:
      if (dialog_id == get_my_dialog_id() && d->last_read_inbox_message_id == MessageId::max() &&
          d->last_read_outbox_message_id == MessageId::max()) {
        d->last_read_inbox_message_id = d->last_new_message_id;
        d->last_read_outbox_message_id = d->last_new_message_id;
      }
      break;
    case DialogType::Chat:
      d->is_is_blocked_inited = true;
      break;
    case DialogType::Channel: {
      auto channel_type = td_->contacts_manager_->get_channel_type(dialog_id.get_channel_id());
      if (channel_type == ChannelType::Broadcast) {
        d->last_read_outbox_message_id = MessageId::max();
        d->is_last_read_outbox_message_id_inited = true;
      }

      auto pts = load_channel_pts(dialog_id);
      if (pts > 0) {
        d->pts = pts;
        if (is_debug_message_op_enabled()) {
          d->debug_message_op.emplace_back(Dialog::MessageOp::SetPts, pts, "add_new_dialog");
        }
      }
      break;
    }
    case DialogType::SecretChat:
      if (!d->last_new_message_id.is_valid()) {
        LOG(INFO) << "Set " << d->dialog_id << " last new message in add_new_dialog";
        d->last_new_message_id = MessageId::min();
      }

      if (!d->notification_settings.is_secret_chat_show_preview_fixed) {
        d->notification_settings.use_default_show_preview = true;
        d->notification_settings.show_preview = false;
        d->notification_settings.is_secret_chat_show_preview_fixed = true;
        on_dialog_updated(d->dialog_id, "fix secret chat show preview");
      }

      d->have_full_history = true;
      d->need_restore_reply_markup = false;
      d->is_last_read_inbox_message_id_inited = true;
      d->is_last_read_outbox_message_id_inited = true;
      d->is_last_pinned_message_id_inited = true;
      d->is_is_blocked_inited = true;
      if (!d->is_folder_id_inited && !td_->auth_manager_->is_bot()) {
        do_set_dialog_folder_id(
            d.get(), td_->contacts_manager_->get_secret_chat_initial_folder_id(dialog_id.get_secret_chat_id()));
      }
      d->message_ttl_setting =
          MessageTtlSetting(td_->contacts_manager_->get_secret_chat_ttl(dialog_id.get_secret_chat_id()));
      d->is_message_ttl_setting_inited = true;

      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }
  if (!is_loaded_from_database) {
    on_dialog_updated(dialog_id, "add_new_dialog");
  }
  if (td_->auth_manager_->is_bot()) {
    d->notification_settings.is_synchronized = true;
  }

  unique_ptr<Message> last_database_message = std::move(d->messages);
  MessageId last_database_message_id = d->last_database_message_id;
  d->last_database_message_id = MessageId();
  int64 order = d->order;
  d->order = DEFAULT_ORDER;
  int32 last_clear_history_date = d->last_clear_history_date;
  MessageId last_clear_history_message_id = d->last_clear_history_message_id;
  d->last_clear_history_date = 0;
  d->last_clear_history_message_id = MessageId();

  if (d->message_notification_group.group_id.is_valid()) {
    notification_group_id_to_dialog_id_.emplace(d->message_notification_group.group_id, d->dialog_id);
  }
  if (d->mention_notification_group.group_id.is_valid()) {
    notification_group_id_to_dialog_id_.emplace(d->mention_notification_group.group_id, d->dialog_id);
  }
  if (pending_dialog_group_call_updates_.count(dialog_id) > 0) {
    auto it = pending_dialog_group_call_updates_.find(dialog_id);
    bool has_active_group_call = it->second.first;
    bool is_group_call_empty = it->second.second;
    pending_dialog_group_call_updates_.erase(it);
    if (d->has_active_group_call != has_active_group_call || d->is_group_call_empty != is_group_call_empty) {
      if (!has_active_group_call) {
        d->active_group_call_id = InputGroupCallId();
      }
      d->has_active_group_call = has_active_group_call;
      d->is_group_call_empty = is_group_call_empty;
      on_dialog_updated(dialog_id, "pending update_dialog_group_call");
    }
  }

  if (!is_loaded_from_database) {
    CHECK(order == DEFAULT_ORDER);
    CHECK(last_database_message == nullptr);
  }

  auto dialog_it = dialogs_.emplace(dialog_id, std::move(d)).first;

  loaded_dialogs_.erase(dialog_id);

  Dialog *dialog = dialog_it->second.get();

  fix_dialog_action_bar(dialog);

  send_update_new_chat(dialog);

  fix_new_dialog(dialog, std::move(last_database_message), last_database_message_id, order, last_clear_history_date,
                 last_clear_history_message_id, is_loaded_from_database);

  return dialog;
}

void MessagesManager::fix_new_dialog(Dialog *d, unique_ptr<Message> &&last_database_message,
                                     MessageId last_database_message_id, int64 order, int32 last_clear_history_date,
                                     MessageId last_clear_history_message_id, bool is_loaded_from_database) {
  CHECK(d != nullptr);
  auto dialog_id = d->dialog_id;
  auto dialog_type = dialog_id.get_type();

  if (!td_->auth_manager_->is_bot() && dialog_type == DialogType::SecretChat) {
    auto user_id = td_->contacts_manager_->get_secret_chat_user_id(dialog_id.get_secret_chat_id());
    if (user_id.is_valid()) {
      force_create_dialog(DialogId(user_id), "add chat with user to load/store action_bar and is_blocked");

      Dialog *user_d = get_dialog_force(DialogId(user_id));
      if (user_d != nullptr && d->is_blocked != user_d->is_blocked) {
        set_dialog_is_blocked(d, user_d->is_blocked);
      }
    }
  }

  if (being_added_dialog_id_ != dialog_id && !td_->auth_manager_->is_bot() && !is_dialog_inited(d) &&
      dialog_type != DialogType::SecretChat && have_input_peer(dialog_id, AccessRights::Read)) {
    // asynchronously get dialog from the server
    send_get_dialog_query(dialog_id, Auto(), 0, "fix_new_dialog 20");
  }

  if (being_added_dialog_id_ != dialog_id && !d->is_is_blocked_inited && !td_->auth_manager_->is_bot()) {
    // asynchronously get is_blocked from the server
    get_dialog_info_full(dialog_id, Auto());
  }
  if (being_added_dialog_id_ != dialog_id && !d->is_last_pinned_message_id_inited && !td_->auth_manager_->is_bot()) {
    // asynchronously get dialog pinned message from the server
    get_dialog_pinned_message(dialog_id, Auto());
  }
  if (being_added_dialog_id_ != dialog_id && !d->is_folder_id_inited && !td_->auth_manager_->is_bot() &&
      order != DEFAULT_ORDER) {
    // asynchronously get dialog folder id from the server
    get_dialog_info_full(dialog_id, Auto());
  }
  if (!d->is_message_ttl_setting_inited && !td_->auth_manager_->is_bot() && order != DEFAULT_ORDER) {
    // asynchronously get dialog message ttl setting from the server
    get_dialog_info_full(dialog_id, Auto());
  }
  if (!d->know_action_bar && !td_->auth_manager_->is_bot() && dialog_type != DialogType::SecretChat &&
      dialog_id != get_my_dialog_id() && have_input_peer(dialog_id, AccessRights::Read)) {
    // asynchronously get action bar from the server
    reget_dialog_action_bar(dialog_id, "fix_new_dialog");
  }
  if (d->has_active_group_call && !d->active_group_call_id.is_valid()) {
    repair_dialog_active_group_call_id(dialog_id);
  }

  if (d->notification_settings.is_synchronized && !d->notification_settings.is_use_default_fixed &&
      have_input_peer(dialog_id, AccessRights::Read) && !td_->auth_manager_->is_bot()) {
    LOG(INFO) << "Reget notification settings of " << dialog_id;
    if (dialog_type == DialogType::SecretChat) {
      if (d->notification_settings.mute_until == 0 && users_notification_settings_.mute_until == 0) {
        d->notification_settings.use_default_mute_until = true;
      }
      if (d->notification_settings.sound == "default" && users_notification_settings_.sound == "default") {
        d->notification_settings.use_default_sound = true;
      }
      if (d->notification_settings.show_preview && users_notification_settings_.show_preview) {
        d->notification_settings.use_default_show_preview = true;
      }
      d->notification_settings.is_use_default_fixed = true;
      on_dialog_updated(dialog_id, "reget notification settings");
    } else {
      send_get_dialog_notification_settings_query(dialog_id, Promise<>());
    }
  }
  if (td_->auth_manager_->is_bot() || d->notification_settings.use_default_mute_until ||
      d->notification_settings.mute_until <= G()->unix_time()) {
    d->notification_settings.mute_until = 0;
  } else {
    schedule_dialog_unmute(dialog_id, false, d->notification_settings.mute_until);
  }
  if (d->pinned_message_notification_message_id.is_valid()) {
    auto pinned_message_id = d->pinned_message_notification_message_id;
    if (!d->mention_notification_group.group_id.is_valid()) {
      LOG(ERROR) << "Have pinned message notification in " << pinned_message_id << " in " << dialog_id
                 << ", but there is no mention notification group";
      d->pinned_message_notification_message_id = MessageId();
      on_dialog_updated(dialog_id, "fix pinned message notification");
    } else if (is_dialog_pinned_message_notifications_disabled(d) ||
               pinned_message_id <= d->last_read_inbox_message_id ||
               pinned_message_id <= d->mention_notification_group.max_removed_message_id) {
      VLOG(notifications) << "Remove disabled pinned message notification in " << pinned_message_id << " in "
                          << dialog_id;
      send_closure_later(G()->notification_manager(), &NotificationManager::remove_temporary_notification_by_message_id,
                         d->mention_notification_group.group_id, pinned_message_id, true,
                         "fix pinned message notification");
      d->pinned_message_notification_message_id = MessageId();
      on_dialog_updated(dialog_id, "fix pinned message notification 2");
    }
  }
  if (d->new_secret_chat_notification_id.is_valid()) {
    auto &group_info = d->message_notification_group;
    if (d->new_secret_chat_notification_id.get() <= group_info.max_removed_notification_id.get() ||
        (group_info.last_notification_date == 0 && group_info.max_removed_notification_id.get() == 0)) {
      VLOG(notifications) << "Fix removing new secret chat " << d->new_secret_chat_notification_id << " in "
                          << dialog_id;
      d->new_secret_chat_notification_id = NotificationId();
      on_dialog_updated(dialog_id, "fix new secret chat notification identifier");
    }
  }

  auto pending_it = pending_add_dialog_last_database_message_dependent_dialogs_.find(dialog_id);
  if (pending_it != pending_add_dialog_last_database_message_dependent_dialogs_.end()) {
    auto pending_dialogs = std::move(pending_it->second);
    pending_add_dialog_last_database_message_dependent_dialogs_.erase(pending_it);

    for (auto &pending_dialog_id : pending_dialogs) {
      auto &counter_message = pending_add_dialog_last_database_message_[pending_dialog_id];
      CHECK(counter_message.first > 0);
      counter_message.first--;
      if (counter_message.first == 0) {
        add_dialog_last_database_message(get_dialog(pending_dialog_id), std::move(counter_message.second));
        pending_add_dialog_last_database_message_.erase(pending_dialog_id);
      }
    }
  }

  if (dialog_id != being_added_dialog_id_) {
    set_dialog_last_clear_history_date(d, last_clear_history_date, last_clear_history_message_id, "fix_new_dialog 8",
                                       is_loaded_from_database);

    set_dialog_order(d, order, false, is_loaded_from_database, "fix_new_dialog 9");
  }

  if (dialog_type != DialogType::SecretChat && d->last_new_message_id.is_valid() &&
      !d->last_new_message_id.is_server()) {
    // fix wrong last_new_message_id
    d->last_new_message_id = d->last_new_message_id.get_prev_server_message_id();
    on_dialog_updated(dialog_id, "fix_new_dialog 10");
  }

  bool need_get_history = true;

  // add last database message to dialog
  MessageId last_message_id;
  if (last_database_message != nullptr) {
    need_get_history = false;
    last_message_id = last_database_message->message_id;
  } else if (last_database_message_id.is_valid()) {
    last_message_id = last_database_message_id;
  }

  if (!d->last_new_message_id.is_valid() && d->last_new_message_id != MessageId()) {
    LOG(ERROR) << "Drop invalid last_new_message_id " << d->last_new_message_id << " in " << dialog_id;
    d->last_new_message_id = MessageId();
  }
  if (!d->last_new_message_id.is_valid() && d->max_unavailable_message_id.is_valid() &&
      d->max_unavailable_message_id.is_server()) {
    LOG(ERROR) << "Bugfixing wrong last_new_message_id with max_unavailable_message_id to "
               << d->max_unavailable_message_id << " in " << dialog_id;
    set_dialog_last_new_message_id(d, d->max_unavailable_message_id, "fix_new_dialog 11");
  }
  if (last_message_id.is_valid()) {
    if ((last_message_id.is_server() || dialog_type == DialogType::SecretChat) && !d->last_new_message_id.is_valid()) {
      LOG(ERROR) << "Bugfixing wrong last_new_message_id to " << last_message_id << " in " << dialog_id;
      // must be called before set_dialog_first_database_message_id and set_dialog_last_database_message_id
      set_dialog_last_new_message_id(d, last_message_id, "fix_new_dialog 1");
    }
    if (!d->first_database_message_id.is_valid() || d->first_database_message_id > last_message_id) {
      LOG(ERROR) << "Bugfixing wrong first_database_message_id from " << d->first_database_message_id << " to "
                 << last_message_id << " in " << dialog_id;
      set_dialog_first_database_message_id(d, last_message_id, "fix_new_dialog 2");
    }
    set_dialog_last_database_message_id(d, last_message_id, "fix_new_dialog 3", is_loaded_from_database);
  } else if (d->first_database_message_id.is_valid()) {
    // ensure that first_database_message_id <= last_database_message_id
    if (d->first_database_message_id <= d->last_new_message_id) {
      set_dialog_last_database_message_id(d, d->last_new_message_id, "fix_new_dialog 4");
    } else {
      // can't fix last_database_message_id, drop first_database_message_id; it shouldn't happen anyway
      set_dialog_first_database_message_id(d, MessageId(), "fix_new_dialog 5");
    }
  }
  d->debug_first_database_message_id = d->first_database_message_id;
  d->debug_last_database_message_id = d->last_database_message_id;
  d->debug_last_new_message_id = d->last_new_message_id;

  if (last_database_message != nullptr) {
    int32 dependent_dialog_count = 0;
    auto depend_on_dialog = [&](DialogId other_dialog_id) {
      if (other_dialog_id.is_valid() && !have_dialog(other_dialog_id)) {
        LOG(INFO) << "Postpone adding of last message in " << dialog_id << " because of cyclic dependency with "
                  << other_dialog_id;
        pending_add_dialog_last_database_message_dependent_dialogs_[other_dialog_id].push_back(dialog_id);
        dependent_dialog_count++;
      }
    };
    if (last_database_message->forward_info != nullptr) {
      depend_on_dialog(last_database_message->forward_info->sender_dialog_id);
      depend_on_dialog(last_database_message->forward_info->from_dialog_id);
    }
    depend_on_dialog(last_database_message->sender_dialog_id);
    depend_on_dialog(last_database_message->reply_in_dialog_id);
    depend_on_dialog(last_database_message->real_forward_from_dialog_id);

    if (dependent_dialog_count == 0) {
      add_dialog_last_database_message(d, std::move(last_database_message));
    } else {
      // can't add message immediately, because need to notify first about adding of dependent dialogs
      d->pending_last_message_date = last_database_message->date;
      d->pending_last_message_id = last_database_message->message_id;
      pending_add_dialog_last_database_message_[dialog_id] = {dependent_dialog_count, std::move(last_database_message)};
    }
  } else if (last_database_message_id.is_valid()) {
    auto date = DialogDate(order, dialog_id).get_date();
    if (date < MIN_PINNED_DIALOG_DATE) {
      d->pending_last_message_date = date;
      d->pending_last_message_id = last_database_message_id;
    }
  }

  switch (dialog_type) {
    case DialogType::User:
      break;
    case DialogType::Chat:
      if (d->last_read_inbox_message_id < d->last_read_outbox_message_id) {
        LOG(INFO) << "Last read outbox message is " << d->last_read_outbox_message_id << " in " << dialog_id
                  << ", but last read inbox message is " << d->last_read_inbox_message_id;
        // can't fix last_read_inbox_message_id by last_read_outbox_message_id because last_read_outbox_message_id is
        // just a message identifier not less than an identifier of last read outgoing message and less than
        // an identifier of first unread outgoing message, so it may not point to the outgoing message
        // read_history_inbox(dialog_id, d->last_read_outbox_message_id, d->server_unread_count, "fix_new_dialog 6");
      }
      break;
    case DialogType::Channel:
      break;
    case DialogType::SecretChat:
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
  }

  if (d->delete_last_message_date != 0) {
    if (d->last_message_id.is_valid()) {
      LOG(ERROR) << "Last " << d->deleted_last_message_id << " in " << dialog_id << " was deleted at "
                 << d->delete_last_message_date << ", but have last " << d->last_message_id;
      d->delete_last_message_date = 0;
      d->deleted_last_message_id = MessageId();
      d->is_last_message_deleted_locally = false;
      on_dialog_updated(dialog_id, "update_delete_last_message_date");
    } else {
      need_get_history = true;
    }
  }

  if (!G()->parameters().use_message_db) {
    d->has_loaded_scheduled_messages_from_database = true;
  }

  if (dialog_id != being_added_dialog_id_) {
    update_dialog_pos(d, "fix_new_dialog 7", true, is_loaded_from_database);
  }
  if (is_loaded_from_database && d->order != order && order < MAX_ORDINARY_DIALOG_ORDER &&
      !td_->contacts_manager_->is_dialog_info_received_from_server(dialog_id) && !d->had_last_yet_unsent_message) {
    LOG(ERROR) << dialog_id << " has order " << d->order << " instead of saved to database order " << order;
  }

  // must be after update_dialog_pos, because uses d->order
  if (d->pending_read_channel_inbox_pts != 0 && !td_->auth_manager_->is_bot() &&
      have_input_peer(dialog_id, AccessRights::Read) && need_unread_counter(d->order)) {
    if (d->pts == d->pending_read_channel_inbox_pts) {
      read_history_inbox(dialog_id, d->pending_read_channel_inbox_max_message_id,
                         d->pending_read_channel_inbox_server_unread_count, "fix_new_dialog 12");
      d->pending_read_channel_inbox_pts = 0;
      on_dialog_updated(dialog_id, "fix_new_dialog 13");
    } else if (d->pts > d->pending_read_channel_inbox_pts) {
      d->need_repair_channel_server_unread_count = true;
      d->pending_read_channel_inbox_pts = 0;
      on_dialog_updated(dialog_id, "fix_new_dialog 14");
    } else {
      channel_get_difference_retry_timeout_.add_timeout_in(dialog_id.get(), 0.001);
    }
  } else {
    d->pending_read_channel_inbox_pts = 0;
  }
  if (need_get_history && !td_->auth_manager_->is_bot() && dialog_id != being_added_dialog_id_ &&
      have_input_peer(dialog_id, AccessRights::Read) && (d->order != DEFAULT_ORDER || is_dialog_sponsored(d))) {
    get_history_from_the_end(dialog_id, true, false, Auto());
  }
  if (d->need_repair_server_unread_count && need_unread_counter(d->order)) {
    CHECK(dialog_type != DialogType::SecretChat);
    repair_server_unread_count(dialog_id, d->server_unread_count);
  }
  if (d->need_repair_channel_server_unread_count) {
    repair_channel_server_unread_count(d);
  }

  LOG(INFO) << "Loaded " << dialog_id << " with last new " << d->last_new_message_id << ", first database "
            << d->first_database_message_id << ", last database " << d->last_database_message_id << ", last "
            << d->last_message_id << " with order " << d->order;
  VLOG(notifications) << "Have " << dialog_id << " with message " << d->message_notification_group.group_id
                      << " with last " << d->message_notification_group.last_notification_id << " sent at "
                      << d->message_notification_group.last_notification_date << ", max removed "
                      << d->message_notification_group.max_removed_notification_id << "/"
                      << d->message_notification_group.max_removed_message_id << " and new secret chat "
                      << d->new_secret_chat_notification_id;
  VLOG(notifications) << "Have " << dialog_id << " with mention " << d->mention_notification_group.group_id
                      << " with last " << d->mention_notification_group.last_notification_id << " sent at "
                      << d->mention_notification_group.last_notification_date << ", max removed "
                      << d->mention_notification_group.max_removed_notification_id << "/"
                      << d->mention_notification_group.max_removed_message_id << " and pinned "
                      << d->pinned_message_notification_message_id;
  VLOG(notifications) << "In " << dialog_id << " have last_read_inbox_message_id = " << d->last_read_inbox_message_id
                      << ", last_new_message_id = " << d->last_new_message_id
                      << ", max_notification_message_id = " << d->max_notification_message_id;

  if (d->messages != nullptr) {
    CHECK(d->messages->message_id == last_message_id);
    CHECK(d->messages->left == nullptr);
    CHECK(d->messages->right == nullptr);
  }
}

void MessagesManager::add_dialog_last_database_message(Dialog *d, unique_ptr<Message> &&last_database_message) {
  CHECK(d != nullptr);
  CHECK(last_database_message != nullptr);
  CHECK(last_database_message->left == nullptr);
  CHECK(last_database_message->right == nullptr);

  auto message_id = last_database_message->message_id;
  CHECK(message_id.is_valid());
  LOG_CHECK(d->last_database_message_id == message_id)
      << message_id << " " << d->last_database_message_id << " " << d->debug_set_dialog_last_database_message_id;

  bool need_update_dialog_pos = false;
  const Message *m = nullptr;
  if (have_input_peer(d->dialog_id, AccessRights::Read)) {
    bool need_update = false;
    last_database_message->have_previous = false;
    last_database_message->have_next = false;
    last_database_message->from_database = true;
    m = add_message_to_dialog(d, std::move(last_database_message), false, &need_update, &need_update_dialog_pos,
                              "add_dialog_last_database_message 1");
    if (need_update_dialog_pos) {
      LOG(ERROR) << "Need to update pos in " << d->dialog_id;
    }
  }
  if (m != nullptr) {
    set_dialog_last_message_id(d, m->message_id, "add_dialog_last_database_message 2");
    send_update_chat_last_message(d, "add_dialog_last_database_message 3");
  } else {
    if (d->pending_last_message_date != 0) {
      d->pending_last_message_date = 0;
      d->pending_last_message_id = MessageId();
      need_update_dialog_pos = true;
    }
    on_dialog_updated(d->dialog_id, "add_dialog_last_database_message 4");  // resave without last database message

    if (!td_->auth_manager_->is_bot() && d->dialog_id != being_added_dialog_id_ &&
        have_input_peer(d->dialog_id, AccessRights::Read) && (d->order != DEFAULT_ORDER || is_dialog_sponsored(d))) {
      get_history_from_the_end(d->dialog_id, true, false, Auto());
    }
  }

  if (need_update_dialog_pos) {
    update_dialog_pos(d, "add_dialog_last_database_message 5");
  }
}

void MessagesManager::update_dialogs_hints(const Dialog *d) {
  if (!td_->auth_manager_->is_bot() && d->order != DEFAULT_ORDER) {
    dialogs_hints_.add(-d->dialog_id.get(), get_dialog_title(d->dialog_id) + ' ' + get_dialog_username(d->dialog_id));
  }
}

void MessagesManager::update_dialogs_hints_rating(const Dialog *d) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }
  if (d->order == DEFAULT_ORDER) {
    LOG(INFO) << "Remove " << d->dialog_id << " from chats search";
    dialogs_hints_.remove(-d->dialog_id.get());
  } else {
    LOG(INFO) << "Change position of " << d->dialog_id << " in chats search";
    dialogs_hints_.set_rating(-d->dialog_id.get(), -get_dialog_base_order(d));
  }
}

int64 MessagesManager::get_dialog_order(MessageId message_id, int32 message_date) {
  CHECK(!message_id.is_scheduled());
  return (static_cast<int64>(message_date) << 32) +
         message_id.get_prev_server_message_id().get_server_message_id().get();
}

bool MessagesManager::is_dialog_sponsored(const Dialog *d) const {
  return d->order == DEFAULT_ORDER && d->dialog_id == sponsored_dialog_id_;
}

int64 MessagesManager::get_dialog_base_order(const Dialog *d) const {
  if (td_->auth_manager_->is_bot()) {
    return 0;  // to not call get_dialog_list
  }
  if (is_dialog_sponsored(d)) {
    return SPONSORED_DIALOG_ORDER;
  }
  if (d->order == DEFAULT_ORDER) {
    return 0;
  }
  auto pinned_order = get_dialog_pinned_order(DialogListId(FolderId::main()), d->dialog_id);
  if (pinned_order != DEFAULT_ORDER) {
    return pinned_order;
  }
  return d->order;
}

int64 MessagesManager::get_dialog_private_order(const DialogList *list, const Dialog *d) const {
  if (list == nullptr || td_->auth_manager_->is_bot()) {
    return 0;
  }

  if (is_dialog_sponsored(d) && list->dialog_list_id == DialogListId(FolderId::main())) {
    return SPONSORED_DIALOG_ORDER;
  }
  if (d->order == DEFAULT_ORDER) {
    return 0;
  }
  auto pinned_order = get_dialog_pinned_order(list, d->dialog_id);
  if (pinned_order != DEFAULT_ORDER) {
    return pinned_order;
  }
  return d->order;
}

td_api::object_ptr<td_api::chatPosition> MessagesManager::get_chat_position_object(DialogListId dialog_list_id,
                                                                                   const Dialog *d) const {
  if (td_->auth_manager_->is_bot()) {
    return nullptr;
  }

  auto *list = get_dialog_list(dialog_list_id);
  if (list == nullptr) {
    return nullptr;
  }

  auto position = get_dialog_position_in_list(list, d);
  if (position.public_order == 0) {
    return nullptr;
  }

  auto chat_source = position.is_sponsored ? sponsored_dialog_source_.get_chat_source_object() : nullptr;
  return td_api::make_object<td_api::chatPosition>(dialog_list_id.get_chat_list_object(), position.public_order,
                                                   position.is_pinned, std::move(chat_source));
}

vector<td_api::object_ptr<td_api::chatPosition>> MessagesManager::get_chat_positions_object(const Dialog *d) const {
  vector<td_api::object_ptr<td_api::chatPosition>> positions;
  if (!td_->auth_manager_->is_bot()) {
    for (auto dialog_list_id : get_dialog_list_ids(d)) {
      auto position = get_chat_position_object(dialog_list_id, d);
      if (position != nullptr) {
        positions.push_back(std::move(position));
      }
    }
    if (is_dialog_sponsored(d)) {
      CHECK(positions.empty());
      positions.push_back(get_chat_position_object(DialogListId(FolderId::main()), d));
    }
  }
  return positions;
}

int64 MessagesManager::get_next_pinned_dialog_order() {
  current_pinned_dialog_order_++;
  LOG(INFO) << "Assign pinned_order = " << current_pinned_dialog_order_;
  return current_pinned_dialog_order_;
}

bool MessagesManager::is_removed_from_dialog_list(const Dialog *d) const {
  switch (d->dialog_id.get_type()) {
    case DialogType::User:
      break;
    case DialogType::Chat:
      return !td_->contacts_manager_->get_chat_is_active(d->dialog_id.get_chat_id());
    case DialogType::Channel:
      return !td_->contacts_manager_->get_channel_status(d->dialog_id.get_channel_id()).is_member();
    case DialogType::SecretChat:
      break;
    case DialogType::None:
    default:
      UNREACHABLE();
      break;
  }
  return false;
}

void MessagesManager::update_dialog_pos(Dialog *d, const char *source, bool need_send_update,
                                        bool is_loaded_from_database) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  LOG(INFO) << "Trying to update " << d->dialog_id << " order from " << source;

  int64 new_order = DEFAULT_ORDER;
  if (!is_removed_from_dialog_list(d)) {
    if (d->last_message_id != MessageId()) {
      auto m = get_message(d, d->last_message_id);
      CHECK(m != nullptr);
      LOG(INFO) << "Last message at " << m->date << " found";
      int64 last_message_order = get_dialog_order(m->message_id, m->date);
      if (last_message_order > new_order) {
        new_order = last_message_order;
      }
    } else if (d->delete_last_message_date > 0) {
      LOG(INFO) << "Deleted last " << d->deleted_last_message_id << " at " << d->delete_last_message_date << " found";
      int64 delete_order = get_dialog_order(d->deleted_last_message_id, d->delete_last_message_date);
      if (delete_order > new_order) {
        new_order = delete_order;
      }
    } else if (d->last_clear_history_date > 0) {
      LOG(INFO) << "Clear history at " << d->last_clear_history_date << " found";
      int64 clear_order = get_dialog_order(d->last_clear_history_message_id, d->last_clear_history_date);
      if (clear_order > new_order) {
        new_order = clear_order;
      }
    }
    if (d->pending_last_message_date > 0) {
      LOG(INFO) << "Pending last " << d->pending_last_message_id << " at " << d->pending_last_message_date << " found";
      int64 pending_order = get_dialog_order(d->pending_last_message_id, d->pending_last_message_date);
      if (pending_order > new_order) {
        new_order = pending_order;
      }
    }
    if (d->draft_message != nullptr && can_send_message(d->dialog_id).is_ok()) {
      LOG(INFO) << "Draft message at " << d->draft_message->date << " found";
      int64 draft_order = get_dialog_order(MessageId(), d->draft_message->date);
      if (draft_order > new_order) {
        new_order = draft_order;
      }
    }
    auto dialog_type = d->dialog_id.get_type();
    if (dialog_type == DialogType::Channel) {
      auto date = td_->contacts_manager_->get_channel_date(d->dialog_id.get_channel_id());
      LOG(INFO) << "Join of channel at " << date << " found";
      int64 join_order = get_dialog_order(MessageId(), date);
      if (join_order > new_order) {
        new_order = join_order;
      }
    }
    if (dialog_type == DialogType::SecretChat) {
      auto date = td_->contacts_manager_->get_secret_chat_date(d->dialog_id.get_secret_chat_id());
      if (date != 0 && !is_deleted_secret_chat(d)) {
        LOG(INFO) << "Creation of secret chat at " << date << " found";
        int64 creation_order = get_dialog_order(MessageId(), date);
        if (creation_order > new_order) {
          new_order = creation_order;
        }
      }
    }
    if (new_order == DEFAULT_ORDER && !d->is_empty) {
      LOG(INFO) << "There are no known messages in the chat, just leave it where it is";
      new_order = d->order;
    }
  }

  if (set_dialog_order(d, new_order, need_send_update, is_loaded_from_database, source)) {
    on_dialog_updated(d->dialog_id, "update_dialog_pos");
  }
}

bool MessagesManager::set_dialog_order(Dialog *d, int64 new_order, bool need_send_update, bool is_loaded_from_database,
                                       const char *source) {
  if (td_->auth_manager_->is_bot()) {
    return false;
  }

  CHECK(d != nullptr);
  DialogId dialog_id = d->dialog_id;
  DialogDate old_date(d->order, dialog_id);
  DialogDate new_date(new_order, dialog_id);

  if (old_date == new_date) {
    LOG(INFO) << "Order of " << d->dialog_id << " from " << d->folder_id << " is still " << new_order << " from "
              << source;
  } else {
    LOG(INFO) << "Update order of " << dialog_id << " from " << d->folder_id << " from " << d->order << " to "
              << new_order << " from " << source;
  }

  auto folder_ptr = get_dialog_folder(d->folder_id);
  CHECK(folder_ptr != nullptr);
  auto &folder = *folder_ptr;
  if (old_date == new_date) {
    if (new_order == DEFAULT_ORDER) {
      // first addition of a new left dialog
      if (folder.ordered_dialogs_.insert(new_date).second) {
        for (auto &dialog_list : dialog_lists_) {
          if (get_dialog_pinned_order(&dialog_list.second, d->dialog_id) != DEFAULT_ORDER) {
            set_dialog_is_pinned(dialog_list.first, d, false);
          }
        }
      }
    }

    return false;
  }

  auto dialog_positions = get_dialog_positions(d);

  if (folder.ordered_dialogs_.erase(old_date) == 0) {
    LOG_IF(ERROR, d->order != DEFAULT_ORDER) << dialog_id << " not found in the chat list from " << source;
  }

  folder.ordered_dialogs_.insert(new_date);

  bool is_added = (d->order == DEFAULT_ORDER);
  bool is_removed = (new_order == DEFAULT_ORDER);

  d->order = new_order;

  if (is_added) {
    update_dialogs_hints(d);
  }
  update_dialogs_hints_rating(d);

  update_dialog_lists(d, std::move(dialog_positions), need_send_update, is_loaded_from_database, source);

  if (!is_loaded_from_database) {
    auto dialog_type = dialog_id.get_type();
    if (dialog_type == DialogType::Channel && is_added && being_added_dialog_id_ != dialog_id) {
      repair_channel_server_unread_count(d);
      LOG(INFO) << "Schedule getDifference in " << dialog_id.get_channel_id();
      channel_get_difference_retry_timeout_.add_timeout_in(dialog_id.get(), 0.001);
    }
    if (dialog_type == DialogType::Channel && is_removed) {
      remove_all_dialog_notifications(d, false, source);
      remove_all_dialog_notifications(d, true, source);
      clear_active_dialog_actions(dialog_id);
    }
  }

  return true;
}

void MessagesManager::update_dialog_lists(
    Dialog *d, std::unordered_map<DialogListId, DialogPositionInList, DialogListIdHash> &&old_positions,
    bool need_send_update, bool is_loaded_from_database, const char *source) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(d != nullptr);
  auto dialog_id = d->dialog_id;
  if (being_added_dialog_id_ == dialog_id) {
    // do not try to update dialog lists, while the dialog isn't inited
    return;
  }

  LOG(INFO) << "Update lists of " << dialog_id << " from " << source;

  if (d->order == DEFAULT_ORDER) {
    for (auto &old_position : old_positions) {
      if (old_position.second.is_pinned) {
        set_dialog_is_pinned(old_position.first, d, false, false);
      }
    }

    if (d->folder_id != FolderId::main()) {
      LOG(INFO) << "Change folder of " << dialog_id << " to " << FolderId::main();
      do_set_dialog_folder_id(d, FolderId::main());
    }
  }

  for (auto &dialog_list : dialog_lists_) {
    auto dialog_list_id = dialog_list.first;
    auto &list = dialog_list.second;

    const DialogPositionInList &old_position = old_positions[dialog_list_id];
    const DialogPositionInList new_position = get_dialog_position_in_list(&list, d, true);

    // sponsored chat is never "in list"
    bool was_in_list = old_position.order != DEFAULT_ORDER && old_position.private_order != 0;
    bool is_in_list = new_position.order != DEFAULT_ORDER && new_position.private_order != 0;
    CHECK(was_in_list == is_dialog_in_list(d, dialog_list_id));

    LOG(DEBUG) << "Update position of " << dialog_id << " in " << dialog_list_id << " from " << old_position << " to "
               << new_position;

    bool need_update_unread_chat_count = false;
    if (was_in_list != is_in_list) {
      const int32 delta = was_in_list ? -1 : 1;
      list.in_memory_dialog_total_count_ += delta;
      if (!is_loaded_from_database) {
        int32 &total_count = dialog_id.get_type() == DialogType::SecretChat ? list.secret_chat_total_count_
                                                                            : list.server_dialog_total_count_;
        if (total_count != -1) {
          total_count += delta;
          if (total_count < 0) {
            LOG(ERROR) << "Total chat count became negative after leaving " << dialog_id;
            total_count = 0;
          }
        }
      }

      if (!is_loaded_from_database) {
        need_update_unread_chat_count =
            list.is_dialog_unread_count_inited_ && old_position.total_dialog_count != get_dialog_total_count(list);
        auto unread_count = d->server_unread_count + d->local_unread_count;
        const char *change_source = was_in_list ? "on_dialog_leave" : "on_dialog_join";
        if (unread_count != 0 && list.is_message_unread_count_inited_) {
          unread_count *= delta;

          list.unread_message_total_count_ += unread_count;
          if (is_dialog_muted(d)) {
            list.unread_message_muted_count_ += unread_count;
          }
          send_update_unread_message_count(list, dialog_id, true, change_source);
        }
        if ((unread_count != 0 || d->is_marked_as_unread) && list.is_dialog_unread_count_inited_) {
          list.unread_dialog_total_count_ += delta;
          if (unread_count == 0 && d->is_marked_as_unread) {
            list.unread_dialog_marked_count_ += delta;
          }
          if (is_dialog_muted(d)) {
            list.unread_dialog_muted_count_ += delta;
            if (unread_count == 0 && d->is_marked_as_unread) {
              list.unread_dialog_muted_marked_count_ += delta;
            }
          }
          need_update_unread_chat_count = true;
        }
        if (need_update_unread_chat_count) {
          send_update_unread_chat_count(list, dialog_id, true, change_source);
        }
      }

      if (was_in_list) {
        remove_dialog_from_list(d, dialog_list_id);
      } else {
        add_dialog_to_list(d, dialog_list_id);
      }
    }
    if (!need_update_unread_chat_count && list.is_dialog_unread_count_inited_ &&
        old_position.total_dialog_count != get_dialog_total_count(list)) {
      send_update_unread_chat_count(list, dialog_id, true, "changed total count");
    }

    if (need_send_update && need_send_update_chat_position(old_position, new_position)) {
      send_update_chat_position(dialog_list_id, d, source);
    }

    if (!is_loaded_from_database && !old_position.is_sponsored && new_position.is_sponsored) {
      // a chat is sponsored only if user isn't a chat member
      remove_all_dialog_notifications(d, false, "update_dialog_lists 3");
      remove_all_dialog_notifications(d, true, "update_dialog_lists 4");
    }
  }
}

void MessagesManager::update_last_dialog_date(FolderId folder_id) {
  CHECK(!td_->auth_manager_->is_bot());
  auto *folder = get_dialog_folder(folder_id);
  CHECK(folder != nullptr);
  auto old_last_dialog_date = folder->folder_last_dialog_date_;
  folder->folder_last_dialog_date_ = folder->last_server_dialog_date_;
  CHECK(old_last_dialog_date <= folder->folder_last_dialog_date_);

  LOG(INFO) << "Update last dialog date in " << folder_id << " from " << old_last_dialog_date << " to "
            << folder->folder_last_dialog_date_;
  LOG(INFO) << "Know about " << folder->ordered_dialogs_.size() << " chats";

  if (old_last_dialog_date != folder->folder_last_dialog_date_) {
    for (auto &dialog_list : dialog_lists_) {
      update_list_last_pinned_dialog_date(dialog_list.second);
      update_list_last_dialog_date(dialog_list.second);
    }
  }

  if (G()->parameters().use_message_db &&
      folder->last_database_server_dialog_date_ < folder->last_server_dialog_date_) {
    auto last_server_dialog_date_string = PSTRING() << folder->last_server_dialog_date_.get_order() << ' '
                                                    << folder->last_server_dialog_date_.get_dialog_id().get();
    G()->td_db()->get_binlog_pmc()->set(PSTRING() << "last_server_dialog_date" << folder_id.get(),
                                        last_server_dialog_date_string);
    LOG(INFO) << "Save last server dialog date " << last_server_dialog_date_string;
    folder->last_database_server_dialog_date_ = folder->last_server_dialog_date_;
    folder->last_loaded_database_dialog_date_ = folder->last_server_dialog_date_;
  }
}

// must not call get_dialog_filter
bool MessagesManager::do_update_list_last_pinned_dialog_date(DialogList &list) const {
  CHECK(!td_->auth_manager_->is_bot());
  if (list.last_pinned_dialog_date_ == MAX_DIALOG_DATE) {
    return false;
  }
  if (!list.are_pinned_dialogs_inited_) {
    return false;
  }

  DialogDate max_dialog_date = MIN_DIALOG_DATE;
  for (auto &pinned_dialog : list.pinned_dialogs_) {
    if (!have_dialog(pinned_dialog.get_dialog_id())) {
      break;
    }

    max_dialog_date = pinned_dialog;
  }
  if (list.pinned_dialogs_.empty() || max_dialog_date == list.pinned_dialogs_.back()) {
    max_dialog_date = MAX_DIALOG_DATE;
  }
  if (list.last_pinned_dialog_date_ < max_dialog_date) {
    LOG(INFO) << "Update last pinned dialog date in " << list.dialog_list_id << " from "
              << list.last_pinned_dialog_date_ << " to " << max_dialog_date;
    list.last_pinned_dialog_date_ = max_dialog_date;
    return true;
  }
  return false;
}

void MessagesManager::update_list_last_pinned_dialog_date(DialogList &list) {
  CHECK(!td_->auth_manager_->is_bot());
  if (do_update_list_last_pinned_dialog_date(list)) {
    update_list_last_dialog_date(list);
  }
}

// must not call get_dialog_filter
bool MessagesManager::do_update_list_last_dialog_date(DialogList &list, const vector<FolderId> &folder_ids) const {
  CHECK(!td_->auth_manager_->is_bot());
  auto new_last_dialog_date = list.last_pinned_dialog_date_;
  for (auto folder_id : folder_ids) {
    const auto &folder = *get_dialog_folder(folder_id);
    if (folder.folder_last_dialog_date_ < new_last_dialog_date) {
      new_last_dialog_date = folder.folder_last_dialog_date_;
    }
  }

  if (list.list_last_dialog_date_ != new_last_dialog_date) {
    auto old_last_dialog_date = list.list_last_dialog_date_;
    LOG(INFO) << "Update last dialog date in " << list.dialog_list_id << " from " << old_last_dialog_date << " to "
              << new_last_dialog_date;
    LOG_CHECK(old_last_dialog_date < new_last_dialog_date)
        << list.dialog_list_id << " " << old_last_dialog_date << " " << new_last_dialog_date << " "
        << get_dialog_list_folder_ids(list) << " " << list.last_pinned_dialog_date_ << " "
        << get_dialog_folder(FolderId::main())->folder_last_dialog_date_ << " "
        << get_dialog_folder(FolderId::archive())->folder_last_dialog_date_ << " " << list.load_list_queries_.size()
        << " " << list.pinned_dialogs_;
    list.list_last_dialog_date_ = new_last_dialog_date;
    return true;
  }
  return false;
}

void MessagesManager::update_list_last_dialog_date(DialogList &list) {
  CHECK(!td_->auth_manager_->is_bot());
  auto old_dialog_total_count = get_dialog_total_count(list);
  auto old_last_dialog_date = list.list_last_dialog_date_;
  if (!do_update_list_last_dialog_date(list, get_dialog_list_folder_ids(list))) {
    return;
  }

  for (auto it = std::upper_bound(list.pinned_dialogs_.begin(), list.pinned_dialogs_.end(), old_last_dialog_date);
       it != list.pinned_dialogs_.end() && *it <= list.list_last_dialog_date_; ++it) {
    auto dialog_id = it->get_dialog_id();
    auto d = get_dialog(dialog_id);
    CHECK(d != nullptr);
    send_update_chat_position(list.dialog_list_id, d, "update_list_last_dialog_date");
  }

  bool is_list_further_loaded = list.list_last_dialog_date_ == MAX_DIALOG_DATE;
  for (auto folder_id : get_dialog_list_folder_ids(list)) {
    const auto &folder = *get_dialog_folder(folder_id);
    for (auto it = folder.ordered_dialogs_.upper_bound(old_last_dialog_date);
         it != folder.ordered_dialogs_.end() && *it <= folder.folder_last_dialog_date_; ++it) {
      if (it->get_order() == DEFAULT_ORDER) {
        break;
      }
      auto dialog_id = it->get_dialog_id();
      if (get_dialog_pinned_order(&list, dialog_id) == DEFAULT_ORDER) {
        auto d = get_dialog(dialog_id);
        CHECK(d != nullptr);
        if (is_dialog_in_list(d, list.dialog_list_id)) {
          send_update_chat_position(list.dialog_list_id, d, "update_list_last_dialog_date 2");
          is_list_further_loaded = true;
        }
      }
    }
  }

  if (list.list_last_dialog_date_ == MAX_DIALOG_DATE) {
    recalc_unread_count(list.dialog_list_id, old_dialog_total_count);
  }

  if (is_list_further_loaded && !list.load_list_queries_.empty()) {
    auto promises = std::move(list.load_list_queries_);
    list.load_list_queries_.clear();
    for (auto &promise : promises) {
      promise.set_value(Unit());
    }
  }
}

uint64 MessagesManager::get_sequence_dispatcher_id(DialogId dialog_id, MessageContentType message_content_type) {
  switch (message_content_type) {
    case MessageContentType::Animation:
    case MessageContentType::Audio:
    case MessageContentType::Document:
    case MessageContentType::Photo:
    case MessageContentType::Sticker:
    case MessageContentType::Video:
    case MessageContentType::VideoNote:
    case MessageContentType::VoiceNote:
      return static_cast<uint64>(dialog_id.get() * 2 + 1);
    default:
      return static_cast<uint64>(dialog_id.get() * 2 + 2);
  }
}

MessagesManager::Dialog *MessagesManager::get_dialog(DialogId dialog_id) {
  auto it = dialogs_.find(dialog_id);
  return it == dialogs_.end() ? nullptr : it->second.get();
}

const MessagesManager::Dialog *MessagesManager::get_dialog(DialogId dialog_id) const {
  auto it = dialogs_.find(dialog_id);
  return it == dialogs_.end() ? nullptr : it->second.get();
}

bool MessagesManager::have_dialog_force(DialogId dialog_id) {
  return loaded_dialogs_.count(dialog_id) > 0 || get_dialog_force(dialog_id) != nullptr;
}

MessagesManager::Dialog *MessagesManager::get_dialog_force(DialogId dialog_id) {
  // TODO remove most usages of that function, preload dialog asynchronously if possible
  auto it = dialogs_.find(dialog_id);
  if (it != dialogs_.end()) {
    return it->second.get();
  }

  if (!dialog_id.is_valid() || !G()->parameters().use_message_db || loaded_dialogs_.count(dialog_id) > 0) {
    return nullptr;
  }

  auto r_value = G()->td_db()->get_dialog_db_sync()->get_dialog(dialog_id);
  if (r_value.is_ok()) {
    LOG(INFO) << "Loaded " << dialog_id << " from database";
    auto d = on_load_dialog_from_database(dialog_id, r_value.move_as_ok());
    LOG_CHECK(d == nullptr || d->dialog_id == dialog_id) << d->dialog_id << " " << dialog_id;
    return d;
  } else {
    LOG(INFO) << "Failed to load " << dialog_id << " from database: " << r_value.error().message();
    return nullptr;
  }
}

unique_ptr<MessagesManager::Dialog> MessagesManager::parse_dialog(DialogId dialog_id, const BufferSlice &value) {
  LOG(INFO) << "Loaded " << dialog_id << " of size " << value.size() << " from database";
  auto d = make_unique<Dialog>();
  d->dialog_id = dialog_id;
  invalidate_message_indexes(d.get());  // must initialize indexes, because some of them could be not parsed

  loaded_dialogs_.insert(dialog_id);

  auto status = log_event_parse(*d, value.as_slice());
  if (status.is_error() || !d->dialog_id.is_valid() || d->dialog_id != dialog_id) {
    // can't happen unless database is broken, but has been seen in the wild
    // if dialog_id is invalid, we can't repair the dialog
    LOG_CHECK(dialog_id.is_valid()) << "Can't repair " << dialog_id << ' ' << d->dialog_id << ' ' << status << ' '
                                    << format::as_hex_dump<4>(value.as_slice());

    LOG(ERROR) << "Repair broken " << dialog_id << ' ' << format::as_hex_dump<4>(value.as_slice());

    // just clean all known data about the dialog
    d = make_unique<Dialog>();
    d->dialog_id = dialog_id;
    invalidate_message_indexes(d.get());

    // and try to reget it from the server if possible
    have_dialog_info_force(dialog_id);
    if (have_input_peer(dialog_id, AccessRights::Read)) {
      if (dialog_id.get_type() != DialogType::SecretChat) {
        send_get_dialog_query(dialog_id, Auto(), 0, "parse_dialog");
      }
    } else {
      LOG(ERROR) << "Have no info about " << dialog_id << " to repair it";
    }
  }
  CHECK(dialog_id == d->dialog_id);

  Dependencies dependencies;
  add_dialog_dependencies(dependencies, dialog_id);
  if (d->messages != nullptr) {
    add_message_dependencies(dependencies, dialog_id, d->messages.get());
  }
  if (d->draft_message != nullptr) {
    add_formatted_text_dependencies(dependencies, &d->draft_message->input_message_text.text);
  }
  resolve_dependencies_force(td_, dependencies, "parse_dialog");

  return d;
}

MessagesManager::Dialog *MessagesManager::on_load_dialog_from_database(DialogId dialog_id, const BufferSlice &value) {
  CHECK(G()->parameters().use_message_db);

  if (!dialog_id.is_valid()) {
    // hack
    LogEventParser dialog_id_parser(value.as_slice());
    int32 flags;
    parse(flags, dialog_id_parser);
    parse(dialog_id, dialog_id_parser);

    if (!dialog_id.is_valid()) {
      LOG(ERROR) << "Failed to parse dialog_id from blob. Database is broken";
      return nullptr;
    }
  }

  auto old_d = get_dialog(dialog_id);
  if (old_d != nullptr) {
    return old_d;
  }

  LOG(INFO) << "Add new " << dialog_id << " from database";
  return add_new_dialog(parse_dialog(dialog_id, value), true);
}

const DialogFilter *MessagesManager::get_server_dialog_filter(DialogFilterId dialog_filter_id) const {
  CHECK(!disable_get_dialog_filter_);
  for (const auto &filter : server_dialog_filters_) {
    if (filter->dialog_filter_id == dialog_filter_id) {
      return filter.get();
    }
  }
  return nullptr;
}

DialogFilter *MessagesManager::get_dialog_filter(DialogFilterId dialog_filter_id) {
  CHECK(!disable_get_dialog_filter_);
  for (auto &filter : dialog_filters_) {
    if (filter->dialog_filter_id == dialog_filter_id) {
      return filter.get();
    }
  }
  return nullptr;
}

const DialogFilter *MessagesManager::get_dialog_filter(DialogFilterId dialog_filter_id) const {
  CHECK(!disable_get_dialog_filter_);
  for (const auto &filter : dialog_filters_) {
    if (filter->dialog_filter_id == dialog_filter_id) {
      return filter.get();
    }
  }
  return nullptr;
}

vector<DialogFilterId> MessagesManager::get_dialog_filter_ids(const vector<unique_ptr<DialogFilter>> &dialog_filters) {
  return transform(dialog_filters, [](const auto &dialog_filter) { return dialog_filter->dialog_filter_id; });
}

vector<FolderId> MessagesManager::get_dialog_filter_folder_ids(const DialogFilter *filter) {
  CHECK(filter != nullptr);
  if (filter->exclude_archived && filter->pinned_dialog_ids.empty() && filter->included_dialog_ids.empty()) {
    return {FolderId::main()};
  }
  return {FolderId::main(), FolderId::archive()};
}

vector<FolderId> MessagesManager::get_dialog_list_folder_ids(const DialogList &list) const {
  CHECK(!td_->auth_manager_->is_bot());
  if (list.dialog_list_id.is_folder()) {
    return {list.dialog_list_id.get_folder_id()};
  }
  if (list.dialog_list_id.is_filter()) {
    auto dialog_filter_id = list.dialog_list_id.get_filter_id();
    return get_dialog_filter_folder_ids(get_dialog_filter(dialog_filter_id));
  }
  UNREACHABLE();
  return {};
}

bool MessagesManager::has_dialogs_from_folder(const DialogList &list, const DialogFolder &folder) const {
  CHECK(!td_->auth_manager_->is_bot());
  if (list.dialog_list_id.is_folder()) {
    return list.dialog_list_id.get_folder_id() == folder.folder_id;
  }
  if (list.dialog_list_id.is_filter()) {
    auto dialog_filter_id = list.dialog_list_id.get_filter_id();
    auto *filter = get_dialog_filter(dialog_filter_id);
    CHECK(filter != nullptr);
    if (filter->exclude_archived && filter->pinned_dialog_ids.empty() && filter->included_dialog_ids.empty()) {
      return folder.folder_id == FolderId::main();
    }
    return true;
  }
  UNREACHABLE();
  return false;
}

bool MessagesManager::is_dialog_in_list(const Dialog *d, DialogListId dialog_list_id) const {
  return td::contains(d->dialog_list_ids, dialog_list_id);
}

void MessagesManager::add_dialog_to_list(Dialog *d, DialogListId dialog_list_id) const {
  LOG(INFO) << "Add " << d->dialog_id << " to " << dialog_list_id;
  CHECK(!is_dialog_in_list(d, dialog_list_id));
  d->dialog_list_ids.push_back(dialog_list_id);
}

void MessagesManager::remove_dialog_from_list(Dialog *d, DialogListId dialog_list_id) const {
  LOG(INFO) << "Remove " << d->dialog_id << " from " << dialog_list_id;
  bool is_removed = td::remove(d->dialog_list_ids, dialog_list_id);
  CHECK(is_removed);
}

bool MessagesManager::need_dialog_in_filter(const Dialog *d, const DialogFilter *filter) const {
  CHECK(d != nullptr);
  CHECK(filter != nullptr);
  CHECK(d->order != DEFAULT_ORDER);

  if (InputDialogId::contains(filter->pinned_dialog_ids, d->dialog_id)) {
    return true;
  }
  if (InputDialogId::contains(filter->included_dialog_ids, d->dialog_id)) {
    return true;
  }
  if (InputDialogId::contains(filter->excluded_dialog_ids, d->dialog_id)) {
    return false;
  }
  if (d->dialog_id.get_type() == DialogType::SecretChat) {
    auto user_id = td_->contacts_manager_->get_secret_chat_user_id(d->dialog_id.get_secret_chat_id());
    if (user_id.is_valid()) {
      auto dialog_id = DialogId(user_id);
      if (InputDialogId::contains(filter->pinned_dialog_ids, dialog_id)) {
        return true;
      }
      if (InputDialogId::contains(filter->included_dialog_ids, dialog_id)) {
        return true;
      }
      if (InputDialogId::contains(filter->excluded_dialog_ids, dialog_id)) {
        return false;
      }
    }
  }
  if (d->unread_mention_count == 0 || is_dialog_mention_notifications_disabled(d)) {
    if (filter->exclude_muted && is_dialog_muted(d)) {
      return false;
    }
    if (filter->exclude_read && d->server_unread_count + d->local_unread_count == 0 && !d->is_marked_as_unread) {
      return false;
    }
  }
  if (filter->exclude_archived && d->folder_id == FolderId::archive()) {
    return false;
  }
  switch (d->dialog_id.get_type()) {
    case DialogType::User: {
      auto user_id = d->dialog_id.get_user_id();
      if (td_->contacts_manager_->is_user_bot(user_id)) {
        return filter->include_bots;
      }
      if (user_id == td_->contacts_manager_->get_my_id() || td_->contacts_manager_->is_user_contact(user_id)) {
        return filter->include_contacts;
      }
      return filter->include_non_contacts;
    }
    case DialogType::Chat:
      return filter->include_groups;
    case DialogType::Channel:
      return is_broadcast_channel(d->dialog_id) ? filter->include_channels : filter->include_groups;
    case DialogType::SecretChat: {
      auto user_id = td_->contacts_manager_->get_secret_chat_user_id(d->dialog_id.get_secret_chat_id());
      if (td_->contacts_manager_->is_user_bot(user_id)) {
        return filter->include_bots;
      }
      if (td_->contacts_manager_->is_user_contact(user_id)) {
        return filter->include_contacts;
      }
      return filter->include_non_contacts;
    }
    default:
      UNREACHABLE();
      return false;
  }
}

bool MessagesManager::need_dialog_in_list(const Dialog *d, const DialogList &list) const {
  CHECK(!td_->auth_manager_->is_bot());
  if (d->order == DEFAULT_ORDER) {
    return false;
  }
  if (list.dialog_list_id.is_folder()) {
    return d->folder_id == list.dialog_list_id.get_folder_id();
  }
  if (list.dialog_list_id.is_filter()) {
    auto dialog_filter_id = list.dialog_list_id.get_filter_id();
    return need_dialog_in_filter(d, get_dialog_filter(dialog_filter_id));
  }
  UNREACHABLE();
  return false;
}

bool MessagesManager::need_send_update_chat_position(const DialogPositionInList &old_position,
                                                     const DialogPositionInList &new_position) {
  if (old_position.public_order != new_position.public_order) {
    return true;
  }
  if (old_position.public_order == 0) {
    return false;
  }
  return old_position.is_pinned != new_position.is_pinned || old_position.is_sponsored != new_position.is_sponsored;
}

MessagesManager::DialogPositionInList MessagesManager::get_dialog_position_in_list(const DialogList *list,
                                                                                   const Dialog *d, bool actual) const {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(list != nullptr);
  CHECK(d != nullptr);

  DialogPositionInList position;
  position.order = d->order;
  if (is_dialog_sponsored(d) || (actual ? need_dialog_in_list(d, *list) : is_dialog_in_list(d, list->dialog_list_id))) {
    position.private_order = get_dialog_private_order(list, d);
  }
  if (position.private_order != 0) {
    position.public_order =
        DialogDate(position.private_order, d->dialog_id) <= list->list_last_dialog_date_ ? position.private_order : 0;
    position.is_pinned = get_dialog_pinned_order(list, d->dialog_id) != DEFAULT_ORDER;
    position.is_sponsored = is_dialog_sponsored(d);
  }
  position.total_dialog_count = get_dialog_total_count(*list);
  return position;
}

std::unordered_map<DialogListId, MessagesManager::DialogPositionInList, DialogListIdHash>
MessagesManager::get_dialog_positions(const Dialog *d) const {
  CHECK(d != nullptr);
  std::unordered_map<DialogListId, MessagesManager::DialogPositionInList, DialogListIdHash> positions;
  if (!td_->auth_manager_->is_bot()) {
    for (auto &dialog_list : dialog_lists_) {
      positions.emplace(dialog_list.first, get_dialog_position_in_list(&dialog_list.second, d));
    }
  }
  return positions;
}

vector<DialogListId> MessagesManager::get_dialog_list_ids(const Dialog *d) const {
  return d->dialog_list_ids;
}

MessagesManager::DialogListView MessagesManager::get_dialog_lists(const Dialog *d) {
  return DialogListView(this, get_dialog_list_ids(d));
}

MessagesManager::DialogList &MessagesManager::add_dialog_list(DialogListId dialog_list_id) {
  CHECK(!td_->auth_manager_->is_bot());
  if (dialog_list_id.is_folder() && dialog_list_id.get_folder_id() != FolderId::archive()) {
    dialog_list_id = DialogListId(FolderId::main());
  }
  if (dialog_lists_.find(dialog_list_id) == dialog_lists_.end()) {
    LOG(INFO) << "Create " << dialog_list_id;
  }
  auto &list = dialog_lists_[dialog_list_id];
  list.dialog_list_id = dialog_list_id;
  return list;
}

MessagesManager::DialogList *MessagesManager::get_dialog_list(DialogListId dialog_list_id) {
  CHECK(!td_->auth_manager_->is_bot());
  if (dialog_list_id.is_folder() && dialog_list_id.get_folder_id() != FolderId::archive()) {
    dialog_list_id = DialogListId(FolderId::main());
  }
  auto it = dialog_lists_.find(dialog_list_id);
  if (it == dialog_lists_.end()) {
    return nullptr;
  }
  return &it->second;
}

const MessagesManager::DialogList *MessagesManager::get_dialog_list(DialogListId dialog_list_id) const {
  CHECK(!td_->auth_manager_->is_bot());
  if (dialog_list_id.is_folder() && dialog_list_id.get_folder_id() != FolderId::archive()) {
    dialog_list_id = DialogListId(FolderId::main());
  }
  auto it = dialog_lists_.find(dialog_list_id);
  if (it == dialog_lists_.end()) {
    return nullptr;
  }
  return &it->second;
}

MessagesManager::DialogFolder *MessagesManager::get_dialog_folder(FolderId folder_id) {
  CHECK(!td_->auth_manager_->is_bot());
  if (folder_id != FolderId::archive()) {
    folder_id = FolderId::main();
  }
  auto it = dialog_folders_.find(folder_id);
  if (it == dialog_folders_.end()) {
    return nullptr;
  }
  return &it->second;
}

const MessagesManager::DialogFolder *MessagesManager::get_dialog_folder(FolderId folder_id) const {
  CHECK(!td_->auth_manager_->is_bot());
  if (folder_id != FolderId::archive()) {
    folder_id = FolderId::main();
  }
  auto it = dialog_folders_.find(folder_id);
  if (it == dialog_folders_.end()) {
    return nullptr;
  }
  return &it->second;
}

void MessagesManager::load_notification_settings() {
  if (td_->auth_manager_->is_bot()) {
    return;
  }
  if (!users_notification_settings_.is_synchronized) {
    send_get_scope_notification_settings_query(NotificationSettingsScope::Private, Promise<>());
  }
  if (!chats_notification_settings_.is_synchronized) {
    send_get_scope_notification_settings_query(NotificationSettingsScope::Group, Promise<>());
  }
  if (!channels_notification_settings_.is_synchronized) {
    send_get_scope_notification_settings_query(NotificationSettingsScope::Channel, Promise<>());
  }
}

string MessagesManager::get_channel_pts_key(DialogId dialog_id) {
  CHECK(dialog_id.get_type() == DialogType::Channel);
  auto channel_id = dialog_id.get_channel_id();
  return PSTRING() << "ch.p" << channel_id.get();
}

int32 MessagesManager::load_channel_pts(DialogId dialog_id) const {
  if (G()->ignore_background_updates()) {
    G()->td_db()->get_binlog_pmc()->erase(get_channel_pts_key(dialog_id));  // just in case
    return 0;
  }
  auto pts = to_integer<int32>(G()->td_db()->get_binlog_pmc()->get(get_channel_pts_key(dialog_id)));
  LOG(INFO) << "Load " << dialog_id << " pts = " << pts;
  return pts;
}

void MessagesManager::set_channel_pts(Dialog *d, int32 new_pts, const char *source) {
  CHECK(d != nullptr);
  CHECK(d->dialog_id.get_type() == DialogType::Channel);

  LOG_IF(ERROR, running_get_channel_difference(d->dialog_id))
      << "Set pts of " << d->dialog_id << " to " << new_pts << " while running getChannelDifference";

  if (is_debug_message_op_enabled()) {
    d->debug_message_op.emplace_back(Dialog::MessageOp::SetPts, new_pts, source);
  }

  // TODO delete_first_messages support in channels
  if (new_pts == std::numeric_limits<int32>::max()) {
    LOG(ERROR) << "Update " << d->dialog_id << " pts to -1";
    G()->td_db()->get_binlog_pmc()->erase(get_channel_pts_key(d->dialog_id));
    d->pts = std::numeric_limits<int32>::max();
    if (d->pending_read_channel_inbox_pts != 0) {
      d->pending_read_channel_inbox_pts = 0;
    }
    return;
  }
  if (new_pts > d->pts || (0 < new_pts && new_pts < d->pts - 99999)) {  // pts can only go up or drop cardinally
    if (new_pts < d->pts - 99999) {
      LOG(WARNING) << "Pts of " << d->dialog_id << " decreases from " << d->pts << " to " << new_pts;
    } else {
      LOG(INFO) << "Update " << d->dialog_id << " pts to " << new_pts;
    }

    d->pts = new_pts;
    if (d->pending_read_channel_inbox_pts != 0 && d->pending_read_channel_inbox_pts <= d->pts) {
      auto pts = d->pending_read_channel_inbox_pts;
      d->pending_read_channel_inbox_pts = 0;
      on_dialog_updated(d->dialog_id, "set_channel_pts");
      if (d->pts == pts) {
        read_history_inbox(d->dialog_id, d->pending_read_channel_inbox_max_message_id,
                           d->pending_read_channel_inbox_server_unread_count, "set_channel_pts");
      } else if (d->pts > pts) {
        repair_channel_server_unread_count(d);
      }
    }
    if (!G()->ignore_background_updates()) {
      G()->td_db()->get_binlog_pmc()->set(get_channel_pts_key(d->dialog_id), to_string(new_pts));
    }
  } else if (new_pts < d->pts) {
    LOG(ERROR) << "Receive wrong pts " << new_pts << " in " << d->dialog_id << ". Current pts is " << d->pts;
  }
}

bool MessagesManager::need_channel_difference_to_add_message(DialogId dialog_id,
                                                             const tl_object_ptr<telegram_api::Message> &message_ptr) {
  // keep consistent with add_message_to_dialog
  if (dialog_id.get_type() != DialogType::Channel || !have_input_peer(dialog_id, AccessRights::Read) ||
      dialog_id == debug_channel_difference_dialog_) {
    return false;
  }
  if (get_message_dialog_id(message_ptr) != dialog_id) {
    return false;
  }

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr || d->last_new_message_id == MessageId()) {
    return false;
  }

  return get_message_id(message_ptr, false) > d->last_new_message_id;
}

void MessagesManager::run_after_channel_difference(DialogId dialog_id, Promise<Unit> &&promise) {
  CHECK(dialog_id.get_type() == DialogType::Channel);
  CHECK(have_input_peer(dialog_id, AccessRights::Read));

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  run_after_get_channel_difference_[dialog_id].push_back(std::move(promise));

  get_channel_difference(dialog_id, d->pts, true, "run_after_channel_difference");
}

bool MessagesManager::running_get_channel_difference(DialogId dialog_id) const {
  return active_get_channel_differencies_.count(dialog_id) > 0;
}

void MessagesManager::on_channel_get_difference_timeout(DialogId dialog_id) {
  if (G()->close_flag()) {
    return;
  }

  CHECK(dialog_id.get_type() == DialogType::Channel);
  auto d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  get_channel_difference(dialog_id, d->pts, true, "on_channel_get_difference_timeout");
}

class MessagesManager::GetChannelDifferenceLogEvent {
 public:
  ChannelId channel_id;
  int64 access_hash;

  GetChannelDifferenceLogEvent() : channel_id(), access_hash() {
  }

  GetChannelDifferenceLogEvent(ChannelId channel_id, int64 access_hash)
      : channel_id(channel_id), access_hash(access_hash) {
  }

  template <class StorerT>
  void store(StorerT &storer) const {
    td::store(channel_id, storer);
    td::store(access_hash, storer);
  }

  template <class ParserT>
  void parse(ParserT &parser) {
    td::parse(channel_id, parser);
    td::parse(access_hash, parser);
  }
};

void MessagesManager::get_channel_difference(DialogId dialog_id, int32 pts, bool force, const char *source) {
  if (channel_get_difference_retry_timeout_.has_timeout(dialog_id.get())) {
    LOG(INFO) << "Skip running channels.getDifference for " << dialog_id << " from " << source
              << " because it is scheduled for later time";
    return;
  }
  LOG_CHECK(dialog_id.get_type() == DialogType::Channel) << dialog_id << " " << source;

  if (active_get_channel_differencies_.count(dialog_id)) {
    LOG(INFO) << "Skip running channels.getDifference for " << dialog_id << " from " << source
              << " because it has already been run";
    return;
  }
  auto input_channel = td_->contacts_manager_->get_input_channel(dialog_id.get_channel_id());
  if (input_channel == nullptr) {
    LOG(ERROR) << "Skip running channels.getDifference for " << dialog_id << " from " << source
               << " because have no info about the chat";
    after_get_channel_difference(dialog_id, false);
    return;
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    LOG(INFO) << "Skip running channels.getDifference for " << dialog_id << " from " << source
              << " because have no read access to it";
    after_get_channel_difference(dialog_id, false);
    return;
  }

  if (force && get_channel_difference_to_log_event_id_.count(dialog_id) == 0 && !G()->ignore_background_updates()) {
    auto channel_id = dialog_id.get_channel_id();
    CHECK(input_channel->get_id() == telegram_api::inputChannel::ID);
    auto access_hash = static_cast<const telegram_api::inputChannel &>(*input_channel).access_hash_;
    auto log_event = GetChannelDifferenceLogEvent(channel_id, access_hash);
    auto log_event_id = binlog_add(G()->td_db()->get_binlog(), LogEvent::HandlerType::GetChannelDifference,
                                   get_log_event_storer(log_event));

    get_channel_difference_to_log_event_id_.emplace(dialog_id, log_event_id);
  }

  return do_get_channel_difference(dialog_id, pts, force, std::move(input_channel), source);
}

void MessagesManager::do_get_channel_difference(DialogId dialog_id, int32 pts, bool force,
                                                tl_object_ptr<telegram_api::InputChannel> &&input_channel,
                                                const char *source) {
  auto inserted = active_get_channel_differencies_.emplace(dialog_id, source);
  if (!inserted.second) {
    LOG(INFO) << "Skip running channels.getDifference for " << dialog_id << " from " << source
              << " because it has already been run";
    return;
  }
  // must work even we know nothing about the dialog

  // can be called multiple times before after_get_channel_difference
  const Dialog *d = get_dialog(dialog_id);
  if (d != nullptr) {
    if (d->message_notification_group.group_id.is_valid()) {
      send_closure_later(G()->notification_manager(), &NotificationManager::before_get_chat_difference,
                         d->message_notification_group.group_id);
    }
    if (d->mention_notification_group.group_id.is_valid()) {
      send_closure_later(G()->notification_manager(), &NotificationManager::before_get_chat_difference,
                         d->mention_notification_group.group_id);
    }
  }

  int32 limit = td_->auth_manager_->is_bot() ? MAX_BOT_CHANNEL_DIFFERENCE : MAX_CHANNEL_DIFFERENCE;
  if (pts <= 0) {
    pts = 1;
    limit = MIN_CHANNEL_DIFFERENCE;
  }

  LOG(INFO) << "-----BEGIN GET CHANNEL DIFFERENCE----- for " << dialog_id << " with pts " << pts << " and limit "
            << limit << " from " << source;

  td_->create_handler<GetChannelDifferenceQuery>()->send(dialog_id, std::move(input_channel), pts, limit, force);
}

void MessagesManager::process_get_channel_difference_updates(
    DialogId dialog_id, vector<tl_object_ptr<telegram_api::Message>> &&new_messages,
    vector<tl_object_ptr<telegram_api::Update>> &&other_updates) {
  LOG(INFO) << "In get channel difference for " << dialog_id << " receive " << new_messages.size() << " messages and "
            << other_updates.size() << " other updates";
  CHECK(!debug_channel_difference_dialog_.is_valid());
  debug_channel_difference_dialog_ = dialog_id;
  for (auto &update : other_updates) {
    if (update->get_id() == telegram_api::updateMessageID::ID) {
      // in channels.getDifference updateMessageID can't be received for scheduled messages
      auto sent_message_update = move_tl_object_as<telegram_api::updateMessageID>(update);
      on_update_message_id(sent_message_update->random_id_, MessageId(ServerMessageId(sent_message_update->id_)),
                           "get_channel_difference");
      update = nullptr;
    }
  }

  // if last message is pretty old, we might have missed the update
  bool need_repair_unread_count =
      !new_messages.empty() && get_message_date(new_messages[0]) < G()->unix_time() - 2 * 86400;

  for (auto &message : new_messages) {
    on_get_message(std::move(message), true, true, false, true, true, "get channel difference");
  }

  for (auto &update : other_updates) {
    if (update != nullptr) {
      switch (update->get_id()) {
        case telegram_api::updateDeleteChannelMessages::ID:
        case telegram_api::updateEditChannelMessage::ID:
        case telegram_api::updatePinnedChannelMessages::ID:
          process_channel_update(std::move(update));
          break;
        default:
          LOG(ERROR) << "Unsupported update received in getChannelDifference: " << oneline(to_string(update));
          break;
      }
    }
  }
  LOG_CHECK(!running_get_channel_difference(dialog_id)) << '"' << active_get_channel_differencies_[dialog_id] << '"';

  if (need_repair_unread_count) {
    repair_channel_server_unread_count(get_dialog(dialog_id));
  }

  CHECK(debug_channel_difference_dialog_ == dialog_id);
  debug_channel_difference_dialog_ = DialogId();
}

void MessagesManager::on_get_channel_dialog(DialogId dialog_id, MessageId last_message_id,
                                            MessageId read_inbox_max_message_id, int32 server_unread_count,
                                            int32 unread_mention_count, MessageId read_outbox_max_message_id,
                                            vector<tl_object_ptr<telegram_api::Message>> &&messages) {
  std::unordered_map<FullMessageId, tl_object_ptr<telegram_api::Message>, FullMessageIdHash> full_message_id_to_message;
  for (auto &message : messages) {
    auto message_id = get_message_id(message, false);
    auto message_dialog_id = get_message_dialog_id(message);
    if (!message_dialog_id.is_valid()) {
      message_dialog_id = dialog_id;
    }
    auto full_message_id = FullMessageId(message_dialog_id, message_id);
    full_message_id_to_message[full_message_id] = std::move(message);
  }

  FullMessageId last_full_message_id(dialog_id, last_message_id);
  if (last_message_id.is_valid()) {
    if (full_message_id_to_message.count(last_full_message_id) == 0) {
      LOG(ERROR) << "Last " << last_message_id << " in " << dialog_id << " not found. Have:";
      for (auto &message : full_message_id_to_message) {
        LOG(ERROR) << to_string(message.second);
      }
      return;
    }
  }
  CHECK(!last_message_id.is_scheduled());

  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);

  // TODO gaps support
  // There are many ways of handling a gap in a channel:
  // 1) Delete all known messages in the chat, begin from scratch. It is easy to implement, but suddenly disappearing
  //    messages looks awful for the user.
  // 2) Save all messages loaded in the memory until application restart, but delete all messages from the database.
  //    Messages left in the memory must be lazily updated using calls to getHistory. It looks much smoothly for the
  //    user, he will need to redownload messages only after client restart. Unsynchronized messages left in the
  //    memory shouldn't be saved to database, results of getHistory and getMessage must be used to update state of
  //    deleted and edited messages left in the memory.
  // 3) Save all messages loaded in the memory and stored in the database without saving that some messages form
  //    continuous ranges. Messages in the database will be excluded from results of getChatHistory and
  //    searchChatMessages after application restart and will be available only through getMessage.
  //    Every message should still be checked using getHistory. It has more disadvantages over 2) than advantages.
  // 4) Save all messages with saving all data about continuous message ranges. Messages from the database may be used
  //    as results of getChatHistory and (if implemented continuous ranges support for searching shared media)
  //    searchChatMessages. The messages should still be lazily checked using getHistory, but they are still available
  //    offline. It is the best way for gaps support, but it is pretty hard to implement correctly.
  // It should be also noted that some messages like outgoing live location messages shouldn't be deleted.

  if (last_message_id > d->last_new_message_id) {
    // TODO properly support last_message_id <= d->last_new_message_id
    set_dialog_first_database_message_id(d, MessageId(), "on_get_channel_dialog 6");
    set_dialog_last_database_message_id(d, MessageId(), "on_get_channel_dialog 7");
    d->have_full_history = false;
  }
  invalidate_message_indexes(d);

  on_dialog_updated(dialog_id, "on_get_channel_dialog 10");

  // TODO properly support last_message_id <= d->last_new_message_id
  if (last_message_id > d->last_new_message_id) {  // if last message is really a new message
    if (!d->last_new_message_id.is_valid() && last_message_id <= d->max_added_message_id) {
      auto prev_message_id = MessageId(ServerMessageId(last_message_id.get_server_message_id().get() - 1));
      remove_dialog_newer_messages(d, prev_message_id, "on_get_channel_dialog 15");
    }
    d->last_new_message_id = MessageId();
    set_dialog_last_message_id(d, MessageId(), "on_get_channel_dialog 20");
    send_update_chat_last_message(d, "on_get_channel_dialog 30");
    auto added_full_message_id = on_get_message(std::move(full_message_id_to_message[last_full_message_id]), true, true,
                                                false, true, true, "channel difference too long");
    if (added_full_message_id.get_message_id().is_valid()) {
      if (added_full_message_id.get_message_id() == d->last_new_message_id) {
        CHECK(last_full_message_id == added_full_message_id);
        CHECK(d->last_message_id == d->last_new_message_id);
      } else {
        LOG(ERROR) << added_full_message_id << " doesn't became last new message, which is " << d->last_new_message_id;
        dump_debug_message_op(d, 2);
      }
    } else if (last_message_id > d->last_new_message_id) {
      set_dialog_last_new_message_id(d, last_message_id,
                                     "on_get_channel_dialog 40");  // skip updates about some messages
    }
  }

  if (d->last_read_inbox_message_id.is_valid() && !d->last_read_inbox_message_id.is_server() &&
      read_inbox_max_message_id == d->last_read_inbox_message_id.get_prev_server_message_id()) {
    read_inbox_max_message_id = d->last_read_inbox_message_id;
  }
  if (d->server_unread_count != server_unread_count || d->last_read_inbox_message_id != read_inbox_max_message_id) {
    set_dialog_last_read_inbox_message_id(d, read_inbox_max_message_id, server_unread_count, d->local_unread_count,
                                          false, "on_get_channel_dialog 50");
  }
  if (d->unread_mention_count != unread_mention_count) {
    set_dialog_unread_mention_count(d, unread_mention_count);
    update_dialog_mention_notification_count(d);
    send_update_chat_unread_mention_count(d);
  }

  if (d->last_read_outbox_message_id != read_outbox_max_message_id) {
    set_dialog_last_read_outbox_message_id(d, read_outbox_max_message_id);
  }
}

void MessagesManager::on_get_channel_difference(
    DialogId dialog_id, int32 request_pts, int32 request_limit,
    tl_object_ptr<telegram_api::updates_ChannelDifference> &&difference_ptr) {
  LOG(INFO) << "----- END  GET CHANNEL DIFFERENCE----- for " << dialog_id;
  CHECK(active_get_channel_differencies_.count(dialog_id) == 1);
  active_get_channel_differencies_.erase(dialog_id);
  auto d = get_dialog_force(dialog_id);

  if (difference_ptr == nullptr) {
    bool have_access = have_input_peer(dialog_id, AccessRights::Read);
    if (have_access && d != nullptr) {
      channel_get_difference_retry_timeout_.add_timeout_in(dialog_id.get(), d->retry_get_difference_timeout);
      d->retry_get_difference_timeout *= 2;
      if (d->retry_get_difference_timeout > 60) {
        d->retry_get_difference_timeout = Random::fast(60, 80);
      }
    } else {
      after_get_channel_difference(dialog_id, false);
    }
    return;
  }

  LOG(INFO) << "Receive result of getChannelDifference for " << dialog_id << " with pts = " << request_pts
            << " and limit = " << request_limit << ": " << to_string(difference_ptr);

  switch (difference_ptr->get_id()) {
    case telegram_api::updates_channelDifferenceEmpty::ID:
      if (d == nullptr) {
        // no need to create the dialog
        after_get_channel_difference(dialog_id, true);
        return;
      }
      break;
    case telegram_api::updates_channelDifference::ID: {
      auto difference = static_cast<telegram_api::updates_channelDifference *>(difference_ptr.get());
      td_->contacts_manager_->on_get_users(std::move(difference->users_), "updates.channelDifference");
      td_->contacts_manager_->on_get_chats(std::move(difference->chats_), "updates.channelDifference");
      break;
    }
    case telegram_api::updates_channelDifferenceTooLong::ID: {
      auto difference = static_cast<telegram_api::updates_channelDifferenceTooLong *>(difference_ptr.get());
      td_->contacts_manager_->on_get_users(std::move(difference->users_), "updates.channelDifferenceTooLong");
      td_->contacts_manager_->on_get_chats(std::move(difference->chats_), "updates.channelDifferenceTooLong");
      break;
    }
    default:
      UNREACHABLE();
  }

  bool need_update_dialog_pos = false;
  if (d == nullptr) {
    d = add_dialog(dialog_id);
    need_update_dialog_pos = true;
  }

  int32 cur_pts = d->pts <= 0 ? 1 : d->pts;
  LOG_IF(ERROR, cur_pts != request_pts) << "Channel pts has changed from " << request_pts << " to " << d->pts << " in "
                                        << dialog_id << " during getChannelDifference";

  d->retry_get_difference_timeout = 1;

  bool is_final = true;
  int32 timeout = 0;
  switch (difference_ptr->get_id()) {
    case telegram_api::updates_channelDifferenceEmpty::ID: {
      auto difference = move_tl_object_as<telegram_api::updates_channelDifferenceEmpty>(difference_ptr);
      int32 flags = difference->flags_;
      is_final = (flags & CHANNEL_DIFFERENCE_FLAG_IS_FINAL) != 0;
      LOG_IF(ERROR, !is_final) << "Receive channelDifferenceEmpty as result of getChannelDifference with pts = "
                               << request_pts << " and limit = " << request_limit << " in " << dialog_id
                               << ", but it is not final";
      if (flags & CHANNEL_DIFFERENCE_FLAG_HAS_TIMEOUT) {
        timeout = difference->timeout_;
      }

      // bots can receive channelDifferenceEmpty with pts bigger than known pts
      LOG_IF(ERROR, request_pts != difference->pts_ && !td_->auth_manager_->is_bot())
          << "Receive channelDifferenceEmpty as result of getChannelDifference with pts = " << request_pts
          << " and limit = " << request_limit << " in " << dialog_id << ", but pts has changed from " << request_pts
          << " to " << difference->pts_;
      set_channel_pts(d, difference->pts_, "channel difference empty");
      break;
    }
    case telegram_api::updates_channelDifference::ID: {
      auto difference = move_tl_object_as<telegram_api::updates_channelDifference>(difference_ptr);

      int32 flags = difference->flags_;
      is_final = (flags & CHANNEL_DIFFERENCE_FLAG_IS_FINAL) != 0;
      if (flags & CHANNEL_DIFFERENCE_FLAG_HAS_TIMEOUT) {
        timeout = difference->timeout_;
      }

      auto new_pts = difference->pts_;
      if (request_pts >= new_pts && request_pts > 1 && (request_pts > new_pts || !td_->auth_manager_->is_bot())) {
        LOG(ERROR) << "Receive channelDifference as result of getChannelDifference with pts = " << request_pts
                   << " and limit = " << request_limit << " in " << dialog_id << ", but pts has changed from " << d->pts
                   << " to " << new_pts << ". Difference: " << oneline(to_string(difference));
        new_pts = request_pts + 1;
      }

      process_get_channel_difference_updates(dialog_id, std::move(difference->new_messages_),
                                             std::move(difference->other_updates_));

      set_channel_pts(d, new_pts, "channel difference");
      break;
    }
    case telegram_api::updates_channelDifferenceTooLong::ID: {
      auto difference = move_tl_object_as<telegram_api::updates_channelDifferenceTooLong>(difference_ptr);

      tl_object_ptr<telegram_api::dialog> dialog;
      switch (difference->dialog_->get_id()) {
        case telegram_api::dialog::ID:
          dialog = telegram_api::move_object_as<telegram_api::dialog>(difference->dialog_);
          break;
        case telegram_api::dialogFolder::ID:
          return after_get_channel_difference(dialog_id, false);
        default:
          UNREACHABLE();
          return;
      }

      CHECK(dialog != nullptr);
      if ((dialog->flags_ & telegram_api::dialog::PTS_MASK) == 0) {
        LOG(ERROR) << "Receive " << dialog_id << " without pts";
        return after_get_channel_difference(dialog_id, false);
      }

      int32 flags = difference->flags_;
      is_final = (flags & CHANNEL_DIFFERENCE_FLAG_IS_FINAL) != 0;
      if (flags & CHANNEL_DIFFERENCE_FLAG_HAS_TIMEOUT) {
        timeout = difference->timeout_;
      }

      auto new_pts = dialog->pts_;
      if (request_pts > new_pts - request_limit) {
        LOG(ERROR) << "Receive channelDifferenceTooLong as result of getChannelDifference with pts = " << request_pts
                   << " and limit = " << request_limit << " in " << dialog_id << ", but pts has changed from " << d->pts
                   << " to " << new_pts << ". Difference: " << oneline(to_string(difference));
        if (request_pts >= new_pts) {
          new_pts = request_pts + 1;
        }
      }

      set_dialog_folder_id(d, FolderId((dialog->flags_ & DIALOG_FLAG_HAS_FOLDER_ID) != 0 ? dialog->folder_id_ : 0));

      on_update_dialog_notify_settings(dialog_id, std::move(dialog->notify_settings_),
                                       "updates.channelDifferenceTooLong");

      bool is_marked_as_unread = (dialog->flags_ & telegram_api::dialog::UNREAD_MARK_MASK) != 0;
      if (is_marked_as_unread != d->is_marked_as_unread) {
        set_dialog_is_marked_as_unread(d, is_marked_as_unread);
      }

      update_dialog_draft_message(d, get_draft_message(td_->contacts_manager_.get(), std::move(dialog->draft_)), true,
                                  false);

      on_get_channel_dialog(dialog_id, MessageId(ServerMessageId(dialog->top_message_)),
                            MessageId(ServerMessageId(dialog->read_inbox_max_id_)), dialog->unread_count_,
                            dialog->unread_mentions_count_, MessageId(ServerMessageId(dialog->read_outbox_max_id_)),
                            std::move(difference->messages_));
      update_dialog_pos(d, "updates.channelDifferenceTooLong");

      if (!td_->auth_manager_->is_bot()) {
        // set is_pinned only after updating dialog pos to ensure that order is initialized
        bool is_pinned = (dialog->flags_ & DIALOG_FLAG_IS_PINNED) != 0;
        bool was_pinned = get_dialog_pinned_order(DialogListId(d->folder_id), dialog_id) != DEFAULT_ORDER;
        if (is_pinned != was_pinned) {
          set_dialog_is_pinned(DialogListId(d->folder_id), d, is_pinned);
        }
      }

      set_channel_pts(d, new_pts, "channel difference too long");
      break;
    }
    default:
      UNREACHABLE();
  }

  if (need_update_dialog_pos) {
    update_dialog_pos(d, "on_get_channel_difference");
  }

  if (!is_final) {
    LOG_IF(ERROR, timeout > 0) << "Have timeout in not final ChannelDifference in " << dialog_id;
    get_channel_difference(dialog_id, d->pts, true, "on_get_channel_difference");
    return;
  }

  LOG_IF(ERROR, timeout == 0) << "Have no timeout in final ChannelDifference in " << dialog_id;
  if (timeout > 0 && d->is_opened) {
    channel_get_difference_timeout_.add_timeout_in(dialog_id.get(), timeout);
  }
  after_get_channel_difference(dialog_id, true);
}

void MessagesManager::after_get_channel_difference(DialogId dialog_id, bool success) {
  LOG(INFO) << "After " << (success ? "" : "un") << "successful get channel difference in " << dialog_id;
  LOG_CHECK(!running_get_channel_difference(dialog_id)) << '"' << active_get_channel_differencies_[dialog_id] << '"';

  auto log_event_it = get_channel_difference_to_log_event_id_.find(dialog_id);
  if (log_event_it != get_channel_difference_to_log_event_id_.end()) {
    if (!G()->close_flag()) {
      binlog_erase(G()->td_db()->get_binlog(), log_event_it->second);
    }
    get_channel_difference_to_log_event_id_.erase(log_event_it);
  }

  auto d = get_dialog(dialog_id);
  if (d != nullptr) {
    bool have_access = have_input_peer(dialog_id, AccessRights::Read);
    if (!d->postponed_channel_updates.empty()) {
      LOG(INFO) << "Begin to apply postponed channel updates";
      while (!d->postponed_channel_updates.empty()) {
        auto it = d->postponed_channel_updates.begin();
        auto update = std::move(it->second.update);
        auto update_pts = it->second.pts;
        auto update_pts_count = it->second.pts_count;
        auto promise = std::move(it->second.promise);
        d->postponed_channel_updates.erase(it);

        auto old_size = d->postponed_channel_updates.size();
        auto update_id = update->get_id();
        if (have_access) {
          add_pending_channel_update(dialog_id, std::move(update), update_pts, update_pts_count, std::move(promise),
                                     "apply postponed channel updates", true);
        } else {
          promise.set_value(Unit());
        }
        if (d->postponed_channel_updates.size() != old_size || running_get_channel_difference(dialog_id)) {
          if (success && update_pts - 10000 < d->pts && update_pts_count == 1) {
            // if getChannelDifference was successful and update pts is near channel pts,
            // we hope that the update eventually can be applied
            LOG(INFO) << "Can't apply postponed channel updates";
          } else {
            // otherwise protect from getChannelDifference repeating calls by dropping postponed updates
            LOG(WARNING) << "Failed to apply postponed updates of type " << update_id << " in " << dialog_id
                         << " with pts " << d->pts << ", update pts is " << update_pts << ", update pts count is "
                         << update_pts_count;
            vector<Promise<Unit>> update_promises;
            for (auto &postponed_update : d->postponed_channel_updates) {
              update_promises.push_back(std::move(postponed_update.second.promise));
            }
            d->postponed_channel_updates.clear();
            for (auto &update_promise : update_promises) {
              update_promise.set_value(Unit());
            }
          }
          break;
        }
      }
      LOG(INFO) << "Finish to apply postponed channel updates";
    }

    if (d->message_notification_group.group_id.is_valid()) {
      send_closure_later(G()->notification_manager(), &NotificationManager::after_get_chat_difference,
                         d->message_notification_group.group_id);
    }
    if (d->mention_notification_group.group_id.is_valid()) {
      send_closure_later(G()->notification_manager(), &NotificationManager::after_get_chat_difference,
                         d->mention_notification_group.group_id);
    }
  }

  if (postponed_chat_read_inbox_updates_.erase(dialog_id) > 0) {
    send_update_chat_read_inbox(d, true, "after_get_channel_difference");
  }

  auto promise_it = run_after_get_channel_difference_.find(dialog_id);
  if (promise_it != run_after_get_channel_difference_.end()) {
    vector<Promise<Unit>> promises = std::move(promise_it->second);
    run_after_get_channel_difference_.erase(promise_it);

    for (auto &promise : promises) {
      promise.set_value(Unit());
    }
  }

  auto it = pending_channel_on_get_dialogs_.find(dialog_id);
  if (it != pending_channel_on_get_dialogs_.end()) {
    LOG(INFO) << "Apply postponed results of channel getDialogs for " << dialog_id;
    PendingOnGetDialogs res = std::move(it->second);
    pending_channel_on_get_dialogs_.erase(it);

    on_get_dialogs(res.folder_id, std::move(res.dialogs), res.total_count, std::move(res.messages),
                   std::move(res.promise));
  }
}

void MessagesManager::reget_message_from_server_if_needed(DialogId dialog_id, const Message *m) {
  if (!m->message_id.is_any_server() || dialog_id.get_type() == DialogType::SecretChat) {
    return;
  }

  if (need_reget_message_content(m->content.get()) || (m->legacy_layer != 0 && m->legacy_layer < MTPROTO_LAYER)) {
    FullMessageId full_message_id{dialog_id, m->message_id};
    LOG(INFO) << "Reget from server " << full_message_id;
    get_message_from_server(full_message_id, Auto());
  }
}

void MessagesManager::speculatively_update_channel_participants(DialogId dialog_id, const Message *m) {
  CHECK(m != nullptr);
  if (!m->message_id.is_any_server() || dialog_id.get_type() != DialogType::Channel || !m->sender_user_id.is_valid()) {
    return;
  }

  auto channel_id = dialog_id.get_channel_id();
  UserId my_user_id(td_->contacts_manager_->get_my_id());
  bool by_me = m->sender_user_id == my_user_id;
  switch (m->content->get_type()) {
    case MessageContentType::ChatAddUsers:
      td_->contacts_manager_->speculative_add_channel_participants(
          channel_id, get_message_content_added_user_ids(m->content.get()), m->sender_user_id, m->date, by_me);
      break;
    case MessageContentType::ChatJoinedByLink:
      td_->contacts_manager_->speculative_add_channel_participants(channel_id, {m->sender_user_id}, m->sender_user_id,
                                                                   m->date, by_me);
      break;
    case MessageContentType::ChatDeleteUser:
      td_->contacts_manager_->speculative_delete_channel_participant(
          channel_id, get_message_content_deleted_user_id(m->content.get()), by_me);
      break;
    default:
      break;
  }
}

void MessagesManager::update_sent_message_contents(DialogId dialog_id, const Message *m) {
  CHECK(m != nullptr);
  if (td_->auth_manager_->is_bot() || (!m->is_outgoing && dialog_id != get_my_dialog_id()) ||
      dialog_id.get_type() == DialogType::SecretChat || m->message_id.is_local() || m->forward_info != nullptr ||
      m->had_forward_info) {
    return;
  }

  on_sent_message_content(td_, m->content.get());
}

void MessagesManager::update_used_hashtags(DialogId dialog_id, const Message *m) {
  CHECK(m != nullptr);
  if (td_->auth_manager_->is_bot() || (!m->is_outgoing && dialog_id != get_my_dialog_id()) ||
      m->via_bot_user_id.is_valid() || m->hide_via_bot || m->forward_info != nullptr || m->had_forward_info) {
    return;
  }

  ::td::update_used_hashtags(td_, m->content.get());
}

void MessagesManager::update_top_dialogs(DialogId dialog_id, const Message *m) {
  CHECK(m != nullptr);
  auto dialog_type = dialog_id.get_type();
  if (td_->auth_manager_->is_bot() || (!m->is_outgoing && dialog_id != get_my_dialog_id()) ||
      dialog_type == DialogType::SecretChat || !m->message_id.is_any_server()) {
    return;
  }

  bool is_forward = m->forward_info != nullptr || m->had_forward_info;
  if (m->via_bot_user_id.is_valid() && !is_forward) {
    // forwarded game messages can't be distinguished from sent via bot game messages, so increase rating anyway
    on_dialog_used(TopDialogCategory::BotInline, DialogId(m->via_bot_user_id), m->date);
  }

  if (is_forward) {
    auto &last_forward_date = last_outgoing_forwarded_message_date_[dialog_id];
    if (last_forward_date < m->date) {
      TopDialogCategory category =
          dialog_type == DialogType::User ? TopDialogCategory::ForwardUsers : TopDialogCategory::ForwardChats;
      on_dialog_used(category, dialog_id, m->date);
      last_forward_date = m->date;
    }
  }

  TopDialogCategory category = TopDialogCategory::Size;
  switch (dialog_type) {
    case DialogType::User: {
      if (td_->contacts_manager_->is_user_bot(dialog_id.get_user_id())) {
        category = TopDialogCategory::BotPM;
      } else {
        category = TopDialogCategory::Correspondent;
      }
      break;
    }
    case DialogType::Chat:
      category = TopDialogCategory::Group;
      break;
    case DialogType::Channel:
      switch (td_->contacts_manager_->get_channel_type(dialog_id.get_channel_id())) {
        case ChannelType::Broadcast:
          category = TopDialogCategory::Channel;
          break;
        case ChannelType::Megagroup:
          category = TopDialogCategory::Group;
          break;
        case ChannelType::Unknown:
          break;
        default:
          UNREACHABLE();
          break;
      }
      break;
    case DialogType::SecretChat:
    case DialogType::None:
    default:
      UNREACHABLE();
  }
  if (category != TopDialogCategory::Size) {
    on_dialog_used(category, dialog_id, m->date);
  }
}

void MessagesManager::update_forward_count(DialogId dialog_id, const Message *m) {
  if (!td_->auth_manager_->is_bot() && m->forward_info != nullptr && m->forward_info->sender_dialog_id.is_valid() &&
      m->forward_info->message_id.is_valid() &&
      (!is_discussion_message(dialog_id, m) || m->forward_info->sender_dialog_id != m->forward_info->from_dialog_id ||
       m->forward_info->message_id != m->forward_info->from_message_id)) {
    update_forward_count(m->forward_info->sender_dialog_id, m->forward_info->message_id, m->date);
  }
}

void MessagesManager::update_forward_count(DialogId dialog_id, MessageId message_id, int32 update_date) {
  CHECK(!td_->auth_manager_->is_bot());
  Dialog *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  Message *m = get_message_force(d, message_id, "update_forward_count");
  if (m != nullptr && !m->message_id.is_scheduled() && m->message_id.is_server() && m->view_count > 0 &&
      m->interaction_info_update_date < update_date) {
    if (m->forward_count == 0) {
      m->forward_count++;
      send_update_message_interaction_info(dialog_id, m);
      on_message_changed(d, m, true, "update_forward_count");
    }

    if (d->pending_viewed_message_ids.insert(m->message_id).second) {
      pending_message_views_timeout_.add_timeout_in(dialog_id.get(), 0.0);
    }
  }
}

void MessagesManager::try_hide_distance(DialogId dialog_id, const Message *m) {
  CHECK(m != nullptr);
  if (td_->auth_manager_->is_bot() || (!m->is_outgoing && dialog_id != get_my_dialog_id())) {
    return;
  }

  Dialog *d = nullptr;
  switch (dialog_id.get_type()) {
    case DialogType::User:
      d = get_dialog(dialog_id);
      break;
    case DialogType::Chat:
    case DialogType::Channel:
      break;
    case DialogType::SecretChat: {
      auto user_id = td_->contacts_manager_->get_secret_chat_user_id(dialog_id.get_secret_chat_id());
      if (user_id.is_valid()) {
        d = get_dialog_force(DialogId(user_id));
      }
      break;
    }
    default:
      UNREACHABLE();
  }
  if (d == nullptr || d->hide_distance) {
    return;
  }

  d->hide_distance = true;
  on_dialog_updated(dialog_id, "try_hide_distance");

  if (d->distance != -1) {
    send_update_chat_action_bar(d);
  }
}

MessagesManager::Message *MessagesManager::continue_send_message(DialogId dialog_id, unique_ptr<Message> &&m,
                                                                 uint64 log_event_id) {
  CHECK(log_event_id != 0);
  CHECK(m != nullptr);
  CHECK(m->content != nullptr);

  Dialog *d = get_dialog_force(dialog_id);
  if (d == nullptr) {
    LOG(ERROR) << "Can't find " << dialog_id << " to continue send a message";
    binlog_erase(G()->td_db()->get_binlog(), log_event_id);
    return nullptr;
  }
  if (!have_input_peer(dialog_id, AccessRights::Read)) {
    binlog_erase(G()->td_db()->get_binlog(), log_event_id);
    return nullptr;
  }

  LOG(INFO) << "Continue to send " << m->message_id << " to " << dialog_id << " initially sent at " << m->send_date
            << " from binlog";

  auto now = G()->unix_time();
  if (m->message_id.is_scheduled()) {
    set_message_id(m, get_next_yet_unsent_scheduled_message_id(d, m->date));
  } else {
    set_message_id(m, get_next_yet_unsent_message_id(d));
    m->date = now;
  }
  m->have_previous = true;
  m->have_next = true;

  message_random_ids_.insert(m->random_id);

  bool need_update = false;
  bool need_update_dialog_pos = false;
  auto result_message =
      add_message_to_dialog(d, std::move(m), true, &need_update, &need_update_dialog_pos, "continue_send_message");
  CHECK(result_message != nullptr);

  if (result_message->message_id.is_scheduled()) {
    send_update_chat_has_scheduled_messages(d, false);
  }

  send_update_new_message(d, result_message);
  if (need_update_dialog_pos) {
    send_update_chat_last_message(d, "continue_send_message");
  }

  auto can_send_status = can_send_message(dialog_id);
  if (can_send_status.is_ok() && result_message->send_date < now - MAX_RESEND_DELAY &&
      dialog_id != get_my_dialog_id()) {
    can_send_status = Status::Error(400, "Message is too old to be re-sent automatically");
  }
  if (can_send_status.is_error()) {
    LOG(INFO) << "Can't continue to send a message to " << dialog_id << ": " << can_send_status.error();

    fail_send_message({dialog_id, result_message->message_id}, can_send_status.move_as_error());
    return nullptr;
  }

  return result_message;
}

void MessagesManager::on_binlog_events(vector<BinlogEvent> &&events) {
  for (auto &event : events) {
    CHECK(event.id_ != 0);
    switch (event.type_) {
      case LogEvent::HandlerType::SendMessage: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        SendMessageLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id;
        auto m = std::move(log_event.m_out);
        m->send_message_log_event_id = event.id_;

        if (m->content->get_type() == MessageContentType::Unsupported) {
          LOG(ERROR) << "Message content is invalid: " << format::as_hex_dump<4>(Slice(event.data_));
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          continue;
        }

        Dependencies dependencies;
        add_dialog_dependencies(dependencies, dialog_id);
        add_message_dependencies(dependencies, dialog_id, m.get());
        resolve_dependencies_force(td_, dependencies, "SendMessageLogEvent");

        m->content =
            dup_message_content(td_, dialog_id, m->content.get(), MessageContentDupType::Send, MessageCopyOptions());

        auto result_message = continue_send_message(dialog_id, std::move(m), event.id_);
        if (result_message != nullptr) {
          do_send_message(dialog_id, result_message);
        }

        break;
      }
      case LogEvent::HandlerType::SendBotStartMessage: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        SendBotStartMessageLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id;
        auto m = std::move(log_event.m_out);
        m->send_message_log_event_id = event.id_;

        CHECK(m->content->get_type() == MessageContentType::Text);

        Dependencies dependencies;
        add_dialog_dependencies(dependencies, dialog_id);
        add_message_dependencies(dependencies, dialog_id, m.get());
        resolve_dependencies_force(td_, dependencies, "SendBotStartMessageLogEvent");

        auto bot_user_id = log_event.bot_user_id;
        if (!td_->contacts_manager_->have_user_force(bot_user_id)) {
          LOG(ERROR) << "Can't find bot " << bot_user_id;
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          continue;
        }

        auto result_message = continue_send_message(dialog_id, std::move(m), event.id_);
        if (result_message != nullptr) {
          do_send_bot_start_message(bot_user_id, dialog_id, log_event.parameter, result_message);
        }
        break;
      }
      case LogEvent::HandlerType::SendInlineQueryResultMessage: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        SendInlineQueryResultMessageLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id;
        auto m = std::move(log_event.m_out);
        m->send_message_log_event_id = event.id_;

        if (m->content->get_type() == MessageContentType::Unsupported) {
          LOG(ERROR) << "Message content is invalid: " << format::as_hex_dump<4>(Slice(event.data_));
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          continue;
        }

        Dependencies dependencies;
        add_dialog_dependencies(dependencies, dialog_id);
        add_message_dependencies(dependencies, dialog_id, m.get());
        resolve_dependencies_force(td_, dependencies, "SendInlineQueryResultMessageLogEvent");

        m->content = dup_message_content(td_, dialog_id, m->content.get(), MessageContentDupType::SendViaBot,
                                         MessageCopyOptions());

        auto result_message = continue_send_message(dialog_id, std::move(m), event.id_);
        if (result_message != nullptr) {
          do_send_inline_query_result_message(dialog_id, result_message, log_event.query_id, log_event.result_id);
        }
        break;
      }
      case LogEvent::HandlerType::SendScreenshotTakenNotificationMessage: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        SendScreenshotTakenNotificationMessageLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id;
        auto m = std::move(log_event.m_out);
        m->send_message_log_event_id = 0;  // to not allow event deletion by message deletion

        CHECK(m->content->get_type() == MessageContentType::ScreenshotTaken);

        Dependencies dependencies;
        add_dialog_dependencies(dependencies, dialog_id);
        add_message_dependencies(dependencies, dialog_id, m.get());
        resolve_dependencies_force(td_, dependencies, "SendScreenshotTakenNotificationMessageLogEvent");

        auto result_message = continue_send_message(dialog_id, std::move(m), event.id_);
        if (result_message != nullptr) {
          do_send_screenshot_taken_notification_message(dialog_id, result_message, event.id_);
        }
        break;
      }
      case LogEvent::HandlerType::ForwardMessages: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          continue;
        }

        ForwardMessagesLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto to_dialog_id = log_event.to_dialog_id;
        auto from_dialog_id = log_event.from_dialog_id;
        auto messages = std::move(log_event.messages_out);

        Dependencies dependencies;
        add_dialog_dependencies(dependencies, to_dialog_id);
        add_dialog_dependencies(dependencies, from_dialog_id);
        for (auto &m : messages) {
          add_message_dependencies(dependencies, to_dialog_id, m.get());
        }
        resolve_dependencies_force(td_, dependencies, "ForwardMessagesLogEvent");

        Dialog *to_dialog = get_dialog_force(to_dialog_id);
        if (to_dialog == nullptr) {
          LOG(ERROR) << "Can't find " << to_dialog_id << " to forward messages to";
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          continue;
        }
        Dialog *from_dialog = get_dialog_force(from_dialog_id);
        if (from_dialog == nullptr) {
          LOG(ERROR) << "Can't find " << from_dialog_id << " to forward messages from";
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          continue;
        }

        auto now = G()->unix_time();
        if (!have_input_peer(from_dialog_id, AccessRights::Read) || can_send_message(to_dialog_id).is_error() ||
            messages.empty() ||
            (messages[0]->send_date < now - MAX_RESEND_DELAY && to_dialog_id != get_my_dialog_id())) {
          LOG(WARNING) << "Can't continue forwarding " << messages.size() << " message(s) to " << to_dialog_id;
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          continue;
        }

        LOG(INFO) << "Continue to forward " << messages.size() << " message(s) to " << to_dialog_id << " from binlog";

        bool need_update = false;
        bool need_update_dialog_pos = false;
        vector<Message *> forwarded_messages;
        for (auto &m : messages) {
          if (m->message_id.is_scheduled()) {
            set_message_id(m, get_next_yet_unsent_scheduled_message_id(to_dialog, m->date));
          } else {
            set_message_id(m, get_next_yet_unsent_message_id(to_dialog));
            m->date = now;
          }
          m->content = dup_message_content(td_, to_dialog_id, m->content.get(), MessageContentDupType::Forward,
                                           MessageCopyOptions());
          CHECK(m->content != nullptr);
          m->have_previous = true;
          m->have_next = true;

          message_random_ids_.insert(m->random_id);
          forwarded_messages.push_back(add_message_to_dialog(to_dialog, std::move(m), true, &need_update,
                                                             &need_update_dialog_pos, "forward message again"));
          send_update_new_message(to_dialog, forwarded_messages.back());
        }

        send_update_chat_has_scheduled_messages(to_dialog, false);

        if (need_update_dialog_pos) {
          send_update_chat_last_message(to_dialog, "on_reforward_message");
        }

        do_forward_messages(to_dialog_id, from_dialog_id, forwarded_messages, log_event.message_ids, event.id_);
        break;
      }
      case LogEvent::HandlerType::DeleteMessage: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        DeleteMessageLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();
        log_event.id_ = event.id_;

        Dialog *d = get_dialog_force(log_event.full_message_id_.get_dialog_id());
        if (d != nullptr) {
          auto message_id = log_event.full_message_id_.get_message_id();
          if (message_id.is_valid_scheduled() && message_id.is_scheduled_server()) {
            d->deleted_scheduled_server_message_ids.insert(message_id.get_scheduled_server_message_id());
          } else {
            d->deleted_message_ids.insert(message_id);
          }
        }

        do_delete_message_log_event(log_event);
        break;
      }
      case LogEvent::HandlerType::DeleteMessagesFromServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        DeleteMessagesFromServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        d->deleted_message_ids.insert(log_event.message_ids_.begin(), log_event.message_ids_.end());

        delete_messages_from_server(dialog_id, std::move(log_event.message_ids_), log_event.revoke_, event.id_, Auto());
        break;
      }
      case LogEvent::HandlerType::DeleteScheduledMessagesFromServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        DeleteScheduledMessagesFromServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        for (auto message_id : log_event.message_ids_) {
          CHECK(message_id.is_scheduled_server());
          d->deleted_scheduled_server_message_ids.insert(message_id.get_scheduled_server_message_id());
        }

        delete_scheduled_messages_from_server(dialog_id, std::move(log_event.message_ids_), event.id_, Auto());
        break;
      }
      case LogEvent::HandlerType::DeleteDialogHistoryFromServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        DeleteDialogHistoryFromServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        delete_dialog_history_from_server(dialog_id, log_event.max_message_id_, log_event.remove_from_dialog_list_,
                                          log_event.revoke_, true, event.id_, Auto());
        break;
      }
      case LogEvent::HandlerType::DeleteAllCallMessagesFromServer: {
        DeleteAllCallMessagesFromServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        delete_all_call_messages_from_server(log_event.revoke_, event.id_, Auto());
        break;
      }
      case LogEvent::HandlerType::BlockMessageSenderFromRepliesOnServer: {
        BlockMessageSenderFromRepliesOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        block_message_sender_from_replies_on_server(log_event.message_id_, log_event.delete_message_,
                                                    log_event.delete_all_messages_, log_event.report_spam_, event.id_,
                                                    Auto());
        break;
      }
      case LogEvent::HandlerType::DeleteAllChannelMessagesFromUserOnServer: {
        if (!G()->parameters().use_chat_info_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        DeleteAllChannelMessagesFromUserOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto channel_id = log_event.channel_id_;
        if (!td_->contacts_manager_->have_channel_force(channel_id)) {
          LOG(ERROR) << "Can't find " << channel_id;
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        auto user_id = log_event.user_id_;
        if (!td_->contacts_manager_->have_user_force(user_id)) {
          LOG(ERROR) << "Can't find user " << user_id;
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        delete_all_channel_messages_from_user_on_server(channel_id, user_id, event.id_, Auto());
        break;
      }
      case LogEvent::HandlerType::ReadHistoryOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        ReadHistoryOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }
        if (d->read_history_log_event_ids[0].log_event_id != 0) {
          // we need only latest read history event
          binlog_erase(G()->td_db()->get_binlog(), d->read_history_log_event_ids[0].log_event_id);
        }
        d->read_history_log_event_ids[0].log_event_id = event.id_;

        read_history_on_server_impl(d, log_event.max_message_id_);
        break;
      }
      case LogEvent::HandlerType::ReadHistoryInSecretChat: {
        ReadHistoryInSecretChatLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        CHECK(dialog_id.get_type() == DialogType::SecretChat);
        if (!td_->contacts_manager_->have_secret_chat_force(dialog_id.get_secret_chat_id())) {
          LOG(ERROR) << "Have no info about " << dialog_id;
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }
        force_create_dialog(dialog_id, "ReadHistoryInSecretChatLogEvent");
        Dialog *d = get_dialog(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }
        if (d->read_history_log_event_ids[0].log_event_id != 0) {
          // we need only latest read history event
          binlog_erase(G()->td_db()->get_binlog(), d->read_history_log_event_ids[0].log_event_id);
        }
        d->read_history_log_event_ids[0].log_event_id = event.id_;
        d->last_read_inbox_message_date = log_event.max_date_;

        read_history_on_server_impl(d, MessageId());
        break;
      }
      case LogEvent::HandlerType::ReadMessageThreadHistoryOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        ReadMessageThreadHistoryOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }
        auto top_thread_message_id = log_event.top_thread_message_id_;
        if (d->read_history_log_event_ids[top_thread_message_id.get()].log_event_id != 0) {
          // we need only latest read history event
          binlog_erase(G()->td_db()->get_binlog(),
                       d->read_history_log_event_ids[top_thread_message_id.get()].log_event_id);
        }
        d->read_history_log_event_ids[top_thread_message_id.get()].log_event_id = event.id_;

        read_message_thread_history_on_server_impl(d, top_thread_message_id, log_event.max_message_id_);
        break;
      }
      case LogEvent::HandlerType::ReadMessageContentsOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        ReadMessageContentsOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        read_message_contents_on_server(dialog_id, std::move(log_event.message_ids_), event.id_, Auto());
        break;
      }
      case LogEvent::HandlerType::ReadAllDialogMentionsOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        ReadAllDialogMentionsOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        read_all_dialog_mentions_on_server(dialog_id, event.id_, Promise<Unit>());
        break;
      }
      case LogEvent::HandlerType::ToggleDialogIsPinnedOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        ToggleDialogIsPinnedOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        toggle_dialog_is_pinned_on_server(dialog_id, log_event.is_pinned_, event.id_);
        break;
      }
      case LogEvent::HandlerType::ReorderPinnedDialogsOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        ReorderPinnedDialogsOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        vector<DialogId> dialog_ids;
        for (auto &dialog_id : log_event.dialog_ids_) {
          Dialog *d = get_dialog_force(dialog_id);
          if (d != nullptr && have_input_peer(dialog_id, AccessRights::Read)) {
            dialog_ids.push_back(dialog_id);
          }
        }
        if (dialog_ids.empty()) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        reorder_pinned_dialogs_on_server(log_event.folder_id_, dialog_ids, event.id_);
        break;
      }
      case LogEvent::HandlerType::ToggleDialogIsMarkedAsUnreadOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        ToggleDialogIsMarkedAsUnreadOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        bool have_info = dialog_id.get_type() == DialogType::User
                             ? td_->contacts_manager_->have_user_force(dialog_id.get_user_id())
                             : have_dialog_force(dialog_id);
        if (!have_info || !have_input_peer(dialog_id, AccessRights::Know)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        toggle_dialog_is_marked_as_unread_on_server(dialog_id, log_event.is_marked_as_unread_, event.id_);
        break;
      }
      case LogEvent::HandlerType::ToggleDialogIsBlockedOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        ToggleDialogIsBlockedOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        toggle_dialog_is_blocked_on_server(dialog_id, log_event.is_blocked_, event.id_);
        break;
      }
      case LogEvent::HandlerType::SaveDialogDraftMessageOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        SaveDialogDraftMessageOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Write)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }
        d->save_draft_message_log_event_id.log_event_id = event.id_;

        save_dialog_draft_message_on_server(dialog_id);
        break;
      }
      case LogEvent::HandlerType::UpdateDialogNotificationSettingsOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        UpdateDialogNotificationSettingsOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }
        d->save_notification_settings_log_event_id.log_event_id = event.id_;

        update_dialog_notification_settings_on_server(dialog_id, true);
        break;
      }
      case LogEvent::HandlerType::UpdateScopeNotificationSettingsOnServer: {
        UpdateScopeNotificationSettingsOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        update_scope_notification_settings_on_server(log_event.scope_, event.id_);
        break;
      }
      case LogEvent::HandlerType::ResetAllNotificationSettingsOnServer: {
        ResetAllNotificationSettingsOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        reset_all_notification_settings_on_server(event.id_);
        break;
      }
      case LogEvent::HandlerType::ChangeDialogReportSpamStateOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        ChangeDialogReportSpamStateOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        change_dialog_report_spam_state_on_server(dialog_id, log_event.is_spam_dialog_, event.id_, Promise<Unit>());
        break;
      }
      case LogEvent::HandlerType::SetDialogFolderIdOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        SetDialogFolderIdOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dialog *d = get_dialog_force(dialog_id);
        if (d == nullptr || !have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }
        d->set_folder_id_log_event_id.log_event_id = event.id_;

        set_dialog_folder_id(d, log_event.folder_id_);

        set_dialog_folder_id_on_server(dialog_id, true);
        break;
      }
      case LogEvent::HandlerType::GetDialogFromServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        GetDialogFromServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        auto dialog_id = log_event.dialog_id_;
        Dependencies dependencies;
        add_dialog_dependencies(dependencies, dialog_id);
        resolve_dependencies_force(td_, dependencies, "GetDialogFromServerLogEvent");

        get_dialog_force(dialog_id);  // load it if exists

        if (!have_input_peer(dialog_id, AccessRights::Read)) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        send_get_dialog_query(dialog_id, Promise<Unit>(), event.id_, "GetDialogFromServerLogEvent");
        break;
      }
      case LogEvent::HandlerType::UnpinAllDialogMessagesOnServer: {
        if (!G()->parameters().use_message_db) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        UnpinAllDialogMessagesOnServerLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        unpin_all_dialog_messages_on_server(log_event.dialog_id_, event.id_, Auto());
        break;
      }
      case LogEvent::HandlerType::GetChannelDifference: {
        if (G()->ignore_background_updates()) {
          binlog_erase(G()->td_db()->get_binlog(), event.id_);
          break;
        }

        GetChannelDifferenceLogEvent log_event;
        log_event_parse(log_event, event.data_).ensure();

        DialogId dialog_id(log_event.channel_id);
        LOG(INFO) << "Continue to run getChannelDifference in " << dialog_id;
        get_channel_difference_to_log_event_id_.emplace(dialog_id, event.id_);
        do_get_channel_difference(
            dialog_id, load_channel_pts(dialog_id), true,
            telegram_api::make_object<telegram_api::inputChannel>(log_event.channel_id.get(), log_event.access_hash),
            "LogEvent::HandlerType::GetChannelDifference");
        break;
      }
      default:
        LOG(FATAL) << "Unsupported log event type " << event.type_;
    }
  }
}

void MessagesManager::save_recently_found_dialogs() {
  if (recently_found_dialogs_loaded_ < 2) {
    return;
  }

  string value;
  for (auto &dialog_id : recently_found_dialog_ids_) {
    if (!value.empty()) {
      value += ',';
    }
    if (!G()->parameters().use_message_db) {
      // if there is no dialog database, prefer to save dialogs by username
      auto username = get_dialog_username(dialog_id);
      if (dialog_id.get_type() != DialogType::SecretChat && !username.empty()) {
        value += '@';
        value += username;
        continue;
      }
    }
    value += to_string(dialog_id.get());
  }
  LOG(DEBUG) << "Save recently found chats " << value;
  G()->td_db()->get_binlog_pmc()->set("recently_found_dialog_usernames_and_ids", value);
}

bool MessagesManager::load_recently_found_dialogs(Promise<Unit> &promise) {
  CHECK(!td_->auth_manager_->is_bot());
  if (recently_found_dialogs_loaded_ >= 2) {
    return true;
  }

  string found_dialogs_str = G()->td_db()->get_binlog_pmc()->get("recently_found_dialog_usernames_and_ids");
  if (found_dialogs_str.empty()) {
    recently_found_dialogs_loaded_ = 2;
    if (!recently_found_dialog_ids_.empty()) {
      save_recently_found_dialogs();
    }
    return true;
  }

  LOG(DEBUG) << "Loaded recently found chats " << found_dialogs_str;
  auto found_dialogs = full_split(found_dialogs_str, ',');
  if (recently_found_dialogs_loaded_ == 1 && resolve_recently_found_dialogs_multipromise_.promise_count() == 0) {
    // queries was sent and have already been finished
    auto newly_found_dialogs = std::move(recently_found_dialog_ids_);
    recently_found_dialog_ids_.clear();

    for (auto it = found_dialogs.rbegin(); it != found_dialogs.rend(); ++it) {
      if ((*it)[0] == '@') {
        auto dialog_id = resolve_dialog_username(it->substr(1));
        if (dialog_id.is_valid() && have_input_peer(dialog_id, AccessRights::Read)) {
          force_create_dialog(dialog_id, "recently found resolved dialog");
          add_recently_found_dialog_internal(dialog_id);
        }
      } else {
        auto dialog_id = DialogId(to_integer<int64>(*it));
        CHECK(dialog_id.is_valid());
        if (have_input_peer(dialog_id, AccessRights::Read)) {
          force_create_dialog(dialog_id, "recently found dialog");
          add_recently_found_dialog_internal(dialog_id);
        }
      }
    }
    for (auto it = newly_found_dialogs.rbegin(); it != newly_found_dialogs.rend(); ++it) {
      add_recently_found_dialog_internal(*it);
    }
    recently_found_dialogs_loaded_ = 2;
    if (!newly_found_dialogs.empty()) {
      save_recently_found_dialogs();
    }
    return true;
  }

  resolve_recently_found_dialogs_multipromise_.add_promise(std::move(promise));
  if (recently_found_dialogs_loaded_ == 0) {
    recently_found_dialogs_loaded_ = 1;

    resolve_recently_found_dialogs_multipromise_.set_ignore_errors(true);

    for (auto &found_dialog : found_dialogs) {
      if (found_dialog[0] == '@') {
        search_public_dialog(found_dialog, false, resolve_recently_found_dialogs_multipromise_.get_promise());
      }
    }
    if (G()->parameters().use_message_db) {
      for (auto &found_dialog : found_dialogs) {
        if (found_dialog[0] != '@') {
          auto dialog_id = DialogId(to_integer<int64>(found_dialog));
          CHECK(dialog_id.is_valid());
          // TODO use asynchronous load
          // get_dialog(dialog_id, resolve_recently_found_dialogs_multipromise_.get_promise());
          get_dialog_force(dialog_id);
        }
      }
      resolve_recently_found_dialogs_multipromise_.get_promise().set_value(Unit());
    } else {
      get_dialogs(DialogListId(FolderId::main()), MIN_DIALOG_DATE, MAX_GET_DIALOGS, false,
                  resolve_recently_found_dialogs_multipromise_.get_promise());
      td_->contacts_manager_->search_contacts("", 1, resolve_recently_found_dialogs_multipromise_.get_promise());
    }
  }
  return false;
}

Status MessagesManager::add_recently_found_dialog(DialogId dialog_id) {
  if (!have_dialog_force(dialog_id)) {
    return Status::Error(5, "Chat not found");
  }
  if (add_recently_found_dialog_internal(dialog_id)) {
    save_recently_found_dialogs();
  }

  return Status::OK();
}

Status MessagesManager::remove_recently_found_dialog(DialogId dialog_id) {
  if (!have_dialog_force(dialog_id)) {
    return Status::Error(5, "Chat not found");
  }
  if (remove_recently_found_dialog_internal(dialog_id)) {
    save_recently_found_dialogs();
  }

  return Status::OK();
}

void MessagesManager::clear_recently_found_dialogs() {
  recently_found_dialogs_loaded_ = 2;
  if (recently_found_dialog_ids_.empty()) {
    return;
  }

  recently_found_dialog_ids_.clear();
  save_recently_found_dialogs();
}

bool MessagesManager::add_recently_found_dialog_internal(DialogId dialog_id) {
  CHECK(have_dialog(dialog_id));

  if (!recently_found_dialog_ids_.empty() && recently_found_dialog_ids_[0] == dialog_id) {
    return false;
  }

  // TODO create function
  auto it = std::find(recently_found_dialog_ids_.begin(), recently_found_dialog_ids_.end(), dialog_id);
  if (it == recently_found_dialog_ids_.end()) {
    if (narrow_cast<int32>(recently_found_dialog_ids_.size()) == MAX_RECENTLY_FOUND_DIALOGS) {
      CHECK(!recently_found_dialog_ids_.empty());
      recently_found_dialog_ids_.back() = dialog_id;
    } else {
      recently_found_dialog_ids_.push_back(dialog_id);
    }
    it = recently_found_dialog_ids_.end() - 1;
  }
  std::rotate(recently_found_dialog_ids_.begin(), it, it + 1);
  return true;
}

bool MessagesManager::remove_recently_found_dialog_internal(DialogId dialog_id) {
  CHECK(have_dialog(dialog_id));
  return td::remove(recently_found_dialog_ids_, dialog_id);
}

void MessagesManager::update_recently_found_dialogs() {
  vector<DialogId> dialog_ids;
  for (auto dialog_id : recently_found_dialog_ids_) {
    const Dialog *d = get_dialog(dialog_id);
    if (d == nullptr) {
      continue;
    }
    switch (dialog_id.get_type()) {
      case DialogType::User:
        // always keep
        break;
      case DialogType::Chat: {
        auto channel_id = td_->contacts_manager_->get_chat_migrated_to_channel_id(dialog_id.get_chat_id());
        if (channel_id.is_valid() && get_dialog(DialogId(channel_id)) != nullptr) {
          dialog_id = DialogId(channel_id);
        }
        break;
      }
      case DialogType::Channel:
        // always keep
        break;
      case DialogType::SecretChat:
        if (is_deleted_secret_chat(d)) {
          dialog_id = DialogId();
        }
        break;
      case DialogType::None:
      default:
        UNREACHABLE();
        break;
    }
    if (dialog_id.is_valid()) {
      dialog_ids.push_back(dialog_id);
    }
  }

  if (dialog_ids != recently_found_dialog_ids_) {
    recently_found_dialog_ids_ = std::move(dialog_ids);
    save_recently_found_dialogs();
  }
}

void MessagesManager::suffix_load_loop(Dialog *d) {
  if (d->suffix_load_has_query_) {
    return;
  }

  if (d->suffix_load_queries_.empty()) {
    return;
  }
  CHECK(!d->suffix_load_done_);

  auto dialog_id = d->dialog_id;
  auto from_message_id = d->suffix_load_first_message_id_;
  LOG(INFO) << "Send suffix load query in " << dialog_id << " from " << from_message_id;
  auto promise = PromiseCreator::lambda([actor_id = actor_id(this), dialog_id](Result<Unit> result) {
    send_closure(actor_id, &MessagesManager::suffix_load_query_ready, dialog_id);
  });
  d->suffix_load_has_query_ = true;
  d->suffix_load_query_message_id_ = from_message_id;
  if (from_message_id.is_valid()) {
    get_history(dialog_id, from_message_id, -1, 100, true, true, std::move(promise));
  } else {
    CHECK(from_message_id == MessageId());
    get_history_from_the_end(dialog_id, true, true, std::move(promise));
  }
}

void MessagesManager::suffix_load_update_first_message_id(Dialog *d) {
  if (!d->suffix_load_first_message_id_.is_valid()) {
    if (!d->last_message_id.is_valid()) {
      return;
    }

    d->suffix_load_first_message_id_ = d->last_message_id;
  }
  auto it = MessagesConstIterator(d, d->suffix_load_first_message_id_);
  CHECK(*it != nullptr);
  CHECK((*it)->message_id == d->suffix_load_first_message_id_);
  while ((*it)->have_previous) {
    --it;
  }
  d->suffix_load_first_message_id_ = (*it)->message_id;
}

void MessagesManager::suffix_load_query_ready(DialogId dialog_id) {
  LOG(INFO) << "Finished suffix load query in " << dialog_id;
  auto *d = get_dialog(dialog_id);
  CHECK(d != nullptr);
  bool is_unchanged = d->suffix_load_first_message_id_ == d->suffix_load_query_message_id_;
  suffix_load_update_first_message_id(d);
  if (is_unchanged && d->suffix_load_first_message_id_ == d->suffix_load_query_message_id_) {
    LOG(INFO) << "Finished suffix load in " << dialog_id;
    d->suffix_load_done_ = true;
  }
  d->suffix_load_has_query_ = false;

  // Remove ready queries
  auto *m = get_message_force(d, d->suffix_load_first_message_id_, "suffix_load_query_ready");
  auto ready_it = std::partition(d->suffix_load_queries_.begin(), d->suffix_load_queries_.end(),
                                 [&](auto &value) { return !(d->suffix_load_done_ || value.second(m)); });
  for (auto it = ready_it; it != d->suffix_load_queries_.end(); ++it) {
    it->first.set_value(Unit());
  }
  d->suffix_load_queries_.erase(ready_it, d->suffix_load_queries_.end());

  suffix_load_loop(d);
}

void MessagesManager::suffix_load_add_query(Dialog *d,
                                            std::pair<Promise<>, std::function<bool(const Message *)>> query) {
  suffix_load_update_first_message_id(d);
  auto *m = get_message_force(d, d->suffix_load_first_message_id_, "suffix_load_add_query");
  if (d->suffix_load_done_ || query.second(m)) {
    query.first.set_value(Unit());
  } else {
    d->suffix_load_queries_.emplace_back(std::move(query));
    suffix_load_loop(d);
  }
}

void MessagesManager::suffix_load_till_date(Dialog *d, int32 date, Promise<> promise) {
  LOG(INFO) << "Load suffix of " << d->dialog_id << " till date " << date;
  auto condition = [date](const Message *m) {
    return m != nullptr && m->date < date;
  };
  suffix_load_add_query(d, std::make_pair(std::move(promise), std::move(condition)));
}

void MessagesManager::suffix_load_till_message_id(Dialog *d, MessageId message_id, Promise<> promise) {
  LOG(INFO) << "Load suffix of " << d->dialog_id << " till " << message_id;
  auto condition = [message_id](const Message *m) {
    return m != nullptr && m->message_id < message_id;
  };
  suffix_load_add_query(d, std::make_pair(std::move(promise), std::move(condition)));
}

void MessagesManager::set_poll_answer(FullMessageId full_message_id, vector<int32> &&option_ids,
                                      Promise<Unit> &&promise) {
  auto m = get_message_force(full_message_id, "set_poll_answer");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }
  if (!have_input_peer(full_message_id.get_dialog_id(), AccessRights::Read)) {
    return promise.set_error(Status::Error(3, "Can't access the chat"));
  }
  if (m->content->get_type() != MessageContentType::Poll) {
    return promise.set_error(Status::Error(5, "Message is not a poll"));
  }
  if (m->message_id.is_scheduled()) {
    return promise.set_error(Status::Error(5, "Can't answer polls from scheduled messages"));
  }
  if (!m->message_id.is_server()) {
    return promise.set_error(Status::Error(5, "Poll can't be answered"));
  }

  set_message_content_poll_answer(td_, m->content.get(), full_message_id, std::move(option_ids), std::move(promise));
}

void MessagesManager::get_poll_voters(FullMessageId full_message_id, int32 option_id, int32 offset, int32 limit,
                                      Promise<std::pair<int32, vector<UserId>>> &&promise) {
  auto m = get_message_force(full_message_id, "get_poll_voters");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }
  if (!have_input_peer(full_message_id.get_dialog_id(), AccessRights::Read)) {
    return promise.set_error(Status::Error(3, "Can't access the chat"));
  }
  if (m->content->get_type() != MessageContentType::Poll) {
    return promise.set_error(Status::Error(5, "Message is not a poll"));
  }
  if (m->message_id.is_scheduled()) {
    return promise.set_error(Status::Error(5, "Can't get poll results from scheduled messages"));
  }
  if (!m->message_id.is_server()) {
    return promise.set_error(Status::Error(5, "Poll results can't be received"));
  }

  get_message_content_poll_voters(td_, m->content.get(), full_message_id, option_id, offset, limit, std::move(promise));
}

void MessagesManager::stop_poll(FullMessageId full_message_id, td_api::object_ptr<td_api::ReplyMarkup> &&reply_markup,
                                Promise<Unit> &&promise) {
  auto m = get_message_force(full_message_id, "stop_poll");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }
  if (!have_input_peer(full_message_id.get_dialog_id(), AccessRights::Read)) {
    return promise.set_error(Status::Error(3, "Can't access the chat"));
  }
  if (m->content->get_type() != MessageContentType::Poll) {
    return promise.set_error(Status::Error(5, "Message is not a poll"));
  }
  if (get_message_content_poll_is_closed(td_, m->content.get())) {
    return promise.set_error(Status::Error(5, "Poll has already been closed"));
  }
  if (!can_edit_message(full_message_id.get_dialog_id(), m, true)) {
    return promise.set_error(Status::Error(5, "Poll can't be stopped"));
  }
  if (m->message_id.is_scheduled()) {
    return promise.set_error(Status::Error(5, "Can't stop polls from scheduled messages"));
  }
  if (!m->message_id.is_server()) {
    return promise.set_error(Status::Error(5, "Poll can't be stopped"));
  }

  auto r_new_reply_markup = get_reply_markup(std::move(reply_markup), td_->auth_manager_->is_bot(), true, false,
                                             has_message_sender_user_id(full_message_id.get_dialog_id(), m));
  if (r_new_reply_markup.is_error()) {
    return promise.set_error(r_new_reply_markup.move_as_error());
  }

  stop_message_content_poll(td_, m->content.get(), full_message_id, r_new_reply_markup.move_as_ok(),
                            std::move(promise));
}

Result<ServerMessageId> MessagesManager::get_invoice_message_id(FullMessageId full_message_id) {
  auto m = get_message_force(full_message_id, "get_invoice_message_id");
  if (m == nullptr) {
    return Status::Error(5, "Message not found");
  }
  if (m->content->get_type() != MessageContentType::Invoice) {
    return Status::Error(5, "Message has no invoice");
  }
  if (m->message_id.is_scheduled()) {
    return Status::Error(5, "Wrong scheduled message identifier");
  }
  if (!m->message_id.is_server()) {
    return Status::Error(5, "Wrong message identifier");
  }
  // TODO need to check that message is not forwarded

  return m->message_id.get_server_message_id();
}

void MessagesManager::get_payment_form(FullMessageId full_message_id,
                                       Promise<tl_object_ptr<td_api::paymentForm>> &&promise) {
  auto r_message_id = get_invoice_message_id(full_message_id);
  if (r_message_id.is_error()) {
    return promise.set_error(r_message_id.move_as_error());
  }

  ::td::get_payment_form(r_message_id.ok(), std::move(promise));
}

void MessagesManager::validate_order_info(FullMessageId full_message_id, tl_object_ptr<td_api::orderInfo> order_info,
                                          bool allow_save,
                                          Promise<tl_object_ptr<td_api::validatedOrderInfo>> &&promise) {
  auto r_message_id = get_invoice_message_id(full_message_id);
  if (r_message_id.is_error()) {
    return promise.set_error(r_message_id.move_as_error());
  }

  ::td::validate_order_info(r_message_id.ok(), std::move(order_info), allow_save, std::move(promise));
}

void MessagesManager::send_payment_form(FullMessageId full_message_id, const string &order_info_id,
                                        const string &shipping_option_id,
                                        const tl_object_ptr<td_api::InputCredentials> &credentials,
                                        Promise<tl_object_ptr<td_api::paymentResult>> &&promise) {
  auto r_message_id = get_invoice_message_id(full_message_id);
  if (r_message_id.is_error()) {
    return promise.set_error(r_message_id.move_as_error());
  }

  ::td::send_payment_form(r_message_id.ok(), order_info_id, shipping_option_id, credentials, std::move(promise));
}

void MessagesManager::get_payment_receipt(FullMessageId full_message_id,
                                          Promise<tl_object_ptr<td_api::paymentReceipt>> &&promise) {
  auto m = get_message_force(full_message_id, "get_payment_receipt");
  if (m == nullptr) {
    return promise.set_error(Status::Error(5, "Message not found"));
  }
  if (m->content->get_type() != MessageContentType::PaymentSuccessful) {
    return promise.set_error(Status::Error(5, "Message has wrong type"));
  }
  if (m->message_id.is_scheduled()) {
    return promise.set_error(Status::Error(5, "Can't get payment receipt from scheduled messages"));
  }
  if (!m->message_id.is_server()) {
    return promise.set_error(Status::Error(5, "Wrong message identifier"));
  }

  ::td::get_payment_receipt(m->message_id.get_server_message_id(), std::move(promise));
}

void MessagesManager::remove_sponsored_dialog() {
  set_sponsored_dialog(DialogId(), DialogSource());
}

void MessagesManager::on_get_sponsored_dialog(tl_object_ptr<telegram_api::Peer> peer, DialogSource source,
                                              vector<tl_object_ptr<telegram_api::User>> users,
                                              vector<tl_object_ptr<telegram_api::Chat>> chats) {
  CHECK(peer != nullptr);

  td_->contacts_manager_->on_get_users(std::move(users), "on_get_sponsored_dialog");
  td_->contacts_manager_->on_get_chats(std::move(chats), "on_get_sponsored_dialog");

  set_sponsored_dialog(DialogId(peer), std::move(source));
}

void MessagesManager::add_sponsored_dialog(const Dialog *d, DialogSource source) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }

  CHECK(!sponsored_dialog_id_.is_valid());
  sponsored_dialog_id_ = d->dialog_id;
  sponsored_dialog_source_ = std::move(source);

  // update last_pinned_dialog_date in any case, because all chats before SPONSORED_DIALOG_ORDER are known
  auto dialog_list_id = DialogListId(FolderId::main());
  auto *list = get_dialog_list(dialog_list_id);
  CHECK(list != nullptr);
  DialogDate max_dialog_date(SPONSORED_DIALOG_ORDER, d->dialog_id);
  if (list->last_pinned_dialog_date_ < max_dialog_date) {
    list->last_pinned_dialog_date_ = max_dialog_date;
    update_list_last_dialog_date(*list);
  }

  if (is_dialog_sponsored(d)) {
    send_update_chat_position(dialog_list_id, d, "add_sponsored_dialog");
    // the sponsored dialog must not be saved there
  }
}

void MessagesManager::save_sponsored_dialog() {
  if (!G()->parameters().use_message_db) {
    return;
  }

  LOG(INFO) << "Save sponsored " << sponsored_dialog_id_ << " with source " << sponsored_dialog_source_;
  if (sponsored_dialog_id_.is_valid()) {
    G()->td_db()->get_binlog_pmc()->set(
        "sponsored_dialog_id",
        PSTRING() << sponsored_dialog_id_.get() << ' ' << sponsored_dialog_source_.DialogSource::serialize());
  } else {
    G()->td_db()->get_binlog_pmc()->erase("sponsored_dialog_id");
  }
}

void MessagesManager::set_sponsored_dialog(DialogId dialog_id, DialogSource source) {
  if (td_->auth_manager_->is_bot()) {
    return;
  }
  LOG(INFO) << "Change sponsored chat from " << sponsored_dialog_id_ << " to " << dialog_id;
  if (removed_sponsored_dialog_id_.is_valid() && dialog_id == removed_sponsored_dialog_id_) {
    return;
  }

  if (sponsored_dialog_id_ == dialog_id) {
    if (sponsored_dialog_source_ != source) {
      CHECK(sponsored_dialog_id_.is_valid());
      sponsored_dialog_source_ = std::move(source);
      const Dialog *d = get_dialog(sponsored_dialog_id_);
      CHECK(d != nullptr);
      send_update_chat_position(DialogListId(FolderId::main()), d, "set_sponsored_dialog");
      save_sponsored_dialog();
    }
    return;
  }

  bool need_update_total_chat_count = false;
  if (sponsored_dialog_id_.is_valid()) {
    const Dialog *d = get_dialog(sponsored_dialog_id_);
    CHECK(d != nullptr);
    bool was_sponsored = is_dialog_sponsored(d);
    sponsored_dialog_id_ = DialogId();
    sponsored_dialog_source_ = DialogSource();
    if (was_sponsored) {
      send_update_chat_position(DialogListId(FolderId::main()), d, "set_sponsored_dialog 2");
      need_update_total_chat_count = true;
    }
  }

  if (dialog_id.is_valid()) {
    force_create_dialog(dialog_id, "set_sponsored_dialog_id");
    const Dialog *d = get_dialog(dialog_id);
    CHECK(d != nullptr);
    add_sponsored_dialog(d, std::move(source));
    if (is_dialog_sponsored(d)) {
      need_update_total_chat_count = !need_update_total_chat_count;
    }
  }

  if (need_update_total_chat_count) {
    auto dialog_list_id = DialogListId(FolderId::main());
    auto *list = get_dialog_list(dialog_list_id);
    CHECK(list != nullptr);
    if (list->is_dialog_unread_count_inited_) {
      send_update_unread_chat_count(*list, DialogId(), true, "set_sponsored_dialog_id");
    }
  }

  save_sponsored_dialog();
}

td_api::object_ptr<td_api::updateChatFilters> MessagesManager::get_update_chat_filters_object() const {
  CHECK(!td_->auth_manager_->is_bot());
  auto update = td_api::make_object<td_api::updateChatFilters>();
  for (const auto &filter : dialog_filters_) {
    update->chat_filters_.push_back(filter->get_chat_filter_info_object());
  }
  return update;
}

td_api::object_ptr<td_api::updateUnreadMessageCount> MessagesManager::get_update_unread_message_count_object(
    const DialogList &list) const {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(list.is_message_unread_count_inited_);
  int32 unread_count = list.unread_message_total_count_;
  int32 unread_unmuted_count = list.unread_message_total_count_ - list.unread_message_muted_count_;
  CHECK(unread_count >= 0);
  CHECK(unread_unmuted_count >= 0);
  return td_api::make_object<td_api::updateUnreadMessageCount>(list.dialog_list_id.get_chat_list_object(), unread_count,
                                                               unread_unmuted_count);
}

td_api::object_ptr<td_api::updateUnreadChatCount> MessagesManager::get_update_unread_chat_count_object(
    const DialogList &list) const {
  CHECK(!td_->auth_manager_->is_bot());
  CHECK(list.is_dialog_unread_count_inited_);
  int32 unread_count = list.unread_dialog_total_count_;
  int32 unread_unmuted_count = unread_count - list.unread_dialog_muted_count_;
  int32 unread_marked_count = list.unread_dialog_marked_count_;
  int32 unread_unmuted_marked_count = unread_marked_count - list.unread_dialog_muted_marked_count_;
  CHECK(unread_count >= 0);
  CHECK(unread_unmuted_count >= 0);
  CHECK(unread_marked_count >= 0);
  CHECK(unread_unmuted_marked_count >= 0);
  return td_api::make_object<td_api::updateUnreadChatCount>(
      list.dialog_list_id.get_chat_list_object(), get_dialog_total_count(list), unread_count, unread_unmuted_count,
      unread_marked_count, unread_unmuted_marked_count);
}

void MessagesManager::get_current_state(vector<td_api::object_ptr<td_api::Update>> &updates) const {
  if (!td_->auth_manager_->is_bot()) {
    if (!dialog_filters_.empty()) {
      updates.push_back(get_update_chat_filters_object());
    }
    if (G()->parameters().use_message_db) {
      for (const auto &it : dialog_lists_) {
        auto &list = it.second;
        if (list.is_message_unread_count_inited_) {
          updates.push_back(get_update_unread_message_count_object(list));
        }
        if (list.is_dialog_unread_count_inited_) {
          updates.push_back(get_update_unread_chat_count_object(list));
        }
      }
    }

    vector<NotificationSettingsScope> scopes{NotificationSettingsScope::Private, NotificationSettingsScope::Group,
                                             NotificationSettingsScope::Channel};
    for (auto scope : scopes) {
      auto current_settings = get_scope_notification_settings(scope);
      CHECK(current_settings != nullptr);
      if (current_settings->is_synchronized) {
        updates.push_back(get_update_scope_notification_settings_object(scope));
      }
    }
  }

  vector<td_api::object_ptr<td_api::Update>> last_message_updates;
  for (auto &it : dialogs_) {
    const Dialog *d = it.second.get();
    auto update = td_api::make_object<td_api::updateNewChat>(get_chat_object(d));
    if (update->chat_->last_message_ != nullptr && update->chat_->last_message_->forward_info_ != nullptr) {
      last_message_updates.push_back(td_api::make_object<td_api::updateChatLastMessage>(
          d->dialog_id.get(), std::move(update->chat_->last_message_), get_chat_positions_object(d)));
    }
    updates.push_back(std::move(update));

    if (d->is_opened) {
      auto info_it = dialog_online_member_counts_.find(d->dialog_id);
      if (info_it != dialog_online_member_counts_.end() && info_it->second.is_update_sent) {
        updates.push_back(td_api::make_object<td_api::updateChatOnlineMemberCount>(
            d->dialog_id.get(), info_it->second.online_member_count));
      }
    }
  }
  append(updates, std::move(last_message_updates));
}

}  // namespace td
